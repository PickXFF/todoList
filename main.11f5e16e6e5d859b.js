"use strict";
(self.webpackChunktodo = self.webpackChunktodo || []).push([
  [179],
  {
    972: () => {
      function Ot(n) {
        return "function" == typeof n;
      }
      function Su(n) {
        const t = n((i) => {
          Error.call(i), (i.stack = new Error().stack);
        });
        return (
          (t.prototype = Object.create(Error.prototype)),
          (t.prototype.constructor = t),
          t
        );
      }
      const Qh = Su(
        (n) =>
          function (t) {
            n(this),
              (this.message = t
                ? `${t.length} errors occurred during unsubscription:\n${t
                    .map((i, r) => `${r + 1}) ${i.toString()}`)
                    .join("\n  ")}`
                : ""),
              (this.name = "UnsubscriptionError"),
              (this.errors = t);
          }
      );
      function ol(n, e) {
        if (n) {
          const t = n.indexOf(e);
          0 <= t && n.splice(t, 1);
        }
      }
      class Sn {
        constructor(e) {
          (this.initialTeardown = e),
            (this.closed = !1),
            (this._parentage = null),
            (this._finalizers = null);
        }
        unsubscribe() {
          let e;
          if (!this.closed) {
            this.closed = !0;
            const { _parentage: t } = this;
            if (t)
              if (((this._parentage = null), Array.isArray(t)))
                for (const s of t) s.remove(this);
              else t.remove(this);
            const { initialTeardown: i } = this;
            if (Ot(i))
              try {
                i();
              } catch (s) {
                e = s instanceof Qh ? s.errors : [s];
              }
            const { _finalizers: r } = this;
            if (r) {
              this._finalizers = null;
              for (const s of r)
                try {
                  GM(s);
                } catch (o) {
                  (e = e ?? []),
                    o instanceof Qh ? (e = [...e, ...o.errors]) : e.push(o);
                }
            }
            if (e) throw new Qh(e);
          }
        }
        add(e) {
          var t;
          if (e && e !== this)
            if (this.closed) GM(e);
            else {
              if (e instanceof Sn) {
                if (e.closed || e._hasParent(this)) return;
                e._addParent(this);
              }
              (this._finalizers =
                null !== (t = this._finalizers) && void 0 !== t ? t : []).push(
                e
              );
            }
        }
        _hasParent(e) {
          const { _parentage: t } = this;
          return t === e || (Array.isArray(t) && t.includes(e));
        }
        _addParent(e) {
          const { _parentage: t } = this;
          this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
        }
        _removeParent(e) {
          const { _parentage: t } = this;
          t === e ? (this._parentage = null) : Array.isArray(t) && ol(t, e);
        }
        remove(e) {
          const { _finalizers: t } = this;
          t && ol(t, e), e instanceof Sn && e._removeParent(this);
        }
      }
      Sn.EMPTY = (() => {
        const n = new Sn();
        return (n.closed = !0), n;
      })();
      const zM = Sn.EMPTY;
      function HM(n) {
        return (
          n instanceof Sn ||
          (n && "closed" in n && Ot(n.remove) && Ot(n.add) && Ot(n.unsubscribe))
        );
      }
      function GM(n) {
        Ot(n) ? n() : n.unsubscribe();
      }
      const sa = {
          onUnhandledError: null,
          onStoppedNotification: null,
          Promise: void 0,
          useDeprecatedSynchronousErrorHandling: !1,
          useDeprecatedNextContext: !1,
        },
        Jh = {
          setTimeout(n, e, ...t) {
            const { delegate: i } = Jh;
            return i?.setTimeout
              ? i.setTimeout(n, e, ...t)
              : setTimeout(n, e, ...t);
          },
          clearTimeout(n) {
            const { delegate: e } = Jh;
            return (e?.clearTimeout || clearTimeout)(n);
          },
          delegate: void 0,
        };
      function WM(n) {
        Jh.setTimeout(() => {
          const { onUnhandledError: e } = sa;
          if (!e) throw n;
          e(n);
        });
      }
      function ef() {}
      const tk = g_("C", void 0, void 0);
      function g_(n, e, t) {
        return { kind: n, value: e, error: t };
      }
      let oa = null;
      function tf(n) {
        if (sa.useDeprecatedSynchronousErrorHandling) {
          const e = !oa;
          if ((e && (oa = { errorThrown: !1, error: null }), n(), e)) {
            const { errorThrown: t, error: i } = oa;
            if (((oa = null), t)) throw i;
          }
        } else n();
      }
      class __ extends Sn {
        constructor(e) {
          super(),
            (this.isStopped = !1),
            e
              ? ((this.destination = e), HM(e) && e.add(this))
              : (this.destination = lk);
        }
        static create(e, t, i) {
          return new Eu(e, t, i);
        }
        next(e) {
          this.isStopped
            ? y_(
                (function ik(n) {
                  return g_("N", n, void 0);
                })(e),
                this
              )
            : this._next(e);
        }
        error(e) {
          this.isStopped
            ? y_(
                (function nk(n) {
                  return g_("E", void 0, n);
                })(e),
                this
              )
            : ((this.isStopped = !0), this._error(e));
        }
        complete() {
          this.isStopped
            ? y_(tk, this)
            : ((this.isStopped = !0), this._complete());
        }
        unsubscribe() {
          this.closed ||
            ((this.isStopped = !0),
            super.unsubscribe(),
            (this.destination = null));
        }
        _next(e) {
          this.destination.next(e);
        }
        _error(e) {
          try {
            this.destination.error(e);
          } finally {
            this.unsubscribe();
          }
        }
        _complete() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }
      }
      const sk = Function.prototype.bind;
      function v_(n, e) {
        return sk.call(n, e);
      }
      class ok {
        constructor(e) {
          this.partialObserver = e;
        }
        next(e) {
          const { partialObserver: t } = this;
          if (t.next)
            try {
              t.next(e);
            } catch (i) {
              nf(i);
            }
        }
        error(e) {
          const { partialObserver: t } = this;
          if (t.error)
            try {
              t.error(e);
            } catch (i) {
              nf(i);
            }
          else nf(e);
        }
        complete() {
          const { partialObserver: e } = this;
          if (e.complete)
            try {
              e.complete();
            } catch (t) {
              nf(t);
            }
        }
      }
      class Eu extends __ {
        constructor(e, t, i) {
          let r;
          if ((super(), Ot(e) || !e))
            r = {
              next: e ?? void 0,
              error: t ?? void 0,
              complete: i ?? void 0,
            };
          else {
            let s;
            this && sa.useDeprecatedNextContext
              ? ((s = Object.create(e)),
                (s.unsubscribe = () => this.unsubscribe()),
                (r = {
                  next: e.next && v_(e.next, s),
                  error: e.error && v_(e.error, s),
                  complete: e.complete && v_(e.complete, s),
                }))
              : (r = e);
          }
          this.destination = new ok(r);
        }
      }
      function nf(n) {
        sa.useDeprecatedSynchronousErrorHandling
          ? (function rk(n) {
              sa.useDeprecatedSynchronousErrorHandling &&
                oa &&
                ((oa.errorThrown = !0), (oa.error = n));
            })(n)
          : WM(n);
      }
      function y_(n, e) {
        const { onStoppedNotification: t } = sa;
        t && Jh.setTimeout(() => t(n, e));
      }
      const lk = {
          closed: !0,
          next: ef,
          error: function ak(n) {
            throw n;
          },
          complete: ef,
        },
        b_ =
          ("function" == typeof Symbol && Symbol.observable) || "@@observable";
      function bo(n) {
        return n;
      }
      function jM(n) {
        return 0 === n.length
          ? bo
          : 1 === n.length
          ? n[0]
          : function (t) {
              return n.reduce((i, r) => r(i), t);
            };
      }
      let Kt = (() => {
        class n {
          constructor(t) {
            t && (this._subscribe = t);
          }
          lift(t) {
            const i = new n();
            return (i.source = this), (i.operator = t), i;
          }
          subscribe(t, i, r) {
            const s = (function dk(n) {
              return (
                (n && n instanceof __) ||
                ((function uk(n) {
                  return n && Ot(n.next) && Ot(n.error) && Ot(n.complete);
                })(n) &&
                  HM(n))
              );
            })(t)
              ? t
              : new Eu(t, i, r);
            return (
              tf(() => {
                const { operator: o, source: a } = this;
                s.add(
                  o
                    ? o.call(s, a)
                    : a
                    ? this._subscribe(s)
                    : this._trySubscribe(s)
                );
              }),
              s
            );
          }
          _trySubscribe(t) {
            try {
              return this._subscribe(t);
            } catch (i) {
              t.error(i);
            }
          }
          forEach(t, i) {
            return new (i = XM(i))((r, s) => {
              const o = new Eu({
                next: (a) => {
                  try {
                    t(a);
                  } catch (l) {
                    s(l), o.unsubscribe();
                  }
                },
                error: s,
                complete: r,
              });
              this.subscribe(o);
            });
          }
          _subscribe(t) {
            var i;
            return null === (i = this.source) || void 0 === i
              ? void 0
              : i.subscribe(t);
          }
          [b_]() {
            return this;
          }
          pipe(...t) {
            return jM(t)(this);
          }
          toPromise(t) {
            return new (t = XM(t))((i, r) => {
              let s;
              this.subscribe(
                (o) => (s = o),
                (o) => r(o),
                () => i(s)
              );
            });
          }
        }
        return (n.create = (e) => new n(e)), n;
      })();
      function XM(n) {
        var e;
        return null !== (e = n ?? sa.Promise) && void 0 !== e ? e : Promise;
      }
      const hk = Su(
        (n) =>
          function () {
            n(this),
              (this.name = "ObjectUnsubscribedError"),
              (this.message = "object unsubscribed");
          }
      );
      let kt = (() => {
        class n extends Kt {
          constructor() {
            super(),
              (this.closed = !1),
              (this.currentObservers = null),
              (this.observers = []),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null);
          }
          lift(t) {
            const i = new qM(this, this);
            return (i.operator = t), i;
          }
          _throwIfClosed() {
            if (this.closed) throw new hk();
          }
          next(t) {
            tf(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.currentObservers ||
                  (this.currentObservers = Array.from(this.observers));
                for (const i of this.currentObservers) i.next(t);
              }
            });
          }
          error(t) {
            tf(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                (this.hasError = this.isStopped = !0), (this.thrownError = t);
                const { observers: i } = this;
                for (; i.length; ) i.shift().error(t);
              }
            });
          }
          complete() {
            tf(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.isStopped = !0;
                const { observers: t } = this;
                for (; t.length; ) t.shift().complete();
              }
            });
          }
          unsubscribe() {
            (this.isStopped = this.closed = !0),
              (this.observers = this.currentObservers = null);
          }
          get observed() {
            var t;
            return (
              (null === (t = this.observers) || void 0 === t
                ? void 0
                : t.length) > 0
            );
          }
          _trySubscribe(t) {
            return this._throwIfClosed(), super._trySubscribe(t);
          }
          _subscribe(t) {
            return (
              this._throwIfClosed(),
              this._checkFinalizedStatuses(t),
              this._innerSubscribe(t)
            );
          }
          _innerSubscribe(t) {
            const { hasError: i, isStopped: r, observers: s } = this;
            return i || r
              ? zM
              : ((this.currentObservers = null),
                s.push(t),
                new Sn(() => {
                  (this.currentObservers = null), ol(s, t);
                }));
          }
          _checkFinalizedStatuses(t) {
            const { hasError: i, thrownError: r, isStopped: s } = this;
            i ? t.error(r) : s && t.complete();
          }
          asObservable() {
            const t = new Kt();
            return (t.source = this), t;
          }
        }
        return (n.create = (e, t) => new qM(e, t)), n;
      })();
      class qM extends kt {
        constructor(e, t) {
          super(), (this.destination = e), (this.source = t);
        }
        next(e) {
          var t, i;
          null ===
            (i =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.next) ||
            void 0 === i ||
            i.call(t, e);
        }
        error(e) {
          var t, i;
          null ===
            (i =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.error) ||
            void 0 === i ||
            i.call(t, e);
        }
        complete() {
          var e, t;
          null ===
            (t =
              null === (e = this.destination) || void 0 === e
                ? void 0
                : e.complete) ||
            void 0 === t ||
            t.call(e);
        }
        _subscribe(e) {
          var t, i;
          return null !==
            (i =
              null === (t = this.source) || void 0 === t
                ? void 0
                : t.subscribe(e)) && void 0 !== i
            ? i
            : zM;
        }
      }
      function YM(n) {
        return Ot(n?.lift);
      }
      function ln(n) {
        return (e) => {
          if (YM(e))
            return e.lift(function (t) {
              try {
                return n(t, this);
              } catch (i) {
                this.error(i);
              }
            });
          throw new TypeError("Unable to lift unknown Observable type");
        };
      }
      function en(n, e, t, i, r) {
        return new fk(n, e, t, i, r);
      }
      class fk extends __ {
        constructor(e, t, i, r, s, o) {
          super(e),
            (this.onFinalize = s),
            (this.shouldUnsubscribe = o),
            (this._next = t
              ? function (a) {
                  try {
                    t(a);
                  } catch (l) {
                    e.error(l);
                  }
                }
              : super._next),
            (this._error = r
              ? function (a) {
                  try {
                    r(a);
                  } catch (l) {
                    e.error(l);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._error),
            (this._complete = i
              ? function () {
                  try {
                    i();
                  } catch (a) {
                    e.error(a);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._complete);
        }
        unsubscribe() {
          var e;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            const { closed: t } = this;
            super.unsubscribe(),
              !t &&
                (null === (e = this.onFinalize) ||
                  void 0 === e ||
                  e.call(this));
          }
        }
      }
      function xt(n, e) {
        return ln((t, i) => {
          let r = 0;
          t.subscribe(
            en(i, (s) => {
              i.next(n.call(e, s, r++));
            })
          );
        });
      }
      function xo(n) {
        return this instanceof xo ? ((this.v = n), this) : new xo(n);
      }
      function QM(n) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var t,
          e = n[Symbol.asyncIterator];
        return e
          ? e.call(n)
          : ((n = (function S_(n) {
              var e = "function" == typeof Symbol && Symbol.iterator,
                t = e && n[e],
                i = 0;
              if (t) return t.call(n);
              if (n && "number" == typeof n.length)
                return {
                  next: function () {
                    return (
                      n && i >= n.length && (n = void 0),
                      { value: n && n[i++], done: !n }
                    );
                  },
                };
              throw new TypeError(
                e
                  ? "Object is not iterable."
                  : "Symbol.iterator is not defined."
              );
            })(n)),
            (t = {}),
            i("next"),
            i("throw"),
            i("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function i(s) {
          t[s] =
            n[s] &&
            function (o) {
              return new Promise(function (a, l) {
                !(function r(s, o, a, l) {
                  Promise.resolve(l).then(function (c) {
                    s({ value: c, done: a });
                  }, o);
                })(a, l, (o = n[s](o)).done, o.value);
              });
            };
        }
      }
      const E_ = (n) =>
        n && "number" == typeof n.length && "function" != typeof n;
      function JM(n) {
        return Ot(n?.then);
      }
      function eS(n) {
        return Ot(n[b_]);
      }
      function tS(n) {
        return Symbol.asyncIterator && Ot(n?.[Symbol.asyncIterator]);
      }
      function nS(n) {
        return new TypeError(
          `You provided ${
            null !== n && "object" == typeof n ? "an invalid object" : `'${n}'`
          } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`
        );
      }
      const iS = (function Pk() {
        return "function" == typeof Symbol && Symbol.iterator
          ? Symbol.iterator
          : "@@iterator";
      })();
      function rS(n) {
        return Ot(n?.[iS]);
      }
      function sS(n) {
        return (function $M(n, e, t) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var r,
            i = t.apply(n, e || []),
            s = [];
          return (
            (r = {}),
            o("next"),
            o("throw"),
            o("return"),
            (r[Symbol.asyncIterator] = function () {
              return this;
            }),
            r
          );
          function o(h) {
            i[h] &&
              (r[h] = function (f) {
                return new Promise(function (p, _) {
                  s.push([h, f, p, _]) > 1 || a(h, f);
                });
              });
          }
          function a(h, f) {
            try {
              !(function l(h) {
                h.value instanceof xo
                  ? Promise.resolve(h.value.v).then(c, u)
                  : d(s[0][2], h);
              })(i[h](f));
            } catch (p) {
              d(s[0][3], p);
            }
          }
          function c(h) {
            a("next", h);
          }
          function u(h) {
            a("throw", h);
          }
          function d(h, f) {
            h(f), s.shift(), s.length && a(s[0][0], s[0][1]);
          }
        })(this, arguments, function* () {
          const t = n.getReader();
          try {
            for (;;) {
              const { value: i, done: r } = yield xo(t.read());
              if (r) return yield xo(void 0);
              yield yield xo(i);
            }
          } finally {
            t.releaseLock();
          }
        });
      }
      function oS(n) {
        return Ot(n?.getReader);
      }
      function di(n) {
        if (n instanceof Kt) return n;
        if (null != n) {
          if (eS(n))
            return (function Ok(n) {
              return new Kt((e) => {
                const t = n[b_]();
                if (Ot(t.subscribe)) return t.subscribe(e);
                throw new TypeError(
                  "Provided object does not correctly implement Symbol.observable"
                );
              });
            })(n);
          if (E_(n))
            return (function Lk(n) {
              return new Kt((e) => {
                for (let t = 0; t < n.length && !e.closed; t++) e.next(n[t]);
                e.complete();
              });
            })(n);
          if (JM(n))
            return (function Fk(n) {
              return new Kt((e) => {
                n.then(
                  (t) => {
                    e.closed || (e.next(t), e.complete());
                  },
                  (t) => e.error(t)
                ).then(null, WM);
              });
            })(n);
          if (tS(n)) return aS(n);
          if (rS(n))
            return (function Nk(n) {
              return new Kt((e) => {
                for (const t of n) if ((e.next(t), e.closed)) return;
                e.complete();
              });
            })(n);
          if (oS(n))
            return (function kk(n) {
              return aS(sS(n));
            })(n);
        }
        throw nS(n);
      }
      function aS(n) {
        return new Kt((e) => {
          (function Bk(n, e) {
            var t, i, r, s;
            return (function ZM(n, e, t, i) {
              return new (t || (t = Promise))(function (s, o) {
                function a(u) {
                  try {
                    c(i.next(u));
                  } catch (d) {
                    o(d);
                  }
                }
                function l(u) {
                  try {
                    c(i.throw(u));
                  } catch (d) {
                    o(d);
                  }
                }
                function c(u) {
                  u.done
                    ? s(u.value)
                    : (function r(s) {
                        return s instanceof t
                          ? s
                          : new t(function (o) {
                              o(s);
                            });
                      })(u.value).then(a, l);
                }
                c((i = i.apply(n, e || [])).next());
              });
            })(this, void 0, void 0, function* () {
              try {
                for (t = QM(n); !(i = yield t.next()).done; )
                  if ((e.next(i.value), e.closed)) return;
              } catch (o) {
                r = { error: o };
              } finally {
                try {
                  i && !i.done && (s = t.return) && (yield s.call(t));
                } finally {
                  if (r) throw r.error;
                }
              }
              e.complete();
            });
          })(n, e).catch((t) => e.error(t));
        });
      }
      function Os(n, e, t, i = 0, r = !1) {
        const s = e.schedule(function () {
          t(), r ? n.add(this.schedule(null, i)) : this.unsubscribe();
        }, i);
        if ((n.add(s), !r)) return s;
      }
      function Un(n, e, t = 1 / 0) {
        return Ot(e)
          ? Un((i, r) => xt((s, o) => e(i, s, r, o))(di(n(i, r))), t)
          : ("number" == typeof e && (t = e),
            ln((i, r) =>
              (function Uk(n, e, t, i, r, s, o, a) {
                const l = [];
                let c = 0,
                  u = 0,
                  d = !1;
                const h = () => {
                    d && !l.length && !c && e.complete();
                  },
                  f = (_) => (c < i ? p(_) : l.push(_)),
                  p = (_) => {
                    s && e.next(_), c++;
                    let m = !1;
                    di(t(_, u++)).subscribe(
                      en(
                        e,
                        (g) => {
                          r?.(g), s ? f(g) : e.next(g);
                        },
                        () => {
                          m = !0;
                        },
                        void 0,
                        () => {
                          if (m)
                            try {
                              for (c--; l.length && c < i; ) {
                                const g = l.shift();
                                o ? Os(e, o, () => p(g)) : p(g);
                              }
                              h();
                            } catch (g) {
                              e.error(g);
                            }
                        }
                      )
                    );
                  };
                return (
                  n.subscribe(
                    en(e, f, () => {
                      (d = !0), h();
                    })
                  ),
                  () => {
                    a?.();
                  }
                );
              })(i, r, n, t)
            ));
      }
      function al(n = 1 / 0) {
        return Un(bo, n);
      }
      const ls = new Kt((n) => n.complete());
      function lS(n) {
        return n && Ot(n.schedule);
      }
      function C_(n) {
        return n[n.length - 1];
      }
      function Cu(n) {
        return lS(C_(n)) ? n.pop() : void 0;
      }
      function uS(n, e = 0) {
        return ln((t, i) => {
          t.subscribe(
            en(
              i,
              (r) => Os(i, n, () => i.next(r), e),
              () => Os(i, n, () => i.complete(), e),
              (r) => Os(i, n, () => i.error(r), e)
            )
          );
        });
      }
      function dS(n, e = 0) {
        return ln((t, i) => {
          i.add(n.schedule(() => t.subscribe(i), e));
        });
      }
      function hS(n, e) {
        if (!n) throw new Error("Iterable cannot be null");
        return new Kt((t) => {
          Os(t, e, () => {
            const i = n[Symbol.asyncIterator]();
            Os(
              t,
              e,
              () => {
                i.next().then((r) => {
                  r.done ? t.complete() : t.next(r.value);
                });
              },
              0,
              !0
            );
          });
        });
      }
      function On(n, e) {
        return e
          ? (function qk(n, e) {
              if (null != n) {
                if (eS(n))
                  return (function Hk(n, e) {
                    return di(n).pipe(dS(e), uS(e));
                  })(n, e);
                if (E_(n))
                  return (function Wk(n, e) {
                    return new Kt((t) => {
                      let i = 0;
                      return e.schedule(function () {
                        i === n.length
                          ? t.complete()
                          : (t.next(n[i++]), t.closed || this.schedule());
                      });
                    });
                  })(n, e);
                if (JM(n))
                  return (function Gk(n, e) {
                    return di(n).pipe(dS(e), uS(e));
                  })(n, e);
                if (tS(n)) return hS(n, e);
                if (rS(n))
                  return (function jk(n, e) {
                    return new Kt((t) => {
                      let i;
                      return (
                        Os(t, e, () => {
                          (i = n[iS]()),
                            Os(
                              t,
                              e,
                              () => {
                                let r, s;
                                try {
                                  ({ value: r, done: s } = i.next());
                                } catch (o) {
                                  return void t.error(o);
                                }
                                s ? t.complete() : t.next(r);
                              },
                              0,
                              !0
                            );
                        }),
                        () => Ot(i?.return) && i.return()
                      );
                    });
                  })(n, e);
                if (oS(n))
                  return (function Xk(n, e) {
                    return hS(sS(n), e);
                  })(n, e);
              }
              throw nS(n);
            })(n, e)
          : di(n);
      }
      function Tu(...n) {
        const e = Cu(n),
          t = (function zk(n, e) {
            return "number" == typeof C_(n) ? n.pop() : e;
          })(n, 1 / 0),
          i = n;
        return i.length ? (1 === i.length ? di(i[0]) : al(t)(On(i, e))) : ls;
      }
      function T_(n, e, ...t) {
        if (!0 === e) return void n();
        if (!1 === e) return;
        const i = new Eu({
          next: () => {
            i.unsubscribe(), n();
          },
        });
        return di(e(...t)).subscribe(i);
      }
      function Zt(n) {
        for (let e in n) if (n[e] === Zt) return e;
        throw Error("Could not find renamed property on target object.");
      }
      function A_(n, e) {
        for (const t in e)
          e.hasOwnProperty(t) && !n.hasOwnProperty(t) && (n[t] = e[t]);
      }
      function $t(n) {
        if ("string" == typeof n) return n;
        if (Array.isArray(n)) return "[" + n.map($t).join(", ") + "]";
        if (null == n) return "" + n;
        if (n.overriddenName) return `${n.overriddenName}`;
        if (n.name) return `${n.name}`;
        const e = n.toString();
        if (null == e) return "" + e;
        const t = e.indexOf("\n");
        return -1 === t ? e : e.substring(0, t);
      }
      function D_(n, e) {
        return null == n || "" === n
          ? null === e
            ? ""
            : e
          : null == e || "" === e
          ? n
          : n + " " + e;
      }
      const Zk = Zt({ __forward_ref__: Zt });
      function Xt(n) {
        return (
          (n.__forward_ref__ = Xt),
          (n.toString = function () {
            return $t(this());
          }),
          n
        );
      }
      function Ke(n) {
        return I_(n) ? n() : n;
      }
      function I_(n) {
        return (
          "function" == typeof n &&
          n.hasOwnProperty(Zk) &&
          n.__forward_ref__ === Xt
        );
      }
      function R_(n) {
        return n && !!n.ɵproviders;
      }
      const rf = "https://g.co/ng/security#xss";
      class J extends Error {
        constructor(e, t) {
          super(sf(e, t)), (this.code = e);
        }
      }
      function sf(n, e) {
        return `NG0${Math.abs(n)}${e ? ": " + e.trim() : ""}`;
      }
      function it(n) {
        return "string" == typeof n ? n : null == n ? "" : String(n);
      }
      function af(n, e) {
        throw new J(-201, !1);
      }
      function fr(n, e) {
        null == n &&
          (function zt(n, e, t, i) {
            throw new Error(
              `ASSERTION ERROR: ${n}` +
                (null == i ? "" : ` [Expected=> ${t} ${i} ${e} <=Actual]`)
            );
          })(e, n, null, "!=");
      }
      function Me(n) {
        return {
          token: n.token,
          providedIn: n.providedIn || null,
          factory: n.factory,
          value: void 0,
        };
      }
      function cn(n) {
        return { providers: n.providers || [], imports: n.imports || [] };
      }
      function lf(n) {
        return fS(n, cf) || fS(n, mS);
      }
      function fS(n, e) {
        return n.hasOwnProperty(e) ? n[e] : null;
      }
      function pS(n) {
        return n && (n.hasOwnProperty(P_) || n.hasOwnProperty(iB))
          ? n[P_]
          : null;
      }
      const cf = Zt({ ɵprov: Zt }),
        P_ = Zt({ ɵinj: Zt }),
        mS = Zt({ ngInjectableDef: Zt }),
        iB = Zt({ ngInjectorDef: Zt });
      var $e = (() => (
        (($e = $e || {})[($e.Default = 0)] = "Default"),
        ($e[($e.Host = 1)] = "Host"),
        ($e[($e.Self = 2)] = "Self"),
        ($e[($e.SkipSelf = 4)] = "SkipSelf"),
        ($e[($e.Optional = 8)] = "Optional"),
        $e
      ))();
      let O_;
      function pr(n) {
        const e = O_;
        return (O_ = n), e;
      }
      function gS(n, e, t) {
        const i = lf(n);
        return i && "root" == i.providedIn
          ? void 0 === i.value
            ? (i.value = i.factory())
            : i.value
          : t & $e.Optional
          ? null
          : void 0 !== e
          ? e
          : void af($t(n));
      }
      const tn = (() =>
          (typeof globalThis < "u" && globalThis) ||
          (typeof global < "u" && global) ||
          (typeof window < "u" && window) ||
          (typeof self < "u" &&
            typeof WorkerGlobalScope < "u" &&
            self instanceof WorkerGlobalScope &&
            self))(),
        Au = {},
        L_ = "__NG_DI_FLAG__",
        uf = "ngTempTokenPath",
        sB = "ngTokenPath",
        oB = /\n/gm,
        aB = "\u0275",
        _S = "__source";
      let Du;
      function ll(n) {
        const e = Du;
        return (Du = n), e;
      }
      function lB(n, e = $e.Default) {
        if (void 0 === Du) throw new J(-203, !1);
        return null === Du
          ? gS(n, void 0, e)
          : Du.get(n, e & $e.Optional ? null : void 0, e);
      }
      function re(n, e = $e.Default) {
        return (
          (function rB() {
            return O_;
          })() || lB
        )(Ke(n), e);
      }
      function ft(n, e = $e.Default) {
        return re(n, df(e));
      }
      function df(n) {
        return typeof n > "u" || "number" == typeof n
          ? n
          : 0 |
              (n.optional && 8) |
              (n.host && 1) |
              (n.self && 2) |
              (n.skipSelf && 4);
      }
      function F_(n) {
        const e = [];
        for (let t = 0; t < n.length; t++) {
          const i = Ke(n[t]);
          if (Array.isArray(i)) {
            if (0 === i.length) throw new J(900, !1);
            let r,
              s = $e.Default;
            for (let o = 0; o < i.length; o++) {
              const a = i[o],
                l = cB(a);
              "number" == typeof l
                ? -1 === l
                  ? (r = a.token)
                  : (s |= l)
                : (r = a);
            }
            e.push(re(r, s));
          } else e.push(re(i));
        }
        return e;
      }
      function Iu(n, e) {
        return (n[L_] = e), (n.prototype[L_] = e), n;
      }
      function cB(n) {
        return n[L_];
      }
      function Ls(n) {
        return { toString: n }.toString();
      }
      var cs = (() => (
          ((cs = cs || {})[(cs.OnPush = 0)] = "OnPush"),
          (cs[(cs.Default = 1)] = "Default"),
          cs
        ))(),
        Fr = (() => {
          return (
            ((n = Fr || (Fr = {}))[(n.Emulated = 0)] = "Emulated"),
            (n[(n.None = 2)] = "None"),
            (n[(n.ShadowDom = 3)] = "ShadowDom"),
            Fr
          );
          var n;
        })();
      const Fs = {},
        Bt = [],
        hf = Zt({ ɵcmp: Zt }),
        N_ = Zt({ ɵdir: Zt }),
        k_ = Zt({ ɵpipe: Zt }),
        yS = Zt({ ɵmod: Zt }),
        Ns = Zt({ ɵfac: Zt }),
        Ru = Zt({ __NG_ELEMENT_ID__: Zt });
      let hB = 0;
      function Xi(n) {
        return Ls(() => {
          const e = xS(n),
            t = {
              ...e,
              decls: n.decls,
              vars: n.vars,
              template: n.template,
              consts: n.consts || null,
              ngContentSelectors: n.ngContentSelectors,
              onPush: n.changeDetection === cs.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              dependencies: (e.standalone && n.dependencies) || null,
              getStandaloneInjector: null,
              data: n.data || {},
              encapsulation: n.encapsulation || Fr.Emulated,
              id: "c" + hB++,
              styles: n.styles || Bt,
              _: null,
              schemas: n.schemas || null,
              tView: null,
            };
          wS(t);
          const i = n.dependencies;
          return (t.directiveDefs = ff(i, !1)), (t.pipeDefs = ff(i, !0)), t;
        });
      }
      function pB(n) {
        return Ht(n) || hi(n);
      }
      function mB(n) {
        return null !== n;
      }
      function _n(n) {
        return Ls(() => ({
          type: n.type,
          bootstrap: n.bootstrap || Bt,
          declarations: n.declarations || Bt,
          imports: n.imports || Bt,
          exports: n.exports || Bt,
          transitiveCompileScopes: null,
          schemas: n.schemas || null,
          id: n.id || null,
        }));
      }
      function bS(n, e) {
        if (null == n) return Fs;
        const t = {};
        for (const i in n)
          if (n.hasOwnProperty(i)) {
            let r = n[i],
              s = r;
            Array.isArray(r) && ((s = r[1]), (r = r[0])),
              (t[r] = i),
              e && (e[r] = s);
          }
        return t;
      }
      function He(n) {
        return Ls(() => {
          const e = xS(n);
          return wS(e), e;
        });
      }
      function bi(n) {
        return {
          type: n.type,
          name: n.name,
          factory: null,
          pure: !1 !== n.pure,
          standalone: !0 === n.standalone,
          onDestroy: n.type.prototype.ngOnDestroy || null,
        };
      }
      function Ht(n) {
        return n[hf] || null;
      }
      function hi(n) {
        return n[N_] || null;
      }
      function Fi(n) {
        return n[k_] || null;
      }
      function qi(n, e) {
        const t = n[yS] || null;
        if (!t && !0 === e)
          throw new Error(`Type ${$t(n)} does not have '\u0275mod' property.`);
        return t;
      }
      function xS(n) {
        const e = {};
        return {
          type: n.type,
          providersResolver: null,
          factory: null,
          hostBindings: n.hostBindings || null,
          hostVars: n.hostVars || 0,
          hostAttrs: n.hostAttrs || null,
          contentQueries: n.contentQueries || null,
          declaredInputs: e,
          exportAs: n.exportAs || null,
          standalone: !0 === n.standalone,
          selectors: n.selectors || Bt,
          viewQuery: n.viewQuery || null,
          features: n.features || null,
          setInput: null,
          findHostDirectiveDefs: null,
          hostDirectives: null,
          inputs: bS(n.inputs, e),
          outputs: bS(n.outputs),
        };
      }
      function wS(n) {
        n.features?.forEach((e) => e(n));
      }
      function ff(n, e) {
        if (!n) return null;
        const t = e ? Fi : pB;
        return () =>
          ("function" == typeof n ? n() : n).map((i) => t(i)).filter(mB);
      }
      const ks = 0,
        De = 1,
        pt = 2,
        vn = 3,
        Nr = 4,
        aa = 5,
        fi = 6,
        ul = 7,
        En = 8,
        pf = 9,
        mf = 10,
        gt = 11,
        B_ = 12,
        Pu = 13,
        MS = 14,
        dl = 15,
        pi = 16,
        Ou = 17,
        hl = 18,
        us = 19,
        Lu = 20,
        SS = 21,
        nn = 22,
        U_ = 1,
        ES = 2,
        gf = 7,
        _f = 8,
        fl = 9,
        xi = 10;
      function Yi(n) {
        return Array.isArray(n) && "object" == typeof n[U_];
      }
      function kr(n) {
        return Array.isArray(n) && !0 === n[U_];
      }
      function V_(n) {
        return 0 != (4 & n.flags);
      }
      function Fu(n) {
        return n.componentOffset > -1;
      }
      function vf(n) {
        return 1 == (1 & n.flags);
      }
      function Br(n) {
        return !!n.template;
      }
      function _B(n) {
        return 0 != (256 & n[pt]);
      }
      function la(n, e) {
        return n.hasOwnProperty(Ns) ? n[Ns] : null;
      }
      class bB {
        constructor(e, t, i) {
          (this.previousValue = e),
            (this.currentValue = t),
            (this.firstChange = i);
        }
        isFirstChange() {
          return this.firstChange;
        }
      }
      function mr() {
        return AS;
      }
      function AS(n) {
        return n.type.prototype.ngOnChanges && (n.setInput = wB), xB;
      }
      function xB() {
        const n = IS(this),
          e = n?.current;
        if (e) {
          const t = n.previous;
          if (t === Fs) n.previous = e;
          else for (let i in e) t[i] = e[i];
          (n.current = null), this.ngOnChanges(e);
        }
      }
      function wB(n, e, t, i) {
        const r = this.declaredInputs[t],
          s =
            IS(n) ||
            (function MB(n, e) {
              return (n[DS] = e);
            })(n, { previous: Fs, current: null }),
          o = s.current || (s.current = {}),
          a = s.previous,
          l = a[r];
        (o[r] = new bB(l && l.currentValue, e, a === Fs)), (n[i] = e);
      }
      mr.ngInherit = !0;
      const DS = "__ngSimpleChanges__";
      function IS(n) {
        return n[DS] || null;
      }
      const gr = function (n, e, t) {},
        RS = "svg";
      function ti(n) {
        for (; Array.isArray(n); ) n = n[ks];
        return n;
      }
      function yf(n, e) {
        return ti(e[n]);
      }
      function Zi(n, e) {
        return ti(e[n.index]);
      }
      function OS(n, e) {
        return n.data[e];
      }
      function pl(n, e) {
        return n[e];
      }
      function Ni(n, e) {
        const t = e[n];
        return Yi(t) ? t : t[ks];
      }
      function bf(n) {
        return 64 == (64 & n[pt]);
      }
      function Mo(n, e) {
        return null == e ? null : n[e];
      }
      function LS(n) {
        n[hl] = 0;
      }
      function H_(n, e) {
        n[aa] += e;
        let t = n,
          i = n[vn];
        for (
          ;
          null !== i && ((1 === e && 1 === t[aa]) || (-1 === e && 0 === t[aa]));

        )
          (i[aa] += e), (t = i), (i = i[vn]);
      }
      const rt = { lFrame: WS(null), bindingsEnabled: !0 };
      function NS() {
        return rt.bindingsEnabled;
      }
      function se() {
        return rt.lFrame.lView;
      }
      function Rt() {
        return rt.lFrame.tView;
      }
      function at(n) {
        return (rt.lFrame.contextLView = n), n[En];
      }
      function lt(n) {
        return (rt.lFrame.contextLView = null), n;
      }
      function ni() {
        let n = kS();
        for (; null !== n && 64 === n.type; ) n = n.parent;
        return n;
      }
      function kS() {
        return rt.lFrame.currentTNode;
      }
      function ds(n, e) {
        const t = rt.lFrame;
        (t.currentTNode = n), (t.isParent = e);
      }
      function G_() {
        return rt.lFrame.isParent;
      }
      function W_() {
        rt.lFrame.isParent = !1;
      }
      function wi() {
        const n = rt.lFrame;
        let e = n.bindingRootIndex;
        return (
          -1 === e && (e = n.bindingRootIndex = n.tView.bindingStartIndex), e
        );
      }
      function ml() {
        return rt.lFrame.bindingIndex++;
      }
      function Us(n) {
        const e = rt.lFrame,
          t = e.bindingIndex;
        return (e.bindingIndex = e.bindingIndex + n), t;
      }
      function NB(n, e) {
        const t = rt.lFrame;
        (t.bindingIndex = t.bindingRootIndex = n), j_(e);
      }
      function j_(n) {
        rt.lFrame.currentDirectiveIndex = n;
      }
      function zS() {
        return rt.lFrame.currentQueryIndex;
      }
      function q_(n) {
        rt.lFrame.currentQueryIndex = n;
      }
      function BB(n) {
        const e = n[De];
        return 2 === e.type ? e.declTNode : 1 === e.type ? n[fi] : null;
      }
      function HS(n, e, t) {
        if (t & $e.SkipSelf) {
          let r = e,
            s = n;
          for (
            ;
            !((r = r.parent),
            null !== r ||
              t & $e.Host ||
              ((r = BB(s)), null === r || ((s = s[dl]), 10 & r.type)));

          );
          if (null === r) return !1;
          (e = r), (n = s);
        }
        const i = (rt.lFrame = GS());
        return (i.currentTNode = e), (i.lView = n), !0;
      }
      function Y_(n) {
        const e = GS(),
          t = n[De];
        (rt.lFrame = e),
          (e.currentTNode = t.firstChild),
          (e.lView = n),
          (e.tView = t),
          (e.contextLView = n),
          (e.bindingIndex = t.bindingStartIndex),
          (e.inI18n = !1);
      }
      function GS() {
        const n = rt.lFrame,
          e = null === n ? null : n.child;
        return null === e ? WS(n) : e;
      }
      function WS(n) {
        const e = {
          currentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: -1,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: n,
          child: null,
          inI18n: !1,
        };
        return null !== n && (n.child = e), e;
      }
      function jS() {
        const n = rt.lFrame;
        return (
          (rt.lFrame = n.parent), (n.currentTNode = null), (n.lView = null), n
        );
      }
      const XS = jS;
      function Z_() {
        const n = jS();
        (n.isParent = !0),
          (n.tView = null),
          (n.selectedIndex = -1),
          (n.contextLView = null),
          (n.elementDepthCount = 0),
          (n.currentDirectiveIndex = -1),
          (n.currentNamespace = null),
          (n.bindingRootIndex = -1),
          (n.bindingIndex = -1),
          (n.currentQueryIndex = 0);
      }
      function Mi() {
        return rt.lFrame.selectedIndex;
      }
      function ca(n) {
        rt.lFrame.selectedIndex = n;
      }
      function un() {
        const n = rt.lFrame;
        return OS(n.tView, n.selectedIndex);
      }
      function K_() {
        rt.lFrame.currentNamespace = RS;
      }
      function xf(n, e) {
        for (let t = e.directiveStart, i = e.directiveEnd; t < i; t++) {
          const s = n.data[t].type.prototype,
            {
              ngAfterContentInit: o,
              ngAfterContentChecked: a,
              ngAfterViewInit: l,
              ngAfterViewChecked: c,
              ngOnDestroy: u,
            } = s;
          o && (n.contentHooks ?? (n.contentHooks = [])).push(-t, o),
            a &&
              ((n.contentHooks ?? (n.contentHooks = [])).push(t, a),
              (n.contentCheckHooks ?? (n.contentCheckHooks = [])).push(t, a)),
            l && (n.viewHooks ?? (n.viewHooks = [])).push(-t, l),
            c &&
              ((n.viewHooks ?? (n.viewHooks = [])).push(t, c),
              (n.viewCheckHooks ?? (n.viewCheckHooks = [])).push(t, c)),
            null != u && (n.destroyHooks ?? (n.destroyHooks = [])).push(t, u);
        }
      }
      function wf(n, e, t) {
        YS(n, e, 3, t);
      }
      function Mf(n, e, t, i) {
        (3 & n[pt]) === t && YS(n, e, t, i);
      }
      function $_(n, e) {
        let t = n[pt];
        (3 & t) === e && ((t &= 2047), (t += 1), (n[pt] = t));
      }
      function YS(n, e, t, i) {
        const s = i ?? -1,
          o = e.length - 1;
        let a = 0;
        for (let l = void 0 !== i ? 65535 & n[hl] : 0; l < o; l++)
          if ("number" == typeof e[l + 1]) {
            if (((a = e[l]), null != i && a >= i)) break;
          } else
            e[l] < 0 && (n[hl] += 65536),
              (a < s || -1 == s) &&
                (jB(n, t, e, l), (n[hl] = (4294901760 & n[hl]) + l + 2)),
              l++;
      }
      function jB(n, e, t, i) {
        const r = t[i] < 0,
          s = t[i + 1],
          a = n[r ? -t[i] : t[i]];
        if (r) {
          if (n[pt] >> 11 < n[hl] >> 16 && (3 & n[pt]) === e) {
            (n[pt] += 2048), gr(4, a, s);
            try {
              s.call(a);
            } finally {
              gr(5, a, s);
            }
          }
        } else {
          gr(4, a, s);
          try {
            s.call(a);
          } finally {
            gr(5, a, s);
          }
        }
      }
      const gl = -1;
      class ku {
        constructor(e, t, i) {
          (this.factory = e),
            (this.resolving = !1),
            (this.canSeeViewProviders = t),
            (this.injectImpl = i);
        }
      }
      function J_(n, e, t) {
        let i = 0;
        for (; i < t.length; ) {
          const r = t[i];
          if ("number" == typeof r) {
            if (0 !== r) break;
            i++;
            const s = t[i++],
              o = t[i++],
              a = t[i++];
            n.setAttribute(e, o, a, s);
          } else {
            const s = r,
              o = t[++i];
            KS(s) ? n.setProperty(e, s, o) : n.setAttribute(e, s, o), i++;
          }
        }
        return i;
      }
      function ZS(n) {
        return 3 === n || 4 === n || 6 === n;
      }
      function KS(n) {
        return 64 === n.charCodeAt(0);
      }
      function Bu(n, e) {
        if (null !== e && 0 !== e.length)
          if (null === n || 0 === n.length) n = e.slice();
          else {
            let t = -1;
            for (let i = 0; i < e.length; i++) {
              const r = e[i];
              "number" == typeof r
                ? (t = r)
                : 0 === t ||
                  $S(n, t, r, null, -1 === t || 2 === t ? e[++i] : null);
            }
          }
        return n;
      }
      function $S(n, e, t, i, r) {
        let s = 0,
          o = n.length;
        if (-1 === e) o = -1;
        else
          for (; s < n.length; ) {
            const a = n[s++];
            if ("number" == typeof a) {
              if (a === e) {
                o = -1;
                break;
              }
              if (a > e) {
                o = s - 1;
                break;
              }
            }
          }
        for (; s < n.length; ) {
          const a = n[s];
          if ("number" == typeof a) break;
          if (a === t) {
            if (null === i) return void (null !== r && (n[s + 1] = r));
            if (i === n[s + 1]) return void (n[s + 2] = r);
          }
          s++, null !== i && s++, null !== r && s++;
        }
        -1 !== o && (n.splice(o, 0, e), (s = o + 1)),
          n.splice(s++, 0, t),
          null !== i && n.splice(s++, 0, i),
          null !== r && n.splice(s++, 0, r);
      }
      function QS(n) {
        return n !== gl;
      }
      function Sf(n) {
        return 32767 & n;
      }
      function Ef(n, e) {
        let t = (function ZB(n) {
            return n >> 16;
          })(n),
          i = e;
        for (; t > 0; ) (i = i[dl]), t--;
        return i;
      }
      let ev = !0;
      function Cf(n) {
        const e = ev;
        return (ev = n), e;
      }
      const JS = 255,
        eE = 5;
      let KB = 0;
      const hs = {};
      function Tf(n, e) {
        const t = tE(n, e);
        if (-1 !== t) return t;
        const i = e[De];
        i.firstCreatePass &&
          ((n.injectorIndex = e.length),
          tv(i.data, n),
          tv(e, null),
          tv(i.blueprint, null));
        const r = nv(n, e),
          s = n.injectorIndex;
        if (QS(r)) {
          const o = Sf(r),
            a = Ef(r, e),
            l = a[De].data;
          for (let c = 0; c < 8; c++) e[s + c] = a[o + c] | l[o + c];
        }
        return (e[s + 8] = r), s;
      }
      function tv(n, e) {
        n.push(0, 0, 0, 0, 0, 0, 0, 0, e);
      }
      function tE(n, e) {
        return -1 === n.injectorIndex ||
          (n.parent && n.parent.injectorIndex === n.injectorIndex) ||
          null === e[n.injectorIndex + 8]
          ? -1
          : n.injectorIndex;
      }
      function nv(n, e) {
        if (n.parent && -1 !== n.parent.injectorIndex)
          return n.parent.injectorIndex;
        let t = 0,
          i = null,
          r = e;
        for (; null !== r; ) {
          if (((i = lE(r)), null === i)) return gl;
          if ((t++, (r = r[dl]), -1 !== i.injectorIndex))
            return i.injectorIndex | (t << 16);
        }
        return gl;
      }
      function iv(n, e, t) {
        !(function $B(n, e, t) {
          let i;
          "string" == typeof t
            ? (i = t.charCodeAt(0) || 0)
            : t.hasOwnProperty(Ru) && (i = t[Ru]),
            null == i && (i = t[Ru] = KB++);
          const r = i & JS;
          e.data[n + (r >> eE)] |= 1 << r;
        })(n, e, t);
      }
      function nE(n, e, t) {
        if (t & $e.Optional || void 0 !== n) return n;
        af();
      }
      function iE(n, e, t, i) {
        if (
          (t & $e.Optional && void 0 === i && (i = null),
          !(t & ($e.Self | $e.Host)))
        ) {
          const r = n[pf],
            s = pr(void 0);
          try {
            return r ? r.get(e, i, t & $e.Optional) : gS(e, i, t & $e.Optional);
          } finally {
            pr(s);
          }
        }
        return nE(i, 0, t);
      }
      function rE(n, e, t, i = $e.Default, r) {
        if (null !== n) {
          if (1024 & e[pt]) {
            const o = (function nU(n, e, t, i, r) {
              let s = n,
                o = e;
              for (
                ;
                null !== s && null !== o && 1024 & o[pt] && !(256 & o[pt]);

              ) {
                const a = sE(s, o, t, i | $e.Self, hs);
                if (a !== hs) return a;
                let l = s.parent;
                if (!l) {
                  const c = o[SS];
                  if (c) {
                    const u = c.get(t, hs, i);
                    if (u !== hs) return u;
                  }
                  (l = lE(o)), (o = o[dl]);
                }
                s = l;
              }
              return r;
            })(n, e, t, i, hs);
            if (o !== hs) return o;
          }
          const s = sE(n, e, t, i, hs);
          if (s !== hs) return s;
        }
        return iE(e, t, i, r);
      }
      function sE(n, e, t, i, r) {
        const s = (function eU(n) {
          if ("string" == typeof n) return n.charCodeAt(0) || 0;
          const e = n.hasOwnProperty(Ru) ? n[Ru] : void 0;
          return "number" == typeof e ? (e >= 0 ? e & JS : tU) : e;
        })(t);
        if ("function" == typeof s) {
          if (!HS(e, n, i)) return i & $e.Host ? nE(r, 0, i) : iE(e, t, i, r);
          try {
            const o = s(i);
            if (null != o || i & $e.Optional) return o;
            af();
          } finally {
            XS();
          }
        } else if ("number" == typeof s) {
          let o = null,
            a = tE(n, e),
            l = gl,
            c = i & $e.Host ? e[pi][fi] : null;
          for (
            (-1 === a || i & $e.SkipSelf) &&
            ((l = -1 === a ? nv(n, e) : e[a + 8]),
            l !== gl && aE(i, !1)
              ? ((o = e[De]), (a = Sf(l)), (e = Ef(l, e)))
              : (a = -1));
            -1 !== a;

          ) {
            const u = e[De];
            if (oE(s, a, u.data)) {
              const d = JB(a, e, t, o, i, c);
              if (d !== hs) return d;
            }
            (l = e[a + 8]),
              l !== gl && aE(i, e[De].data[a + 8] === c) && oE(s, a, e)
                ? ((o = u), (a = Sf(l)), (e = Ef(l, e)))
                : (a = -1);
          }
        }
        return r;
      }
      function JB(n, e, t, i, r, s) {
        const o = e[De],
          a = o.data[n + 8],
          u = Af(
            a,
            o,
            t,
            null == i ? Fu(a) && ev : i != o && 0 != (3 & a.type),
            r & $e.Host && s === a
          );
        return null !== u ? ua(e, o, u, a) : hs;
      }
      function Af(n, e, t, i, r) {
        const s = n.providerIndexes,
          o = e.data,
          a = 1048575 & s,
          l = n.directiveStart,
          u = s >> 20,
          h = r ? a + u : n.directiveEnd;
        for (let f = i ? a : a + u; f < h; f++) {
          const p = o[f];
          if ((f < l && t === p) || (f >= l && p.type === t)) return f;
        }
        if (r) {
          const f = o[l];
          if (f && Br(f) && f.type === t) return l;
        }
        return null;
      }
      function ua(n, e, t, i) {
        let r = n[t];
        const s = e.data;
        if (
          (function XB(n) {
            return n instanceof ku;
          })(r)
        ) {
          const o = r;
          o.resolving &&
            (function Kk(n, e) {
              const t = e ? `. Dependency path: ${e.join(" > ")} > ${n}` : "";
              throw new J(
                -200,
                `Circular dependency in DI detected for ${n}${t}`
              );
            })(
              (function Vt(n) {
                return "function" == typeof n
                  ? n.name || n.toString()
                  : "object" == typeof n &&
                    null != n &&
                    "function" == typeof n.type
                  ? n.type.name || n.type.toString()
                  : it(n);
              })(s[t])
            );
          const a = Cf(o.canSeeViewProviders);
          o.resolving = !0;
          const l = o.injectImpl ? pr(o.injectImpl) : null;
          HS(n, i, $e.Default);
          try {
            (r = n[t] = o.factory(void 0, s, n, i)),
              e.firstCreatePass &&
                t >= i.directiveStart &&
                (function WB(n, e, t) {
                  const {
                    ngOnChanges: i,
                    ngOnInit: r,
                    ngDoCheck: s,
                  } = e.type.prototype;
                  if (i) {
                    const o = AS(e);
                    (t.preOrderHooks ?? (t.preOrderHooks = [])).push(n, o),
                      (
                        t.preOrderCheckHooks ?? (t.preOrderCheckHooks = [])
                      ).push(n, o);
                  }
                  r &&
                    (t.preOrderHooks ?? (t.preOrderHooks = [])).push(0 - n, r),
                    s &&
                      ((t.preOrderHooks ?? (t.preOrderHooks = [])).push(n, s),
                      (
                        t.preOrderCheckHooks ?? (t.preOrderCheckHooks = [])
                      ).push(n, s));
                })(t, s[t], e);
          } finally {
            null !== l && pr(l), Cf(a), (o.resolving = !1), XS();
          }
        }
        return r;
      }
      function oE(n, e, t) {
        return !!(t[e + (n >> eE)] & (1 << n));
      }
      function aE(n, e) {
        return !(n & $e.Self || (n & $e.Host && e));
      }
      class _l {
        constructor(e, t) {
          (this._tNode = e), (this._lView = t);
        }
        get(e, t, i) {
          return rE(this._tNode, this._lView, e, df(i), t);
        }
      }
      function tU() {
        return new _l(ni(), se());
      }
      function Vn(n) {
        return Ls(() => {
          const e = n.prototype.constructor,
            t = e[Ns] || rv(e),
            i = Object.prototype;
          let r = Object.getPrototypeOf(n.prototype).constructor;
          for (; r && r !== i; ) {
            const s = r[Ns] || rv(r);
            if (s && s !== t) return s;
            r = Object.getPrototypeOf(r);
          }
          return (s) => new s();
        });
      }
      function rv(n) {
        return I_(n)
          ? () => {
              const e = rv(Ke(n));
              return e && e();
            }
          : la(n);
      }
      function lE(n) {
        const e = n[De],
          t = e.type;
        return 2 === t ? e.declTNode : 1 === t ? n[fi] : null;
      }
      const yl = "__parameters__";
      function xl(n, e, t) {
        return Ls(() => {
          const i = (function sv(n) {
            return function (...t) {
              if (n) {
                const i = n(...t);
                for (const r in i) this[r] = i[r];
              }
            };
          })(e);
          function r(...s) {
            if (this instanceof r) return i.apply(this, s), this;
            const o = new r(...s);
            return (a.annotation = o), a;
            function a(l, c, u) {
              const d = l.hasOwnProperty(yl)
                ? l[yl]
                : Object.defineProperty(l, yl, { value: [] })[yl];
              for (; d.length <= u; ) d.push(null);
              return (d[u] = d[u] || []).push(o), l;
            }
          }
          return (
            t && (r.prototype = Object.create(t.prototype)),
            (r.prototype.ngMetadataName = n),
            (r.annotationCls = r),
            r
          );
        });
      }
      class ye {
        constructor(e, t) {
          (this._desc = e),
            (this.ngMetadataName = "InjectionToken"),
            (this.ɵprov = void 0),
            "number" == typeof t
              ? (this.__NG_ELEMENT_ID__ = t)
              : void 0 !== t &&
                (this.ɵprov = Me({
                  token: this,
                  providedIn: t.providedIn || "root",
                  factory: t.factory,
                }));
        }
        get multi() {
          return this;
        }
        toString() {
          return `InjectionToken ${this._desc}`;
        }
      }
      function da(n, e) {
        n.forEach((t) => (Array.isArray(t) ? da(t, e) : e(t)));
      }
      function uE(n, e, t) {
        e >= n.length ? n.push(t) : n.splice(e, 0, t);
      }
      function Df(n, e) {
        return e >= n.length - 1 ? n.pop() : n.splice(e, 1)[0];
      }
      function Hu(n, e) {
        const t = [];
        for (let i = 0; i < n; i++) t.push(e);
        return t;
      }
      function Ki(n, e, t) {
        let i = wl(n, e);
        return (
          i >= 0
            ? (n[1 | i] = t)
            : ((i = ~i),
              (function oU(n, e, t, i) {
                let r = n.length;
                if (r == e) n.push(t, i);
                else if (1 === r) n.push(i, n[0]), (n[0] = t);
                else {
                  for (r--, n.push(n[r - 1], n[r]); r > e; )
                    (n[r] = n[r - 2]), r--;
                  (n[e] = t), (n[e + 1] = i);
                }
              })(n, i, e, t)),
          i
        );
      }
      function av(n, e) {
        const t = wl(n, e);
        if (t >= 0) return n[1 | t];
      }
      function wl(n, e) {
        return (function dE(n, e, t) {
          let i = 0,
            r = n.length >> t;
          for (; r !== i; ) {
            const s = i + ((r - i) >> 1),
              o = n[s << t];
            if (e === o) return s << t;
            o > e ? (r = s) : (i = s + 1);
          }
          return ~(r << t);
        })(n, e, 1);
      }
      const Rf = Iu(
          xl("Inject", (n) => ({ token: n })),
          -1
        ),
        Ml = Iu(xl("Optional"), 8),
        Gu = Iu(xl("SkipSelf"), 4);
      var ki = (() => (
        ((ki = ki || {})[(ki.Important = 1)] = "Important"),
        (ki[(ki.DashCase = 2)] = "DashCase"),
        ki
      ))();
      const hv = new Map();
      let AU = 0;
      const pv = "__ngContext__";
      function mi(n, e) {
        Yi(e)
          ? ((n[pv] = e[Lu]),
            (function IU(n) {
              hv.set(n[Lu], n);
            })(e))
          : (n[pv] = e);
      }
      let mv;
      function gv(n, e) {
        return mv(n, e);
      }
      function qu(n) {
        const e = n[vn];
        return kr(e) ? e[vn] : e;
      }
      function _v(n) {
        return RE(n[Pu]);
      }
      function vv(n) {
        return RE(n[Nr]);
      }
      function RE(n) {
        for (; null !== n && !kr(n); ) n = n[Nr];
        return n;
      }
      function El(n, e, t, i, r) {
        if (null != i) {
          let s,
            o = !1;
          kr(i) ? (s = i) : Yi(i) && ((o = !0), (i = i[ks]));
          const a = ti(i);
          0 === n && null !== t
            ? null == r
              ? kE(e, t, a)
              : ha(e, t, a, r || null, !0)
            : 1 === n && null !== t
            ? ha(e, t, a, r || null, !0)
            : 2 === n
            ? (function Ev(n, e, t) {
                const i = Lf(n, e);
                i &&
                  (function KU(n, e, t, i) {
                    n.removeChild(e, t, i);
                  })(n, i, e, t);
              })(e, a, o)
            : 3 === n && e.destroyNode(a),
            null != s &&
              (function JU(n, e, t, i, r) {
                const s = t[gf];
                s !== ti(t) && El(e, n, i, s, r);
                for (let a = xi; a < t.length; a++) {
                  const l = t[a];
                  Yu(l[De], l, n, e, i, s);
                }
              })(e, n, s, t, r);
        }
      }
      function bv(n, e, t) {
        return n.createElement(e, t);
      }
      function OE(n, e) {
        const t = n[fl],
          i = t.indexOf(e),
          r = e[vn];
        512 & e[pt] && ((e[pt] &= -513), H_(r, -1)), t.splice(i, 1);
      }
      function xv(n, e) {
        if (n.length <= xi) return;
        const t = xi + e,
          i = n[t];
        if (i) {
          const r = i[Ou];
          null !== r && r !== n && OE(r, i), e > 0 && (n[t - 1][Nr] = i[Nr]);
          const s = Df(n, xi + e);
          !(function HU(n, e) {
            Yu(n, e, e[gt], 2, null, null), (e[ks] = null), (e[fi] = null);
          })(i[De], i);
          const o = s[us];
          null !== o && o.detachView(s[De]),
            (i[vn] = null),
            (i[Nr] = null),
            (i[pt] &= -65);
        }
        return i;
      }
      function LE(n, e) {
        if (!(128 & e[pt])) {
          const t = e[gt];
          t.destroyNode && Yu(n, e, t, 3, null, null),
            (function jU(n) {
              let e = n[Pu];
              if (!e) return wv(n[De], n);
              for (; e; ) {
                let t = null;
                if (Yi(e)) t = e[Pu];
                else {
                  const i = e[xi];
                  i && (t = i);
                }
                if (!t) {
                  for (; e && !e[Nr] && e !== n; )
                    Yi(e) && wv(e[De], e), (e = e[vn]);
                  null === e && (e = n),
                    Yi(e) && wv(e[De], e),
                    (t = e && e[Nr]);
                }
                e = t;
              }
            })(e);
        }
      }
      function wv(n, e) {
        if (!(128 & e[pt])) {
          (e[pt] &= -65),
            (e[pt] |= 128),
            (function ZU(n, e) {
              let t;
              if (null != n && null != (t = n.destroyHooks))
                for (let i = 0; i < t.length; i += 2) {
                  const r = e[t[i]];
                  if (!(r instanceof ku)) {
                    const s = t[i + 1];
                    if (Array.isArray(s))
                      for (let o = 0; o < s.length; o += 2) {
                        const a = r[s[o]],
                          l = s[o + 1];
                        gr(4, a, l);
                        try {
                          l.call(a);
                        } finally {
                          gr(5, a, l);
                        }
                      }
                    else {
                      gr(4, r, s);
                      try {
                        s.call(r);
                      } finally {
                        gr(5, r, s);
                      }
                    }
                  }
                }
            })(n, e),
            (function YU(n, e) {
              const t = n.cleanup,
                i = e[ul];
              let r = -1;
              if (null !== t)
                for (let s = 0; s < t.length - 1; s += 2)
                  if ("string" == typeof t[s]) {
                    const o = t[s + 3];
                    o >= 0 ? i[(r = o)]() : i[(r = -o)].unsubscribe(), (s += 2);
                  } else {
                    const o = i[(r = t[s + 1])];
                    t[s].call(o);
                  }
              if (null !== i) {
                for (let s = r + 1; s < i.length; s++) (0, i[s])();
                e[ul] = null;
              }
            })(n, e),
            1 === e[De].type && e[gt].destroy();
          const t = e[Ou];
          if (null !== t && kr(e[vn])) {
            t !== e[vn] && OE(t, e);
            const i = e[us];
            null !== i && i.detachView(n);
          }
          !(function RU(n) {
            hv.delete(n[Lu]);
          })(e);
        }
      }
      function FE(n, e, t) {
        return (function NE(n, e, t) {
          let i = e;
          for (; null !== i && 40 & i.type; ) i = (e = i).parent;
          if (null === i) return t[ks];
          {
            const { componentOffset: r } = i;
            if (r > -1) {
              const { encapsulation: s } = n.data[i.directiveStart + r];
              if (s === Fr.None || s === Fr.Emulated) return null;
            }
            return Zi(i, t);
          }
        })(n, e.parent, t);
      }
      function ha(n, e, t, i, r) {
        n.insertBefore(e, t, i, r);
      }
      function kE(n, e, t) {
        n.appendChild(e, t);
      }
      function BE(n, e, t, i, r) {
        null !== i ? ha(n, e, t, i, r) : kE(n, e, t);
      }
      function Lf(n, e) {
        return n.parentNode(e);
      }
      function UE(n, e, t) {
        return zE(n, e, t);
      }
      let Mv,
        kf,
        Av,
        Bf,
        zE = function VE(n, e, t) {
          return 40 & n.type ? Zi(n, t) : null;
        };
      function Ff(n, e, t, i) {
        const r = FE(n, i, e),
          s = e[gt],
          a = UE(i.parent || e[fi], i, e);
        if (null != r)
          if (Array.isArray(t))
            for (let l = 0; l < t.length; l++) BE(s, r, t[l], a, !1);
          else BE(s, r, t, a, !1);
        void 0 !== Mv && Mv(s, i, e, t, r);
      }
      function Nf(n, e) {
        if (null !== e) {
          const t = e.type;
          if (3 & t) return Zi(e, n);
          if (4 & t) return Sv(-1, n[e.index]);
          if (8 & t) {
            const i = e.child;
            if (null !== i) return Nf(n, i);
            {
              const r = n[e.index];
              return kr(r) ? Sv(-1, r) : ti(r);
            }
          }
          if (32 & t) return gv(e, n)() || ti(n[e.index]);
          {
            const i = GE(n, e);
            return null !== i
              ? Array.isArray(i)
                ? i[0]
                : Nf(qu(n[pi]), i)
              : Nf(n, e.next);
          }
        }
        return null;
      }
      function GE(n, e) {
        return null !== e ? n[pi][fi].projection[e.projection] : null;
      }
      function Sv(n, e) {
        const t = xi + n + 1;
        if (t < e.length) {
          const i = e[t],
            r = i[De].firstChild;
          if (null !== r) return Nf(i, r);
        }
        return e[gf];
      }
      function Cv(n, e, t, i, r, s, o) {
        for (; null != t; ) {
          const a = i[t.index],
            l = t.type;
          if (
            (o && 0 === e && (a && mi(ti(a), i), (t.flags |= 2)),
            32 != (32 & t.flags))
          )
            if (8 & l) Cv(n, e, t.child, i, r, s, !1), El(e, n, r, a, s);
            else if (32 & l) {
              const c = gv(t, i);
              let u;
              for (; (u = c()); ) El(e, n, r, u, s);
              El(e, n, r, a, s);
            } else 16 & l ? WE(n, e, i, t, r, s) : El(e, n, r, a, s);
          t = o ? t.projectionNext : t.next;
        }
      }
      function Yu(n, e, t, i, r, s) {
        Cv(t, i, n.firstChild, e, r, s, !1);
      }
      function WE(n, e, t, i, r, s) {
        const o = t[pi],
          l = o[fi].projection[i.projection];
        if (Array.isArray(l))
          for (let c = 0; c < l.length; c++) El(e, n, r, l[c], s);
        else Cv(n, e, l, o[vn], r, s, !0);
      }
      function jE(n, e, t) {
        "" === t
          ? n.removeAttribute(e, "class")
          : n.setAttribute(e, "class", t);
      }
      function XE(n, e, t) {
        const { mergedAttrs: i, classes: r, styles: s } = t;
        null !== i && J_(n, e, i),
          null !== r && jE(n, e, r),
          null !== s &&
            (function t3(n, e, t) {
              n.setAttribute(e, "style", t);
            })(n, e, s);
      }
      function Cl(n) {
        return (
          (function Tv() {
            if (void 0 === kf && ((kf = null), tn.trustedTypes))
              try {
                kf = tn.trustedTypes.createPolicy("angular", {
                  createHTML: (n) => n,
                  createScript: (n) => n,
                  createScriptURL: (n) => n,
                });
              } catch {}
            return kf;
          })()?.createHTML(n) || n
        );
      }
      function YE(n) {
        return (
          (function Dv() {
            if (void 0 === Bf && ((Bf = null), tn.trustedTypes))
              try {
                Bf = tn.trustedTypes.createPolicy("angular#unsafe-bypass", {
                  createHTML: (n) => n,
                  createScript: (n) => n,
                  createScriptURL: (n) => n,
                });
              } catch {}
            return Bf;
          })()?.createHTML(n) || n
        );
      }
      class fa {
        constructor(e) {
          this.changingThisBreaksApplicationSecurity = e;
        }
        toString() {
          return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${rf})`;
        }
      }
      class a3 extends fa {
        getTypeName() {
          return "HTML";
        }
      }
      class l3 extends fa {
        getTypeName() {
          return "Style";
        }
      }
      class c3 extends fa {
        getTypeName() {
          return "Script";
        }
      }
      class u3 extends fa {
        getTypeName() {
          return "URL";
        }
      }
      class d3 extends fa {
        getTypeName() {
          return "ResourceURL";
        }
      }
      function $i(n) {
        return n instanceof fa ? n.changingThisBreaksApplicationSecurity : n;
      }
      function fs(n, e) {
        const t = (function h3(n) {
          return (n instanceof fa && n.getTypeName()) || null;
        })(n);
        if (null != t && t !== e) {
          if ("ResourceURL" === t && "URL" === e) return !0;
          throw new Error(`Required a safe ${e}, got a ${t} (see ${rf})`);
        }
        return t === e;
      }
      class v3 {
        constructor(e) {
          this.inertDocumentHelper = e;
        }
        getInertBodyElement(e) {
          e = "<body><remove></remove>" + e;
          try {
            const t = new window.DOMParser().parseFromString(
              Cl(e),
              "text/html"
            ).body;
            return null === t
              ? this.inertDocumentHelper.getInertBodyElement(e)
              : (t.removeChild(t.firstChild), t);
          } catch {
            return null;
          }
        }
      }
      class y3 {
        constructor(e) {
          (this.defaultDoc = e),
            (this.inertDocument =
              this.defaultDoc.implementation.createHTMLDocument(
                "sanitization-inert"
              ));
        }
        getInertBodyElement(e) {
          const t = this.inertDocument.createElement("template");
          return (t.innerHTML = Cl(e)), t;
        }
      }
      const x3 = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
      function Uf(n) {
        return (n = String(n)).match(x3) ? n : "unsafe:" + n;
      }
      function Vs(n) {
        const e = {};
        for (const t of n.split(",")) e[t] = !0;
        return e;
      }
      function Zu(...n) {
        const e = {};
        for (const t of n)
          for (const i in t) t.hasOwnProperty(i) && (e[i] = !0);
        return e;
      }
      const QE = Vs("area,br,col,hr,img,wbr"),
        JE = Vs("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
        eC = Vs("rp,rt"),
        Iv = Zu(
          QE,
          Zu(
            JE,
            Vs(
              "address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"
            )
          ),
          Zu(
            eC,
            Vs(
              "a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"
            )
          ),
          Zu(eC, JE)
        ),
        Rv = Vs("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
        tC = Zu(
          Rv,
          Vs(
            "abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"
          ),
          Vs(
            "aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"
          )
        ),
        w3 = Vs("script,style,template");
      class M3 {
        constructor() {
          (this.sanitizedSomething = !1), (this.buf = []);
        }
        sanitizeChildren(e) {
          let t = e.firstChild,
            i = !0;
          for (; t; )
            if (
              (t.nodeType === Node.ELEMENT_NODE
                ? (i = this.startElement(t))
                : t.nodeType === Node.TEXT_NODE
                ? this.chars(t.nodeValue)
                : (this.sanitizedSomething = !0),
              i && t.firstChild)
            )
              t = t.firstChild;
            else
              for (; t; ) {
                t.nodeType === Node.ELEMENT_NODE && this.endElement(t);
                let r = this.checkClobberedElement(t, t.nextSibling);
                if (r) {
                  t = r;
                  break;
                }
                t = this.checkClobberedElement(t, t.parentNode);
              }
          return this.buf.join("");
        }
        startElement(e) {
          const t = e.nodeName.toLowerCase();
          if (!Iv.hasOwnProperty(t))
            return (this.sanitizedSomething = !0), !w3.hasOwnProperty(t);
          this.buf.push("<"), this.buf.push(t);
          const i = e.attributes;
          for (let r = 0; r < i.length; r++) {
            const s = i.item(r),
              o = s.name,
              a = o.toLowerCase();
            if (!tC.hasOwnProperty(a)) {
              this.sanitizedSomething = !0;
              continue;
            }
            let l = s.value;
            Rv[a] && (l = Uf(l)), this.buf.push(" ", o, '="', nC(l), '"');
          }
          return this.buf.push(">"), !0;
        }
        endElement(e) {
          const t = e.nodeName.toLowerCase();
          Iv.hasOwnProperty(t) &&
            !QE.hasOwnProperty(t) &&
            (this.buf.push("</"), this.buf.push(t), this.buf.push(">"));
        }
        chars(e) {
          this.buf.push(nC(e));
        }
        checkClobberedElement(e, t) {
          if (
            t &&
            (e.compareDocumentPosition(t) &
              Node.DOCUMENT_POSITION_CONTAINED_BY) ===
              Node.DOCUMENT_POSITION_CONTAINED_BY
          )
            throw new Error(
              `Failed to sanitize html because the element is clobbered: ${e.outerHTML}`
            );
          return t;
        }
      }
      const S3 = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        E3 = /([^\#-~ |!])/g;
      function nC(n) {
        return n
          .replace(/&/g, "&amp;")
          .replace(S3, function (e) {
            return (
              "&#" +
              (1024 * (e.charCodeAt(0) - 55296) +
                (e.charCodeAt(1) - 56320) +
                65536) +
              ";"
            );
          })
          .replace(E3, function (e) {
            return "&#" + e.charCodeAt(0) + ";";
          })
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }
      let Vf;
      function iC(n, e) {
        let t = null;
        try {
          Vf =
            Vf ||
            (function $E(n) {
              const e = new y3(n);
              return (function b3() {
                try {
                  return !!new window.DOMParser().parseFromString(
                    Cl(""),
                    "text/html"
                  );
                } catch {
                  return !1;
                }
              })()
                ? new v3(e)
                : e;
            })(n);
          let i = e ? String(e) : "";
          t = Vf.getInertBodyElement(i);
          let r = 5,
            s = i;
          do {
            if (0 === r)
              throw new Error(
                "Failed to sanitize html because the input is unstable"
              );
            r--, (i = s), (s = t.innerHTML), (t = Vf.getInertBodyElement(i));
          } while (i !== s);
          return Cl(new M3().sanitizeChildren(Pv(t) || t));
        } finally {
          if (t) {
            const i = Pv(t) || t;
            for (; i.firstChild; ) i.removeChild(i.firstChild);
          }
        }
      }
      function Pv(n) {
        return "content" in n &&
          (function C3(n) {
            return (
              n.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === n.nodeName
            );
          })(n)
          ? n.content
          : null;
      }
      var Qt = (() => (
        ((Qt = Qt || {})[(Qt.NONE = 0)] = "NONE"),
        (Qt[(Qt.HTML = 1)] = "HTML"),
        (Qt[(Qt.STYLE = 2)] = "STYLE"),
        (Qt[(Qt.SCRIPT = 3)] = "SCRIPT"),
        (Qt[(Qt.URL = 4)] = "URL"),
        (Qt[(Qt.RESOURCE_URL = 5)] = "RESOURCE_URL"),
        Qt
      ))();
      function rC(n) {
        const e = (function Ku() {
          const n = se();
          return n && n[B_];
        })();
        return e
          ? YE(e.sanitize(Qt.HTML, n) || "")
          : fs(n, "HTML")
          ? YE($i(n))
          : iC(
              (function qE() {
                return void 0 !== Av
                  ? Av
                  : typeof document < "u"
                  ? document
                  : void 0;
              })(),
              it(n)
            );
      }
      const zf = new ye("ENVIRONMENT_INITIALIZER"),
        lC = new ye("INJECTOR", -1),
        cC = new ye("INJECTOR_DEF_TYPES");
      class uC {
        get(e, t = Au) {
          if (t === Au) {
            const i = new Error(`NullInjectorError: No provider for ${$t(e)}!`);
            throw ((i.name = "NullInjectorError"), i);
          }
          return t;
        }
      }
      function P3(...n) {
        return { ɵproviders: dC(0, n), ɵfromNgModule: !0 };
      }
      function dC(n, ...e) {
        const t = [],
          i = new Set();
        let r;
        return (
          da(e, (s) => {
            const o = s;
            Ov(o, t, [], i) && (r || (r = []), r.push(o));
          }),
          void 0 !== r && hC(r, t),
          t
        );
      }
      function hC(n, e) {
        for (let t = 0; t < n.length; t++) {
          const { providers: r } = n[t];
          Lv(r, (s) => {
            e.push(s);
          });
        }
      }
      function Ov(n, e, t, i) {
        if (!(n = Ke(n))) return !1;
        let r = null,
          s = pS(n);
        const o = !s && Ht(n);
        if (s || o) {
          if (o && !o.standalone) return !1;
          r = n;
        } else {
          const l = n.ngModule;
          if (((s = pS(l)), !s)) return !1;
          r = l;
        }
        const a = i.has(r);
        if (o) {
          if (a) return !1;
          if ((i.add(r), o.dependencies)) {
            const l =
              "function" == typeof o.dependencies
                ? o.dependencies()
                : o.dependencies;
            for (const c of l) Ov(c, e, t, i);
          }
        } else {
          if (!s) return !1;
          {
            if (null != s.imports && !a) {
              let c;
              i.add(r);
              try {
                da(s.imports, (u) => {
                  Ov(u, e, t, i) && (c || (c = []), c.push(u));
                });
              } finally {
              }
              void 0 !== c && hC(c, e);
            }
            if (!a) {
              const c = la(r) || (() => new r());
              e.push(
                { provide: r, useFactory: c, deps: Bt },
                { provide: cC, useValue: r, multi: !0 },
                { provide: zf, useValue: () => re(r), multi: !0 }
              );
            }
            const l = s.providers;
            null == l ||
              a ||
              Lv(l, (u) => {
                e.push(u);
              });
          }
        }
        return r !== n && void 0 !== n.providers;
      }
      function Lv(n, e) {
        for (let t of n)
          R_(t) && (t = t.ɵproviders), Array.isArray(t) ? Lv(t, e) : e(t);
      }
      const O3 = Zt({ provide: String, useValue: Zt });
      function Fv(n) {
        return null !== n && "object" == typeof n && O3 in n;
      }
      function pa(n) {
        return "function" == typeof n;
      }
      const Nv = new ye("Set Injector scope."),
        Hf = {},
        F3 = {};
      let kv;
      function Gf() {
        return void 0 === kv && (kv = new uC()), kv;
      }
      class zs {}
      class mC extends zs {
        get destroyed() {
          return this._destroyed;
        }
        constructor(e, t, i, r) {
          super(),
            (this.parent = t),
            (this.source = i),
            (this.scopes = r),
            (this.records = new Map()),
            (this._ngOnDestroyHooks = new Set()),
            (this._onDestroyHooks = []),
            (this._destroyed = !1),
            Uv(e, (o) => this.processProvider(o)),
            this.records.set(lC, Tl(void 0, this)),
            r.has("environment") && this.records.set(zs, Tl(void 0, this));
          const s = this.records.get(Nv);
          null != s && "string" == typeof s.value && this.scopes.add(s.value),
            (this.injectorDefTypes = new Set(this.get(cC.multi, Bt, $e.Self)));
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0);
          try {
            for (const e of this._ngOnDestroyHooks) e.ngOnDestroy();
            for (const e of this._onDestroyHooks) e();
          } finally {
            this.records.clear(),
              this._ngOnDestroyHooks.clear(),
              this.injectorDefTypes.clear(),
              (this._onDestroyHooks.length = 0);
          }
        }
        onDestroy(e) {
          this._onDestroyHooks.push(e);
        }
        runInContext(e) {
          this.assertNotDestroyed();
          const t = ll(this),
            i = pr(void 0);
          try {
            return e();
          } finally {
            ll(t), pr(i);
          }
        }
        get(e, t = Au, i = $e.Default) {
          this.assertNotDestroyed(), (i = df(i));
          const r = ll(this),
            s = pr(void 0);
          try {
            if (!(i & $e.SkipSelf)) {
              let a = this.records.get(e);
              if (void 0 === a) {
                const l =
                  (function V3(n) {
                    return (
                      "function" == typeof n ||
                      ("object" == typeof n && n instanceof ye)
                    );
                  })(e) && lf(e);
                (a = l && this.injectableDefInScope(l) ? Tl(Bv(e), Hf) : null),
                  this.records.set(e, a);
              }
              if (null != a) return this.hydrate(e, a);
            }
            return (i & $e.Self ? Gf() : this.parent).get(
              e,
              (t = i & $e.Optional && t === Au ? null : t)
            );
          } catch (o) {
            if ("NullInjectorError" === o.name) {
              if (((o[uf] = o[uf] || []).unshift($t(e)), r)) throw o;
              return (function uB(n, e, t, i) {
                const r = n[uf];
                throw (
                  (e[_S] && r.unshift(e[_S]),
                  (n.message = (function dB(n, e, t, i = null) {
                    n =
                      n && "\n" === n.charAt(0) && n.charAt(1) == aB
                        ? n.slice(2)
                        : n;
                    let r = $t(e);
                    if (Array.isArray(e)) r = e.map($t).join(" -> ");
                    else if ("object" == typeof e) {
                      let s = [];
                      for (let o in e)
                        if (e.hasOwnProperty(o)) {
                          let a = e[o];
                          s.push(
                            o +
                              ":" +
                              ("string" == typeof a ? JSON.stringify(a) : $t(a))
                          );
                        }
                      r = `{${s.join(", ")}}`;
                    }
                    return `${t}${i ? "(" + i + ")" : ""}[${r}]: ${n.replace(
                      oB,
                      "\n  "
                    )}`;
                  })("\n" + n.message, r, t, i)),
                  (n[sB] = r),
                  (n[uf] = null),
                  n)
                );
              })(o, e, "R3InjectorError", this.source);
            }
            throw o;
          } finally {
            pr(s), ll(r);
          }
        }
        resolveInjectorInitializers() {
          const e = ll(this),
            t = pr(void 0);
          try {
            const i = this.get(zf.multi, Bt, $e.Self);
            for (const r of i) r();
          } finally {
            ll(e), pr(t);
          }
        }
        toString() {
          const e = [],
            t = this.records;
          for (const i of t.keys()) e.push($t(i));
          return `R3Injector[${e.join(", ")}]`;
        }
        assertNotDestroyed() {
          if (this._destroyed) throw new J(205, !1);
        }
        processProvider(e) {
          let t = pa((e = Ke(e))) ? e : Ke(e && e.provide);
          const i = (function k3(n) {
            return Fv(n) ? Tl(void 0, n.useValue) : Tl(gC(n), Hf);
          })(e);
          if (pa(e) || !0 !== e.multi) this.records.get(t);
          else {
            let r = this.records.get(t);
            r ||
              ((r = Tl(void 0, Hf, !0)),
              (r.factory = () => F_(r.multi)),
              this.records.set(t, r)),
              (t = e),
              r.multi.push(e);
          }
          this.records.set(t, i);
        }
        hydrate(e, t) {
          return (
            t.value === Hf && ((t.value = F3), (t.value = t.factory())),
            "object" == typeof t.value &&
              t.value &&
              (function U3(n) {
                return (
                  null !== n &&
                  "object" == typeof n &&
                  "function" == typeof n.ngOnDestroy
                );
              })(t.value) &&
              this._ngOnDestroyHooks.add(t.value),
            t.value
          );
        }
        injectableDefInScope(e) {
          if (!e.providedIn) return !1;
          const t = Ke(e.providedIn);
          return "string" == typeof t
            ? "any" === t || this.scopes.has(t)
            : this.injectorDefTypes.has(t);
        }
      }
      function Bv(n) {
        const e = lf(n),
          t = null !== e ? e.factory : la(n);
        if (null !== t) return t;
        if (n instanceof ye) throw new J(204, !1);
        if (n instanceof Function)
          return (function N3(n) {
            const e = n.length;
            if (e > 0) throw (Hu(e, "?"), new J(204, !1));
            const t = (function nB(n) {
              return (n && (n[cf] || n[mS])) || null;
            })(n);
            return null !== t ? () => t.factory(n) : () => new n();
          })(n);
        throw new J(204, !1);
      }
      function gC(n, e, t) {
        let i;
        if (pa(n)) {
          const r = Ke(n);
          return la(r) || Bv(r);
        }
        if (Fv(n)) i = () => Ke(n.useValue);
        else if (
          (function pC(n) {
            return !(!n || !n.useFactory);
          })(n)
        )
          i = () => n.useFactory(...F_(n.deps || []));
        else if (
          (function fC(n) {
            return !(!n || !n.useExisting);
          })(n)
        )
          i = () => re(Ke(n.useExisting));
        else {
          const r = Ke(n && (n.useClass || n.provide));
          if (
            !(function B3(n) {
              return !!n.deps;
            })(n)
          )
            return la(r) || Bv(r);
          i = () => new r(...F_(n.deps));
        }
        return i;
      }
      function Tl(n, e, t = !1) {
        return { factory: n, value: e, multi: t ? [] : void 0 };
      }
      function Uv(n, e) {
        for (const t of n)
          Array.isArray(t) ? Uv(t, e) : t && R_(t) ? Uv(t.ɵproviders, e) : e(t);
      }
      class z3 {}
      class _C {}
      class G3 {
        resolveComponentFactory(e) {
          throw (function H3(n) {
            const e = Error(
              `No component factory found for ${$t(
                n
              )}. Did you add it to @NgModule.entryComponents?`
            );
            return (e.ngComponent = n), e;
          })(e);
        }
      }
      let Al = (() => {
        class n {}
        return (n.NULL = new G3()), n;
      })();
      function W3() {
        return Dl(ni(), se());
      }
      function Dl(n, e) {
        return new rn(Zi(n, e));
      }
      let rn = (() => {
        class n {
          constructor(t) {
            this.nativeElement = t;
          }
        }
        return (n.__NG_ELEMENT_ID__ = W3), n;
      })();
      function j3(n) {
        return n instanceof rn ? n.nativeElement : n;
      }
      class $u {}
      let Hs = (() => {
          class n {}
          return (
            (n.__NG_ELEMENT_ID__ = () =>
              (function X3() {
                const n = se(),
                  t = Ni(ni().index, n);
                return (Yi(t) ? t : n)[gt];
              })()),
            n
          );
        })(),
        q3 = (() => {
          class n {}
          return (
            (n.ɵprov = Me({
              token: n,
              providedIn: "root",
              factory: () => null,
            })),
            n
          );
        })();
      class ma {
        constructor(e) {
          (this.full = e),
            (this.major = e.split(".")[0]),
            (this.minor = e.split(".")[1]),
            (this.patch = e.split(".").slice(2).join("."));
        }
      }
      const Y3 = new ma("15.2.9"),
        Vv = {},
        zv = "ngOriginalError";
      function Hv(n) {
        return n[zv];
      }
      class Il {
        constructor() {
          this._console = console;
        }
        handleError(e) {
          const t = this._findOriginalError(e);
          this._console.error("ERROR", e),
            t && this._console.error("ORIGINAL ERROR", t);
        }
        _findOriginalError(e) {
          let t = e && Hv(e);
          for (; t && Hv(t); ) t = Hv(t);
          return t || null;
        }
      }
      function Qu(n) {
        return n.ownerDocument;
      }
      function Gs(n) {
        return n instanceof Function ? n() : n;
      }
      function bC(n, e, t) {
        let i = n.length;
        for (;;) {
          const r = n.indexOf(e, t);
          if (-1 === r) return r;
          if (0 === r || n.charCodeAt(r - 1) <= 32) {
            const s = e.length;
            if (r + s === i || n.charCodeAt(r + s) <= 32) return r;
          }
          t = r + 1;
        }
      }
      const xC = "ng-template";
      function rV(n, e, t) {
        let i = 0,
          r = !0;
        for (; i < n.length; ) {
          let s = n[i++];
          if ("string" == typeof s && r) {
            const o = n[i++];
            if (t && "class" === s && -1 !== bC(o.toLowerCase(), e, 0))
              return !0;
          } else {
            if (1 === s) {
              for (; i < n.length && "string" == typeof (s = n[i++]); )
                if (s.toLowerCase() === e) return !0;
              return !1;
            }
            "number" == typeof s && (r = !1);
          }
        }
        return !1;
      }
      function wC(n) {
        return 4 === n.type && n.value !== xC;
      }
      function sV(n, e, t) {
        return e === (4 !== n.type || t ? n.value : xC);
      }
      function oV(n, e, t) {
        let i = 4;
        const r = n.attrs || [],
          s = (function cV(n) {
            for (let e = 0; e < n.length; e++) if (ZS(n[e])) return e;
            return n.length;
          })(r);
        let o = !1;
        for (let a = 0; a < e.length; a++) {
          const l = e[a];
          if ("number" != typeof l) {
            if (!o)
              if (4 & i) {
                if (
                  ((i = 2 | (1 & i)),
                  ("" !== l && !sV(n, l, t)) || ("" === l && 1 === e.length))
                ) {
                  if (Ur(i)) return !1;
                  o = !0;
                }
              } else {
                const c = 8 & i ? l : e[++a];
                if (8 & i && null !== n.attrs) {
                  if (!rV(n.attrs, c, t)) {
                    if (Ur(i)) return !1;
                    o = !0;
                  }
                  continue;
                }
                const d = aV(8 & i ? "class" : l, r, wC(n), t);
                if (-1 === d) {
                  if (Ur(i)) return !1;
                  o = !0;
                  continue;
                }
                if ("" !== c) {
                  let h;
                  h = d > s ? "" : r[d + 1].toLowerCase();
                  const f = 8 & i ? h : null;
                  if ((f && -1 !== bC(f, c, 0)) || (2 & i && c !== h)) {
                    if (Ur(i)) return !1;
                    o = !0;
                  }
                }
              }
          } else {
            if (!o && !Ur(i) && !Ur(l)) return !1;
            if (o && Ur(l)) continue;
            (o = !1), (i = l | (1 & i));
          }
        }
        return Ur(i) || o;
      }
      function Ur(n) {
        return 0 == (1 & n);
      }
      function aV(n, e, t, i) {
        if (null === e) return -1;
        let r = 0;
        if (i || !t) {
          let s = !1;
          for (; r < e.length; ) {
            const o = e[r];
            if (o === n) return r;
            if (3 === o || 6 === o) s = !0;
            else {
              if (1 === o || 2 === o) {
                let a = e[++r];
                for (; "string" == typeof a; ) a = e[++r];
                continue;
              }
              if (4 === o) break;
              if (0 === o) {
                r += 4;
                continue;
              }
            }
            r += s ? 1 : 2;
          }
          return -1;
        }
        return (function uV(n, e) {
          let t = n.indexOf(4);
          if (t > -1)
            for (t++; t < n.length; ) {
              const i = n[t];
              if ("number" == typeof i) return -1;
              if (i === e) return t;
              t++;
            }
          return -1;
        })(e, n);
      }
      function MC(n, e, t = !1) {
        for (let i = 0; i < e.length; i++) if (oV(n, e[i], t)) return !0;
        return !1;
      }
      function dV(n, e) {
        e: for (let t = 0; t < e.length; t++) {
          const i = e[t];
          if (n.length === i.length) {
            for (let r = 0; r < n.length; r++) if (n[r] !== i[r]) continue e;
            return !0;
          }
        }
        return !1;
      }
      function SC(n, e) {
        return n ? ":not(" + e.trim() + ")" : e;
      }
      function hV(n) {
        let e = n[0],
          t = 1,
          i = 2,
          r = "",
          s = !1;
        for (; t < n.length; ) {
          let o = n[t];
          if ("string" == typeof o)
            if (2 & i) {
              const a = n[++t];
              r += "[" + o + (a.length > 0 ? '="' + a + '"' : "") + "]";
            } else 8 & i ? (r += "." + o) : 4 & i && (r += " " + o);
          else
            "" !== r && !Ur(o) && ((e += SC(s, r)), (r = "")),
              (i = o),
              (s = s || !Ur(i));
          t++;
        }
        return "" !== r && (e += SC(s, r)), e;
      }
      const st = {};
      function je(n) {
        EC(Rt(), se(), Mi() + n, !1);
      }
      function EC(n, e, t, i) {
        if (!i)
          if (3 == (3 & e[pt])) {
            const s = n.preOrderCheckHooks;
            null !== s && wf(e, s, t);
          } else {
            const s = n.preOrderHooks;
            null !== s && Mf(e, s, 0, t);
          }
        ca(t);
      }
      function DC(n, e = null, t = null, i) {
        const r = IC(n, e, t, i);
        return r.resolveInjectorInitializers(), r;
      }
      function IC(n, e = null, t = null, i, r = new Set()) {
        const s = [t || Bt, P3(n)];
        return (
          (i = i || ("object" == typeof n ? void 0 : $t(n))),
          new mC(s, e || Gf(), i || null, r)
        );
      }
      let Qi = (() => {
        class n {
          static create(t, i) {
            if (Array.isArray(t)) return DC({ name: "" }, i, t, "");
            {
              const r = t.name ?? "";
              return DC({ name: r }, t.parent, t.providers, r);
            }
          }
        }
        return (
          (n.THROW_IF_NOT_FOUND = Au),
          (n.NULL = new uC()),
          (n.ɵprov = Me({
            token: n,
            providedIn: "any",
            factory: () => re(lC),
          })),
          (n.__NG_ELEMENT_ID__ = -1),
          n
        );
      })();
      function G(n, e = $e.Default) {
        const t = se();
        return null === t ? re(n, e) : rE(ni(), t, Ke(n), e);
      }
      function qv() {
        throw new Error("invalid");
      }
      function kC(n, e) {
        const t = n.contentQueries;
        if (null !== t)
          for (let i = 0; i < t.length; i += 2) {
            const s = t[i + 1];
            if (-1 !== s) {
              const o = n.data[s];
              q_(t[i]), o.contentQueries(2, e[s], s);
            }
          }
      }
      function jf(n, e, t, i, r, s, o, a, l, c, u) {
        const d = e.blueprint.slice();
        return (
          (d[ks] = r),
          (d[pt] = 76 | i),
          (null !== u || (n && 1024 & n[pt])) && (d[pt] |= 1024),
          LS(d),
          (d[vn] = d[dl] = n),
          (d[En] = t),
          (d[mf] = o || (n && n[mf])),
          (d[gt] = a || (n && n[gt])),
          (d[B_] = l || (n && n[B_]) || null),
          (d[pf] = c || (n && n[pf]) || null),
          (d[fi] = s),
          (d[Lu] = (function DU() {
            return AU++;
          })()),
          (d[SS] = u),
          (d[pi] = 2 == e.type ? n[pi] : d),
          d
        );
      }
      function Ol(n, e, t, i, r) {
        let s = n.data[e];
        if (null === s)
          (s = (function Yv(n, e, t, i, r) {
            const s = kS(),
              o = G_(),
              l = (n.data[e] = (function BV(n, e, t, i, r, s) {
                return {
                  type: t,
                  index: i,
                  insertBeforeIndex: null,
                  injectorIndex: e ? e.injectorIndex : -1,
                  directiveStart: -1,
                  directiveEnd: -1,
                  directiveStylingLast: -1,
                  componentOffset: -1,
                  propertyBindings: null,
                  flags: 0,
                  providerIndexes: 0,
                  value: r,
                  attrs: s,
                  mergedAttrs: null,
                  localNames: null,
                  initialInputs: void 0,
                  inputs: null,
                  outputs: null,
                  tView: null,
                  next: null,
                  prev: null,
                  projectionNext: null,
                  child: null,
                  parent: e,
                  projection: null,
                  styles: null,
                  stylesWithoutHost: null,
                  residualStyles: void 0,
                  classes: null,
                  classesWithoutHost: null,
                  residualClasses: void 0,
                  classBindings: 0,
                  styleBindings: 0,
                };
              })(0, o ? s : s && s.parent, t, e, i, r));
            return (
              null === n.firstChild && (n.firstChild = l),
              null !== s &&
                (o
                  ? null == s.child && null !== l.parent && (s.child = l)
                  : null === s.next && ((s.next = l), (l.prev = s))),
              l
            );
          })(n, e, t, i, r)),
            (function FB() {
              return rt.lFrame.inI18n;
            })() && (s.flags |= 32);
        else if (64 & s.type) {
          (s.type = t), (s.value = i), (s.attrs = r);
          const o = (function Nu() {
            const n = rt.lFrame,
              e = n.currentTNode;
            return n.isParent ? e : e.parent;
          })();
          s.injectorIndex = null === o ? -1 : o.injectorIndex;
        }
        return ds(s, !0), s;
      }
      function Ju(n, e, t, i) {
        if (0 === t) return -1;
        const r = e.length;
        for (let s = 0; s < t; s++)
          e.push(i), n.blueprint.push(i), n.data.push(null);
        return r;
      }
      function Zv(n, e, t) {
        Y_(e);
        try {
          const i = n.viewQuery;
          null !== i && ry(1, i, t);
          const r = n.template;
          null !== r && BC(n, e, r, 1, t),
            n.firstCreatePass && (n.firstCreatePass = !1),
            n.staticContentQueries && kC(n, e),
            n.staticViewQueries && ry(2, n.viewQuery, t);
          const s = n.components;
          null !== s &&
            (function FV(n, e) {
              for (let t = 0; t < e.length; t++) rz(n, e[t]);
            })(e, s);
        } catch (i) {
          throw (
            (n.firstCreatePass &&
              ((n.incompleteFirstPass = !0), (n.firstCreatePass = !1)),
            i)
          );
        } finally {
          (e[pt] &= -5), Z_();
        }
      }
      function Xf(n, e, t, i) {
        const r = e[pt];
        if (128 != (128 & r)) {
          Y_(e);
          try {
            LS(e),
              (function US(n) {
                return (rt.lFrame.bindingIndex = n);
              })(n.bindingStartIndex),
              null !== t && BC(n, e, t, 2, i);
            const o = 3 == (3 & r);
            if (o) {
              const c = n.preOrderCheckHooks;
              null !== c && wf(e, c, null);
            } else {
              const c = n.preOrderHooks;
              null !== c && Mf(e, c, 0, null), $_(e, 0);
            }
            if (
              ((function nz(n) {
                for (let e = _v(n); null !== e; e = vv(e)) {
                  if (!e[ES]) continue;
                  const t = e[fl];
                  for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    512 & r[pt] || H_(r[vn], 1), (r[pt] |= 512);
                  }
                }
              })(e),
              (function tz(n) {
                for (let e = _v(n); null !== e; e = vv(e))
                  for (let t = xi; t < e.length; t++) {
                    const i = e[t],
                      r = i[De];
                    bf(i) && Xf(r, i, r.template, i[En]);
                  }
              })(e),
              null !== n.contentQueries && kC(n, e),
              o)
            ) {
              const c = n.contentCheckHooks;
              null !== c && wf(e, c);
            } else {
              const c = n.contentHooks;
              null !== c && Mf(e, c, 1), $_(e, 1);
            }
            !(function OV(n, e) {
              const t = n.hostBindingOpCodes;
              if (null !== t)
                try {
                  for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    if (r < 0) ca(~r);
                    else {
                      const s = r,
                        o = t[++i],
                        a = t[++i];
                      NB(o, s), a(2, e[s]);
                    }
                  }
                } finally {
                  ca(-1);
                }
            })(n, e);
            const a = n.components;
            null !== a &&
              (function LV(n, e) {
                for (let t = 0; t < e.length; t++) iz(n, e[t]);
              })(e, a);
            const l = n.viewQuery;
            if ((null !== l && ry(2, l, i), o)) {
              const c = n.viewCheckHooks;
              null !== c && wf(e, c);
            } else {
              const c = n.viewHooks;
              null !== c && Mf(e, c, 2), $_(e, 2);
            }
            !0 === n.firstUpdatePass && (n.firstUpdatePass = !1),
              (e[pt] &= -41),
              512 & e[pt] && ((e[pt] &= -513), H_(e[vn], -1));
          } finally {
            Z_();
          }
        }
      }
      function BC(n, e, t, i, r) {
        const s = Mi(),
          o = 2 & i;
        try {
          ca(-1),
            o && e.length > nn && EC(n, e, nn, !1),
            gr(o ? 2 : 0, r),
            t(i, r);
        } finally {
          ca(s), gr(o ? 3 : 1, r);
        }
      }
      function Kv(n, e, t) {
        if (V_(e)) {
          const r = e.directiveEnd;
          for (let s = e.directiveStart; s < r; s++) {
            const o = n.data[s];
            o.contentQueries && o.contentQueries(1, t[s], s);
          }
        }
      }
      function $v(n, e, t) {
        NS() &&
          ((function jV(n, e, t, i) {
            const r = t.directiveStart,
              s = t.directiveEnd;
            Fu(t) &&
              (function QV(n, e, t) {
                const i = Zi(e, n),
                  r = UC(t),
                  s = n[mf],
                  o = qf(
                    n,
                    jf(
                      n,
                      r,
                      null,
                      t.onPush ? 32 : 16,
                      i,
                      e,
                      s,
                      s.createRenderer(i, t),
                      null,
                      null,
                      null
                    )
                  );
                n[e.index] = o;
              })(e, t, n.data[r + t.componentOffset]),
              n.firstCreatePass || Tf(t, e),
              mi(i, e);
            const o = t.initialInputs;
            for (let a = r; a < s; a++) {
              const l = n.data[a],
                c = ua(e, n, a, t);
              mi(c, e),
                null !== o && JV(0, a - r, c, l, 0, o),
                Br(l) && (Ni(t.index, e)[En] = ua(e, n, a, t));
            }
          })(n, e, t, Zi(t, e)),
          64 == (64 & t.flags) && WC(n, e, t));
      }
      function Qv(n, e, t = Zi) {
        const i = e.localNames;
        if (null !== i) {
          let r = e.index + 1;
          for (let s = 0; s < i.length; s += 2) {
            const o = i[s + 1],
              a = -1 === o ? t(e, n) : n[o];
            n[r++] = a;
          }
        }
      }
      function UC(n) {
        const e = n.tView;
        return null === e || e.incompleteFirstPass
          ? (n.tView = Jv(
              1,
              null,
              n.template,
              n.decls,
              n.vars,
              n.directiveDefs,
              n.pipeDefs,
              n.viewQuery,
              n.schemas,
              n.consts
            ))
          : e;
      }
      function Jv(n, e, t, i, r, s, o, a, l, c) {
        const u = nn + i,
          d = u + r,
          h = (function NV(n, e) {
            const t = [];
            for (let i = 0; i < e; i++) t.push(i < n ? null : st);
            return t;
          })(u, d),
          f = "function" == typeof c ? c() : c;
        return (h[De] = {
          type: n,
          blueprint: h,
          template: t,
          queries: null,
          viewQuery: a,
          declTNode: e,
          data: h.slice().fill(null, u),
          bindingStartIndex: u,
          expandoStartIndex: d,
          hostBindingOpCodes: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: "function" == typeof s ? s() : s,
          pipeRegistry: "function" == typeof o ? o() : o,
          firstChild: null,
          schemas: l,
          consts: f,
          incompleteFirstPass: !1,
        });
      }
      function VC(n, e, t, i) {
        const r = XC(e);
        null === t
          ? r.push(i)
          : (r.push(t), n.firstCreatePass && qC(n).push(i, r.length - 1));
      }
      function zC(n, e, t, i) {
        for (let r in n)
          if (n.hasOwnProperty(r)) {
            t = null === t ? {} : t;
            const s = n[r];
            null === i
              ? HC(t, e, r, s)
              : i.hasOwnProperty(r) && HC(t, e, i[r], s);
          }
        return t;
      }
      function HC(n, e, t, i) {
        n.hasOwnProperty(t) ? n[t].push(e, i) : (n[t] = [e, i]);
      }
      function Ji(n, e, t, i, r, s, o, a) {
        const l = Zi(e, t);
        let u,
          c = e.inputs;
        !a && null != c && (u = c[i])
          ? (sy(n, t, u, i, r),
            Fu(e) &&
              (function zV(n, e) {
                const t = Ni(e, n);
                16 & t[pt] || (t[pt] |= 32);
              })(t, e.index))
          : 3 & e.type &&
            ((i = (function VV(n) {
              return "class" === n
                ? "className"
                : "for" === n
                ? "htmlFor"
                : "formaction" === n
                ? "formAction"
                : "innerHtml" === n
                ? "innerHTML"
                : "readonly" === n
                ? "readOnly"
                : "tabindex" === n
                ? "tabIndex"
                : n;
            })(i)),
            (r = null != o ? o(r, e.value || "", i) : r),
            s.setProperty(l, i, r));
      }
      function ey(n, e, t, i) {
        if (NS()) {
          const r = null === i ? null : { "": -1 },
            s = (function qV(n, e) {
              const t = n.directiveRegistry;
              let i = null,
                r = null;
              if (t)
                for (let s = 0; s < t.length; s++) {
                  const o = t[s];
                  if (MC(e, o.selectors, !1))
                    if ((i || (i = []), Br(o)))
                      if (null !== o.findHostDirectiveDefs) {
                        const a = [];
                        (r = r || new Map()),
                          o.findHostDirectiveDefs(o, a, r),
                          i.unshift(...a, o),
                          ty(n, e, a.length);
                      } else i.unshift(o), ty(n, e, 0);
                    else
                      (r = r || new Map()),
                        o.findHostDirectiveDefs?.(o, i, r),
                        i.push(o);
                }
              return null === i ? null : [i, r];
            })(n, t);
          let o, a;
          null === s ? (o = a = null) : ([o, a] = s),
            null !== o && GC(n, e, t, o, r, a),
            r &&
              (function YV(n, e, t) {
                if (e) {
                  const i = (n.localNames = []);
                  for (let r = 0; r < e.length; r += 2) {
                    const s = t[e[r + 1]];
                    if (null == s) throw new J(-301, !1);
                    i.push(e[r], s);
                  }
                }
              })(t, i, r);
        }
        t.mergedAttrs = Bu(t.mergedAttrs, t.attrs);
      }
      function GC(n, e, t, i, r, s) {
        for (let c = 0; c < i.length; c++) iv(Tf(t, e), n, i[c].type);
        !(function KV(n, e, t) {
          (n.flags |= 1),
            (n.directiveStart = e),
            (n.directiveEnd = e + t),
            (n.providerIndexes = e);
        })(t, n.data.length, i.length);
        for (let c = 0; c < i.length; c++) {
          const u = i[c];
          u.providersResolver && u.providersResolver(u);
        }
        let o = !1,
          a = !1,
          l = Ju(n, e, i.length, null);
        for (let c = 0; c < i.length; c++) {
          const u = i[c];
          (t.mergedAttrs = Bu(t.mergedAttrs, u.hostAttrs)),
            $V(n, t, e, l, u),
            ZV(l, u, r),
            null !== u.contentQueries && (t.flags |= 4),
            (null !== u.hostBindings ||
              null !== u.hostAttrs ||
              0 !== u.hostVars) &&
              (t.flags |= 64);
          const d = u.type.prototype;
          !o &&
            (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) &&
            ((n.preOrderHooks ?? (n.preOrderHooks = [])).push(t.index),
            (o = !0)),
            !a &&
              (d.ngOnChanges || d.ngDoCheck) &&
              ((n.preOrderCheckHooks ?? (n.preOrderCheckHooks = [])).push(
                t.index
              ),
              (a = !0)),
            l++;
        }
        !(function UV(n, e, t) {
          const r = e.directiveEnd,
            s = n.data,
            o = e.attrs,
            a = [];
          let l = null,
            c = null;
          for (let u = e.directiveStart; u < r; u++) {
            const d = s[u],
              h = t ? t.get(d) : null,
              p = h ? h.outputs : null;
            (l = zC(d.inputs, u, l, h ? h.inputs : null)),
              (c = zC(d.outputs, u, c, p));
            const _ = null === l || null === o || wC(e) ? null : ez(l, u, o);
            a.push(_);
          }
          null !== l &&
            (l.hasOwnProperty("class") && (e.flags |= 8),
            l.hasOwnProperty("style") && (e.flags |= 16)),
            (e.initialInputs = a),
            (e.inputs = l),
            (e.outputs = c);
        })(n, t, s);
      }
      function WC(n, e, t) {
        const i = t.directiveStart,
          r = t.directiveEnd,
          s = t.index,
          o = (function kB() {
            return rt.lFrame.currentDirectiveIndex;
          })();
        try {
          ca(s);
          for (let a = i; a < r; a++) {
            const l = n.data[a],
              c = e[a];
            j_(a),
              (null !== l.hostBindings ||
                0 !== l.hostVars ||
                null !== l.hostAttrs) &&
                XV(l, c);
          }
        } finally {
          ca(-1), j_(o);
        }
      }
      function XV(n, e) {
        null !== n.hostBindings && n.hostBindings(1, e);
      }
      function ty(n, e, t) {
        (e.componentOffset = t),
          (n.components ?? (n.components = [])).push(e.index);
      }
      function ZV(n, e, t) {
        if (t) {
          if (e.exportAs)
            for (let i = 0; i < e.exportAs.length; i++) t[e.exportAs[i]] = n;
          Br(e) && (t[""] = n);
        }
      }
      function $V(n, e, t, i, r) {
        n.data[i] = r;
        const s = r.factory || (r.factory = la(r.type)),
          o = new ku(s, Br(r), G);
        (n.blueprint[i] = o),
          (t[i] = o),
          (function GV(n, e, t, i, r) {
            const s = r.hostBindings;
            if (s) {
              let o = n.hostBindingOpCodes;
              null === o && (o = n.hostBindingOpCodes = []);
              const a = ~e.index;
              (function WV(n) {
                let e = n.length;
                for (; e > 0; ) {
                  const t = n[--e];
                  if ("number" == typeof t && t < 0) return t;
                }
                return 0;
              })(o) != a && o.push(a),
                o.push(t, i, s);
            }
          })(n, e, i, Ju(n, t, r.hostVars, st), r);
      }
      function ps(n, e, t, i, r, s) {
        const o = Zi(n, e);
        !(function ny(n, e, t, i, r, s, o) {
          if (null == s) n.removeAttribute(e, r, t);
          else {
            const a = null == o ? it(s) : o(s, i || "", r);
            n.setAttribute(e, r, a, t);
          }
        })(e[gt], o, s, n.value, t, i, r);
      }
      function JV(n, e, t, i, r, s) {
        const o = s[e];
        if (null !== o) {
          const a = i.setInput;
          for (let l = 0; l < o.length; ) {
            const c = o[l++],
              u = o[l++],
              d = o[l++];
            null !== a ? i.setInput(t, d, c, u) : (t[u] = d);
          }
        }
      }
      function ez(n, e, t) {
        let i = null,
          r = 0;
        for (; r < t.length; ) {
          const s = t[r];
          if (0 !== s)
            if (5 !== s) {
              if ("number" == typeof s) break;
              if (n.hasOwnProperty(s)) {
                null === i && (i = []);
                const o = n[s];
                for (let a = 0; a < o.length; a += 2)
                  if (o[a] === e) {
                    i.push(s, o[a + 1], t[r + 1]);
                    break;
                  }
              }
              r += 2;
            } else r += 2;
          else r += 4;
        }
        return i;
      }
      function jC(n, e, t, i) {
        return [n, !0, !1, e, null, 0, i, t, null, null];
      }
      function iz(n, e) {
        const t = Ni(e, n);
        if (bf(t)) {
          const i = t[De];
          48 & t[pt] ? Xf(i, t, i.template, t[En]) : t[aa] > 0 && iy(t);
        }
      }
      function iy(n) {
        for (let i = _v(n); null !== i; i = vv(i))
          for (let r = xi; r < i.length; r++) {
            const s = i[r];
            if (bf(s))
              if (512 & s[pt]) {
                const o = s[De];
                Xf(o, s, o.template, s[En]);
              } else s[aa] > 0 && iy(s);
          }
        const t = n[De].components;
        if (null !== t)
          for (let i = 0; i < t.length; i++) {
            const r = Ni(t[i], n);
            bf(r) && r[aa] > 0 && iy(r);
          }
      }
      function rz(n, e) {
        const t = Ni(e, n),
          i = t[De];
        (function sz(n, e) {
          for (let t = e.length; t < n.blueprint.length; t++)
            e.push(n.blueprint[t]);
        })(i, t),
          Zv(i, t, t[En]);
      }
      function qf(n, e) {
        return n[Pu] ? (n[MS][Nr] = e) : (n[Pu] = e), (n[MS] = e), e;
      }
      function Yf(n) {
        for (; n; ) {
          n[pt] |= 32;
          const e = qu(n);
          if (_B(n) && !e) return n;
          n = e;
        }
        return null;
      }
      function Zf(n, e, t, i = !0) {
        const r = e[mf];
        r.begin && r.begin();
        try {
          Xf(n, e, n.template, t);
        } catch (o) {
          throw (i && ZC(e, o), o);
        } finally {
          r.end && r.end();
        }
      }
      function ry(n, e, t) {
        q_(0), e(n, t);
      }
      function XC(n) {
        return n[ul] || (n[ul] = []);
      }
      function qC(n) {
        return n.cleanup || (n.cleanup = []);
      }
      function ZC(n, e) {
        const t = n[pf],
          i = t ? t.get(Il, null) : null;
        i && i.handleError(e);
      }
      function sy(n, e, t, i, r) {
        for (let s = 0; s < t.length; ) {
          const o = t[s++],
            a = t[s++],
            l = e[o],
            c = n.data[o];
          null !== c.setInput ? c.setInput(l, r, i, a) : (l[a] = r);
        }
      }
      function Ws(n, e, t) {
        const i = yf(e, n);
        !(function PE(n, e, t) {
          n.setValue(e, t);
        })(n[gt], i, t);
      }
      function Kf(n, e, t) {
        let i = t ? n.styles : null,
          r = t ? n.classes : null,
          s = 0;
        if (null !== e)
          for (let o = 0; o < e.length; o++) {
            const a = e[o];
            "number" == typeof a
              ? (s = a)
              : 1 == s
              ? (r = D_(r, a))
              : 2 == s && (i = D_(i, a + ": " + e[++o] + ";"));
          }
        t ? (n.styles = i) : (n.stylesWithoutHost = i),
          t ? (n.classes = r) : (n.classesWithoutHost = r);
      }
      function $f(n, e, t, i, r = !1) {
        for (; null !== t; ) {
          const s = e[t.index];
          if ((null !== s && i.push(ti(s)), kr(s)))
            for (let a = xi; a < s.length; a++) {
              const l = s[a],
                c = l[De].firstChild;
              null !== c && $f(l[De], l, c, i);
            }
          const o = t.type;
          if (8 & o) $f(n, e, t.child, i);
          else if (32 & o) {
            const a = gv(t, e);
            let l;
            for (; (l = a()); ) i.push(l);
          } else if (16 & o) {
            const a = GE(e, t);
            if (Array.isArray(a)) i.push(...a);
            else {
              const l = qu(e[pi]);
              $f(l[De], l, a, i, !0);
            }
          }
          t = r ? t.projectionNext : t.next;
        }
        return i;
      }
      class ed {
        get rootNodes() {
          const e = this._lView,
            t = e[De];
          return $f(t, e, t.firstChild, []);
        }
        constructor(e, t) {
          (this._lView = e),
            (this._cdRefInjectingView = t),
            (this._appRef = null),
            (this._attachedToViewContainer = !1);
        }
        get context() {
          return this._lView[En];
        }
        set context(e) {
          this._lView[En] = e;
        }
        get destroyed() {
          return 128 == (128 & this._lView[pt]);
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this);
          else if (this._attachedToViewContainer) {
            const e = this._lView[vn];
            if (kr(e)) {
              const t = e[_f],
                i = t ? t.indexOf(this) : -1;
              i > -1 && (xv(e, i), Df(t, i));
            }
            this._attachedToViewContainer = !1;
          }
          LE(this._lView[De], this._lView);
        }
        onDestroy(e) {
          VC(this._lView[De], this._lView, null, e);
        }
        markForCheck() {
          Yf(this._cdRefInjectingView || this._lView);
        }
        detach() {
          this._lView[pt] &= -65;
        }
        reattach() {
          this._lView[pt] |= 64;
        }
        detectChanges() {
          Zf(this._lView[De], this._lView, this.context);
        }
        checkNoChanges() {}
        attachToViewContainerRef() {
          if (this._appRef) throw new J(902, !1);
          this._attachedToViewContainer = !0;
        }
        detachFromAppRef() {
          (this._appRef = null),
            (function WU(n, e) {
              Yu(n, e, e[gt], 2, null, null);
            })(this._lView[De], this._lView);
        }
        attachToAppRef(e) {
          if (this._attachedToViewContainer) throw new J(902, !1);
          this._appRef = e;
        }
      }
      class oz extends ed {
        constructor(e) {
          super(e), (this._view = e);
        }
        detectChanges() {
          const e = this._view;
          Zf(e[De], e, e[En], !1);
        }
        checkNoChanges() {}
        get context() {
          return null;
        }
      }
      class KC extends Al {
        constructor(e) {
          super(), (this.ngModule = e);
        }
        resolveComponentFactory(e) {
          const t = Ht(e);
          return new td(t, this.ngModule);
        }
      }
      function $C(n) {
        const e = [];
        for (let t in n)
          n.hasOwnProperty(t) && e.push({ propName: n[t], templateName: t });
        return e;
      }
      class lz {
        constructor(e, t) {
          (this.injector = e), (this.parentInjector = t);
        }
        get(e, t, i) {
          i = df(i);
          const r = this.injector.get(e, Vv, i);
          return r !== Vv || t === Vv ? r : this.parentInjector.get(e, t, i);
        }
      }
      class td extends _C {
        get inputs() {
          return $C(this.componentDef.inputs);
        }
        get outputs() {
          return $C(this.componentDef.outputs);
        }
        constructor(e, t) {
          super(),
            (this.componentDef = e),
            (this.ngModule = t),
            (this.componentType = e.type),
            (this.selector = (function fV(n) {
              return n.map(hV).join(",");
            })(e.selectors)),
            (this.ngContentSelectors = e.ngContentSelectors
              ? e.ngContentSelectors
              : []),
            (this.isBoundToModule = !!t);
        }
        create(e, t, i, r) {
          let s = (r = r || this.ngModule) instanceof zs ? r : r?.injector;
          s &&
            null !== this.componentDef.getStandaloneInjector &&
            (s = this.componentDef.getStandaloneInjector(s) || s);
          const o = s ? new lz(e, s) : e,
            a = o.get($u, null);
          if (null === a) throw new J(407, !1);
          const l = o.get(q3, null),
            c = a.createRenderer(null, this.componentDef),
            u = this.componentDef.selectors[0][0] || "div",
            d = i
              ? (function kV(n, e, t) {
                  return n.selectRootElement(e, t === Fr.ShadowDom);
                })(c, i, this.componentDef.encapsulation)
              : bv(
                  c,
                  u,
                  (function az(n) {
                    const e = n.toLowerCase();
                    return "svg" === e ? RS : "math" === e ? "math" : null;
                  })(u)
                ),
            h = this.componentDef.onPush ? 288 : 272,
            f = Jv(0, null, null, 1, 0, null, null, null, null, null),
            p = jf(null, f, null, h, null, null, a, c, l, o, null);
          let _, m;
          Y_(p);
          try {
            const g = this.componentDef;
            let y,
              v = null;
            g.findHostDirectiveDefs
              ? ((y = []),
                (v = new Map()),
                g.findHostDirectiveDefs(g, y, v),
                y.push(g))
              : (y = [g]);
            const b = (function uz(n, e) {
                const t = n[De],
                  i = nn;
                return (n[i] = e), Ol(t, i, 2, "#host", null);
              })(p, d),
              x = (function dz(n, e, t, i, r, s, o, a) {
                const l = r[De];
                !(function hz(n, e, t, i) {
                  for (const r of n)
                    e.mergedAttrs = Bu(e.mergedAttrs, r.hostAttrs);
                  null !== e.mergedAttrs &&
                    (Kf(e, e.mergedAttrs, !0), null !== t && XE(i, t, e));
                })(i, n, e, o);
                const c = s.createRenderer(e, t),
                  u = jf(
                    r,
                    UC(t),
                    null,
                    t.onPush ? 32 : 16,
                    r[n.index],
                    n,
                    s,
                    c,
                    a || null,
                    null,
                    null
                  );
                return (
                  l.firstCreatePass && ty(l, n, i.length - 1),
                  qf(r, u),
                  (r[n.index] = u)
                );
              })(b, d, g, y, p, a, c);
            (m = OS(f, nn)),
              d &&
                (function pz(n, e, t, i) {
                  if (i) J_(n, t, ["ng-version", Y3.full]);
                  else {
                    const { attrs: r, classes: s } = (function pV(n) {
                      const e = [],
                        t = [];
                      let i = 1,
                        r = 2;
                      for (; i < n.length; ) {
                        let s = n[i];
                        if ("string" == typeof s)
                          2 === r
                            ? "" !== s && e.push(s, n[++i])
                            : 8 === r && t.push(s);
                        else {
                          if (!Ur(r)) break;
                          r = s;
                        }
                        i++;
                      }
                      return { attrs: e, classes: t };
                    })(e.selectors[0]);
                    r && J_(n, t, r),
                      s && s.length > 0 && jE(n, t, s.join(" "));
                  }
                })(c, g, d, i),
              void 0 !== t &&
                (function mz(n, e, t) {
                  const i = (n.projection = []);
                  for (let r = 0; r < e.length; r++) {
                    const s = t[r];
                    i.push(null != s ? Array.from(s) : null);
                  }
                })(m, this.ngContentSelectors, t),
              (_ = (function fz(n, e, t, i, r, s) {
                const o = ni(),
                  a = r[De],
                  l = Zi(o, r);
                GC(a, r, o, t, null, i);
                for (let u = 0; u < t.length; u++)
                  mi(ua(r, a, o.directiveStart + u, o), r);
                WC(a, r, o), l && mi(l, r);
                const c = ua(r, a, o.directiveStart + o.componentOffset, o);
                if (((n[En] = r[En] = c), null !== s))
                  for (const u of s) u(c, e);
                return Kv(a, o, n), c;
              })(x, g, y, v, p, [gz])),
              Zv(f, p, null);
          } finally {
            Z_();
          }
          return new cz(this.componentType, _, Dl(m, p), p, m);
        }
      }
      class cz extends z3 {
        constructor(e, t, i, r, s) {
          super(),
            (this.location = i),
            (this._rootLView = r),
            (this._tNode = s),
            (this.instance = t),
            (this.hostView = this.changeDetectorRef = new oz(r)),
            (this.componentType = e);
        }
        setInput(e, t) {
          const i = this._tNode.inputs;
          let r;
          if (null !== i && (r = i[e])) {
            const s = this._rootLView;
            sy(s[De], s, r, e, t), Yf(Ni(this._tNode.index, s));
          }
        }
        get injector() {
          return new _l(this._tNode, this._rootLView);
        }
        destroy() {
          this.hostView.destroy();
        }
        onDestroy(e) {
          this.hostView.onDestroy(e);
        }
      }
      function gz() {
        const n = ni();
        xf(se()[De], n);
      }
      function St(n) {
        let e = (function QC(n) {
            return Object.getPrototypeOf(n.prototype).constructor;
          })(n.type),
          t = !0;
        const i = [n];
        for (; e; ) {
          let r;
          if (Br(n)) r = e.ɵcmp || e.ɵdir;
          else {
            if (e.ɵcmp) throw new J(903, !1);
            r = e.ɵdir;
          }
          if (r) {
            if (t) {
              i.push(r);
              const o = n;
              (o.inputs = oy(n.inputs)),
                (o.declaredInputs = oy(n.declaredInputs)),
                (o.outputs = oy(n.outputs));
              const a = r.hostBindings;
              a && bz(n, a);
              const l = r.viewQuery,
                c = r.contentQueries;
              if (
                (l && vz(n, l),
                c && yz(n, c),
                A_(n.inputs, r.inputs),
                A_(n.declaredInputs, r.declaredInputs),
                A_(n.outputs, r.outputs),
                Br(r) && r.data.animation)
              ) {
                const u = n.data;
                u.animation = (u.animation || []).concat(r.data.animation);
              }
            }
            const s = r.features;
            if (s)
              for (let o = 0; o < s.length; o++) {
                const a = s[o];
                a && a.ngInherit && a(n), a === St && (t = !1);
              }
          }
          e = Object.getPrototypeOf(e);
        }
        !(function _z(n) {
          let e = 0,
            t = null;
          for (let i = n.length - 1; i >= 0; i--) {
            const r = n[i];
            (r.hostVars = e += r.hostVars),
              (r.hostAttrs = Bu(r.hostAttrs, (t = Bu(t, r.hostAttrs))));
          }
        })(i);
      }
      function oy(n) {
        return n === Fs ? {} : n === Bt ? [] : n;
      }
      function vz(n, e) {
        const t = n.viewQuery;
        n.viewQuery = t
          ? (i, r) => {
              e(i, r), t(i, r);
            }
          : e;
      }
      function yz(n, e) {
        const t = n.contentQueries;
        n.contentQueries = t
          ? (i, r, s) => {
              e(i, r, s), t(i, r, s);
            }
          : e;
      }
      function bz(n, e) {
        const t = n.hostBindings;
        n.hostBindings = t
          ? (i, r) => {
              e(i, r), t(i, r);
            }
          : e;
      }
      function Qf(n) {
        return (
          !!ay(n) &&
          (Array.isArray(n) || (!(n instanceof Map) && Symbol.iterator in n))
        );
      }
      function ay(n) {
        return null !== n && ("function" == typeof n || "object" == typeof n);
      }
      function ms(n, e, t) {
        return (n[e] = t);
      }
      function gi(n, e, t) {
        return !Object.is(n[e], t) && ((n[e] = t), !0);
      }
      function ga(n, e, t, i) {
        const r = gi(n, e, t);
        return gi(n, e + 1, i) || r;
      }
      function ii(n, e, t, i) {
        const r = se();
        return gi(r, ml(), e) && (Rt(), ps(un(), r, n, e, t, i)), ii;
      }
      function Nl(n, e, t, i, r, s) {
        const a = ga(
          n,
          (function Bs() {
            return rt.lFrame.bindingIndex;
          })(),
          t,
          r
        );
        return Us(2), a ? e + it(t) + i + it(r) + s : st;
      }
      function jt(n, e, t, i, r, s, o, a) {
        const l = se(),
          c = Rt(),
          u = n + nn,
          d = c.firstCreatePass
            ? (function Iz(n, e, t, i, r, s, o, a, l) {
                const c = e.consts,
                  u = Ol(e, n, 4, o || null, Mo(c, a));
                ey(e, t, u, Mo(c, l)), xf(e, u);
                const d = (u.tView = Jv(
                  2,
                  u,
                  i,
                  r,
                  s,
                  e.directiveRegistry,
                  e.pipeRegistry,
                  null,
                  e.schemas,
                  c
                ));
                return (
                  null !== e.queries &&
                    (e.queries.template(e, u),
                    (d.queries = e.queries.embeddedTView(u))),
                  u
                );
              })(u, c, l, e, t, i, r, s, o)
            : c.data[u];
        ds(d, !1);
        const h = l[gt].createComment("");
        Ff(c, l, h, d),
          mi(h, l),
          qf(l, (l[u] = jC(h, l, h, d))),
          vf(d) && $v(c, l, d),
          null != o && Qv(l, d, a);
      }
      function yr(n) {
        return pl(
          (function LB() {
            return rt.lFrame.contextLView;
          })(),
          nn + n
        );
      }
      function Xe(n, e, t) {
        const i = se();
        return gi(i, ml(), e) && Ji(Rt(), un(), i, n, e, i[gt], t, !1), Xe;
      }
      function ly(n, e, t, i, r) {
        const o = r ? "class" : "style";
        sy(n, t, e.inputs[o], o, i);
      }
      function Se(n, e, t, i) {
        const r = se(),
          s = Rt(),
          o = nn + n,
          a = r[gt],
          l = s.firstCreatePass
            ? (function Pz(n, e, t, i, r, s) {
                const o = e.consts,
                  l = Ol(e, n, 2, i, Mo(o, r));
                return (
                  ey(e, t, l, Mo(o, s)),
                  null !== l.attrs && Kf(l, l.attrs, !1),
                  null !== l.mergedAttrs && Kf(l, l.mergedAttrs, !0),
                  null !== e.queries && e.queries.elementStart(e, l),
                  l
                );
              })(o, s, r, e, t, i)
            : s.data[o],
          c = (r[o] = bv(
            a,
            e,
            (function GB() {
              return rt.lFrame.currentNamespace;
            })()
          )),
          u = vf(l);
        return (
          ds(l, !0),
          XE(a, c, l),
          32 != (32 & l.flags) && Ff(s, r, c, l),
          0 ===
            (function DB() {
              return rt.lFrame.elementDepthCount;
            })() && mi(c, r),
          (function IB() {
            rt.lFrame.elementDepthCount++;
          })(),
          u && ($v(s, r, l), Kv(s, l, r)),
          null !== i && Qv(r, l),
          Se
        );
      }
      function Re() {
        let n = ni();
        G_() ? W_() : ((n = n.parent), ds(n, !1));
        const e = n;
        !(function RB() {
          rt.lFrame.elementDepthCount--;
        })();
        const t = Rt();
        return (
          t.firstCreatePass && (xf(t, n), V_(n) && t.queries.elementEnd(n)),
          null != e.classesWithoutHost &&
            (function qB(n) {
              return 0 != (8 & n.flags);
            })(e) &&
            ly(t, e, se(), e.classesWithoutHost, !0),
          null != e.stylesWithoutHost &&
            (function YB(n) {
              return 0 != (16 & n.flags);
            })(e) &&
            ly(t, e, se(), e.stylesWithoutHost, !1),
          Re
        );
      }
      function Gt(n, e, t, i) {
        return Se(n, e, t, i), Re(), Gt;
      }
      function Vr(n, e, t) {
        const i = se(),
          r = Rt(),
          s = n + nn,
          o = r.firstCreatePass
            ? (function Oz(n, e, t, i, r) {
                const s = e.consts,
                  o = Mo(s, i),
                  a = Ol(e, n, 8, "ng-container", o);
                return (
                  null !== o && Kf(a, o, !0),
                  ey(e, t, a, Mo(s, r)),
                  null !== e.queries && e.queries.elementStart(e, a),
                  a
                );
              })(s, r, i, e, t)
            : r.data[s];
        ds(o, !0);
        const a = (i[s] = i[gt].createComment(""));
        return (
          Ff(r, i, a, o),
          mi(a, i),
          vf(o) && ($v(r, i, o), Kv(r, o, i)),
          null != t && Qv(i, o),
          Vr
        );
      }
      function zr() {
        let n = ni();
        const e = Rt();
        return (
          G_() ? W_() : ((n = n.parent), ds(n, !1)),
          e.firstCreatePass && (xf(e, n), V_(n) && e.queries.elementEnd(n)),
          zr
        );
      }
      function qn() {
        return se();
      }
      function id(n) {
        return !!n && "function" == typeof n.then;
      }
      const cy = function hT(n) {
        return !!n && "function" == typeof n.subscribe;
      };
      function Le(n, e, t, i) {
        const r = se(),
          s = Rt(),
          o = ni();
        return (
          (function pT(n, e, t, i, r, s, o) {
            const a = vf(i),
              c = n.firstCreatePass && qC(n),
              u = e[En],
              d = XC(e);
            let h = !0;
            if (3 & i.type || o) {
              const _ = Zi(i, e),
                m = o ? o(_) : _,
                g = d.length,
                y = o ? (b) => o(ti(b[i.index])) : i.index;
              let v = null;
              if (
                (!o &&
                  a &&
                  (v = (function Lz(n, e, t, i) {
                    const r = n.cleanup;
                    if (null != r)
                      for (let s = 0; s < r.length - 1; s += 2) {
                        const o = r[s];
                        if (o === t && r[s + 1] === i) {
                          const a = e[ul],
                            l = r[s + 2];
                          return a.length > l ? a[l] : null;
                        }
                        "string" == typeof o && (s += 2);
                      }
                    return null;
                  })(n, e, r, i.index)),
                null !== v)
              )
                ((v.__ngLastListenerFn__ || v).__ngNextListenerFn__ = s),
                  (v.__ngLastListenerFn__ = s),
                  (h = !1);
              else {
                s = gT(i, e, u, s, !1);
                const b = t.listen(m, r, s);
                d.push(s, b), c && c.push(r, y, g, g + 1);
              }
            } else s = gT(i, e, u, s, !1);
            const f = i.outputs;
            let p;
            if (h && null !== f && (p = f[r])) {
              const _ = p.length;
              if (_)
                for (let m = 0; m < _; m += 2) {
                  const x = e[p[m]][p[m + 1]].subscribe(s),
                    M = d.length;
                  d.push(s, x), c && c.push(r, i.index, M, -(M + 1));
                }
            }
          })(s, r, r[gt], o, n, e, i),
          Le
        );
      }
      function mT(n, e, t, i) {
        try {
          return gr(6, e, t), !1 !== t(i);
        } catch (r) {
          return ZC(n, r), !1;
        } finally {
          gr(7, e, t);
        }
      }
      function gT(n, e, t, i, r) {
        return function s(o) {
          if (o === Function) return i;
          Yf(n.componentOffset > -1 ? Ni(n.index, e) : e);
          let l = mT(e, t, i, o),
            c = s.__ngNextListenerFn__;
          for (; c; ) (l = mT(e, t, c, o) && l), (c = c.__ngNextListenerFn__);
          return r && !1 === l && (o.preventDefault(), (o.returnValue = !1)), l;
        };
      }
      function me(n = 1) {
        return (function UB(n) {
          return (rt.lFrame.contextLView = (function VB(n, e) {
            for (; n > 0; ) (e = e[dl]), n--;
            return e;
          })(n, rt.lFrame.contextLView))[En];
        })(n);
      }
      function Fz(n, e) {
        let t = null;
        const i = (function lV(n) {
          const e = n.attrs;
          if (null != e) {
            const t = e.indexOf(5);
            if (!(1 & t)) return e[t + 1];
          }
          return null;
        })(n);
        for (let r = 0; r < e.length; r++) {
          const s = e[r];
          if ("*" !== s) {
            if (null === i ? MC(n, s, !0) : dV(i, s)) return r;
          } else t = r;
        }
        return t;
      }
      function rd(n) {
        const e = se()[pi][fi];
        if (!e.projection) {
          const i = (e.projection = Hu(n ? n.length : 1, null)),
            r = i.slice();
          let s = e.child;
          for (; null !== s; ) {
            const o = n ? Fz(s, n) : 0;
            null !== o &&
              (r[o] ? (r[o].projectionNext = s) : (i[o] = s), (r[o] = s)),
              (s = s.next);
          }
        }
      }
      function Gl(n, e = 0, t) {
        const i = se(),
          r = Rt(),
          s = Ol(r, nn + n, 16, null, t || null);
        null === s.projection && (s.projection = e),
          W_(),
          32 != (32 & s.flags) &&
            (function QU(n, e, t) {
              WE(e[gt], 0, e, t, FE(n, t, e), UE(t.parent || e[fi], t, e));
            })(r, i, s);
      }
      function ep(n, e) {
        return (n << 17) | (e << 2);
      }
      function So(n) {
        return (n >> 17) & 32767;
      }
      function dy(n) {
        return 2 | n;
      }
      function _a(n) {
        return (131068 & n) >> 2;
      }
      function hy(n, e) {
        return (-131069 & n) | (e << 2);
      }
      function fy(n) {
        return 1 | n;
      }
      function CT(n, e, t, i, r) {
        const s = n[t + 1],
          o = null === e;
        let a = i ? So(s) : _a(s),
          l = !1;
        for (; 0 !== a && (!1 === l || o); ) {
          const u = n[a + 1];
          zz(n[a], e) && ((l = !0), (n[a + 1] = i ? fy(u) : dy(u))),
            (a = i ? So(u) : _a(u));
        }
        l && (n[t + 1] = i ? dy(s) : fy(s));
      }
      function zz(n, e) {
        return (
          null === n ||
          null == e ||
          (Array.isArray(n) ? n[1] : n) === e ||
          (!(!Array.isArray(n) || "string" != typeof e) && wl(n, e) >= 0)
        );
      }
      const Hn = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 };
      function TT(n) {
        return n.substring(Hn.key, Hn.keyEnd);
      }
      function Hz(n) {
        return n.substring(Hn.value, Hn.valueEnd);
      }
      function DT(n, e) {
        const t = Hn.textEnd;
        let i = (Hn.key = Wl(n, e, t));
        return t === i
          ? -1
          : ((i = Hn.keyEnd =
              (function Xz(n, e, t) {
                let i;
                for (
                  ;
                  e < t &&
                  (45 === (i = n.charCodeAt(e)) ||
                    95 === i ||
                    ((-33 & i) >= 65 && (-33 & i) <= 90) ||
                    (i >= 48 && i <= 57));

                )
                  e++;
                return e;
              })(n, i, t)),
            (i = RT(n, i, t)),
            (i = Hn.value = Wl(n, i, t)),
            (i = Hn.valueEnd =
              (function qz(n, e, t) {
                let i = -1,
                  r = -1,
                  s = -1,
                  o = e,
                  a = o;
                for (; o < t; ) {
                  const l = n.charCodeAt(o++);
                  if (59 === l) return a;
                  34 === l || 39 === l
                    ? (a = o = PT(n, l, o, t))
                    : e === o - 4 &&
                      85 === s &&
                      82 === r &&
                      76 === i &&
                      40 === l
                    ? (a = o = PT(n, 41, o, t))
                    : l > 32 && (a = o),
                    (s = r),
                    (r = i),
                    (i = -33 & l);
                }
                return a;
              })(n, i, t)),
            RT(n, i, t));
      }
      function Wl(n, e, t) {
        for (; e < t && n.charCodeAt(e) <= 32; ) e++;
        return e;
      }
      function RT(n, e, t, i) {
        return (e = Wl(n, e, t)) < t && e++, e;
      }
      function PT(n, e, t, i) {
        let r = -1,
          s = t;
        for (; s < i; ) {
          const o = n.charCodeAt(s++);
          if (o == e && 92 !== r) return s;
          r = 92 == o && 92 === r ? 0 : o;
        }
        throw new Error();
      }
      function tp(n, e, t) {
        return Gr(n, e, t, !1), tp;
      }
      function gs(n, e) {
        return Gr(n, e, null, !0), gs;
      }
      function Hr(n) {
        !(function Wr(n, e, t, i) {
          const r = Rt(),
            s = Us(2);
          r.firstUpdatePass && LT(r, null, s, i);
          const o = se();
          if (t !== st && gi(o, s, t)) {
            const a = r.data[Mi()];
            if (BT(a, i) && !OT(r, s)) {
              let l = i ? a.classesWithoutHost : a.stylesWithoutHost;
              null !== l && (t = D_(l, t || "")), ly(r, a, o, t, i);
            } else
              !(function nH(n, e, t, i, r, s, o, a) {
                r === st && (r = Bt);
                let l = 0,
                  c = 0,
                  u = 0 < r.length ? r[0] : null,
                  d = 0 < s.length ? s[0] : null;
                for (; null !== u || null !== d; ) {
                  const h = l < r.length ? r[l + 1] : void 0,
                    f = c < s.length ? s[c + 1] : void 0;
                  let _,
                    p = null;
                  u === d
                    ? ((l += 2), (c += 2), h !== f && ((p = d), (_ = f)))
                    : null === d || (null !== u && u < d)
                    ? ((l += 2), (p = u))
                    : ((c += 2), (p = d), (_ = f)),
                    null !== p && NT(n, e, t, i, p, _, o, a),
                    (u = l < r.length ? r[l] : null),
                    (d = c < s.length ? s[c] : null);
                }
              })(
                r,
                a,
                o,
                o[gt],
                o[s + 1],
                (o[s + 1] = (function eH(n, e, t) {
                  if (null == t || "" === t) return Bt;
                  const i = [],
                    r = $i(t);
                  if (Array.isArray(r))
                    for (let s = 0; s < r.length; s++) n(i, r[s], !0);
                  else if ("object" == typeof r)
                    for (const s in r) r.hasOwnProperty(s) && n(i, s, r[s]);
                  else "string" == typeof r && e(i, r);
                  return i;
                })(n, e, t)),
                i,
                s
              );
          }
        })(FT, Yz, n, !1);
      }
      function Yz(n, e) {
        for (
          let t = (function Wz(n) {
            return (
              (function IT(n) {
                (Hn.key = 0),
                  (Hn.keyEnd = 0),
                  (Hn.value = 0),
                  (Hn.valueEnd = 0),
                  (Hn.textEnd = n.length);
              })(n),
              DT(n, Wl(n, 0, Hn.textEnd))
            );
          })(e);
          t >= 0;
          t = DT(e, t)
        )
          FT(n, TT(e), Hz(e));
      }
      function Gr(n, e, t, i) {
        const r = se(),
          s = Rt(),
          o = Us(2);
        s.firstUpdatePass && LT(s, n, o, i),
          e !== st &&
            gi(r, o, e) &&
            NT(
              s,
              s.data[Mi()],
              r,
              r[gt],
              n,
              (r[o + 1] = (function iH(n, e) {
                return (
                  null == n ||
                    "" === n ||
                    ("string" == typeof e
                      ? (n += e)
                      : "object" == typeof n && (n = $t($i(n)))),
                  n
                );
              })(e, t)),
              i,
              o
            );
      }
      function OT(n, e) {
        return e >= n.expandoStartIndex;
      }
      function LT(n, e, t, i) {
        const r = n.data;
        if (null === r[t + 1]) {
          const s = r[Mi()],
            o = OT(n, t);
          BT(s, i) && null === e && !o && (e = !1),
            (e = (function Kz(n, e, t, i) {
              const r = (function X_(n) {
                const e = rt.lFrame.currentDirectiveIndex;
                return -1 === e ? null : n[e];
              })(n);
              let s = i ? e.residualClasses : e.residualStyles;
              if (null === r)
                0 === (i ? e.classBindings : e.styleBindings) &&
                  ((t = sd((t = py(null, n, e, t, i)), e.attrs, i)),
                  (s = null));
              else {
                const o = e.directiveStylingLast;
                if (-1 === o || n[o] !== r)
                  if (((t = py(r, n, e, t, i)), null === s)) {
                    let l = (function $z(n, e, t) {
                      const i = t ? e.classBindings : e.styleBindings;
                      if (0 !== _a(i)) return n[So(i)];
                    })(n, e, i);
                    void 0 !== l &&
                      Array.isArray(l) &&
                      ((l = py(null, n, e, l[1], i)),
                      (l = sd(l, e.attrs, i)),
                      (function Qz(n, e, t, i) {
                        n[So(t ? e.classBindings : e.styleBindings)] = i;
                      })(n, e, i, l));
                  } else
                    s = (function Jz(n, e, t) {
                      let i;
                      const r = e.directiveEnd;
                      for (let s = 1 + e.directiveStylingLast; s < r; s++)
                        i = sd(i, n[s].hostAttrs, t);
                      return sd(i, e.attrs, t);
                    })(n, e, i);
              }
              return (
                void 0 !== s &&
                  (i ? (e.residualClasses = s) : (e.residualStyles = s)),
                t
              );
            })(r, s, e, i)),
            (function Uz(n, e, t, i, r, s) {
              let o = s ? e.classBindings : e.styleBindings,
                a = So(o),
                l = _a(o);
              n[i] = t;
              let u,
                c = !1;
              if (
                (Array.isArray(t)
                  ? ((u = t[1]), (null === u || wl(t, u) > 0) && (c = !0))
                  : (u = t),
                r)
              )
                if (0 !== l) {
                  const h = So(n[a + 1]);
                  (n[i + 1] = ep(h, a)),
                    0 !== h && (n[h + 1] = hy(n[h + 1], i)),
                    (n[a + 1] = (function kz(n, e) {
                      return (131071 & n) | (e << 17);
                    })(n[a + 1], i));
                } else
                  (n[i + 1] = ep(a, 0)),
                    0 !== a && (n[a + 1] = hy(n[a + 1], i)),
                    (a = i);
              else
                (n[i + 1] = ep(l, 0)),
                  0 === a ? (a = i) : (n[l + 1] = hy(n[l + 1], i)),
                  (l = i);
              c && (n[i + 1] = dy(n[i + 1])),
                CT(n, u, i, !0),
                CT(n, u, i, !1),
                (function Vz(n, e, t, i, r) {
                  const s = r ? n.residualClasses : n.residualStyles;
                  null != s &&
                    "string" == typeof e &&
                    wl(s, e) >= 0 &&
                    (t[i + 1] = fy(t[i + 1]));
                })(e, u, n, i, s),
                (o = ep(a, l)),
                s ? (e.classBindings = o) : (e.styleBindings = o);
            })(r, s, e, t, o, i);
        }
      }
      function py(n, e, t, i, r) {
        let s = null;
        const o = t.directiveEnd;
        let a = t.directiveStylingLast;
        for (
          -1 === a ? (a = t.directiveStart) : a++;
          a < o && ((s = e[a]), (i = sd(i, s.hostAttrs, r)), s !== n);

        )
          a++;
        return null !== n && (t.directiveStylingLast = a), i;
      }
      function sd(n, e, t) {
        const i = t ? 1 : 2;
        let r = -1;
        if (null !== e)
          for (let s = 0; s < e.length; s++) {
            const o = e[s];
            "number" == typeof o
              ? (r = o)
              : r === i &&
                (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]),
                Ki(n, o, !!t || e[++s]));
          }
        return void 0 === n ? null : n;
      }
      function FT(n, e, t) {
        Ki(n, e, $i(t));
      }
      function NT(n, e, t, i, r, s, o, a) {
        if (!(3 & e.type)) return;
        const l = n.data,
          c = l[a + 1],
          u = (function Bz(n) {
            return 1 == (1 & n);
          })(c)
            ? kT(l, e, t, r, _a(c), o)
            : void 0;
        np(u) ||
          (np(s) ||
            ((function Nz(n) {
              return 2 == (2 & n);
            })(c) &&
              (s = kT(l, null, t, r, a, o))),
          (function e3(n, e, t, i, r) {
            if (e) r ? n.addClass(t, i) : n.removeClass(t, i);
            else {
              let s = -1 === i.indexOf("-") ? void 0 : ki.DashCase;
              null == r
                ? n.removeStyle(t, i, s)
                : ("string" == typeof r &&
                    r.endsWith("!important") &&
                    ((r = r.slice(0, -10)), (s |= ki.Important)),
                  n.setStyle(t, i, r, s));
            }
          })(i, o, yf(Mi(), t), r, s));
      }
      function kT(n, e, t, i, r, s) {
        const o = null === e;
        let a;
        for (; r > 0; ) {
          const l = n[r],
            c = Array.isArray(l),
            u = c ? l[1] : l,
            d = null === u;
          let h = t[r + 1];
          h === st && (h = d ? Bt : void 0);
          let f = d ? av(h, i) : u === i ? h : void 0;
          if ((c && !np(f) && (f = av(l, i)), np(f) && ((a = f), o))) return a;
          const p = n[r + 1];
          r = o ? So(p) : _a(p);
        }
        if (null !== e) {
          let l = s ? e.residualClasses : e.residualStyles;
          null != l && (a = av(l, i));
        }
        return a;
      }
      function np(n) {
        return void 0 !== n;
      }
      function BT(n, e) {
        return 0 != (n.flags & (e ? 8 : 16));
      }
      function ri(n, e = "") {
        const t = se(),
          i = Rt(),
          r = n + nn,
          s = i.firstCreatePass ? Ol(i, r, 1, e, null) : i.data[r],
          o = (t[r] = (function yv(n, e) {
            return n.createText(e);
          })(t[gt], e));
        Ff(i, t, o, s), ds(s, !1);
      }
      function vs(n) {
        return ip("", n, ""), vs;
      }
      function ip(n, e, t) {
        const i = se(),
          r = (function Fl(n, e, t, i) {
            return gi(n, ml(), t) ? e + it(t) + i : st;
          })(i, n, e, t);
        return r !== st && Ws(i, Mi(), r), ip;
      }
      function my(n, e, t, i, r) {
        const s = se(),
          o = Nl(s, n, e, t, i, r);
        return o !== st && Ws(s, Mi(), o), my;
      }
      function gy(n, e, t) {
        const i = se();
        return gi(i, ml(), e) && Ji(Rt(), un(), i, n, e, i[gt], t, !0), gy;
      }
      const Xl = "en-US";
      let rA = Xl;
      function yy(n, e, t, i, r) {
        if (((n = Ke(n)), Array.isArray(n)))
          for (let s = 0; s < n.length; s++) yy(n[s], e, t, i, r);
        else {
          const s = Rt(),
            o = se();
          let a = pa(n) ? n : Ke(n.provide),
            l = gC(n);
          const c = ni(),
            u = 1048575 & c.providerIndexes,
            d = c.directiveStart,
            h = c.providerIndexes >> 20;
          if (pa(n) || !n.multi) {
            const f = new ku(l, r, G),
              p = xy(a, e, r ? u : u + h, d);
            -1 === p
              ? (iv(Tf(c, o), s, a),
                by(s, n, e.length),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                t.push(f),
                o.push(f))
              : ((t[p] = f), (o[p] = f));
          } else {
            const f = xy(a, e, u + h, d),
              p = xy(a, e, u, u + h),
              m = p >= 0 && t[p];
            if ((r && !m) || (!r && !(f >= 0 && t[f]))) {
              iv(Tf(c, o), s, a);
              const g = (function w4(n, e, t, i, r) {
                const s = new ku(n, t, G);
                return (
                  (s.multi = []),
                  (s.index = e),
                  (s.componentProviders = 0),
                  DA(s, r, i && !t),
                  s
                );
              })(r ? x4 : b4, t.length, r, i, l);
              !r && m && (t[p].providerFactory = g),
                by(s, n, e.length, 0),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                t.push(g),
                o.push(g);
            } else by(s, n, f > -1 ? f : p, DA(t[r ? p : f], l, !r && i));
            !r && i && m && t[p].componentProviders++;
          }
        }
      }
      function by(n, e, t, i) {
        const r = pa(e),
          s = (function L3(n) {
            return !!n.useClass;
          })(e);
        if (r || s) {
          const l = (s ? Ke(e.useClass) : e).prototype.ngOnDestroy;
          if (l) {
            const c = n.destroyHooks || (n.destroyHooks = []);
            if (!r && e.multi) {
              const u = c.indexOf(t);
              -1 === u ? c.push(t, [i, l]) : c[u + 1].push(i, l);
            } else c.push(t, l);
          }
        }
      }
      function DA(n, e, t) {
        return t && n.componentProviders++, n.multi.push(e) - 1;
      }
      function xy(n, e, t, i) {
        for (let r = t; r < i; r++) if (e[r] === n) return r;
        return -1;
      }
      function b4(n, e, t, i) {
        return wy(this.multi, []);
      }
      function x4(n, e, t, i) {
        const r = this.multi;
        let s;
        if (this.providerFactory) {
          const o = this.providerFactory.componentProviders,
            a = ua(t, t[De], this.providerFactory.index, i);
          (s = a.slice(0, o)), wy(r, s);
          for (let l = o; l < a.length; l++) s.push(a[l]);
        } else (s = []), wy(r, s);
        return s;
      }
      function wy(n, e) {
        for (let t = 0; t < n.length; t++) e.push((0, n[t])());
        return e;
      }
      function qt(n, e = []) {
        return (t) => {
          t.providersResolver = (i, r) =>
            (function y4(n, e, t) {
              const i = Rt();
              if (i.firstCreatePass) {
                const r = Br(n);
                yy(t, i.data, i.blueprint, r, !0),
                  yy(e, i.data, i.blueprint, r, !1);
              }
            })(i, r ? r(n) : n, e);
        };
      }
      class ql {}
      class IA {}
      class RA extends ql {
        constructor(e, t) {
          super(),
            (this._parent = t),
            (this._bootstrapComponents = []),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new KC(this));
          const i = qi(e);
          (this._bootstrapComponents = Gs(i.bootstrap)),
            (this._r3Injector = IC(
              e,
              t,
              [
                { provide: ql, useValue: this },
                { provide: Al, useValue: this.componentFactoryResolver },
              ],
              $t(e),
              new Set(["environment"])
            )),
            this._r3Injector.resolveInjectorInitializers(),
            (this.instance = this._r3Injector.get(e));
        }
        get injector() {
          return this._r3Injector;
        }
        destroy() {
          const e = this._r3Injector;
          !e.destroyed && e.destroy(),
            this.destroyCbs.forEach((t) => t()),
            (this.destroyCbs = null);
        }
        onDestroy(e) {
          this.destroyCbs.push(e);
        }
      }
      class My extends IA {
        constructor(e) {
          super(), (this.moduleType = e);
        }
        create(e) {
          return new RA(this.moduleType, e);
        }
      }
      class S4 extends ql {
        constructor(e, t, i) {
          super(),
            (this.componentFactoryResolver = new KC(this)),
            (this.instance = null);
          const r = new mC(
            [
              ...e,
              { provide: ql, useValue: this },
              { provide: Al, useValue: this.componentFactoryResolver },
            ],
            t || Gf(),
            i,
            new Set(["environment"])
          );
          (this.injector = r), r.resolveInjectorInitializers();
        }
        destroy() {
          this.injector.destroy();
        }
        onDestroy(e) {
          this.injector.onDestroy(e);
        }
      }
      function lp(n, e, t = null) {
        return new S4(n, e, t).injector;
      }
      let E4 = (() => {
        class n {
          constructor(t) {
            (this._injector = t), (this.cachedInjectors = new Map());
          }
          getOrCreateStandaloneInjector(t) {
            if (!t.standalone) return null;
            if (!this.cachedInjectors.has(t.id)) {
              const i = dC(0, t.type),
                r =
                  i.length > 0
                    ? lp([i], this._injector, `Standalone[${t.type.name}]`)
                    : null;
              this.cachedInjectors.set(t.id, r);
            }
            return this.cachedInjectors.get(t.id);
          }
          ngOnDestroy() {
            try {
              for (const t of this.cachedInjectors.values())
                null !== t && t.destroy();
            } finally {
              this.cachedInjectors.clear();
            }
          }
        }
        return (
          (n.ɵprov = Me({
            token: n,
            providedIn: "environment",
            factory: () => new n(re(zs)),
          })),
          n
        );
      })();
      function Sy(n) {
        n.getStandaloneInjector = (e) =>
          e.get(E4).getOrCreateStandaloneInjector(n);
      }
      function dd(n, e, t, i) {
        return BA(se(), wi(), n, e, t, i);
      }
      function Cy(n, e, t, i, r) {
        return (function UA(n, e, t, i, r, s, o) {
          const a = e + t;
          return ga(n, a, r, s)
            ? ms(n, a + 2, o ? i.call(o, r, s) : i(r, s))
            : hd(n, a + 2);
        })(se(), wi(), n, e, t, i, r);
      }
      function hd(n, e) {
        const t = n[e];
        return t === st ? void 0 : t;
      }
      function BA(n, e, t, i, r, s) {
        const o = e + t;
        return gi(n, o, r)
          ? ms(n, o + 1, s ? i.call(s, r) : i(r))
          : hd(n, o + 1);
      }
      function WA(n, e, t) {
        const i = n + nn,
          r = se(),
          s = pl(r, i);
        return (function fd(n, e) {
          return n[De].data[e].pure;
        })(r, i)
          ? BA(r, wi(), e, s.transform, t, s)
          : s.transform(t);
      }
      function Ty(n) {
        return (e) => {
          setTimeout(n, void 0, e);
        };
      }
      const Ut = class q4 extends kt {
        constructor(e = !1) {
          super(), (this.__isAsync = e);
        }
        emit(e) {
          super.next(e);
        }
        subscribe(e, t, i) {
          let r = e,
            s = t || (() => null),
            o = i;
          if (e && "object" == typeof e) {
            const l = e;
            (r = l.next?.bind(l)),
              (s = l.error?.bind(l)),
              (o = l.complete?.bind(l));
          }
          this.__isAsync && ((s = Ty(s)), r && (r = Ty(r)), o && (o = Ty(o)));
          const a = super.subscribe({ next: r, error: s, complete: o });
          return e instanceof Sn && e.add(a), a;
        }
      };
      function Y4() {
        return this._results[Symbol.iterator]();
      }
      class Yl {
        get changes() {
          return this._changes || (this._changes = new Ut());
        }
        constructor(e = !1) {
          (this._emitDistinctChangesOnly = e),
            (this.dirty = !0),
            (this._results = []),
            (this._changesDetected = !1),
            (this._changes = null),
            (this.length = 0),
            (this.first = void 0),
            (this.last = void 0);
          const t = Yl.prototype;
          t[Symbol.iterator] || (t[Symbol.iterator] = Y4);
        }
        get(e) {
          return this._results[e];
        }
        map(e) {
          return this._results.map(e);
        }
        filter(e) {
          return this._results.filter(e);
        }
        find(e) {
          return this._results.find(e);
        }
        reduce(e, t) {
          return this._results.reduce(e, t);
        }
        forEach(e) {
          this._results.forEach(e);
        }
        some(e) {
          return this._results.some(e);
        }
        toArray() {
          return this._results.slice();
        }
        toString() {
          return this._results.toString();
        }
        reset(e, t) {
          const i = this;
          i.dirty = !1;
          const r = (function _r(n) {
            return n.flat(Number.POSITIVE_INFINITY);
          })(e);
          (this._changesDetected = !(function rU(n, e, t) {
            if (n.length !== e.length) return !1;
            for (let i = 0; i < n.length; i++) {
              let r = n[i],
                s = e[i];
              if ((t && ((r = t(r)), (s = t(s))), s !== r)) return !1;
            }
            return !0;
          })(i._results, r, t)) &&
            ((i._results = r),
            (i.length = r.length),
            (i.last = r[this.length - 1]),
            (i.first = r[0]));
        }
        notifyOnChanges() {
          this._changes &&
            (this._changesDetected || !this._emitDistinctChangesOnly) &&
            this._changes.emit(this);
        }
        setDirty() {
          this.dirty = !0;
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe();
        }
      }
      let ys = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = $4), n;
      })();
      const Z4 = ys,
        K4 = class extends Z4 {
          constructor(e, t, i) {
            super(),
              (this._declarationLView = e),
              (this._declarationTContainer = t),
              (this.elementRef = i);
          }
          createEmbeddedView(e, t) {
            const i = this._declarationTContainer.tView,
              r = jf(
                this._declarationLView,
                i,
                e,
                16,
                null,
                i.declTNode,
                null,
                null,
                null,
                null,
                t || null
              );
            r[Ou] = this._declarationLView[this._declarationTContainer.index];
            const o = this._declarationLView[us];
            return (
              null !== o && (r[us] = o.createEmbeddedView(i)),
              Zv(i, r, e),
              new ed(r)
            );
          }
        };
      function $4() {
        return cp(ni(), se());
      }
      function cp(n, e) {
        return 4 & n.type ? new K4(e, n, Dl(n, e)) : null;
      }
      let br = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = Q4), n;
      })();
      function Q4() {
        return qA(ni(), se());
      }
      const J4 = br,
        jA = class extends J4 {
          constructor(e, t, i) {
            super(),
              (this._lContainer = e),
              (this._hostTNode = t),
              (this._hostLView = i);
          }
          get element() {
            return Dl(this._hostTNode, this._hostLView);
          }
          get injector() {
            return new _l(this._hostTNode, this._hostLView);
          }
          get parentInjector() {
            const e = nv(this._hostTNode, this._hostLView);
            if (QS(e)) {
              const t = Ef(e, this._hostLView),
                i = Sf(e);
              return new _l(t[De].data[i + 8], t);
            }
            return new _l(null, this._hostLView);
          }
          clear() {
            for (; this.length > 0; ) this.remove(this.length - 1);
          }
          get(e) {
            const t = XA(this._lContainer);
            return (null !== t && t[e]) || null;
          }
          get length() {
            return this._lContainer.length - xi;
          }
          createEmbeddedView(e, t, i) {
            let r, s;
            "number" == typeof i
              ? (r = i)
              : null != i && ((r = i.index), (s = i.injector));
            const o = e.createEmbeddedView(t || {}, s);
            return this.insert(o, r), o;
          }
          createComponent(e, t, i, r, s) {
            const o =
              e &&
              !(function zu(n) {
                return "function" == typeof n;
              })(e);
            let a;
            if (o) a = t;
            else {
              const d = t || {};
              (a = d.index),
                (i = d.injector),
                (r = d.projectableNodes),
                (s = d.environmentInjector || d.ngModuleRef);
            }
            const l = o ? e : new td(Ht(e)),
              c = i || this.parentInjector;
            if (!s && null == l.ngModule) {
              const h = (o ? c : this.parentInjector).get(zs, null);
              h && (s = h);
            }
            const u = l.create(c, r, void 0, s);
            return this.insert(u.hostView, a), u;
          }
          insert(e, t) {
            const i = e._lView,
              r = i[De];
            if (
              (function AB(n) {
                return kr(n[vn]);
              })(i)
            ) {
              const u = this.indexOf(e);
              if (-1 !== u) this.detach(u);
              else {
                const d = i[vn],
                  h = new jA(d, d[fi], d[vn]);
                h.detach(h.indexOf(e));
              }
            }
            const s = this._adjustIndex(t),
              o = this._lContainer;
            !(function XU(n, e, t, i) {
              const r = xi + i,
                s = t.length;
              i > 0 && (t[r - 1][Nr] = e),
                i < s - xi
                  ? ((e[Nr] = t[r]), uE(t, xi + i, e))
                  : (t.push(e), (e[Nr] = null)),
                (e[vn] = t);
              const o = e[Ou];
              null !== o &&
                t !== o &&
                (function qU(n, e) {
                  const t = n[fl];
                  e[pi] !== e[vn][vn][pi] && (n[ES] = !0),
                    null === t ? (n[fl] = [e]) : t.push(e);
                })(o, e);
              const a = e[us];
              null !== a && a.insertView(n), (e[pt] |= 64);
            })(r, i, o, s);
            const a = Sv(s, o),
              l = i[gt],
              c = Lf(l, o[gf]);
            return (
              null !== c &&
                (function GU(n, e, t, i, r, s) {
                  (i[ks] = r), (i[fi] = e), Yu(n, i, t, 1, r, s);
                })(r, o[fi], l, i, c, a),
              e.attachToViewContainerRef(),
              uE(Ay(o), s, e),
              e
            );
          }
          move(e, t) {
            return this.insert(e, t);
          }
          indexOf(e) {
            const t = XA(this._lContainer);
            return null !== t ? t.indexOf(e) : -1;
          }
          remove(e) {
            const t = this._adjustIndex(e, -1),
              i = xv(this._lContainer, t);
            i && (Df(Ay(this._lContainer), t), LE(i[De], i));
          }
          detach(e) {
            const t = this._adjustIndex(e, -1),
              i = xv(this._lContainer, t);
            return i && null != Df(Ay(this._lContainer), t) ? new ed(i) : null;
          }
          _adjustIndex(e, t = 0) {
            return e ?? this.length + t;
          }
        };
      function XA(n) {
        return n[_f];
      }
      function Ay(n) {
        return n[_f] || (n[_f] = []);
      }
      function qA(n, e) {
        let t;
        const i = e[n.index];
        if (kr(i)) t = i;
        else {
          let r;
          if (8 & n.type) r = ti(i);
          else {
            const s = e[gt];
            r = s.createComment("");
            const o = Zi(n, e);
            ha(
              s,
              Lf(s, o),
              r,
              (function $U(n, e) {
                return n.nextSibling(e);
              })(s, o),
              !1
            );
          }
          (e[n.index] = t = jC(i, e, r, n)), qf(e, t);
        }
        return new jA(t, n, e);
      }
      class Dy {
        constructor(e) {
          (this.queryList = e), (this.matches = null);
        }
        clone() {
          return new Dy(this.queryList);
        }
        setDirty() {
          this.queryList.setDirty();
        }
      }
      class Iy {
        constructor(e = []) {
          this.queries = e;
        }
        createEmbeddedView(e) {
          const t = e.queries;
          if (null !== t) {
            const i =
                null !== e.contentQueries ? e.contentQueries[0] : t.length,
              r = [];
            for (let s = 0; s < i; s++) {
              const o = t.getByIndex(s);
              r.push(this.queries[o.indexInDeclarationView].clone());
            }
            return new Iy(r);
          }
          return null;
        }
        insertView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        detachView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        dirtyQueriesWithMatches(e) {
          for (let t = 0; t < this.queries.length; t++)
            null !== QA(e, t).matches && this.queries[t].setDirty();
        }
      }
      class YA {
        constructor(e, t, i = null) {
          (this.predicate = e), (this.flags = t), (this.read = i);
        }
      }
      class Ry {
        constructor(e = []) {
          this.queries = e;
        }
        elementStart(e, t) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].elementStart(e, t);
        }
        elementEnd(e) {
          for (let t = 0; t < this.queries.length; t++)
            this.queries[t].elementEnd(e);
        }
        embeddedTView(e) {
          let t = null;
          for (let i = 0; i < this.length; i++) {
            const r = null !== t ? t.length : 0,
              s = this.getByIndex(i).embeddedTView(e, r);
            s &&
              ((s.indexInDeclarationView = i),
              null !== t ? t.push(s) : (t = [s]));
          }
          return null !== t ? new Ry(t) : null;
        }
        template(e, t) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].template(e, t);
        }
        getByIndex(e) {
          return this.queries[e];
        }
        get length() {
          return this.queries.length;
        }
        track(e) {
          this.queries.push(e);
        }
      }
      class Py {
        constructor(e, t = -1) {
          (this.metadata = e),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = t);
        }
        elementStart(e, t) {
          this.isApplyingToNode(t) && this.matchTNode(e, t);
        }
        elementEnd(e) {
          this._declarationNodeIndex === e.index &&
            (this._appliesToNextNode = !1);
        }
        template(e, t) {
          this.elementStart(e, t);
        }
        embeddedTView(e, t) {
          return this.isApplyingToNode(e)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-e.index, t),
              new Py(this.metadata))
            : null;
        }
        isApplyingToNode(e) {
          if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
            const t = this._declarationNodeIndex;
            let i = e.parent;
            for (; null !== i && 8 & i.type && i.index !== t; ) i = i.parent;
            return t === (null !== i ? i.index : -1);
          }
          return this._appliesToNextNode;
        }
        matchTNode(e, t) {
          const i = this.metadata.predicate;
          if (Array.isArray(i))
            for (let r = 0; r < i.length; r++) {
              const s = i[r];
              this.matchTNodeWithReadOption(e, t, eG(t, s)),
                this.matchTNodeWithReadOption(e, t, Af(t, e, s, !1, !1));
            }
          else
            i === ys
              ? 4 & t.type && this.matchTNodeWithReadOption(e, t, -1)
              : this.matchTNodeWithReadOption(e, t, Af(t, e, i, !1, !1));
        }
        matchTNodeWithReadOption(e, t, i) {
          if (null !== i) {
            const r = this.metadata.read;
            if (null !== r)
              if (r === rn || r === br || (r === ys && 4 & t.type))
                this.addMatch(t.index, -2);
              else {
                const s = Af(t, e, r, !1, !1);
                null !== s && this.addMatch(t.index, s);
              }
            else this.addMatch(t.index, i);
          }
        }
        addMatch(e, t) {
          null === this.matches
            ? (this.matches = [e, t])
            : this.matches.push(e, t);
        }
      }
      function eG(n, e) {
        const t = n.localNames;
        if (null !== t)
          for (let i = 0; i < t.length; i += 2) if (t[i] === e) return t[i + 1];
        return null;
      }
      function nG(n, e, t, i) {
        return -1 === t
          ? (function tG(n, e) {
              return 11 & n.type ? Dl(n, e) : 4 & n.type ? cp(n, e) : null;
            })(e, n)
          : -2 === t
          ? (function iG(n, e, t) {
              return t === rn
                ? Dl(e, n)
                : t === ys
                ? cp(e, n)
                : t === br
                ? qA(e, n)
                : void 0;
            })(n, e, i)
          : ua(n, n[De], t, e);
      }
      function ZA(n, e, t, i) {
        const r = e[us].queries[i];
        if (null === r.matches) {
          const s = n.data,
            o = t.matches,
            a = [];
          for (let l = 0; l < o.length; l += 2) {
            const c = o[l];
            a.push(c < 0 ? null : nG(e, s[c], o[l + 1], t.metadata.read));
          }
          r.matches = a;
        }
        return r.matches;
      }
      function Oy(n, e, t, i) {
        const r = n.queries.getByIndex(t),
          s = r.matches;
        if (null !== s) {
          const o = ZA(n, e, r, t);
          for (let a = 0; a < s.length; a += 2) {
            const l = s[a];
            if (l > 0) i.push(o[a / 2]);
            else {
              const c = s[a + 1],
                u = e[-l];
              for (let d = xi; d < u.length; d++) {
                const h = u[d];
                h[Ou] === h[vn] && Oy(h[De], h, c, i);
              }
              if (null !== u[fl]) {
                const d = u[fl];
                for (let h = 0; h < d.length; h++) {
                  const f = d[h];
                  Oy(f[De], f, c, i);
                }
              }
            }
          }
        }
        return i;
      }
      function Ei(n) {
        const e = se(),
          t = Rt(),
          i = zS();
        q_(i + 1);
        const r = QA(t, i);
        if (
          n.dirty &&
          (function TB(n) {
            return 4 == (4 & n[pt]);
          })(e) ===
            (2 == (2 & r.metadata.flags))
        ) {
          if (null === r.matches) n.reset([]);
          else {
            const s = r.crossesNgTemplate ? Oy(t, e, i, []) : ZA(t, e, r, i);
            n.reset(s, j3), n.notifyOnChanges();
          }
          return !0;
        }
        return !1;
      }
      function jr(n, e, t) {
        const i = Rt();
        i.firstCreatePass &&
          ($A(i, new YA(n, e, t), -1),
          2 == (2 & e) && (i.staticViewQueries = !0)),
          KA(i, se(), e);
      }
      function pd(n, e, t, i) {
        const r = Rt();
        if (r.firstCreatePass) {
          const s = ni();
          $A(r, new YA(e, t, i), s.index),
            (function sG(n, e) {
              const t = n.contentQueries || (n.contentQueries = []);
              e !== (t.length ? t[t.length - 1] : -1) &&
                t.push(n.queries.length - 1, e);
            })(r, n),
            2 == (2 & t) && (r.staticContentQueries = !0);
        }
        KA(r, se(), t);
      }
      function Ci() {
        return (function rG(n, e) {
          return n[us].queries[e].queryList;
        })(se(), zS());
      }
      function KA(n, e, t) {
        const i = new Yl(4 == (4 & t));
        VC(n, e, i, i.destroy),
          null === e[us] && (e[us] = new Iy()),
          e[us].queries.push(new Dy(i));
      }
      function $A(n, e, t) {
        null === n.queries && (n.queries = new Ry()),
          n.queries.track(new Py(e, t));
      }
      function QA(n, e) {
        return n.queries.getByIndex(e);
      }
      function Eo(n, e) {
        return cp(n, e);
      }
      function dp(...n) {}
      const hp = new ye("Application Initializer");
      let fp = (() => {
        class n {
          constructor(t) {
            (this.appInits = t),
              (this.resolve = dp),
              (this.reject = dp),
              (this.initialized = !1),
              (this.done = !1),
              (this.donePromise = new Promise((i, r) => {
                (this.resolve = i), (this.reject = r);
              }));
          }
          runInitializers() {
            if (this.initialized) return;
            const t = [],
              i = () => {
                (this.done = !0), this.resolve();
              };
            if (this.appInits)
              for (let r = 0; r < this.appInits.length; r++) {
                const s = this.appInits[r]();
                if (id(s)) t.push(s);
                else if (cy(s)) {
                  const o = new Promise((a, l) => {
                    s.subscribe({ complete: a, error: l });
                  });
                  t.push(o);
                }
              }
            Promise.all(t)
              .then(() => {
                i();
              })
              .catch((r) => {
                this.reject(r);
              }),
              0 === t.length && i(),
              (this.initialized = !0);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(hp, 8));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const gd = new ye("AppId", {
        providedIn: "root",
        factory: function gD() {
          return `${Uy()}${Uy()}${Uy()}`;
        },
      });
      function Uy() {
        return String.fromCharCode(97 + Math.floor(25 * Math.random()));
      }
      const _D = new ye("Platform Initializer"),
        Vy = new ye("Platform ID", {
          providedIn: "platform",
          factory: () => "unknown",
        }),
        _d = new ye("AnimationModuleType");
      let EG = (() => {
        class n {
          log(t) {
            console.log(t);
          }
          warn(t) {
            console.warn(t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "platform" })),
          n
        );
      })();
      const bs = new ye("LocaleId", {
        providedIn: "root",
        factory: () =>
          ft(bs, $e.Optional | $e.SkipSelf) ||
          (function CG() {
            return (typeof $localize < "u" && $localize.locale) || Xl;
          })(),
      });
      class AG {
        constructor(e, t) {
          (this.ngModuleFactory = e), (this.componentFactories = t);
        }
      }
      let vD = (() => {
        class n {
          compileModuleSync(t) {
            return new My(t);
          }
          compileModuleAsync(t) {
            return Promise.resolve(this.compileModuleSync(t));
          }
          compileModuleAndAllComponentsSync(t) {
            const i = this.compileModuleSync(t),
              s = Gs(qi(t).declarations).reduce((o, a) => {
                const l = Ht(a);
                return l && o.push(new td(l)), o;
              }, []);
            return new AG(i, s);
          }
          compileModuleAndAllComponentsAsync(t) {
            return Promise.resolve(this.compileModuleAndAllComponentsSync(t));
          }
          clearCache() {}
          clearCacheFor(t) {}
          getModuleId(t) {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const RG = (() => Promise.resolve(0))();
      function zy(n) {
        typeof Zone > "u"
          ? RG.then(() => {
              n && n.apply(null, null);
            })
          : Zone.current.scheduleMicroTask("scheduleMicrotask", n);
      }
      class wt {
        constructor({
          enableLongStackTrace: e = !1,
          shouldCoalesceEventChangeDetection: t = !1,
          shouldCoalesceRunChangeDetection: i = !1,
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new Ut(!1)),
            (this.onMicrotaskEmpty = new Ut(!1)),
            (this.onStable = new Ut(!1)),
            (this.onError = new Ut(!1)),
            typeof Zone > "u")
          )
            throw new J(908, !1);
          Zone.assertZonePatched();
          const r = this;
          (r._nesting = 0),
            (r._outer = r._inner = Zone.current),
            Zone.TaskTrackingZoneSpec &&
              (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec())),
            e &&
              Zone.longStackTraceZoneSpec &&
              (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)),
            (r.shouldCoalesceEventChangeDetection = !i && t),
            (r.shouldCoalesceRunChangeDetection = i),
            (r.lastRequestAnimationFrameId = -1),
            (r.nativeRequestAnimationFrame = (function PG() {
              let n = tn.requestAnimationFrame,
                e = tn.cancelAnimationFrame;
              if (typeof Zone < "u" && n && e) {
                const t = n[Zone.__symbol__("OriginalDelegate")];
                t && (n = t);
                const i = e[Zone.__symbol__("OriginalDelegate")];
                i && (e = i);
              }
              return {
                nativeRequestAnimationFrame: n,
                nativeCancelAnimationFrame: e,
              };
            })().nativeRequestAnimationFrame),
            (function FG(n) {
              const e = () => {
                !(function LG(n) {
                  n.isCheckStableRunning ||
                    -1 !== n.lastRequestAnimationFrameId ||
                    ((n.lastRequestAnimationFrameId =
                      n.nativeRequestAnimationFrame.call(tn, () => {
                        n.fakeTopEventTask ||
                          (n.fakeTopEventTask = Zone.root.scheduleEventTask(
                            "fakeTopEventTask",
                            () => {
                              (n.lastRequestAnimationFrameId = -1),
                                Gy(n),
                                (n.isCheckStableRunning = !0),
                                Hy(n),
                                (n.isCheckStableRunning = !1);
                            },
                            void 0,
                            () => {},
                            () => {}
                          )),
                          n.fakeTopEventTask.invoke();
                      })),
                    Gy(n));
                })(n);
              };
              n._inner = n._inner.fork({
                name: "angular",
                properties: { isAngularZone: !0 },
                onInvokeTask: (t, i, r, s, o, a) => {
                  try {
                    return xD(n), t.invokeTask(r, s, o, a);
                  } finally {
                    ((n.shouldCoalesceEventChangeDetection &&
                      "eventTask" === s.type) ||
                      n.shouldCoalesceRunChangeDetection) &&
                      e(),
                      wD(n);
                  }
                },
                onInvoke: (t, i, r, s, o, a, l) => {
                  try {
                    return xD(n), t.invoke(r, s, o, a, l);
                  } finally {
                    n.shouldCoalesceRunChangeDetection && e(), wD(n);
                  }
                },
                onHasTask: (t, i, r, s) => {
                  t.hasTask(r, s),
                    i === r &&
                      ("microTask" == s.change
                        ? ((n._hasPendingMicrotasks = s.microTask),
                          Gy(n),
                          Hy(n))
                        : "macroTask" == s.change &&
                          (n.hasPendingMacrotasks = s.macroTask));
                },
                onHandleError: (t, i, r, s) => (
                  t.handleError(r, s),
                  n.runOutsideAngular(() => n.onError.emit(s)),
                  !1
                ),
              });
            })(r);
        }
        static isInAngularZone() {
          return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone");
        }
        static assertInAngularZone() {
          if (!wt.isInAngularZone()) throw new J(909, !1);
        }
        static assertNotInAngularZone() {
          if (wt.isInAngularZone()) throw new J(909, !1);
        }
        run(e, t, i) {
          return this._inner.run(e, t, i);
        }
        runTask(e, t, i, r) {
          const s = this._inner,
            o = s.scheduleEventTask("NgZoneEvent: " + r, e, OG, dp, dp);
          try {
            return s.runTask(o, t, i);
          } finally {
            s.cancelTask(o);
          }
        }
        runGuarded(e, t, i) {
          return this._inner.runGuarded(e, t, i);
        }
        runOutsideAngular(e) {
          return this._outer.run(e);
        }
      }
      const OG = {};
      function Hy(n) {
        if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable)
          try {
            n._nesting++, n.onMicrotaskEmpty.emit(null);
          } finally {
            if ((n._nesting--, !n.hasPendingMicrotasks))
              try {
                n.runOutsideAngular(() => n.onStable.emit(null));
              } finally {
                n.isStable = !0;
              }
          }
      }
      function Gy(n) {
        n.hasPendingMicrotasks = !!(
          n._hasPendingMicrotasks ||
          ((n.shouldCoalesceEventChangeDetection ||
            n.shouldCoalesceRunChangeDetection) &&
            -1 !== n.lastRequestAnimationFrameId)
        );
      }
      function xD(n) {
        n._nesting++,
          n.isStable && ((n.isStable = !1), n.onUnstable.emit(null));
      }
      function wD(n) {
        n._nesting--, Hy(n);
      }
      class NG {
        constructor() {
          (this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new Ut()),
            (this.onMicrotaskEmpty = new Ut()),
            (this.onStable = new Ut()),
            (this.onError = new Ut());
        }
        run(e, t, i) {
          return e.apply(t, i);
        }
        runGuarded(e, t, i) {
          return e.apply(t, i);
        }
        runOutsideAngular(e) {
          return e();
        }
        runTask(e, t, i, r) {
          return e.apply(t, i);
        }
      }
      const MD = new ye(""),
        pp = new ye("");
      let Xy,
        Wy = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngZone = t),
                (this.registry = i),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                Xy ||
                  ((function kG(n) {
                    Xy = n;
                  })(r),
                  r.addToWindow(i)),
                this._watchAngularEvents(),
                t.run(() => {
                  this.taskTrackingZone =
                    typeof Zone > "u"
                      ? null
                      : Zone.current.get("TaskTrackingZone");
                });
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  (this._didWork = !0), (this._isZoneStable = !1);
                },
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      wt.assertNotInAngularZone(),
                        zy(() => {
                          (this._isZoneStable = !0),
                            this._runCallbacksIfReady();
                        });
                    },
                  });
                });
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              );
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error("pending async requests below zero");
              return this._runCallbacksIfReady(), this._pendingCount;
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              );
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                zy(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let t = this._callbacks.pop();
                    clearTimeout(t.timeoutId), t.doneCb(this._didWork);
                  }
                  this._didWork = !1;
                });
              else {
                let t = this.getPendingTasks();
                (this._callbacks = this._callbacks.filter(
                  (i) =>
                    !i.updateCb ||
                    !i.updateCb(t) ||
                    (clearTimeout(i.timeoutId), !1)
                )),
                  (this._didWork = !0);
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map((t) => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data,
                  }))
                : [];
            }
            addCallback(t, i, r) {
              let s = -1;
              i &&
                i > 0 &&
                (s = setTimeout(() => {
                  (this._callbacks = this._callbacks.filter(
                    (o) => o.timeoutId !== s
                  )),
                    t(this._didWork, this.getPendingTasks());
                }, i)),
                this._callbacks.push({ doneCb: t, timeoutId: s, updateCb: r });
            }
            whenStable(t, i, r) {
              if (r && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'
                );
              this.addCallback(t, i, r), this._runCallbacksIfReady();
            }
            getPendingRequestCount() {
              return this._pendingCount;
            }
            registerApplication(t) {
              this.registry.registerApplication(t, this);
            }
            unregisterApplication(t) {
              this.registry.unregisterApplication(t);
            }
            findProviders(t, i, r) {
              return [];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(wt), re(jy), re(pp));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        jy = (() => {
          class n {
            constructor() {
              this._applications = new Map();
            }
            registerApplication(t, i) {
              this._applications.set(t, i);
            }
            unregisterApplication(t) {
              this._applications.delete(t);
            }
            unregisterAllApplications() {
              this._applications.clear();
            }
            getTestability(t) {
              return this._applications.get(t) || null;
            }
            getAllTestabilities() {
              return Array.from(this._applications.values());
            }
            getAllRootElements() {
              return Array.from(this._applications.keys());
            }
            findTestabilityInTree(t, i = !0) {
              return Xy?.findTestabilityInTree(this, t, i) ?? null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({
              token: n,
              factory: n.ɵfac,
              providedIn: "platform",
            })),
            n
          );
        })();
      const js = !1;
      let Co = null;
      const SD = new ye("AllowMultipleToken"),
        qy = new ye("PlatformDestroyListeners"),
        ED = new ye("appBootstrapListener");
      class CD {
        constructor(e, t) {
          (this.name = e), (this.token = t);
        }
      }
      function AD(n, e, t = []) {
        const i = `Platform: ${e}`,
          r = new ye(i);
        return (s = []) => {
          let o = Yy();
          if (!o || o.injector.get(SD, !1)) {
            const a = [...t, ...s, { provide: r, useValue: !0 }];
            n
              ? n(a)
              : (function VG(n) {
                  if (Co && !Co.get(SD, !1)) throw new J(400, !1);
                  Co = n;
                  const e = n.get(ID);
                  (function TD(n) {
                    const e = n.get(_D, null);
                    e && e.forEach((t) => t());
                  })(n);
                })(
                  (function DD(n = [], e) {
                    return Qi.create({
                      name: e,
                      providers: [
                        { provide: Nv, useValue: "platform" },
                        { provide: qy, useValue: new Set([() => (Co = null)]) },
                        ...n,
                      ],
                    });
                  })(a, i)
                );
          }
          return (function HG(n) {
            const e = Yy();
            if (!e) throw new J(401, !1);
            return e;
          })();
        };
      }
      function Yy() {
        return Co?.get(ID) ?? null;
      }
      let ID = (() => {
        class n {
          constructor(t) {
            (this._injector = t),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1);
          }
          bootstrapModuleFactory(t, i) {
            const r = (function PD(n, e) {
                let t;
                return (
                  (t =
                    "noop" === n
                      ? new NG()
                      : ("zone.js" === n ? void 0 : n) || new wt(e)),
                  t
                );
              })(
                i?.ngZone,
                (function RD(n) {
                  return {
                    enableLongStackTrace: !1,
                    shouldCoalesceEventChangeDetection:
                      !(!n || !n.ngZoneEventCoalescing) || !1,
                    shouldCoalesceRunChangeDetection:
                      !(!n || !n.ngZoneRunCoalescing) || !1,
                  };
                })(i)
              ),
              s = [{ provide: wt, useValue: r }];
            return r.run(() => {
              const o = Qi.create({
                  providers: s,
                  parent: this.injector,
                  name: t.moduleType.name,
                }),
                a = t.create(o),
                l = a.injector.get(Il, null);
              if (!l) throw new J(402, !1);
              return (
                r.runOutsideAngular(() => {
                  const c = r.onError.subscribe({
                    next: (u) => {
                      l.handleError(u);
                    },
                  });
                  a.onDestroy(() => {
                    mp(this._modules, a), c.unsubscribe();
                  });
                }),
                (function OD(n, e, t) {
                  try {
                    const i = t();
                    return id(i)
                      ? i.catch((r) => {
                          throw (
                            (e.runOutsideAngular(() => n.handleError(r)), r)
                          );
                        })
                      : i;
                  } catch (i) {
                    throw (e.runOutsideAngular(() => n.handleError(i)), i);
                  }
                })(l, r, () => {
                  const c = a.injector.get(fp);
                  return (
                    c.runInitializers(),
                    c.donePromise.then(
                      () => (
                        (function sA(n) {
                          fr(n, "Expected localeId to be defined"),
                            "string" == typeof n &&
                              (rA = n.toLowerCase().replace(/_/g, "-"));
                        })(a.injector.get(bs, Xl) || Xl),
                        this._moduleDoBootstrap(a),
                        a
                      )
                    )
                  );
                })
              );
            });
          }
          bootstrapModule(t, i = []) {
            const r = LD({}, i);
            return (function BG(n, e, t) {
              const i = new My(t);
              return Promise.resolve(i);
            })(0, 0, t).then((s) => this.bootstrapModuleFactory(s, r));
          }
          _moduleDoBootstrap(t) {
            const i = t.injector.get($l);
            if (t._bootstrapComponents.length > 0)
              t._bootstrapComponents.forEach((r) => i.bootstrap(r));
            else {
              if (!t.instance.ngDoBootstrap) throw new J(-403, !1);
              t.instance.ngDoBootstrap(i);
            }
            this._modules.push(t);
          }
          onDestroy(t) {
            this._destroyListeners.push(t);
          }
          get injector() {
            return this._injector;
          }
          destroy() {
            if (this._destroyed) throw new J(404, !1);
            this._modules.slice().forEach((i) => i.destroy()),
              this._destroyListeners.forEach((i) => i());
            const t = this._injector.get(qy, null);
            t && (t.forEach((i) => i()), t.clear()), (this._destroyed = !0);
          }
          get destroyed() {
            return this._destroyed;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(Qi));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "platform" })),
          n
        );
      })();
      function LD(n, e) {
        return Array.isArray(e) ? e.reduce(LD, n) : { ...n, ...e };
      }
      let $l = (() => {
        class n {
          get destroyed() {
            return this._destroyed;
          }
          get injector() {
            return this._injector;
          }
          constructor(t, i, r) {
            (this._zone = t),
              (this._injector = i),
              (this._exceptionHandler = r),
              (this._bootstrapListeners = []),
              (this._views = []),
              (this._runningTick = !1),
              (this._stable = !0),
              (this._destroyed = !1),
              (this._destroyListeners = []),
              (this.componentTypes = []),
              (this.components = []),
              (this._onMicrotaskEmptySubscription =
                this._zone.onMicrotaskEmpty.subscribe({
                  next: () => {
                    this._zone.run(() => {
                      this.tick();
                    });
                  },
                }));
            const s = new Kt((a) => {
                (this._stable =
                  this._zone.isStable &&
                  !this._zone.hasPendingMacrotasks &&
                  !this._zone.hasPendingMicrotasks),
                  this._zone.runOutsideAngular(() => {
                    a.next(this._stable), a.complete();
                  });
              }),
              o = new Kt((a) => {
                let l;
                this._zone.runOutsideAngular(() => {
                  l = this._zone.onStable.subscribe(() => {
                    wt.assertNotInAngularZone(),
                      zy(() => {
                        !this._stable &&
                          !this._zone.hasPendingMacrotasks &&
                          !this._zone.hasPendingMicrotasks &&
                          ((this._stable = !0), a.next(!0));
                      });
                  });
                });
                const c = this._zone.onUnstable.subscribe(() => {
                  wt.assertInAngularZone(),
                    this._stable &&
                      ((this._stable = !1),
                      this._zone.runOutsideAngular(() => {
                        a.next(!1);
                      }));
                });
                return () => {
                  l.unsubscribe(), c.unsubscribe();
                };
              });
            this.isStable = Tu(
              s,
              o.pipe(
                (function Yk(n = {}) {
                  const {
                    connector: e = () => new kt(),
                    resetOnError: t = !0,
                    resetOnComplete: i = !0,
                    resetOnRefCountZero: r = !0,
                  } = n;
                  return (s) => {
                    let o,
                      a,
                      l,
                      c = 0,
                      u = !1,
                      d = !1;
                    const h = () => {
                        a?.unsubscribe(), (a = void 0);
                      },
                      f = () => {
                        h(), (o = l = void 0), (u = d = !1);
                      },
                      p = () => {
                        const _ = o;
                        f(), _?.unsubscribe();
                      };
                    return ln((_, m) => {
                      c++, !d && !u && h();
                      const g = (l = l ?? e());
                      m.add(() => {
                        c--, 0 === c && !d && !u && (a = T_(p, r));
                      }),
                        g.subscribe(m),
                        !o &&
                          c > 0 &&
                          ((o = new Eu({
                            next: (y) => g.next(y),
                            error: (y) => {
                              (d = !0), h(), (a = T_(f, t, y)), g.error(y);
                            },
                            complete: () => {
                              (u = !0), h(), (a = T_(f, i)), g.complete();
                            },
                          })),
                          di(_).subscribe(o));
                    })(s);
                  };
                })()
              )
            );
          }
          bootstrap(t, i) {
            const r = t instanceof _C;
            if (!this._injector.get(fp).done) {
              !r &&
                (function cl(n) {
                  const e = Ht(n) || hi(n) || Fi(n);
                  return null !== e && e.standalone;
                })(t);
              throw new J(405, js);
            }
            let o;
            (o = r ? t : this._injector.get(Al).resolveComponentFactory(t)),
              this.componentTypes.push(o.componentType);
            const a = (function UG(n) {
                return n.isBoundToModule;
              })(o)
                ? void 0
                : this._injector.get(ql),
              c = o.create(Qi.NULL, [], i || o.selector, a),
              u = c.location.nativeElement,
              d = c.injector.get(MD, null);
            return (
              d?.registerApplication(u),
              c.onDestroy(() => {
                this.detachView(c.hostView),
                  mp(this.components, c),
                  d?.unregisterApplication(u);
              }),
              this._loadComponent(c),
              c
            );
          }
          tick() {
            if (this._runningTick) throw new J(101, !1);
            try {
              this._runningTick = !0;
              for (let t of this._views) t.detectChanges();
            } catch (t) {
              this._zone.runOutsideAngular(() =>
                this._exceptionHandler.handleError(t)
              );
            } finally {
              this._runningTick = !1;
            }
          }
          attachView(t) {
            const i = t;
            this._views.push(i), i.attachToAppRef(this);
          }
          detachView(t) {
            const i = t;
            mp(this._views, i), i.detachFromAppRef();
          }
          _loadComponent(t) {
            this.attachView(t.hostView), this.tick(), this.components.push(t);
            const i = this._injector.get(ED, []);
            i.push(...this._bootstrapListeners), i.forEach((r) => r(t));
          }
          ngOnDestroy() {
            if (!this._destroyed)
              try {
                this._destroyListeners.forEach((t) => t()),
                  this._views.slice().forEach((t) => t.destroy()),
                  this._onMicrotaskEmptySubscription.unsubscribe();
              } finally {
                (this._destroyed = !0),
                  (this._views = []),
                  (this._bootstrapListeners = []),
                  (this._destroyListeners = []);
              }
          }
          onDestroy(t) {
            return (
              this._destroyListeners.push(t),
              () => mp(this._destroyListeners, t)
            );
          }
          destroy() {
            if (this._destroyed) throw new J(406, !1);
            const t = this._injector;
            t.destroy && !t.destroyed && t.destroy();
          }
          get viewCount() {
            return this._views.length;
          }
          warnIfDestroyed() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(wt), re(zs), re(Il));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function mp(n, e) {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      }
      let Ui = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = WG), n;
      })();
      function WG(n) {
        return (function jG(n, e, t) {
          if (Fu(n) && !t) {
            const i = Ni(n.index, e);
            return new ed(i, i);
          }
          return 47 & n.type ? new ed(e[pi], e) : null;
        })(ni(), se(), 16 == (16 & n));
      }
      class UD {
        constructor() {}
        supports(e) {
          return Qf(e);
        }
        create(e) {
          return new $G(e);
        }
      }
      const KG = (n, e) => e;
      class $G {
        constructor(e) {
          (this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = e || KG);
        }
        forEachItem(e) {
          let t;
          for (t = this._itHead; null !== t; t = t._next) e(t);
        }
        forEachOperation(e) {
          let t = this._itHead,
            i = this._removalsHead,
            r = 0,
            s = null;
          for (; t || i; ) {
            const o = !i || (t && t.currentIndex < zD(i, r, s)) ? t : i,
              a = zD(o, r, s),
              l = o.currentIndex;
            if (o === i) r--, (i = i._nextRemoved);
            else if (((t = t._next), null == o.previousIndex)) r++;
            else {
              s || (s = []);
              const c = a - r,
                u = l - r;
              if (c != u) {
                for (let h = 0; h < c; h++) {
                  const f = h < s.length ? s[h] : (s[h] = 0),
                    p = f + h;
                  u <= p && p < c && (s[h] = f + 1);
                }
                s[o.previousIndex] = u - c;
              }
            }
            a !== l && e(o, a, l);
          }
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousItHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachMovedItem(e) {
          let t;
          for (t = this._movesHead; null !== t; t = t._nextMoved) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        forEachIdentityChange(e) {
          let t;
          for (
            t = this._identityChangesHead;
            null !== t;
            t = t._nextIdentityChange
          )
            e(t);
        }
        diff(e) {
          if ((null == e && (e = []), !Qf(e))) throw new J(900, !1);
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let r,
            s,
            o,
            t = this._itHead,
            i = !1;
          if (Array.isArray(e)) {
            this.length = e.length;
            for (let a = 0; a < this.length; a++)
              (s = e[a]),
                (o = this._trackByFn(a, s)),
                null !== t && Object.is(t.trackById, o)
                  ? (i && (t = this._verifyReinsertion(t, s, o, a)),
                    Object.is(t.item, s) || this._addIdentityChange(t, s))
                  : ((t = this._mismatch(t, s, o, a)), (i = !0)),
                (t = t._next);
          } else
            (r = 0),
              (function Tz(n, e) {
                if (Array.isArray(n))
                  for (let t = 0; t < n.length; t++) e(n[t]);
                else {
                  const t = n[Symbol.iterator]();
                  let i;
                  for (; !(i = t.next()).done; ) e(i.value);
                }
              })(e, (a) => {
                (o = this._trackByFn(r, a)),
                  null !== t && Object.is(t.trackById, o)
                    ? (i && (t = this._verifyReinsertion(t, a, o, r)),
                      Object.is(t.item, a) || this._addIdentityChange(t, a))
                    : ((t = this._mismatch(t, a, o, r)), (i = !0)),
                  (t = t._next),
                  r++;
              }),
              (this.length = r);
          return this._truncate(t), (this.collection = e), this.isDirty;
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              e = this._previousItHead = this._itHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._additionsHead; null !== e; e = e._nextAdded)
              e.previousIndex = e.currentIndex;
            for (
              this._additionsHead = this._additionsTail = null,
                e = this._movesHead;
              null !== e;
              e = e._nextMoved
            )
              e.previousIndex = e.currentIndex;
            (this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null);
          }
        }
        _mismatch(e, t, i, r) {
          let s;
          return (
            null === e ? (s = this._itTail) : ((s = e._prev), this._remove(e)),
            null !==
            (e =
              null === this._unlinkedRecords
                ? null
                : this._unlinkedRecords.get(i, null))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._reinsertAfter(e, s, r))
              : null !==
                (e =
                  null === this._linkedRecords
                    ? null
                    : this._linkedRecords.get(i, r))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._moveAfter(e, s, r))
              : (e = this._addAfter(new QG(t, i), s, r)),
            e
          );
        }
        _verifyReinsertion(e, t, i, r) {
          let s =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(i, null);
          return (
            null !== s
              ? (e = this._reinsertAfter(s, e._prev, r))
              : e.currentIndex != r &&
                ((e.currentIndex = r), this._addToMoves(e, r)),
            e
          );
        }
        _truncate(e) {
          for (; null !== e; ) {
            const t = e._next;
            this._addToRemovals(this._unlink(e)), (e = t);
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null);
        }
        _reinsertAfter(e, t, i) {
          null !== this._unlinkedRecords && this._unlinkedRecords.remove(e);
          const r = e._prevRemoved,
            s = e._nextRemoved;
          return (
            null === r ? (this._removalsHead = s) : (r._nextRemoved = s),
            null === s ? (this._removalsTail = r) : (s._prevRemoved = r),
            this._insertAfter(e, t, i),
            this._addToMoves(e, i),
            e
          );
        }
        _moveAfter(e, t, i) {
          return (
            this._unlink(e),
            this._insertAfter(e, t, i),
            this._addToMoves(e, i),
            e
          );
        }
        _addAfter(e, t, i) {
          return (
            this._insertAfter(e, t, i),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = e)
                : (this._additionsTail._nextAdded = e)),
            e
          );
        }
        _insertAfter(e, t, i) {
          const r = null === t ? this._itHead : t._next;
          return (
            (e._next = r),
            (e._prev = t),
            null === r ? (this._itTail = e) : (r._prev = e),
            null === t ? (this._itHead = e) : (t._next = e),
            null === this._linkedRecords && (this._linkedRecords = new VD()),
            this._linkedRecords.put(e),
            (e.currentIndex = i),
            e
          );
        }
        _remove(e) {
          return this._addToRemovals(this._unlink(e));
        }
        _unlink(e) {
          null !== this._linkedRecords && this._linkedRecords.remove(e);
          const t = e._prev,
            i = e._next;
          return (
            null === t ? (this._itHead = i) : (t._next = i),
            null === i ? (this._itTail = t) : (i._prev = t),
            e
          );
        }
        _addToMoves(e, t) {
          return (
            e.previousIndex === t ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = e)
                  : (this._movesTail._nextMoved = e)),
            e
          );
        }
        _addToRemovals(e) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new VD()),
            this._unlinkedRecords.put(e),
            (e.currentIndex = null),
            (e._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = e),
                (e._prevRemoved = null))
              : ((e._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = e)),
            e
          );
        }
        _addIdentityChange(e, t) {
          return (
            (e.item = t),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = e)
                : (this._identityChangesTail._nextIdentityChange = e)),
            e
          );
        }
      }
      class QG {
        constructor(e, t) {
          (this.item = e),
            (this.trackById = t),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null);
        }
      }
      class JG {
        constructor() {
          (this._head = null), (this._tail = null);
        }
        add(e) {
          null === this._head
            ? ((this._head = this._tail = e),
              (e._nextDup = null),
              (e._prevDup = null))
            : ((this._tail._nextDup = e),
              (e._prevDup = this._tail),
              (e._nextDup = null),
              (this._tail = e));
        }
        get(e, t) {
          let i;
          for (i = this._head; null !== i; i = i._nextDup)
            if (
              (null === t || t <= i.currentIndex) &&
              Object.is(i.trackById, e)
            )
              return i;
          return null;
        }
        remove(e) {
          const t = e._prevDup,
            i = e._nextDup;
          return (
            null === t ? (this._head = i) : (t._nextDup = i),
            null === i ? (this._tail = t) : (i._prevDup = t),
            null === this._head
          );
        }
      }
      class VD {
        constructor() {
          this.map = new Map();
        }
        put(e) {
          const t = e.trackById;
          let i = this.map.get(t);
          i || ((i = new JG()), this.map.set(t, i)), i.add(e);
        }
        get(e, t) {
          const r = this.map.get(e);
          return r ? r.get(e, t) : null;
        }
        remove(e) {
          const t = e.trackById;
          return this.map.get(t).remove(e) && this.map.delete(t), e;
        }
        get isEmpty() {
          return 0 === this.map.size;
        }
        clear() {
          this.map.clear();
        }
      }
      function zD(n, e, t) {
        const i = n.previousIndex;
        if (null === i) return i;
        let r = 0;
        return t && i < t.length && (r = t[i]), i + e + r;
      }
      class HD {
        constructor() {}
        supports(e) {
          return e instanceof Map || ay(e);
        }
        create() {
          return new e5();
        }
      }
      class e5 {
        constructor() {
          (this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null);
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          );
        }
        forEachItem(e) {
          let t;
          for (t = this._mapHead; null !== t; t = t._next) e(t);
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousMapHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachChangedItem(e) {
          let t;
          for (t = this._changesHead; null !== t; t = t._nextChanged) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        diff(e) {
          if (e) {
            if (!(e instanceof Map || ay(e))) throw new J(900, !1);
          } else e = new Map();
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let t = this._mapHead;
          if (
            ((this._appendAfter = null),
            this._forEach(e, (i, r) => {
              if (t && t.key === r)
                this._maybeAddToChanges(t, i),
                  (this._appendAfter = t),
                  (t = t._next);
              else {
                const s = this._getOrCreateRecordForKey(r, i);
                t = this._insertBeforeOrAppend(t, s);
              }
            }),
            t)
          ) {
            t._prev && (t._prev._next = null), (this._removalsHead = t);
            for (let i = t; null !== i; i = i._nextRemoved)
              i === this._mapHead && (this._mapHead = null),
                this._records.delete(i.key),
                (i._nextRemoved = i._next),
                (i.previousValue = i.currentValue),
                (i.currentValue = null),
                (i._prev = null),
                (i._next = null);
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          );
        }
        _insertBeforeOrAppend(e, t) {
          if (e) {
            const i = e._prev;
            return (
              (t._next = e),
              (t._prev = i),
              (e._prev = t),
              i && (i._next = t),
              e === this._mapHead && (this._mapHead = t),
              (this._appendAfter = e),
              e
            );
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = t), (t._prev = this._appendAfter))
              : (this._mapHead = t),
            (this._appendAfter = t),
            null
          );
        }
        _getOrCreateRecordForKey(e, t) {
          if (this._records.has(e)) {
            const r = this._records.get(e);
            this._maybeAddToChanges(r, t);
            const s = r._prev,
              o = r._next;
            return (
              s && (s._next = o),
              o && (o._prev = s),
              (r._next = null),
              (r._prev = null),
              r
            );
          }
          const i = new t5(e);
          return (
            this._records.set(e, i),
            (i.currentValue = t),
            this._addToAdditions(i),
            i
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              this._previousMapHead = this._mapHead, e = this._previousMapHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._changesHead; null !== e; e = e._nextChanged)
              e.previousValue = e.currentValue;
            for (e = this._additionsHead; null != e; e = e._nextAdded)
              e.previousValue = e.currentValue;
            (this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null);
          }
        }
        _maybeAddToChanges(e, t) {
          Object.is(t, e.currentValue) ||
            ((e.previousValue = e.currentValue),
            (e.currentValue = t),
            this._addToChanges(e));
        }
        _addToAdditions(e) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = e)
            : ((this._additionsTail._nextAdded = e), (this._additionsTail = e));
        }
        _addToChanges(e) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = e)
            : ((this._changesTail._nextChanged = e), (this._changesTail = e));
        }
        _forEach(e, t) {
          e instanceof Map
            ? e.forEach(t)
            : Object.keys(e).forEach((i) => t(e[i], i));
        }
      }
      class t5 {
        constructor(e) {
          (this.key = e),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null);
        }
      }
      function GD() {
        return new vp([new UD()]);
      }
      let vp = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, i) {
            if (null != i) {
              const r = i.factories.slice();
              t = t.concat(r);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (i) => n.create(t, i || GD()),
              deps: [[n, new Gu(), new Ml()]],
            };
          }
          find(t) {
            const i = this.factories.find((r) => r.supports(t));
            if (null != i) return i;
            throw new J(901, !1);
          }
        }
        return (n.ɵprov = Me({ token: n, providedIn: "root", factory: GD })), n;
      })();
      function WD() {
        return new vd([new HD()]);
      }
      let vd = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, i) {
            if (i) {
              const r = i.factories.slice();
              t = t.concat(r);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (i) => n.create(t, i || WD()),
              deps: [[n, new Gu(), new Ml()]],
            };
          }
          find(t) {
            const i = this.factories.find((r) => r.supports(t));
            if (i) return i;
            throw new J(901, !1);
          }
        }
        return (n.ɵprov = Me({ token: n, providedIn: "root", factory: WD })), n;
      })();
      const s5 = AD(null, "core", []);
      let o5 = (() => {
          class n {
            constructor(t) {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re($l));
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({})),
            n
          );
        })(),
        Jy = null;
      function Xs() {
        return Jy;
      }
      class c5 {}
      const Lt = new ye("DocumentToken");
      let e0 = (() => {
        class n {
          historyGo(t) {
            throw new Error("Not implemented");
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({
            token: n,
            factory: function () {
              return (function u5() {
                return re(jD);
              })();
            },
            providedIn: "platform",
          })),
          n
        );
      })();
      const d5 = new ye("Location Initialized");
      let jD = (() => {
        class n extends e0 {
          constructor(t) {
            super(),
              (this._doc = t),
              (this._location = window.location),
              (this._history = window.history);
          }
          getBaseHrefFromDOM() {
            return Xs().getBaseHref(this._doc);
          }
          onPopState(t) {
            const i = Xs().getGlobalEventTarget(this._doc, "window");
            return (
              i.addEventListener("popstate", t, !1),
              () => i.removeEventListener("popstate", t)
            );
          }
          onHashChange(t) {
            const i = Xs().getGlobalEventTarget(this._doc, "window");
            return (
              i.addEventListener("hashchange", t, !1),
              () => i.removeEventListener("hashchange", t)
            );
          }
          get href() {
            return this._location.href;
          }
          get protocol() {
            return this._location.protocol;
          }
          get hostname() {
            return this._location.hostname;
          }
          get port() {
            return this._location.port;
          }
          get pathname() {
            return this._location.pathname;
          }
          get search() {
            return this._location.search;
          }
          get hash() {
            return this._location.hash;
          }
          set pathname(t) {
            this._location.pathname = t;
          }
          pushState(t, i, r) {
            XD() ? this._history.pushState(t, i, r) : (this._location.hash = r);
          }
          replaceState(t, i, r) {
            XD()
              ? this._history.replaceState(t, i, r)
              : (this._location.hash = r);
          }
          forward() {
            this._history.forward();
          }
          back() {
            this._history.back();
          }
          historyGo(t = 0) {
            this._history.go(t);
          }
          getState() {
            return this._history.state;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(Lt));
          }),
          (n.ɵprov = Me({
            token: n,
            factory: function () {
              return (function h5() {
                return new jD(re(Lt));
              })();
            },
            providedIn: "platform",
          })),
          n
        );
      })();
      function XD() {
        return !!window.history.pushState;
      }
      function t0(n, e) {
        if (0 == n.length) return e;
        if (0 == e.length) return n;
        let t = 0;
        return (
          n.endsWith("/") && t++,
          e.startsWith("/") && t++,
          2 == t ? n + e.substring(1) : 1 == t ? n + e : n + "/" + e
        );
      }
      function qD(n) {
        const e = n.match(/#|\?|$/),
          t = (e && e.index) || n.length;
        return n.slice(0, t - ("/" === n[t - 1] ? 1 : 0)) + n.slice(t);
      }
      function qs(n) {
        return n && "?" !== n[0] ? "?" + n : n;
      }
      let ba = (() => {
        class n {
          historyGo(t) {
            throw new Error("Not implemented");
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({
            token: n,
            factory: function () {
              return ft(ZD);
            },
            providedIn: "root",
          })),
          n
        );
      })();
      const YD = new ye("appBaseHref");
      let ZD = (() => {
          class n extends ba {
            constructor(t, i) {
              super(),
                (this._platformLocation = t),
                (this._removeListenerFns = []),
                (this._baseHref =
                  i ??
                  this._platformLocation.getBaseHrefFromDOM() ??
                  ft(Lt).location?.origin ??
                  "");
            }
            ngOnDestroy() {
              for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()();
            }
            onPopState(t) {
              this._removeListenerFns.push(
                this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
              );
            }
            getBaseHref() {
              return this._baseHref;
            }
            prepareExternalUrl(t) {
              return t0(this._baseHref, t);
            }
            path(t = !1) {
              const i =
                  this._platformLocation.pathname +
                  qs(this._platformLocation.search),
                r = this._platformLocation.hash;
              return r && t ? `${i}${r}` : i;
            }
            pushState(t, i, r, s) {
              const o = this.prepareExternalUrl(r + qs(s));
              this._platformLocation.pushState(t, i, o);
            }
            replaceState(t, i, r, s) {
              const o = this.prepareExternalUrl(r + qs(s));
              this._platformLocation.replaceState(t, i, o);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
            getState() {
              return this._platformLocation.getState();
            }
            historyGo(t = 0) {
              this._platformLocation.historyGo?.(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(e0), re(YD, 8));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        f5 = (() => {
          class n extends ba {
            constructor(t, i) {
              super(),
                (this._platformLocation = t),
                (this._baseHref = ""),
                (this._removeListenerFns = []),
                null != i && (this._baseHref = i);
            }
            ngOnDestroy() {
              for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()();
            }
            onPopState(t) {
              this._removeListenerFns.push(
                this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
              );
            }
            getBaseHref() {
              return this._baseHref;
            }
            path(t = !1) {
              let i = this._platformLocation.hash;
              return null == i && (i = "#"), i.length > 0 ? i.substring(1) : i;
            }
            prepareExternalUrl(t) {
              const i = t0(this._baseHref, t);
              return i.length > 0 ? "#" + i : i;
            }
            pushState(t, i, r, s) {
              let o = this.prepareExternalUrl(r + qs(s));
              0 == o.length && (o = this._platformLocation.pathname),
                this._platformLocation.pushState(t, i, o);
            }
            replaceState(t, i, r, s) {
              let o = this.prepareExternalUrl(r + qs(s));
              0 == o.length && (o = this._platformLocation.pathname),
                this._platformLocation.replaceState(t, i, o);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
            getState() {
              return this._platformLocation.getState();
            }
            historyGo(t = 0) {
              this._platformLocation.historyGo?.(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(e0), re(YD, 8));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        yp = (() => {
          class n {
            constructor(t) {
              (this._subject = new Ut()),
                (this._urlChangeListeners = []),
                (this._urlChangeSubscription = null),
                (this._locationStrategy = t);
              const i = this._locationStrategy.getBaseHref();
              (this._basePath = (function g5(n) {
                if (new RegExp("^(https?:)?//").test(n)) {
                  const [, t] = n.split(/\/\/[^\/]+/);
                  return t;
                }
                return n;
              })(qD(KD(i)))),
                this._locationStrategy.onPopState((r) => {
                  this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: r.state,
                    type: r.type,
                  });
                });
            }
            ngOnDestroy() {
              this._urlChangeSubscription?.unsubscribe(),
                (this._urlChangeListeners = []);
            }
            path(t = !1) {
              return this.normalize(this._locationStrategy.path(t));
            }
            getState() {
              return this._locationStrategy.getState();
            }
            isCurrentPathEqualTo(t, i = "") {
              return this.path() == this.normalize(t + qs(i));
            }
            normalize(t) {
              return n.stripTrailingSlash(
                (function m5(n, e) {
                  if (!n || !e.startsWith(n)) return e;
                  const t = e.substring(n.length);
                  return "" === t || ["/", ";", "?", "#"].includes(t[0])
                    ? t
                    : e;
                })(this._basePath, KD(t))
              );
            }
            prepareExternalUrl(t) {
              return (
                t && "/" !== t[0] && (t = "/" + t),
                this._locationStrategy.prepareExternalUrl(t)
              );
            }
            go(t, i = "", r = null) {
              this._locationStrategy.pushState(r, "", t, i),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + qs(i)),
                  r
                );
            }
            replaceState(t, i = "", r = null) {
              this._locationStrategy.replaceState(r, "", t, i),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + qs(i)),
                  r
                );
            }
            forward() {
              this._locationStrategy.forward();
            }
            back() {
              this._locationStrategy.back();
            }
            historyGo(t = 0) {
              this._locationStrategy.historyGo?.(t);
            }
            onUrlChange(t) {
              return (
                this._urlChangeListeners.push(t),
                this._urlChangeSubscription ||
                  (this._urlChangeSubscription = this.subscribe((i) => {
                    this._notifyUrlChangeListeners(i.url, i.state);
                  })),
                () => {
                  const i = this._urlChangeListeners.indexOf(t);
                  this._urlChangeListeners.splice(i, 1),
                    0 === this._urlChangeListeners.length &&
                      (this._urlChangeSubscription?.unsubscribe(),
                      (this._urlChangeSubscription = null));
                }
              );
            }
            _notifyUrlChangeListeners(t = "", i) {
              this._urlChangeListeners.forEach((r) => r(t, i));
            }
            subscribe(t, i, r) {
              return this._subject.subscribe({
                next: t,
                error: i,
                complete: r,
              });
            }
          }
          return (
            (n.normalizeQueryParams = qs),
            (n.joinWithSlash = t0),
            (n.stripTrailingSlash = qD),
            (n.ɵfac = function (t) {
              return new (t || n)(re(ba));
            }),
            (n.ɵprov = Me({
              token: n,
              factory: function () {
                return (function p5() {
                  return new yp(re(ba));
                })();
              },
              providedIn: "root",
            })),
            n
          );
        })();
      function KD(n) {
        return n.replace(/\/index.html$/, "");
      }
      const h0 = /\s+/,
        o1 = [];
      let Jl = (() => {
        class n {
          constructor(t, i, r, s) {
            (this._iterableDiffers = t),
              (this._keyValueDiffers = i),
              (this._ngEl = r),
              (this._renderer = s),
              (this.initialClasses = o1),
              (this.stateMap = new Map());
          }
          set klass(t) {
            this.initialClasses = null != t ? t.trim().split(h0) : o1;
          }
          set ngClass(t) {
            this.rawClass = "string" == typeof t ? t.trim().split(h0) : t;
          }
          ngDoCheck() {
            for (const i of this.initialClasses) this._updateState(i, !0);
            const t = this.rawClass;
            if (Array.isArray(t) || t instanceof Set)
              for (const i of t) this._updateState(i, !0);
            else if (null != t)
              for (const i of Object.keys(t))
                this._updateState(i, Boolean(t[i]));
            this._applyStateDiff();
          }
          _updateState(t, i) {
            const r = this.stateMap.get(t);
            void 0 !== r
              ? (r.enabled !== i && ((r.changed = !0), (r.enabled = i)),
                (r.touched = !0))
              : this.stateMap.set(t, { enabled: i, changed: !0, touched: !0 });
          }
          _applyStateDiff() {
            for (const t of this.stateMap) {
              const i = t[0],
                r = t[1];
              r.changed
                ? (this._toggleClass(i, r.enabled), (r.changed = !1))
                : r.touched ||
                  (r.enabled && this._toggleClass(i, !1),
                  this.stateMap.delete(i)),
                (r.touched = !1);
            }
          }
          _toggleClass(t, i) {
            (t = t.trim()).length > 0 &&
              t.split(h0).forEach((r) => {
                i
                  ? this._renderer.addClass(this._ngEl.nativeElement, r)
                  : this._renderer.removeClass(this._ngEl.nativeElement, r);
              });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(vp), G(vd), G(rn), G(Hs));
          }),
          (n.ɵdir = He({
            type: n,
            selectors: [["", "ngClass", ""]],
            inputs: { klass: ["class", "klass"], ngClass: "ngClass" },
            standalone: !0,
          })),
          n
        );
      })();
      class t8 {
        constructor(e, t, i, r) {
          (this.$implicit = e),
            (this.ngForOf = t),
            (this.index = i),
            (this.count = r);
        }
        get first() {
          return 0 === this.index;
        }
        get last() {
          return this.index === this.count - 1;
        }
        get even() {
          return this.index % 2 == 0;
        }
        get odd() {
          return !this.even;
        }
      }
      let xd = (() => {
        class n {
          set ngForOf(t) {
            (this._ngForOf = t), (this._ngForOfDirty = !0);
          }
          set ngForTrackBy(t) {
            this._trackByFn = t;
          }
          get ngForTrackBy() {
            return this._trackByFn;
          }
          constructor(t, i, r) {
            (this._viewContainer = t),
              (this._template = i),
              (this._differs = r),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null);
          }
          set ngForTemplate(t) {
            t && (this._template = t);
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1;
              const t = this._ngForOf;
              !this._differ &&
                t &&
                (this._differ = this._differs
                  .find(t)
                  .create(this.ngForTrackBy));
            }
            if (this._differ) {
              const t = this._differ.diff(this._ngForOf);
              t && this._applyChanges(t);
            }
          }
          _applyChanges(t) {
            const i = this._viewContainer;
            t.forEachOperation((r, s, o) => {
              if (null == r.previousIndex)
                i.createEmbeddedView(
                  this._template,
                  new t8(r.item, this._ngForOf, -1, -1),
                  null === o ? void 0 : o
                );
              else if (null == o) i.remove(null === s ? void 0 : s);
              else if (null !== s) {
                const a = i.get(s);
                i.move(a, o), c1(a, r);
              }
            });
            for (let r = 0, s = i.length; r < s; r++) {
              const a = i.get(r).context;
              (a.index = r), (a.count = s), (a.ngForOf = this._ngForOf);
            }
            t.forEachIdentityChange((r) => {
              c1(i.get(r.currentIndex), r);
            });
          }
          static ngTemplateContextGuard(t, i) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(br), G(ys), G(vp));
          }),
          (n.ɵdir = He({
            type: n,
            selectors: [["", "ngFor", "", "ngForOf", ""]],
            inputs: {
              ngForOf: "ngForOf",
              ngForTrackBy: "ngForTrackBy",
              ngForTemplate: "ngForTemplate",
            },
            standalone: !0,
          })),
          n
        );
      })();
      function c1(n, e) {
        n.context.$implicit = e.item;
      }
      let ec = (() => {
        class n {
          constructor(t, i) {
            (this._viewContainer = t),
              (this._context = new i8()),
              (this._thenTemplateRef = null),
              (this._elseTemplateRef = null),
              (this._thenViewRef = null),
              (this._elseViewRef = null),
              (this._thenTemplateRef = i);
          }
          set ngIf(t) {
            (this._context.$implicit = this._context.ngIf = t),
              this._updateView();
          }
          set ngIfThen(t) {
            u1("ngIfThen", t),
              (this._thenTemplateRef = t),
              (this._thenViewRef = null),
              this._updateView();
          }
          set ngIfElse(t) {
            u1("ngIfElse", t),
              (this._elseTemplateRef = t),
              (this._elseViewRef = null),
              this._updateView();
          }
          _updateView() {
            this._context.$implicit
              ? this._thenViewRef ||
                (this._viewContainer.clear(),
                (this._elseViewRef = null),
                this._thenTemplateRef &&
                  (this._thenViewRef = this._viewContainer.createEmbeddedView(
                    this._thenTemplateRef,
                    this._context
                  )))
              : this._elseViewRef ||
                (this._viewContainer.clear(),
                (this._thenViewRef = null),
                this._elseTemplateRef &&
                  (this._elseViewRef = this._viewContainer.createEmbeddedView(
                    this._elseTemplateRef,
                    this._context
                  )));
          }
          static ngTemplateContextGuard(t, i) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(br), G(ys));
          }),
          (n.ɵdir = He({
            type: n,
            selectors: [["", "ngIf", ""]],
            inputs: {
              ngIf: "ngIf",
              ngIfThen: "ngIfThen",
              ngIfElse: "ngIfElse",
            },
            standalone: !0,
          })),
          n
        );
      })();
      class i8 {
        constructor() {
          (this.$implicit = null), (this.ngIf = null);
        }
      }
      function u1(n, e) {
        if (e && !e.createEmbeddedView)
          throw new Error(
            `${n} must be a TemplateRef, but received '${$t(e)}'.`
          );
      }
      let Dp = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = _n({ type: n })),
          (n.ɵinj = cn({})),
          n
        );
      })();
      const f1 = "browser";
      let P8 = (() => {
        class n {}
        return (
          (n.ɵprov = Me({
            token: n,
            providedIn: "root",
            factory: () => new O8(re(Lt), window),
          })),
          n
        );
      })();
      class O8 {
        constructor(e, t) {
          (this.document = e), (this.window = t), (this.offset = () => [0, 0]);
        }
        setOffset(e) {
          this.offset = Array.isArray(e) ? () => e : e;
        }
        getScrollPosition() {
          return this.supportsScrolling()
            ? [this.window.pageXOffset, this.window.pageYOffset]
            : [0, 0];
        }
        scrollToPosition(e) {
          this.supportsScrolling() && this.window.scrollTo(e[0], e[1]);
        }
        scrollToAnchor(e) {
          if (!this.supportsScrolling()) return;
          const t = (function L8(n, e) {
            const t = n.getElementById(e) || n.getElementsByName(e)[0];
            if (t) return t;
            if (
              "function" == typeof n.createTreeWalker &&
              n.body &&
              (n.body.createShadowRoot || n.body.attachShadow)
            ) {
              const i = n.createTreeWalker(n.body, NodeFilter.SHOW_ELEMENT);
              let r = i.currentNode;
              for (; r; ) {
                const s = r.shadowRoot;
                if (s) {
                  const o =
                    s.getElementById(e) || s.querySelector(`[name="${e}"]`);
                  if (o) return o;
                }
                r = i.nextNode();
              }
            }
            return null;
          })(this.document, e);
          t && (this.scrollToElement(t), t.focus());
        }
        setHistoryScrollRestoration(e) {
          if (this.supportScrollRestoration()) {
            const t = this.window.history;
            t && t.scrollRestoration && (t.scrollRestoration = e);
          }
        }
        scrollToElement(e) {
          const t = e.getBoundingClientRect(),
            i = t.left + this.window.pageXOffset,
            r = t.top + this.window.pageYOffset,
            s = this.offset();
          this.window.scrollTo(i - s[0], r - s[1]);
        }
        supportScrollRestoration() {
          try {
            if (!this.supportsScrolling()) return !1;
            const e =
              p1(this.window.history) ||
              p1(Object.getPrototypeOf(this.window.history));
            return !(!e || (!e.writable && !e.set));
          } catch {
            return !1;
          }
        }
        supportsScrolling() {
          try {
            return (
              !!this.window &&
              !!this.window.scrollTo &&
              "pageXOffset" in this.window
            );
          } catch {
            return !1;
          }
        }
      }
      function p1(n) {
        return Object.getOwnPropertyDescriptor(n, "scrollRestoration");
      }
      class lW extends c5 {
        constructor() {
          super(...arguments), (this.supportsDOMEvents = !0);
        }
      }
      class y0 extends lW {
        static makeCurrent() {
          !(function l5(n) {
            Jy || (Jy = n);
          })(new y0());
        }
        onAndCancel(e, t, i) {
          return (
            e.addEventListener(t, i, !1),
            () => {
              e.removeEventListener(t, i, !1);
            }
          );
        }
        dispatchEvent(e, t) {
          e.dispatchEvent(t);
        }
        remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
        createElement(e, t) {
          return (t = t || this.getDefaultDocument()).createElement(e);
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument("fakeTitle");
        }
        getDefaultDocument() {
          return document;
        }
        isElementNode(e) {
          return e.nodeType === Node.ELEMENT_NODE;
        }
        isShadowRoot(e) {
          return e instanceof DocumentFragment;
        }
        getGlobalEventTarget(e, t) {
          return "window" === t
            ? window
            : "document" === t
            ? e
            : "body" === t
            ? e.body
            : null;
        }
        getBaseHref(e) {
          const t = (function cW() {
            return (
              (Md = Md || document.querySelector("base")),
              Md ? Md.getAttribute("href") : null
            );
          })();
          return null == t
            ? null
            : (function uW(n) {
                (Pp = Pp || document.createElement("a")),
                  Pp.setAttribute("href", n);
                const e = Pp.pathname;
                return "/" === e.charAt(0) ? e : `/${e}`;
              })(t);
        }
        resetBaseElement() {
          Md = null;
        }
        getUserAgent() {
          return window.navigator.userAgent;
        }
        getCookie(e) {
          return (function J5(n, e) {
            e = encodeURIComponent(e);
            for (const t of n.split(";")) {
              const i = t.indexOf("="),
                [r, s] = -1 == i ? [t, ""] : [t.slice(0, i), t.slice(i + 1)];
              if (r.trim() === e) return decodeURIComponent(s);
            }
            return null;
          })(document.cookie, e);
        }
      }
      let Pp,
        Md = null;
      const y1 = new ye("TRANSITION_ID"),
        hW = [
          {
            provide: hp,
            useFactory: function dW(n, e, t) {
              return () => {
                t.get(fp).donePromise.then(() => {
                  const i = Xs(),
                    r = e.querySelectorAll(`style[ng-transition="${n}"]`);
                  for (let s = 0; s < r.length; s++) i.remove(r[s]);
                });
              };
            },
            deps: [y1, Lt, Qi],
            multi: !0,
          },
        ];
      let pW = (() => {
        class n {
          build() {
            return new XMLHttpRequest();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const Op = new ye("EventManagerPlugins");
      let Lp = (() => {
        class n {
          constructor(t, i) {
            (this._zone = i),
              (this._eventNameToPlugin = new Map()),
              t.forEach((r) => {
                r.manager = this;
              }),
              (this._plugins = t.slice().reverse());
          }
          addEventListener(t, i, r) {
            return this._findPluginFor(i).addEventListener(t, i, r);
          }
          addGlobalEventListener(t, i, r) {
            return this._findPluginFor(i).addGlobalEventListener(t, i, r);
          }
          getZone() {
            return this._zone;
          }
          _findPluginFor(t) {
            const i = this._eventNameToPlugin.get(t);
            if (i) return i;
            const r = this._plugins;
            for (let s = 0; s < r.length; s++) {
              const o = r[s];
              if (o.supports(t)) return this._eventNameToPlugin.set(t, o), o;
            }
            throw new Error(`No event manager plugin found for event ${t}`);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(Op), re(wt));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class b1 {
        constructor(e) {
          this._doc = e;
        }
        addGlobalEventListener(e, t, i) {
          const r = Xs().getGlobalEventTarget(this._doc, e);
          if (!r)
            throw new Error(`Unsupported event target ${r} for event ${t}`);
          return this.addEventListener(r, t, i);
        }
      }
      let x1 = (() => {
          class n {
            constructor() {
              this.usageCount = new Map();
            }
            addStyles(t) {
              for (const i of t)
                1 === this.changeUsageCount(i, 1) && this.onStyleAdded(i);
            }
            removeStyles(t) {
              for (const i of t)
                0 === this.changeUsageCount(i, -1) && this.onStyleRemoved(i);
            }
            onStyleRemoved(t) {}
            onStyleAdded(t) {}
            getAllStyles() {
              return this.usageCount.keys();
            }
            changeUsageCount(t, i) {
              const r = this.usageCount;
              let s = r.get(t) ?? 0;
              return (s += i), s > 0 ? r.set(t, s) : r.delete(t), s;
            }
            ngOnDestroy() {
              for (const t of this.getAllStyles()) this.onStyleRemoved(t);
              this.usageCount.clear();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Sd = (() => {
          class n extends x1 {
            constructor(t) {
              super(),
                (this.doc = t),
                (this.styleRef = new Map()),
                (this.hostNodes = new Set()),
                this.resetHostNodes();
            }
            onStyleAdded(t) {
              for (const i of this.hostNodes) this.addStyleToHost(i, t);
            }
            onStyleRemoved(t) {
              const i = this.styleRef;
              i.get(t)?.forEach((s) => s.remove()), i.delete(t);
            }
            ngOnDestroy() {
              super.ngOnDestroy(), this.styleRef.clear(), this.resetHostNodes();
            }
            addHost(t) {
              this.hostNodes.add(t);
              for (const i of this.getAllStyles()) this.addStyleToHost(t, i);
            }
            removeHost(t) {
              this.hostNodes.delete(t);
            }
            addStyleToHost(t, i) {
              const r = this.doc.createElement("style");
              (r.textContent = i), t.appendChild(r);
              const s = this.styleRef.get(i);
              s ? s.push(r) : this.styleRef.set(i, [r]);
            }
            resetHostNodes() {
              const t = this.hostNodes;
              t.clear(), t.add(this.doc.head);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Lt));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
            n
          );
        })();
      const b0 = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: "http://www.w3.org/1999/xhtml",
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
          math: "http://www.w3.org/1998/MathML/",
        },
        x0 = /%COMP%/g,
        S1 = new ye("RemoveStylesOnCompDestory", {
          providedIn: "root",
          factory: () => !1,
        });
      function E1(n, e) {
        return e.flat(100).map((t) => t.replace(x0, n));
      }
      function C1(n) {
        return (e) => {
          if ("__ngUnwrap__" === e) return n;
          !1 === n(e) && (e.preventDefault(), (e.returnValue = !1));
        };
      }
      let Fp = (() => {
        class n {
          constructor(t, i, r, s) {
            (this.eventManager = t),
              (this.sharedStylesHost = i),
              (this.appId = r),
              (this.removeStylesOnCompDestory = s),
              (this.rendererByCompId = new Map()),
              (this.defaultRenderer = new w0(t));
          }
          createRenderer(t, i) {
            if (!t || !i) return this.defaultRenderer;
            const r = this.getOrCreateRenderer(t, i);
            return (
              r instanceof D1
                ? r.applyToHost(t)
                : r instanceof M0 && r.applyStyles(),
              r
            );
          }
          getOrCreateRenderer(t, i) {
            const r = this.rendererByCompId;
            let s = r.get(i.id);
            if (!s) {
              const o = this.eventManager,
                a = this.sharedStylesHost,
                l = this.removeStylesOnCompDestory;
              switch (i.encapsulation) {
                case Fr.Emulated:
                  s = new D1(o, a, i, this.appId, l);
                  break;
                case Fr.ShadowDom:
                  return new xW(o, a, t, i);
                default:
                  s = new M0(o, a, i, l);
              }
              (s.onDestroy = () => r.delete(i.id)), r.set(i.id, s);
            }
            return s;
          }
          ngOnDestroy() {
            this.rendererByCompId.clear();
          }
          begin() {}
          end() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(Lp), re(Sd), re(gd), re(S1));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class w0 {
        constructor(e) {
          (this.eventManager = e),
            (this.data = Object.create(null)),
            (this.destroyNode = null);
        }
        destroy() {}
        createElement(e, t) {
          return t
            ? document.createElementNS(b0[t] || t, e)
            : document.createElement(e);
        }
        createComment(e) {
          return document.createComment(e);
        }
        createText(e) {
          return document.createTextNode(e);
        }
        appendChild(e, t) {
          (A1(e) ? e.content : e).appendChild(t);
        }
        insertBefore(e, t, i) {
          e && (A1(e) ? e.content : e).insertBefore(t, i);
        }
        removeChild(e, t) {
          e && e.removeChild(t);
        }
        selectRootElement(e, t) {
          let i = "string" == typeof e ? document.querySelector(e) : e;
          if (!i)
            throw new Error(`The selector "${e}" did not match any elements`);
          return t || (i.textContent = ""), i;
        }
        parentNode(e) {
          return e.parentNode;
        }
        nextSibling(e) {
          return e.nextSibling;
        }
        setAttribute(e, t, i, r) {
          if (r) {
            t = r + ":" + t;
            const s = b0[r];
            s ? e.setAttributeNS(s, t, i) : e.setAttribute(t, i);
          } else e.setAttribute(t, i);
        }
        removeAttribute(e, t, i) {
          if (i) {
            const r = b0[i];
            r ? e.removeAttributeNS(r, t) : e.removeAttribute(`${i}:${t}`);
          } else e.removeAttribute(t);
        }
        addClass(e, t) {
          e.classList.add(t);
        }
        removeClass(e, t) {
          e.classList.remove(t);
        }
        setStyle(e, t, i, r) {
          r & (ki.DashCase | ki.Important)
            ? e.style.setProperty(t, i, r & ki.Important ? "important" : "")
            : (e.style[t] = i);
        }
        removeStyle(e, t, i) {
          i & ki.DashCase ? e.style.removeProperty(t) : (e.style[t] = "");
        }
        setProperty(e, t, i) {
          e[t] = i;
        }
        setValue(e, t) {
          e.nodeValue = t;
        }
        listen(e, t, i) {
          return "string" == typeof e
            ? this.eventManager.addGlobalEventListener(e, t, C1(i))
            : this.eventManager.addEventListener(e, t, C1(i));
        }
      }
      function A1(n) {
        return "TEMPLATE" === n.tagName && void 0 !== n.content;
      }
      class xW extends w0 {
        constructor(e, t, i, r) {
          super(e),
            (this.sharedStylesHost = t),
            (this.hostEl = i),
            (this.shadowRoot = i.attachShadow({ mode: "open" })),
            this.sharedStylesHost.addHost(this.shadowRoot);
          const s = E1(r.id, r.styles);
          for (const o of s) {
            const a = document.createElement("style");
            (a.textContent = o), this.shadowRoot.appendChild(a);
          }
        }
        nodeOrShadowRoot(e) {
          return e === this.hostEl ? this.shadowRoot : e;
        }
        appendChild(e, t) {
          return super.appendChild(this.nodeOrShadowRoot(e), t);
        }
        insertBefore(e, t, i) {
          return super.insertBefore(this.nodeOrShadowRoot(e), t, i);
        }
        removeChild(e, t) {
          return super.removeChild(this.nodeOrShadowRoot(e), t);
        }
        parentNode(e) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(e))
          );
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot);
        }
      }
      class M0 extends w0 {
        constructor(e, t, i, r, s = i.id) {
          super(e),
            (this.sharedStylesHost = t),
            (this.removeStylesOnCompDestory = r),
            (this.rendererUsageCount = 0),
            (this.styles = E1(s, i.styles));
        }
        applyStyles() {
          this.sharedStylesHost.addStyles(this.styles),
            this.rendererUsageCount++;
        }
        destroy() {
          this.removeStylesOnCompDestory &&
            (this.sharedStylesHost.removeStyles(this.styles),
            this.rendererUsageCount--,
            0 === this.rendererUsageCount && this.onDestroy?.());
        }
      }
      class D1 extends M0 {
        constructor(e, t, i, r, s) {
          const o = r + "-" + i.id;
          super(e, t, i, s, o),
            (this.contentAttr = (function vW(n) {
              return "_ngcontent-%COMP%".replace(x0, n);
            })(o)),
            (this.hostAttr = (function yW(n) {
              return "_nghost-%COMP%".replace(x0, n);
            })(o));
        }
        applyToHost(e) {
          this.applyStyles(), this.setAttribute(e, this.hostAttr, "");
        }
        createElement(e, t) {
          const i = super.createElement(e, t);
          return super.setAttribute(i, this.contentAttr, ""), i;
        }
      }
      let wW = (() => {
        class n extends b1 {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return !0;
          }
          addEventListener(t, i, r) {
            return (
              t.addEventListener(i, r, !1),
              () => this.removeEventListener(t, i, r)
            );
          }
          removeEventListener(t, i, r) {
            return t.removeEventListener(i, r);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(Lt));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const I1 = ["alt", "control", "meta", "shift"],
        MW = {
          "\b": "Backspace",
          "\t": "Tab",
          "\x7f": "Delete",
          "\x1b": "Escape",
          Del: "Delete",
          Esc: "Escape",
          Left: "ArrowLeft",
          Right: "ArrowRight",
          Up: "ArrowUp",
          Down: "ArrowDown",
          Menu: "ContextMenu",
          Scroll: "ScrollLock",
          Win: "OS",
        },
        SW = {
          alt: (n) => n.altKey,
          control: (n) => n.ctrlKey,
          meta: (n) => n.metaKey,
          shift: (n) => n.shiftKey,
        };
      let EW = (() => {
        class n extends b1 {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return null != n.parseEventName(t);
          }
          addEventListener(t, i, r) {
            const s = n.parseEventName(i),
              o = n.eventCallback(s.fullKey, r, this.manager.getZone());
            return this.manager
              .getZone()
              .runOutsideAngular(() => Xs().onAndCancel(t, s.domEventName, o));
          }
          static parseEventName(t) {
            const i = t.toLowerCase().split("."),
              r = i.shift();
            if (0 === i.length || ("keydown" !== r && "keyup" !== r))
              return null;
            const s = n._normalizeKey(i.pop());
            let o = "",
              a = i.indexOf("code");
            if (
              (a > -1 && (i.splice(a, 1), (o = "code.")),
              I1.forEach((c) => {
                const u = i.indexOf(c);
                u > -1 && (i.splice(u, 1), (o += c + "."));
              }),
              (o += s),
              0 != i.length || 0 === s.length)
            )
              return null;
            const l = {};
            return (l.domEventName = r), (l.fullKey = o), l;
          }
          static matchEventFullKeyCode(t, i) {
            let r = MW[t.key] || t.key,
              s = "";
            return (
              i.indexOf("code.") > -1 && ((r = t.code), (s = "code.")),
              !(null == r || !r) &&
                ((r = r.toLowerCase()),
                " " === r ? (r = "space") : "." === r && (r = "dot"),
                I1.forEach((o) => {
                  o !== r && (0, SW[o])(t) && (s += o + ".");
                }),
                (s += r),
                s === i)
            );
          }
          static eventCallback(t, i, r) {
            return (s) => {
              n.matchEventFullKeyCode(s, t) && r.runGuarded(() => i(s));
            };
          }
          static _normalizeKey(t) {
            return "esc" === t ? "escape" : t;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(Lt));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const DW = AD(s5, "browser", [
          { provide: Vy, useValue: f1 },
          {
            provide: _D,
            useValue: function CW() {
              y0.makeCurrent();
            },
            multi: !0,
          },
          {
            provide: Lt,
            useFactory: function AW() {
              return (
                (function o3(n) {
                  Av = n;
                })(document),
                document
              );
            },
            deps: [],
          },
        ]),
        O1 = new ye(""),
        L1 = [
          {
            provide: pp,
            useClass: class fW {
              addToWindow(e) {
                (tn.getAngularTestability = (i, r = !0) => {
                  const s = e.findTestabilityInTree(i, r);
                  if (null == s)
                    throw new Error("Could not find testability for element.");
                  return s;
                }),
                  (tn.getAllAngularTestabilities = () =>
                    e.getAllTestabilities()),
                  (tn.getAllAngularRootElements = () => e.getAllRootElements()),
                  tn.frameworkStabilizers || (tn.frameworkStabilizers = []),
                  tn.frameworkStabilizers.push((i) => {
                    const r = tn.getAllAngularTestabilities();
                    let s = r.length,
                      o = !1;
                    const a = function (l) {
                      (o = o || l), s--, 0 == s && i(o);
                    };
                    r.forEach(function (l) {
                      l.whenStable(a);
                    });
                  });
              }
              findTestabilityInTree(e, t, i) {
                return null == t
                  ? null
                  : e.getTestability(t) ??
                      (i
                        ? Xs().isShadowRoot(t)
                          ? this.findTestabilityInTree(e, t.host, !0)
                          : this.findTestabilityInTree(e, t.parentElement, !0)
                        : null);
              }
            },
            deps: [],
          },
          { provide: MD, useClass: Wy, deps: [wt, jy, pp] },
          { provide: Wy, useClass: Wy, deps: [wt, jy, pp] },
        ],
        F1 = [
          { provide: Nv, useValue: "root" },
          {
            provide: Il,
            useFactory: function TW() {
              return new Il();
            },
            deps: [],
          },
          { provide: Op, useClass: wW, multi: !0, deps: [Lt, wt, Vy] },
          { provide: Op, useClass: EW, multi: !0, deps: [Lt] },
          { provide: Fp, useClass: Fp, deps: [Lp, Sd, gd, S1] },
          { provide: $u, useExisting: Fp },
          { provide: x1, useExisting: Sd },
          { provide: Sd, useClass: Sd, deps: [Lt] },
          { provide: Lp, useClass: Lp, deps: [Op, wt] },
          { provide: class F8 {}, useClass: pW, deps: [] },
          [],
        ];
      let N1 = (() => {
          class n {
            constructor(t) {}
            static withServerTransition(t) {
              return {
                ngModule: n,
                providers: [
                  { provide: gd, useValue: t.appId },
                  { provide: y1, useExisting: gd },
                  hW,
                ],
              };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(O1, 12));
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ providers: [...F1, ...L1], imports: [Dp, o5] })),
            n
          );
        })(),
        k1 = (() => {
          class n {
            constructor(t) {
              this._doc = t;
            }
            getTitle() {
              return this._doc.title;
            }
            setTitle(t) {
              this._doc.title = t || "";
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Lt));
            }),
            (n.ɵprov = Me({
              token: n,
              factory: function (t) {
                let i = null;
                return (
                  (i = t
                    ? new t()
                    : (function RW() {
                        return new k1(re(Lt));
                      })()),
                  i
                );
              },
              providedIn: "root",
            })),
            n
          );
        })();
      typeof window < "u" && window;
      let V1 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({
              token: n,
              factory: function (t) {
                let i = null;
                return (i = t ? new (t || n)() : re(z1)), i;
              },
              providedIn: "root",
            })),
            n
          );
        })(),
        z1 = (() => {
          class n extends V1 {
            constructor(t) {
              super(), (this._doc = t);
            }
            sanitize(t, i) {
              if (null == i) return null;
              switch (t) {
                case Qt.NONE:
                  return i;
                case Qt.HTML:
                  return fs(i, "HTML")
                    ? $i(i)
                    : iC(this._doc, String(i)).toString();
                case Qt.STYLE:
                  return fs(i, "Style") ? $i(i) : i;
                case Qt.SCRIPT:
                  if (fs(i, "Script")) return $i(i);
                  throw new Error("unsafe value used in a script context");
                case Qt.URL:
                  return fs(i, "URL") ? $i(i) : Uf(String(i));
                case Qt.RESOURCE_URL:
                  if (fs(i, "ResourceURL")) return $i(i);
                  throw new Error(
                    `unsafe value used in a resource URL context (see ${rf})`
                  );
                default:
                  throw new Error(
                    `Unexpected SecurityContext ${t} (see ${rf})`
                  );
              }
            }
            bypassSecurityTrustHtml(t) {
              return (function f3(n) {
                return new a3(n);
              })(t);
            }
            bypassSecurityTrustStyle(t) {
              return (function p3(n) {
                return new l3(n);
              })(t);
            }
            bypassSecurityTrustScript(t) {
              return (function m3(n) {
                return new c3(n);
              })(t);
            }
            bypassSecurityTrustUrl(t) {
              return (function g3(n) {
                return new u3(n);
              })(t);
            }
            bypassSecurityTrustResourceUrl(t) {
              return (function _3(n) {
                return new d3(n);
              })(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Lt));
            }),
            (n.ɵprov = Me({
              token: n,
              factory: function (t) {
                let i = null;
                return (
                  (i = t
                    ? new t()
                    : (function NW(n) {
                        return new z1(n.get(Lt));
                      })(re(Qi))),
                  i
                );
              },
              providedIn: "root",
            })),
            n
          );
        })();
      function Ge(...n) {
        return On(n, Cu(n));
      }
      class Mr extends kt {
        constructor(e) {
          super(), (this._value = e);
        }
        get value() {
          return this.getValue();
        }
        _subscribe(e) {
          const t = super._subscribe(e);
          return !t.closed && e.next(this._value), t;
        }
        getValue() {
          const { hasError: e, thrownError: t, _value: i } = this;
          if (e) throw t;
          return this._throwIfClosed(), i;
        }
        next(e) {
          super.next((this._value = e));
        }
      }
      const Np = Su(
          (n) =>
            function () {
              n(this),
                (this.name = "EmptyError"),
                (this.message = "no elements in sequence");
            }
        ),
        { isArray: kW } = Array,
        { getPrototypeOf: BW, prototype: UW, keys: VW } = Object;
      const { isArray: HW } = Array;
      function C0(n) {
        return xt((e) =>
          (function GW(n, e) {
            return HW(e) ? n(...e) : n(e);
          })(n, e)
        );
      }
      function T0(...n) {
        const e = Cu(n),
          t = (function cS(n) {
            return Ot(C_(n)) ? n.pop() : void 0;
          })(n),
          { args: i, keys: r } = (function H1(n) {
            if (1 === n.length) {
              const e = n[0];
              if (kW(e)) return { args: e, keys: null };
              if (
                (function zW(n) {
                  return n && "object" == typeof n && BW(n) === UW;
                })(e)
              ) {
                const t = VW(e);
                return { args: t.map((i) => e[i]), keys: t };
              }
            }
            return { args: n, keys: null };
          })(n);
        if (0 === i.length) return On([], e);
        const s = new Kt(
          (function WW(n, e, t = bo) {
            return (i) => {
              W1(
                e,
                () => {
                  const { length: r } = n,
                    s = new Array(r);
                  let o = r,
                    a = r;
                  for (let l = 0; l < r; l++)
                    W1(
                      e,
                      () => {
                        const c = On(n[l], e);
                        let u = !1;
                        c.subscribe(
                          en(
                            i,
                            (d) => {
                              (s[l] = d),
                                u || ((u = !0), a--),
                                a || i.next(t(s.slice()));
                            },
                            () => {
                              --o || i.complete();
                            }
                          )
                        );
                      },
                      i
                    );
                },
                i
              );
            };
          })(
            i,
            e,
            r
              ? (o) =>
                  (function G1(n, e) {
                    return n.reduce((t, i, r) => ((t[i] = e[r]), t), {});
                  })(r, o)
              : bo
          )
        );
        return t ? s.pipe(C0(t)) : s;
      }
      function W1(n, e, t) {
        n ? Os(t, n, e) : e();
      }
      function Ed(...n) {
        return (function jW() {
          return al(1);
        })()(On(n, Cu(n)));
      }
      function j1(n) {
        return new Kt((e) => {
          di(n()).subscribe(e);
        });
      }
      function Cd(n, e) {
        const t = Ot(n) ? n : () => n,
          i = (r) => r.error(t());
        return new Kt(e ? (r) => e.schedule(i, 0, r) : i);
      }
      function A0() {
        return ln((n, e) => {
          let t = null;
          n._refCount++;
          const i = en(e, void 0, void 0, void 0, () => {
            if (!n || n._refCount <= 0 || 0 < --n._refCount)
              return void (t = null);
            const r = n._connection,
              s = t;
            (t = null),
              r && (!s || r === s) && r.unsubscribe(),
              e.unsubscribe();
          });
          n.subscribe(i), i.closed || (t = n.connect());
        });
      }
      class X1 extends Kt {
        constructor(e, t) {
          super(),
            (this.source = e),
            (this.subjectFactory = t),
            (this._subject = null),
            (this._refCount = 0),
            (this._connection = null),
            YM(e) && (this.lift = e.lift);
        }
        _subscribe(e) {
          return this.getSubject().subscribe(e);
        }
        getSubject() {
          const e = this._subject;
          return (
            (!e || e.isStopped) && (this._subject = this.subjectFactory()),
            this._subject
          );
        }
        _teardown() {
          this._refCount = 0;
          const { _connection: e } = this;
          (this._subject = this._connection = null), e?.unsubscribe();
        }
        connect() {
          let e = this._connection;
          if (!e) {
            e = this._connection = new Sn();
            const t = this.getSubject();
            e.add(
              this.source.subscribe(
                en(
                  t,
                  void 0,
                  () => {
                    this._teardown(), t.complete();
                  },
                  (i) => {
                    this._teardown(), t.error(i);
                  },
                  () => this._teardown()
                )
              )
            ),
              e.closed && ((this._connection = null), (e = Sn.EMPTY));
          }
          return e;
        }
        refCount() {
          return A0()(this);
        }
      }
      function Sr(n, e) {
        return ln((t, i) => {
          let r = null,
            s = 0,
            o = !1;
          const a = () => o && !r && i.complete();
          t.subscribe(
            en(
              i,
              (l) => {
                r?.unsubscribe();
                let c = 0;
                const u = s++;
                di(n(l, u)).subscribe(
                  (r = en(
                    i,
                    (d) => i.next(e ? e(l, d, u, c++) : d),
                    () => {
                      (r = null), a();
                    }
                  ))
                );
              },
              () => {
                (o = !0), a();
              }
            )
          );
        });
      }
      function er(n) {
        return n <= 0
          ? () => ls
          : ln((e, t) => {
              let i = 0;
              e.subscribe(
                en(t, (r) => {
                  ++i <= n && (t.next(r), n <= i && t.complete());
                })
              );
            });
      }
      function tc(...n) {
        const e = Cu(n);
        return ln((t, i) => {
          (e ? Ed(n, t, e) : Ed(n, t)).subscribe(i);
        });
      }
      function _i(n, e) {
        return ln((t, i) => {
          let r = 0;
          t.subscribe(en(i, (s) => n.call(e, s, r++) && i.next(s)));
        });
      }
      function kp(n) {
        return ln((e, t) => {
          let i = !1;
          e.subscribe(
            en(
              t,
              (r) => {
                (i = !0), t.next(r);
              },
              () => {
                i || t.next(n), t.complete();
              }
            )
          );
        });
      }
      function q1(n = XW) {
        return ln((e, t) => {
          let i = !1;
          e.subscribe(
            en(
              t,
              (r) => {
                (i = !0), t.next(r);
              },
              () => (i ? t.complete() : t.error(n()))
            )
          );
        });
      }
      function XW() {
        return new Np();
      }
      function Ao(n, e) {
        const t = arguments.length >= 2;
        return (i) =>
          i.pipe(
            n ? _i((r, s) => n(r, s, i)) : bo,
            er(1),
            t ? kp(e) : q1(() => new Np())
          );
      }
      function xa(n, e) {
        return Ot(e) ? Un(n, e, 1) : Un(n, 1);
      }
      function si(n, e, t) {
        const i = Ot(n) || e || t ? { next: n, error: e, complete: t } : n;
        return i
          ? ln((r, s) => {
              var o;
              null === (o = i.subscribe) || void 0 === o || o.call(i);
              let a = !0;
              r.subscribe(
                en(
                  s,
                  (l) => {
                    var c;
                    null === (c = i.next) || void 0 === c || c.call(i, l),
                      s.next(l);
                  },
                  () => {
                    var l;
                    (a = !1),
                      null === (l = i.complete) || void 0 === l || l.call(i),
                      s.complete();
                  },
                  (l) => {
                    var c;
                    (a = !1),
                      null === (c = i.error) || void 0 === c || c.call(i, l),
                      s.error(l);
                  },
                  () => {
                    var l, c;
                    a &&
                      (null === (l = i.unsubscribe) ||
                        void 0 === l ||
                        l.call(i)),
                      null === (c = i.finalize) || void 0 === c || c.call(i);
                  }
                )
              );
            })
          : bo;
      }
      function Do(n) {
        return ln((e, t) => {
          let s,
            i = null,
            r = !1;
          (i = e.subscribe(
            en(t, void 0, void 0, (o) => {
              (s = di(n(o, Do(n)(e)))),
                i ? (i.unsubscribe(), (i = null), s.subscribe(t)) : (r = !0);
            })
          )),
            r && (i.unsubscribe(), (i = null), s.subscribe(t));
        });
      }
      function Y1(n, e) {
        return ln(
          (function qW(n, e, t, i, r) {
            return (s, o) => {
              let a = t,
                l = e,
                c = 0;
              s.subscribe(
                en(
                  o,
                  (u) => {
                    const d = c++;
                    (l = a ? n(l, u, d) : ((a = !0), u)), i && o.next(l);
                  },
                  r &&
                    (() => {
                      a && o.next(l), o.complete();
                    })
                )
              );
            };
          })(n, e, arguments.length >= 2, !0)
        );
      }
      function D0(n) {
        return n <= 0
          ? () => ls
          : ln((e, t) => {
              let i = [];
              e.subscribe(
                en(
                  t,
                  (r) => {
                    i.push(r), n < i.length && i.shift();
                  },
                  () => {
                    for (const r of i) t.next(r);
                    t.complete();
                  },
                  void 0,
                  () => {
                    i = null;
                  }
                )
              );
            });
      }
      function Z1(n, e) {
        const t = arguments.length >= 2;
        return (i) =>
          i.pipe(
            n ? _i((r, s) => n(r, s, i)) : bo,
            D0(1),
            t ? kp(e) : q1(() => new Np())
          );
      }
      function K1(n) {
        return xt(() => n);
      }
      function I0(n) {
        return ln((e, t) => {
          try {
            e.subscribe(t);
          } finally {
            t.add(n);
          }
        });
      }
      const ct = "primary",
        Td = Symbol("RouteTitle");
      class ZW {
        constructor(e) {
          this.params = e || {};
        }
        has(e) {
          return Object.prototype.hasOwnProperty.call(this.params, e);
        }
        get(e) {
          if (this.has(e)) {
            const t = this.params[e];
            return Array.isArray(t) ? t[0] : t;
          }
          return null;
        }
        getAll(e) {
          if (this.has(e)) {
            const t = this.params[e];
            return Array.isArray(t) ? t : [t];
          }
          return [];
        }
        get keys() {
          return Object.keys(this.params);
        }
      }
      function nc(n) {
        return new ZW(n);
      }
      function KW(n, e, t) {
        const i = t.path.split("/");
        if (
          i.length > n.length ||
          ("full" === t.pathMatch && (e.hasChildren() || i.length < n.length))
        )
          return null;
        const r = {};
        for (let s = 0; s < i.length; s++) {
          const o = i[s],
            a = n[s];
          if (o.startsWith(":")) r[o.substring(1)] = a;
          else if (o !== a.path) return null;
        }
        return { consumed: n.slice(0, i.length), posParams: r };
      }
      function xs(n, e) {
        const t = n ? Object.keys(n) : void 0,
          i = e ? Object.keys(e) : void 0;
        if (!t || !i || t.length != i.length) return !1;
        let r;
        for (let s = 0; s < t.length; s++)
          if (((r = t[s]), !$1(n[r], e[r]))) return !1;
        return !0;
      }
      function $1(n, e) {
        if (Array.isArray(n) && Array.isArray(e)) {
          if (n.length !== e.length) return !1;
          const t = [...n].sort(),
            i = [...e].sort();
          return t.every((r, s) => i[s] === r);
        }
        return n === e;
      }
      function Q1(n) {
        return Array.prototype.concat.apply([], n);
      }
      function J1(n) {
        return n.length > 0 ? n[n.length - 1] : null;
      }
      function oi(n, e) {
        for (const t in n) n.hasOwnProperty(t) && e(n[t], t);
      }
      function Io(n) {
        return cy(n) ? n : id(n) ? On(Promise.resolve(n)) : Ge(n);
      }
      const Bp = !1,
        QW = {
          exact: function nI(n, e, t) {
            if (
              !wa(n.segments, e.segments) ||
              !Up(n.segments, e.segments, t) ||
              n.numberOfChildren !== e.numberOfChildren
            )
              return !1;
            for (const i in e.children)
              if (!n.children[i] || !nI(n.children[i], e.children[i], t))
                return !1;
            return !0;
          },
          subset: iI,
        },
        eI = {
          exact: function JW(n, e) {
            return xs(n, e);
          },
          subset: function ej(n, e) {
            return (
              Object.keys(e).length <= Object.keys(n).length &&
              Object.keys(e).every((t) => $1(n[t], e[t]))
            );
          },
          ignored: () => !0,
        };
      function tI(n, e, t) {
        return (
          QW[t.paths](n.root, e.root, t.matrixParams) &&
          eI[t.queryParams](n.queryParams, e.queryParams) &&
          !("exact" === t.fragment && n.fragment !== e.fragment)
        );
      }
      function iI(n, e, t) {
        return rI(n, e, e.segments, t);
      }
      function rI(n, e, t, i) {
        if (n.segments.length > t.length) {
          const r = n.segments.slice(0, t.length);
          return !(!wa(r, t) || e.hasChildren() || !Up(r, t, i));
        }
        if (n.segments.length === t.length) {
          if (!wa(n.segments, t) || !Up(n.segments, t, i)) return !1;
          for (const r in e.children)
            if (!n.children[r] || !iI(n.children[r], e.children[r], i))
              return !1;
          return !0;
        }
        {
          const r = t.slice(0, n.segments.length),
            s = t.slice(n.segments.length);
          return (
            !!(wa(n.segments, r) && Up(n.segments, r, i) && n.children[ct]) &&
            rI(n.children[ct], e, s, i)
          );
        }
      }
      function Up(n, e, t) {
        return e.every((i, r) => eI[t](n[r].parameters, i.parameters));
      }
      class Ro {
        constructor(e = new Mt([], {}), t = {}, i = null) {
          (this.root = e), (this.queryParams = t), (this.fragment = i);
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = nc(this.queryParams)),
            this._queryParamMap
          );
        }
        toString() {
          return ij.serialize(this);
        }
      }
      class Mt {
        constructor(e, t) {
          (this.segments = e),
            (this.children = t),
            (this.parent = null),
            oi(t, (i, r) => (i.parent = this));
        }
        hasChildren() {
          return this.numberOfChildren > 0;
        }
        get numberOfChildren() {
          return Object.keys(this.children).length;
        }
        toString() {
          return Vp(this);
        }
      }
      class Ad {
        constructor(e, t) {
          (this.path = e), (this.parameters = t);
        }
        get parameterMap() {
          return (
            this._parameterMap || (this._parameterMap = nc(this.parameters)),
            this._parameterMap
          );
        }
        toString() {
          return aI(this);
        }
      }
      function wa(n, e) {
        return n.length === e.length && n.every((t, i) => t.path === e[i].path);
      }
      let Dd = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({
            token: n,
            factory: function () {
              return new R0();
            },
            providedIn: "root",
          })),
          n
        );
      })();
      class R0 {
        parse(e) {
          const t = new hj(e);
          return new Ro(
            t.parseRootSegment(),
            t.parseQueryParams(),
            t.parseFragment()
          );
        }
        serialize(e) {
          const t = `/${Id(e.root, !0)}`,
            i = (function oj(n) {
              const e = Object.keys(n)
                .map((t) => {
                  const i = n[t];
                  return Array.isArray(i)
                    ? i.map((r) => `${zp(t)}=${zp(r)}`).join("&")
                    : `${zp(t)}=${zp(i)}`;
                })
                .filter((t) => !!t);
              return e.length ? `?${e.join("&")}` : "";
            })(e.queryParams);
          return `${t}${i}${
            "string" == typeof e.fragment
              ? `#${(function rj(n) {
                  return encodeURI(n);
                })(e.fragment)}`
              : ""
          }`;
        }
      }
      const ij = new R0();
      function Vp(n) {
        return n.segments.map((e) => aI(e)).join("/");
      }
      function Id(n, e) {
        if (!n.hasChildren()) return Vp(n);
        if (e) {
          const t = n.children[ct] ? Id(n.children[ct], !1) : "",
            i = [];
          return (
            oi(n.children, (r, s) => {
              s !== ct && i.push(`${s}:${Id(r, !1)}`);
            }),
            i.length > 0 ? `${t}(${i.join("//")})` : t
          );
        }
        {
          const t = (function nj(n, e) {
            let t = [];
            return (
              oi(n.children, (i, r) => {
                r === ct && (t = t.concat(e(i, r)));
              }),
              oi(n.children, (i, r) => {
                r !== ct && (t = t.concat(e(i, r)));
              }),
              t
            );
          })(n, (i, r) =>
            r === ct ? [Id(n.children[ct], !1)] : [`${r}:${Id(i, !1)}`]
          );
          return 1 === Object.keys(n.children).length && null != n.children[ct]
            ? `${Vp(n)}/${t[0]}`
            : `${Vp(n)}/(${t.join("//")})`;
        }
      }
      function sI(n) {
        return encodeURIComponent(n)
          .replace(/%40/g, "@")
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",");
      }
      function zp(n) {
        return sI(n).replace(/%3B/gi, ";");
      }
      function P0(n) {
        return sI(n)
          .replace(/\(/g, "%28")
          .replace(/\)/g, "%29")
          .replace(/%26/gi, "&");
      }
      function Hp(n) {
        return decodeURIComponent(n);
      }
      function oI(n) {
        return Hp(n.replace(/\+/g, "%20"));
      }
      function aI(n) {
        return `${P0(n.path)}${(function sj(n) {
          return Object.keys(n)
            .map((e) => `;${P0(e)}=${P0(n[e])}`)
            .join("");
        })(n.parameters)}`;
      }
      const aj = /^[^\/()?;=#]+/;
      function Gp(n) {
        const e = n.match(aj);
        return e ? e[0] : "";
      }
      const lj = /^[^=?&#]+/,
        uj = /^[^&#]+/;
      class hj {
        constructor(e) {
          (this.url = e), (this.remaining = e);
        }
        parseRootSegment() {
          return (
            this.consumeOptional("/"),
            "" === this.remaining ||
            this.peekStartsWith("?") ||
            this.peekStartsWith("#")
              ? new Mt([], {})
              : new Mt([], this.parseChildren())
          );
        }
        parseQueryParams() {
          const e = {};
          if (this.consumeOptional("?"))
            do {
              this.parseQueryParam(e);
            } while (this.consumeOptional("&"));
          return e;
        }
        parseFragment() {
          return this.consumeOptional("#")
            ? decodeURIComponent(this.remaining)
            : null;
        }
        parseChildren() {
          if ("" === this.remaining) return {};
          this.consumeOptional("/");
          const e = [];
          for (
            this.peekStartsWith("(") || e.push(this.parseSegment());
            this.peekStartsWith("/") &&
            !this.peekStartsWith("//") &&
            !this.peekStartsWith("/(");

          )
            this.capture("/"), e.push(this.parseSegment());
          let t = {};
          this.peekStartsWith("/(") &&
            (this.capture("/"), (t = this.parseParens(!0)));
          let i = {};
          return (
            this.peekStartsWith("(") && (i = this.parseParens(!1)),
            (e.length > 0 || Object.keys(t).length > 0) &&
              (i[ct] = new Mt(e, t)),
            i
          );
        }
        parseSegment() {
          const e = Gp(this.remaining);
          if ("" === e && this.peekStartsWith(";")) throw new J(4009, Bp);
          return this.capture(e), new Ad(Hp(e), this.parseMatrixParams());
        }
        parseMatrixParams() {
          const e = {};
          for (; this.consumeOptional(";"); ) this.parseParam(e);
          return e;
        }
        parseParam(e) {
          const t = Gp(this.remaining);
          if (!t) return;
          this.capture(t);
          let i = "";
          if (this.consumeOptional("=")) {
            const r = Gp(this.remaining);
            r && ((i = r), this.capture(i));
          }
          e[Hp(t)] = Hp(i);
        }
        parseQueryParam(e) {
          const t = (function cj(n) {
            const e = n.match(lj);
            return e ? e[0] : "";
          })(this.remaining);
          if (!t) return;
          this.capture(t);
          let i = "";
          if (this.consumeOptional("=")) {
            const o = (function dj(n) {
              const e = n.match(uj);
              return e ? e[0] : "";
            })(this.remaining);
            o && ((i = o), this.capture(i));
          }
          const r = oI(t),
            s = oI(i);
          if (e.hasOwnProperty(r)) {
            let o = e[r];
            Array.isArray(o) || ((o = [o]), (e[r] = o)), o.push(s);
          } else e[r] = s;
        }
        parseParens(e) {
          const t = {};
          for (
            this.capture("(");
            !this.consumeOptional(")") && this.remaining.length > 0;

          ) {
            const i = Gp(this.remaining),
              r = this.remaining[i.length];
            if ("/" !== r && ")" !== r && ";" !== r) throw new J(4010, Bp);
            let s;
            i.indexOf(":") > -1
              ? ((s = i.slice(0, i.indexOf(":"))),
                this.capture(s),
                this.capture(":"))
              : e && (s = ct);
            const o = this.parseChildren();
            (t[s] = 1 === Object.keys(o).length ? o[ct] : new Mt([], o)),
              this.consumeOptional("//");
          }
          return t;
        }
        peekStartsWith(e) {
          return this.remaining.startsWith(e);
        }
        consumeOptional(e) {
          return (
            !!this.peekStartsWith(e) &&
            ((this.remaining = this.remaining.substring(e.length)), !0)
          );
        }
        capture(e) {
          if (!this.consumeOptional(e)) throw new J(4011, Bp);
        }
      }
      function O0(n) {
        return n.segments.length > 0 ? new Mt([], { [ct]: n }) : n;
      }
      function Wp(n) {
        const e = {};
        for (const i of Object.keys(n.children)) {
          const s = Wp(n.children[i]);
          (s.segments.length > 0 || s.hasChildren()) && (e[i] = s);
        }
        return (function fj(n) {
          if (1 === n.numberOfChildren && n.children[ct]) {
            const e = n.children[ct];
            return new Mt(n.segments.concat(e.segments), e.children);
          }
          return n;
        })(new Mt(n.segments, e));
      }
      function Ma(n) {
        return n instanceof Ro;
      }
      const L0 = !1;
      function pj(n, e, t, i, r) {
        if (0 === t.length) return ic(e.root, e.root, e.root, i, r);
        const s = (function hI(n) {
          if ("string" == typeof n[0] && 1 === n.length && "/" === n[0])
            return new dI(!0, 0, n);
          let e = 0,
            t = !1;
          const i = n.reduce((r, s, o) => {
            if ("object" == typeof s && null != s) {
              if (s.outlets) {
                const a = {};
                return (
                  oi(s.outlets, (l, c) => {
                    a[c] = "string" == typeof l ? l.split("/") : l;
                  }),
                  [...r, { outlets: a }]
                );
              }
              if (s.segmentPath) return [...r, s.segmentPath];
            }
            return "string" != typeof s
              ? [...r, s]
              : 0 === o
              ? (s.split("/").forEach((a, l) => {
                  (0 == l && "." === a) ||
                    (0 == l && "" === a
                      ? (t = !0)
                      : ".." === a
                      ? e++
                      : "" != a && r.push(a));
                }),
                r)
              : [...r, s];
          }, []);
          return new dI(t, e, i);
        })(t);
        return s.toRoot()
          ? ic(e.root, e.root, new Mt([], {}), i, r)
          : (function o(l) {
              const c = (function gj(n, e, t, i) {
                  if (n.isAbsolute) return new rc(e.root, !0, 0);
                  if (-1 === i) return new rc(t, t === e.root, 0);
                  return (function fI(n, e, t) {
                    let i = n,
                      r = e,
                      s = t;
                    for (; s > r; ) {
                      if (((s -= r), (i = i.parent), !i))
                        throw new J(4005, L0 && "Invalid number of '../'");
                      r = i.segments.length;
                    }
                    return new rc(i, !1, r - s);
                  })(t, i + (Rd(n.commands[0]) ? 0 : 1), n.numberOfDoubleDots);
                })(s, e, n.snapshot?._urlSegment, l),
                u = c.processChildren
                  ? sc(c.segmentGroup, c.index, s.commands)
                  : F0(c.segmentGroup, c.index, s.commands);
              return ic(e.root, c.segmentGroup, u, i, r);
            })(n.snapshot?._lastPathIndex);
      }
      function Rd(n) {
        return (
          "object" == typeof n && null != n && !n.outlets && !n.segmentPath
        );
      }
      function Pd(n) {
        return "object" == typeof n && null != n && n.outlets;
      }
      function ic(n, e, t, i, r) {
        let o,
          s = {};
        i &&
          oi(i, (l, c) => {
            s[c] = Array.isArray(l) ? l.map((u) => `${u}`) : `${l}`;
          }),
          (o = n === e ? t : uI(n, e, t));
        const a = O0(Wp(o));
        return new Ro(a, s, r);
      }
      function uI(n, e, t) {
        const i = {};
        return (
          oi(n.children, (r, s) => {
            i[s] = r === e ? t : uI(r, e, t);
          }),
          new Mt(n.segments, i)
        );
      }
      class dI {
        constructor(e, t, i) {
          if (
            ((this.isAbsolute = e),
            (this.numberOfDoubleDots = t),
            (this.commands = i),
            e && i.length > 0 && Rd(i[0]))
          )
            throw new J(
              4003,
              L0 && "Root segment cannot have matrix parameters"
            );
          const r = i.find(Pd);
          if (r && r !== J1(i))
            throw new J(4004, L0 && "{outlets:{}} has to be the last command");
        }
        toRoot() {
          return (
            this.isAbsolute &&
            1 === this.commands.length &&
            "/" == this.commands[0]
          );
        }
      }
      class rc {
        constructor(e, t, i) {
          (this.segmentGroup = e), (this.processChildren = t), (this.index = i);
        }
      }
      function F0(n, e, t) {
        if (
          (n || (n = new Mt([], {})),
          0 === n.segments.length && n.hasChildren())
        )
          return sc(n, e, t);
        const i = (function vj(n, e, t) {
            let i = 0,
              r = e;
            const s = { match: !1, pathIndex: 0, commandIndex: 0 };
            for (; r < n.segments.length; ) {
              if (i >= t.length) return s;
              const o = n.segments[r],
                a = t[i];
              if (Pd(a)) break;
              const l = `${a}`,
                c = i < t.length - 1 ? t[i + 1] : null;
              if (r > 0 && void 0 === l) break;
              if (l && c && "object" == typeof c && void 0 === c.outlets) {
                if (!mI(l, c, o)) return s;
                i += 2;
              } else {
                if (!mI(l, {}, o)) return s;
                i++;
              }
              r++;
            }
            return { match: !0, pathIndex: r, commandIndex: i };
          })(n, e, t),
          r = t.slice(i.commandIndex);
        if (i.match && i.pathIndex < n.segments.length) {
          const s = new Mt(n.segments.slice(0, i.pathIndex), {});
          return (
            (s.children[ct] = new Mt(
              n.segments.slice(i.pathIndex),
              n.children
            )),
            sc(s, 0, r)
          );
        }
        return i.match && 0 === r.length
          ? new Mt(n.segments, {})
          : i.match && !n.hasChildren()
          ? N0(n, e, t)
          : i.match
          ? sc(n, 0, r)
          : N0(n, e, t);
      }
      function sc(n, e, t) {
        if (0 === t.length) return new Mt(n.segments, {});
        {
          const i = (function _j(n) {
              return Pd(n[0]) ? n[0].outlets : { [ct]: n };
            })(t),
            r = {};
          if (
            !i[ct] &&
            n.children[ct] &&
            1 === n.numberOfChildren &&
            0 === n.children[ct].segments.length
          ) {
            const s = sc(n.children[ct], e, t);
            return new Mt(n.segments, s.children);
          }
          return (
            oi(i, (s, o) => {
              "string" == typeof s && (s = [s]),
                null !== s && (r[o] = F0(n.children[o], e, s));
            }),
            oi(n.children, (s, o) => {
              void 0 === i[o] && (r[o] = s);
            }),
            new Mt(n.segments, r)
          );
        }
      }
      function N0(n, e, t) {
        const i = n.segments.slice(0, e);
        let r = 0;
        for (; r < t.length; ) {
          const s = t[r];
          if (Pd(s)) {
            const l = yj(s.outlets);
            return new Mt(i, l);
          }
          if (0 === r && Rd(t[0])) {
            i.push(new Ad(n.segments[e].path, pI(t[0]))), r++;
            continue;
          }
          const o = Pd(s) ? s.outlets[ct] : `${s}`,
            a = r < t.length - 1 ? t[r + 1] : null;
          o && a && Rd(a)
            ? (i.push(new Ad(o, pI(a))), (r += 2))
            : (i.push(new Ad(o, {})), r++);
        }
        return new Mt(i, {});
      }
      function yj(n) {
        const e = {};
        return (
          oi(n, (t, i) => {
            "string" == typeof t && (t = [t]),
              null !== t && (e[i] = N0(new Mt([], {}), 0, t));
          }),
          e
        );
      }
      function pI(n) {
        const e = {};
        return oi(n, (t, i) => (e[i] = `${t}`)), e;
      }
      function mI(n, e, t) {
        return n == t.path && xs(e, t.parameters);
      }
      const Od = "imperative";
      class ws {
        constructor(e, t) {
          (this.id = e), (this.url = t);
        }
      }
      class k0 extends ws {
        constructor(e, t, i = "imperative", r = null) {
          super(e, t),
            (this.type = 0),
            (this.navigationTrigger = i),
            (this.restoredState = r);
        }
        toString() {
          return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
        }
      }
      class Sa extends ws {
        constructor(e, t, i) {
          super(e, t), (this.urlAfterRedirects = i), (this.type = 1);
        }
        toString() {
          return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
        }
      }
      class jp extends ws {
        constructor(e, t, i, r) {
          super(e, t), (this.reason = i), (this.code = r), (this.type = 2);
        }
        toString() {
          return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
        }
      }
      class Xp extends ws {
        constructor(e, t, i, r) {
          super(e, t), (this.reason = i), (this.code = r), (this.type = 16);
        }
      }
      class B0 extends ws {
        constructor(e, t, i, r) {
          super(e, t), (this.error = i), (this.target = r), (this.type = 3);
        }
        toString() {
          return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
        }
      }
      class bj extends ws {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 4);
        }
        toString() {
          return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class xj extends ws {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 7);
        }
        toString() {
          return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class wj extends ws {
        constructor(e, t, i, r, s) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.shouldActivate = s),
            (this.type = 8);
        }
        toString() {
          return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
        }
      }
      class Mj extends ws {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 5);
        }
        toString() {
          return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class Sj extends ws {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 6);
        }
        toString() {
          return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class Ej {
        constructor(e) {
          (this.route = e), (this.type = 9);
        }
        toString() {
          return `RouteConfigLoadStart(path: ${this.route.path})`;
        }
      }
      class Cj {
        constructor(e) {
          (this.route = e), (this.type = 10);
        }
        toString() {
          return `RouteConfigLoadEnd(path: ${this.route.path})`;
        }
      }
      class Tj {
        constructor(e) {
          (this.snapshot = e), (this.type = 11);
        }
        toString() {
          return `ChildActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class Aj {
        constructor(e) {
          (this.snapshot = e), (this.type = 12);
        }
        toString() {
          return `ChildActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class Dj {
        constructor(e) {
          (this.snapshot = e), (this.type = 13);
        }
        toString() {
          return `ActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class Ij {
        constructor(e) {
          (this.snapshot = e), (this.type = 14);
        }
        toString() {
          return `ActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class gI {
        constructor(e, t, i) {
          (this.routerEvent = e),
            (this.position = t),
            (this.anchor = i),
            (this.type = 15);
        }
        toString() {
          return `Scroll(anchor: '${this.anchor}', position: '${
            this.position ? `${this.position[0]}, ${this.position[1]}` : null
          }')`;
        }
      }
      let Oj = (() => {
          class n {
            createUrlTree(t, i, r, s, o, a) {
              return pj(t || i.root, r, s, o, a);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Fj = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({
              token: n,
              factory: function (e) {
                return Oj.ɵfac(e);
              },
              providedIn: "root",
            })),
            n
          );
        })();
      class _I {
        constructor(e) {
          this._root = e;
        }
        get root() {
          return this._root.value;
        }
        parent(e) {
          const t = this.pathFromRoot(e);
          return t.length > 1 ? t[t.length - 2] : null;
        }
        children(e) {
          const t = U0(e, this._root);
          return t ? t.children.map((i) => i.value) : [];
        }
        firstChild(e) {
          const t = U0(e, this._root);
          return t && t.children.length > 0 ? t.children[0].value : null;
        }
        siblings(e) {
          const t = V0(e, this._root);
          return t.length < 2
            ? []
            : t[t.length - 2].children
                .map((r) => r.value)
                .filter((r) => r !== e);
        }
        pathFromRoot(e) {
          return V0(e, this._root).map((t) => t.value);
        }
      }
      function U0(n, e) {
        if (n === e.value) return e;
        for (const t of e.children) {
          const i = U0(n, t);
          if (i) return i;
        }
        return null;
      }
      function V0(n, e) {
        if (n === e.value) return [e];
        for (const t of e.children) {
          const i = V0(n, t);
          if (i.length) return i.unshift(e), i;
        }
        return [];
      }
      class Zs {
        constructor(e, t) {
          (this.value = e), (this.children = t);
        }
        toString() {
          return `TreeNode(${this.value})`;
        }
      }
      function oc(n) {
        const e = {};
        return n && n.children.forEach((t) => (e[t.value.outlet] = t)), e;
      }
      class vI extends _I {
        constructor(e, t) {
          super(e), (this.snapshot = t), z0(this, e);
        }
        toString() {
          return this.snapshot.toString();
        }
      }
      function yI(n, e) {
        const t = (function Nj(n, e) {
            const o = new qp([], {}, {}, "", {}, ct, e, null, n.root, -1, {});
            return new xI("", new Zs(o, []));
          })(n, e),
          i = new Mr([new Ad("", {})]),
          r = new Mr({}),
          s = new Mr({}),
          o = new Mr({}),
          a = new Mr(""),
          l = new ac(i, r, o, a, s, ct, e, t.root);
        return (l.snapshot = t.root), new vI(new Zs(l, []), t);
      }
      class ac {
        constructor(e, t, i, r, s, o, a, l) {
          (this.url = e),
            (this.params = t),
            (this.queryParams = i),
            (this.fragment = r),
            (this.data = s),
            (this.outlet = o),
            (this.component = a),
            (this.title = this.data?.pipe(xt((c) => c[Td])) ?? Ge(void 0)),
            (this._futureSnapshot = l);
        }
        get routeConfig() {
          return this._futureSnapshot.routeConfig;
        }
        get root() {
          return this._routerState.root;
        }
        get parent() {
          return this._routerState.parent(this);
        }
        get firstChild() {
          return this._routerState.firstChild(this);
        }
        get children() {
          return this._routerState.children(this);
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this);
        }
        get paramMap() {
          return (
            this._paramMap ||
              (this._paramMap = this.params.pipe(xt((e) => nc(e)))),
            this._paramMap
          );
        }
        get queryParamMap() {
          return (
            this._queryParamMap ||
              (this._queryParamMap = this.queryParams.pipe(xt((e) => nc(e)))),
            this._queryParamMap
          );
        }
        toString() {
          return this.snapshot
            ? this.snapshot.toString()
            : `Future(${this._futureSnapshot})`;
        }
      }
      function bI(n, e = "emptyOnly") {
        const t = n.pathFromRoot;
        let i = 0;
        if ("always" !== e)
          for (i = t.length - 1; i >= 1; ) {
            const r = t[i],
              s = t[i - 1];
            if (r.routeConfig && "" === r.routeConfig.path) i--;
            else {
              if (s.component) break;
              i--;
            }
          }
        return (function kj(n) {
          return n.reduce(
            (e, t) => ({
              params: { ...e.params, ...t.params },
              data: { ...e.data, ...t.data },
              resolve: {
                ...t.data,
                ...e.resolve,
                ...t.routeConfig?.data,
                ...t._resolvedData,
              },
            }),
            { params: {}, data: {}, resolve: {} }
          );
        })(t.slice(i));
      }
      class qp {
        get title() {
          return this.data?.[Td];
        }
        constructor(e, t, i, r, s, o, a, l, c, u, d) {
          (this.url = e),
            (this.params = t),
            (this.queryParams = i),
            (this.fragment = r),
            (this.data = s),
            (this.outlet = o),
            (this.component = a),
            (this.routeConfig = l),
            (this._urlSegment = c),
            (this._lastPathIndex = u),
            (this._resolve = d);
        }
        get root() {
          return this._routerState.root;
        }
        get parent() {
          return this._routerState.parent(this);
        }
        get firstChild() {
          return this._routerState.firstChild(this);
        }
        get children() {
          return this._routerState.children(this);
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this);
        }
        get paramMap() {
          return (
            this._paramMap || (this._paramMap = nc(this.params)), this._paramMap
          );
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = nc(this.queryParams)),
            this._queryParamMap
          );
        }
        toString() {
          return `Route(url:'${this.url
            .map((i) => i.toString())
            .join("/")}', path:'${
            this.routeConfig ? this.routeConfig.path : ""
          }')`;
        }
      }
      class xI extends _I {
        constructor(e, t) {
          super(t), (this.url = e), z0(this, t);
        }
        toString() {
          return wI(this._root);
        }
      }
      function z0(n, e) {
        (e.value._routerState = n), e.children.forEach((t) => z0(n, t));
      }
      function wI(n) {
        const e =
          n.children.length > 0 ? ` { ${n.children.map(wI).join(", ")} } ` : "";
        return `${n.value}${e}`;
      }
      function H0(n) {
        if (n.snapshot) {
          const e = n.snapshot,
            t = n._futureSnapshot;
          (n.snapshot = t),
            xs(e.queryParams, t.queryParams) ||
              n.queryParams.next(t.queryParams),
            e.fragment !== t.fragment && n.fragment.next(t.fragment),
            xs(e.params, t.params) || n.params.next(t.params),
            (function $W(n, e) {
              if (n.length !== e.length) return !1;
              for (let t = 0; t < n.length; ++t) if (!xs(n[t], e[t])) return !1;
              return !0;
            })(e.url, t.url) || n.url.next(t.url),
            xs(e.data, t.data) || n.data.next(t.data);
        } else
          (n.snapshot = n._futureSnapshot), n.data.next(n._futureSnapshot.data);
      }
      function G0(n, e) {
        const t =
          xs(n.params, e.params) &&
          (function tj(n, e) {
            return (
              wa(n, e) && n.every((t, i) => xs(t.parameters, e[i].parameters))
            );
          })(n.url, e.url);
        return (
          t &&
          !(!n.parent != !e.parent) &&
          (!n.parent || G0(n.parent, e.parent))
        );
      }
      function Ld(n, e, t) {
        if (t && n.shouldReuseRoute(e.value, t.value.snapshot)) {
          const i = t.value;
          i._futureSnapshot = e.value;
          const r = (function Uj(n, e, t) {
            return e.children.map((i) => {
              for (const r of t.children)
                if (n.shouldReuseRoute(i.value, r.value.snapshot))
                  return Ld(n, i, r);
              return Ld(n, i);
            });
          })(n, e, t);
          return new Zs(i, r);
        }
        {
          if (n.shouldAttach(e.value)) {
            const s = n.retrieve(e.value);
            if (null !== s) {
              const o = s.route;
              return (
                (o.value._futureSnapshot = e.value),
                (o.children = e.children.map((a) => Ld(n, a))),
                o
              );
            }
          }
          const i = (function Vj(n) {
              return new ac(
                new Mr(n.url),
                new Mr(n.params),
                new Mr(n.queryParams),
                new Mr(n.fragment),
                new Mr(n.data),
                n.outlet,
                n.component,
                n
              );
            })(e.value),
            r = e.children.map((s) => Ld(n, s));
          return new Zs(i, r);
        }
      }
      const W0 = "ngNavigationCancelingError";
      function MI(n, e) {
        const { redirectTo: t, navigationBehaviorOptions: i } = Ma(e)
            ? { redirectTo: e, navigationBehaviorOptions: void 0 }
            : e,
          r = SI(!1, 0, e);
        return (r.url = t), (r.navigationBehaviorOptions = i), r;
      }
      function SI(n, e, t) {
        const i = new Error("NavigationCancelingError: " + (n || ""));
        return (i[W0] = !0), (i.cancellationCode = e), t && (i.url = t), i;
      }
      function EI(n) {
        return CI(n) && Ma(n.url);
      }
      function CI(n) {
        return n && n[W0];
      }
      class zj {
        constructor() {
          (this.outlet = null),
            (this.route = null),
            (this.resolver = null),
            (this.injector = null),
            (this.children = new Fd()),
            (this.attachRef = null);
        }
      }
      let Fd = (() => {
        class n {
          constructor() {
            this.contexts = new Map();
          }
          onChildOutletCreated(t, i) {
            const r = this.getOrCreateContext(t);
            (r.outlet = i), this.contexts.set(t, r);
          }
          onChildOutletDestroyed(t) {
            const i = this.getContext(t);
            i && ((i.outlet = null), (i.attachRef = null));
          }
          onOutletDeactivated() {
            const t = this.contexts;
            return (this.contexts = new Map()), t;
          }
          onOutletReAttached(t) {
            this.contexts = t;
          }
          getOrCreateContext(t) {
            let i = this.getContext(t);
            return i || ((i = new zj()), this.contexts.set(t, i)), i;
          }
          getContext(t) {
            return this.contexts.get(t) || null;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const Yp = !1;
      let j0 = (() => {
        class n {
          constructor() {
            (this.activated = null),
              (this._activatedRoute = null),
              (this.name = ct),
              (this.activateEvents = new Ut()),
              (this.deactivateEvents = new Ut()),
              (this.attachEvents = new Ut()),
              (this.detachEvents = new Ut()),
              (this.parentContexts = ft(Fd)),
              (this.location = ft(br)),
              (this.changeDetector = ft(Ui)),
              (this.environmentInjector = ft(zs));
          }
          ngOnChanges(t) {
            if (t.name) {
              const { firstChange: i, previousValue: r } = t.name;
              if (i) return;
              this.isTrackedInParentContexts(r) &&
                (this.deactivate(),
                this.parentContexts.onChildOutletDestroyed(r)),
                this.initializeOutletWithName();
            }
          }
          ngOnDestroy() {
            this.isTrackedInParentContexts(this.name) &&
              this.parentContexts.onChildOutletDestroyed(this.name);
          }
          isTrackedInParentContexts(t) {
            return this.parentContexts.getContext(t)?.outlet === this;
          }
          ngOnInit() {
            this.initializeOutletWithName();
          }
          initializeOutletWithName() {
            if (
              (this.parentContexts.onChildOutletCreated(this.name, this),
              this.activated)
            )
              return;
            const t = this.parentContexts.getContext(this.name);
            t?.route &&
              (t.attachRef
                ? this.attach(t.attachRef, t.route)
                : this.activateWith(t.route, t.injector));
          }
          get isActivated() {
            return !!this.activated;
          }
          get component() {
            if (!this.activated) throw new J(4012, Yp);
            return this.activated.instance;
          }
          get activatedRoute() {
            if (!this.activated) throw new J(4012, Yp);
            return this._activatedRoute;
          }
          get activatedRouteData() {
            return this._activatedRoute
              ? this._activatedRoute.snapshot.data
              : {};
          }
          detach() {
            if (!this.activated) throw new J(4012, Yp);
            this.location.detach();
            const t = this.activated;
            return (
              (this.activated = null),
              (this._activatedRoute = null),
              this.detachEvents.emit(t.instance),
              t
            );
          }
          attach(t, i) {
            (this.activated = t),
              (this._activatedRoute = i),
              this.location.insert(t.hostView),
              this.attachEvents.emit(t.instance);
          }
          deactivate() {
            if (this.activated) {
              const t = this.component;
              this.activated.destroy(),
                (this.activated = null),
                (this._activatedRoute = null),
                this.deactivateEvents.emit(t);
            }
          }
          activateWith(t, i) {
            if (this.isActivated) throw new J(4013, Yp);
            this._activatedRoute = t;
            const r = this.location,
              o = t.snapshot.component,
              a = this.parentContexts.getOrCreateContext(this.name).children,
              l = new Hj(t, a, r.injector);
            if (
              i &&
              (function Gj(n) {
                return !!n.resolveComponentFactory;
              })(i)
            ) {
              const c = i.resolveComponentFactory(o);
              this.activated = r.createComponent(c, r.length, l);
            } else
              this.activated = r.createComponent(o, {
                index: r.length,
                injector: l,
                environmentInjector: i ?? this.environmentInjector,
              });
            this.changeDetector.markForCheck(),
              this.activateEvents.emit(this.activated.instance);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵdir = He({
            type: n,
            selectors: [["router-outlet"]],
            inputs: { name: "name" },
            outputs: {
              activateEvents: "activate",
              deactivateEvents: "deactivate",
              attachEvents: "attach",
              detachEvents: "detach",
            },
            exportAs: ["outlet"],
            standalone: !0,
            features: [mr],
          })),
          n
        );
      })();
      class Hj {
        constructor(e, t, i) {
          (this.route = e), (this.childContexts = t), (this.parent = i);
        }
        get(e, t) {
          return e === ac
            ? this.route
            : e === Fd
            ? this.childContexts
            : this.parent.get(e, t);
        }
      }
      let X0 = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = Xi({
            type: n,
            selectors: [["ng-component"]],
            standalone: !0,
            features: [Sy],
            decls: 1,
            vars: 0,
            template: function (t, i) {
              1 & t && Gt(0, "router-outlet");
            },
            dependencies: [j0],
            encapsulation: 2,
          })),
          n
        );
      })();
      function TI(n, e) {
        return (
          n.providers &&
            !n._injector &&
            (n._injector = lp(n.providers, e, `Route: ${n.path}`)),
          n._injector ?? e
        );
      }
      function Y0(n) {
        const e = n.children && n.children.map(Y0),
          t = e ? { ...n, children: e } : { ...n };
        return (
          !t.component &&
            !t.loadComponent &&
            (e || t.loadChildren) &&
            t.outlet &&
            t.outlet !== ct &&
            (t.component = X0),
          t
        );
      }
      function Er(n) {
        return n.outlet || ct;
      }
      function AI(n, e) {
        const t = n.filter((i) => Er(i) === e);
        return t.push(...n.filter((i) => Er(i) !== e)), t;
      }
      function Nd(n) {
        if (!n) return null;
        if (n.routeConfig?._injector) return n.routeConfig._injector;
        for (let e = n.parent; e; e = e.parent) {
          const t = e.routeConfig;
          if (t?._loadedInjector) return t._loadedInjector;
          if (t?._injector) return t._injector;
        }
        return null;
      }
      class Yj {
        constructor(e, t, i, r) {
          (this.routeReuseStrategy = e),
            (this.futureState = t),
            (this.currState = i),
            (this.forwardEvent = r);
        }
        activate(e) {
          const t = this.futureState._root,
            i = this.currState ? this.currState._root : null;
          this.deactivateChildRoutes(t, i, e),
            H0(this.futureState.root),
            this.activateChildRoutes(t, i, e);
        }
        deactivateChildRoutes(e, t, i) {
          const r = oc(t);
          e.children.forEach((s) => {
            const o = s.value.outlet;
            this.deactivateRoutes(s, r[o], i), delete r[o];
          }),
            oi(r, (s, o) => {
              this.deactivateRouteAndItsChildren(s, i);
            });
        }
        deactivateRoutes(e, t, i) {
          const r = e.value,
            s = t ? t.value : null;
          if (r === s)
            if (r.component) {
              const o = i.getContext(r.outlet);
              o && this.deactivateChildRoutes(e, t, o.children);
            } else this.deactivateChildRoutes(e, t, i);
          else s && this.deactivateRouteAndItsChildren(t, i);
        }
        deactivateRouteAndItsChildren(e, t) {
          e.value.component &&
          this.routeReuseStrategy.shouldDetach(e.value.snapshot)
            ? this.detachAndStoreRouteSubtree(e, t)
            : this.deactivateRouteAndOutlet(e, t);
        }
        detachAndStoreRouteSubtree(e, t) {
          const i = t.getContext(e.value.outlet),
            r = i && e.value.component ? i.children : t,
            s = oc(e);
          for (const o of Object.keys(s))
            this.deactivateRouteAndItsChildren(s[o], r);
          if (i && i.outlet) {
            const o = i.outlet.detach(),
              a = i.children.onOutletDeactivated();
            this.routeReuseStrategy.store(e.value.snapshot, {
              componentRef: o,
              route: e,
              contexts: a,
            });
          }
        }
        deactivateRouteAndOutlet(e, t) {
          const i = t.getContext(e.value.outlet),
            r = i && e.value.component ? i.children : t,
            s = oc(e);
          for (const o of Object.keys(s))
            this.deactivateRouteAndItsChildren(s[o], r);
          i &&
            (i.outlet &&
              (i.outlet.deactivate(), i.children.onOutletDeactivated()),
            (i.attachRef = null),
            (i.resolver = null),
            (i.route = null));
        }
        activateChildRoutes(e, t, i) {
          const r = oc(t);
          e.children.forEach((s) => {
            this.activateRoutes(s, r[s.value.outlet], i),
              this.forwardEvent(new Ij(s.value.snapshot));
          }),
            e.children.length && this.forwardEvent(new Aj(e.value.snapshot));
        }
        activateRoutes(e, t, i) {
          const r = e.value,
            s = t ? t.value : null;
          if ((H0(r), r === s))
            if (r.component) {
              const o = i.getOrCreateContext(r.outlet);
              this.activateChildRoutes(e, t, o.children);
            } else this.activateChildRoutes(e, t, i);
          else if (r.component) {
            const o = i.getOrCreateContext(r.outlet);
            if (this.routeReuseStrategy.shouldAttach(r.snapshot)) {
              const a = this.routeReuseStrategy.retrieve(r.snapshot);
              this.routeReuseStrategy.store(r.snapshot, null),
                o.children.onOutletReAttached(a.contexts),
                (o.attachRef = a.componentRef),
                (o.route = a.route.value),
                o.outlet && o.outlet.attach(a.componentRef, a.route.value),
                H0(a.route.value),
                this.activateChildRoutes(e, null, o.children);
            } else {
              const a = Nd(r.snapshot),
                l = a?.get(Al) ?? null;
              (o.attachRef = null),
                (o.route = r),
                (o.resolver = l),
                (o.injector = a),
                o.outlet && o.outlet.activateWith(r, o.injector),
                this.activateChildRoutes(e, null, o.children);
            }
          } else this.activateChildRoutes(e, null, i);
        }
      }
      class DI {
        constructor(e) {
          (this.path = e), (this.route = this.path[this.path.length - 1]);
        }
      }
      class Zp {
        constructor(e, t) {
          (this.component = e), (this.route = t);
        }
      }
      function Zj(n, e, t) {
        const i = n._root;
        return kd(i, e ? e._root : null, t, [i.value]);
      }
      function lc(n, e) {
        const t = Symbol(),
          i = e.get(n, t);
        return i === t
          ? "function" != typeof n ||
            (function tB(n) {
              return null !== lf(n);
            })(n)
            ? e.get(n)
            : n
          : i;
      }
      function kd(
        n,
        e,
        t,
        i,
        r = { canDeactivateChecks: [], canActivateChecks: [] }
      ) {
        const s = oc(e);
        return (
          n.children.forEach((o) => {
            (function $j(
              n,
              e,
              t,
              i,
              r = { canDeactivateChecks: [], canActivateChecks: [] }
            ) {
              const s = n.value,
                o = e ? e.value : null,
                a = t ? t.getContext(n.value.outlet) : null;
              if (o && s.routeConfig === o.routeConfig) {
                const l = (function Qj(n, e, t) {
                  if ("function" == typeof t) return t(n, e);
                  switch (t) {
                    case "pathParamsChange":
                      return !wa(n.url, e.url);
                    case "pathParamsOrQueryParamsChange":
                      return (
                        !wa(n.url, e.url) || !xs(n.queryParams, e.queryParams)
                      );
                    case "always":
                      return !0;
                    case "paramsOrQueryParamsChange":
                      return !G0(n, e) || !xs(n.queryParams, e.queryParams);
                    default:
                      return !G0(n, e);
                  }
                })(o, s, s.routeConfig.runGuardsAndResolvers);
                l
                  ? r.canActivateChecks.push(new DI(i))
                  : ((s.data = o.data), (s._resolvedData = o._resolvedData)),
                  kd(n, e, s.component ? (a ? a.children : null) : t, i, r),
                  l &&
                    a &&
                    a.outlet &&
                    a.outlet.isActivated &&
                    r.canDeactivateChecks.push(new Zp(a.outlet.component, o));
              } else
                o && Bd(e, a, r),
                  r.canActivateChecks.push(new DI(i)),
                  kd(n, null, s.component ? (a ? a.children : null) : t, i, r);
            })(o, s[o.value.outlet], t, i.concat([o.value]), r),
              delete s[o.value.outlet];
          }),
          oi(s, (o, a) => Bd(o, t.getContext(a), r)),
          r
        );
      }
      function Bd(n, e, t) {
        const i = oc(n),
          r = n.value;
        oi(i, (s, o) => {
          Bd(s, r.component ? (e ? e.children.getContext(o) : null) : e, t);
        }),
          t.canDeactivateChecks.push(
            new Zp(
              r.component && e && e.outlet && e.outlet.isActivated
                ? e.outlet.component
                : null,
              r
            )
          );
      }
      function Ud(n) {
        return "function" == typeof n;
      }
      function Z0(n) {
        return n instanceof Np || "EmptyError" === n?.name;
      }
      const Kp = Symbol("INITIAL_VALUE");
      function cc() {
        return Sr((n) =>
          T0(n.map((e) => e.pipe(er(1), tc(Kp)))).pipe(
            xt((e) => {
              for (const t of e)
                if (!0 !== t) {
                  if (t === Kp) return Kp;
                  if (!1 === t || t instanceof Ro) return t;
                }
              return !0;
            }),
            _i((e) => e !== Kp),
            er(1)
          )
        );
      }
      function II(n) {
        return (function ck(...n) {
          return jM(n);
        })(
          si((e) => {
            if (Ma(e)) throw MI(0, e);
          }),
          xt((e) => !0 === e)
        );
      }
      const K0 = {
        matched: !1,
        consumedSegments: [],
        remainingSegments: [],
        parameters: {},
        positionalParamSegments: {},
      };
      function RI(n, e, t, i, r) {
        const s = $0(n, e, t);
        return s.matched
          ? (function m6(n, e, t, i) {
              const r = e.canMatch;
              return r && 0 !== r.length
                ? Ge(
                    r.map((o) => {
                      const a = lc(o, n);
                      return Io(
                        (function r6(n) {
                          return n && Ud(n.canMatch);
                        })(a)
                          ? a.canMatch(e, t)
                          : n.runInContext(() => a(e, t))
                      );
                    })
                  ).pipe(cc(), II())
                : Ge(!0);
            })((i = TI(e, i)), e, t).pipe(xt((o) => (!0 === o ? s : { ...K0 })))
          : Ge(s);
      }
      function $0(n, e, t) {
        if ("" === e.path)
          return "full" === e.pathMatch && (n.hasChildren() || t.length > 0)
            ? { ...K0 }
            : {
                matched: !0,
                consumedSegments: [],
                remainingSegments: t,
                parameters: {},
                positionalParamSegments: {},
              };
        const r = (e.matcher || KW)(t, n, e);
        if (!r) return { ...K0 };
        const s = {};
        oi(r.posParams, (a, l) => {
          s[l] = a.path;
        });
        const o =
          r.consumed.length > 0
            ? { ...s, ...r.consumed[r.consumed.length - 1].parameters }
            : s;
        return {
          matched: !0,
          consumedSegments: r.consumed,
          remainingSegments: t.slice(r.consumed.length),
          parameters: o,
          positionalParamSegments: r.posParams ?? {},
        };
      }
      function $p(n, e, t, i) {
        if (
          t.length > 0 &&
          (function v6(n, e, t) {
            return t.some((i) => Qp(n, e, i) && Er(i) !== ct);
          })(n, t, i)
        ) {
          const s = new Mt(
            e,
            (function _6(n, e, t, i) {
              const r = {};
              (r[ct] = i),
                (i._sourceSegment = n),
                (i._segmentIndexShift = e.length);
              for (const s of t)
                if ("" === s.path && Er(s) !== ct) {
                  const o = new Mt([], {});
                  (o._sourceSegment = n),
                    (o._segmentIndexShift = e.length),
                    (r[Er(s)] = o);
                }
              return r;
            })(n, e, i, new Mt(t, n.children))
          );
          return (
            (s._sourceSegment = n),
            (s._segmentIndexShift = e.length),
            { segmentGroup: s, slicedSegments: [] }
          );
        }
        if (
          0 === t.length &&
          (function y6(n, e, t) {
            return t.some((i) => Qp(n, e, i));
          })(n, t, i)
        ) {
          const s = new Mt(
            n.segments,
            (function g6(n, e, t, i, r) {
              const s = {};
              for (const o of i)
                if (Qp(n, t, o) && !r[Er(o)]) {
                  const a = new Mt([], {});
                  (a._sourceSegment = n),
                    (a._segmentIndexShift = e.length),
                    (s[Er(o)] = a);
                }
              return { ...r, ...s };
            })(n, e, t, i, n.children)
          );
          return (
            (s._sourceSegment = n),
            (s._segmentIndexShift = e.length),
            { segmentGroup: s, slicedSegments: t }
          );
        }
        const r = new Mt(n.segments, n.children);
        return (
          (r._sourceSegment = n),
          (r._segmentIndexShift = e.length),
          { segmentGroup: r, slicedSegments: t }
        );
      }
      function Qp(n, e, t) {
        return (
          (!(n.hasChildren() || e.length > 0) || "full" !== t.pathMatch) &&
          "" === t.path
        );
      }
      function PI(n, e, t, i) {
        return (
          !!(Er(n) === i || (i !== ct && Qp(e, t, n))) &&
          ("**" === n.path || $0(e, n, t).matched)
        );
      }
      function OI(n, e, t) {
        return 0 === e.length && !n.children[t];
      }
      const Jp = !1;
      class em {
        constructor(e) {
          this.segmentGroup = e || null;
        }
      }
      class LI {
        constructor(e) {
          this.urlTree = e;
        }
      }
      function Vd(n) {
        return Cd(new em(n));
      }
      function FI(n) {
        return Cd(new LI(n));
      }
      class M6 {
        constructor(e, t, i, r, s) {
          (this.injector = e),
            (this.configLoader = t),
            (this.urlSerializer = i),
            (this.urlTree = r),
            (this.config = s),
            (this.allowRedirects = !0);
        }
        apply() {
          const e = $p(this.urlTree.root, [], [], this.config).segmentGroup,
            t = new Mt(e.segments, e.children);
          return this.expandSegmentGroup(this.injector, this.config, t, ct)
            .pipe(
              xt((s) =>
                this.createUrlTree(
                  Wp(s),
                  this.urlTree.queryParams,
                  this.urlTree.fragment
                )
              )
            )
            .pipe(
              Do((s) => {
                if (s instanceof LI)
                  return (this.allowRedirects = !1), this.match(s.urlTree);
                throw s instanceof em ? this.noMatchError(s) : s;
              })
            );
        }
        match(e) {
          return this.expandSegmentGroup(this.injector, this.config, e.root, ct)
            .pipe(
              xt((r) => this.createUrlTree(Wp(r), e.queryParams, e.fragment))
            )
            .pipe(
              Do((r) => {
                throw r instanceof em ? this.noMatchError(r) : r;
              })
            );
        }
        noMatchError(e) {
          return new J(4002, Jp);
        }
        createUrlTree(e, t, i) {
          const r = O0(e);
          return new Ro(r, t, i);
        }
        expandSegmentGroup(e, t, i, r) {
          return 0 === i.segments.length && i.hasChildren()
            ? this.expandChildren(e, t, i).pipe(xt((s) => new Mt([], s)))
            : this.expandSegment(e, i, t, i.segments, r, !0);
        }
        expandChildren(e, t, i) {
          const r = [];
          for (const s of Object.keys(i.children))
            "primary" === s ? r.unshift(s) : r.push(s);
          return On(r).pipe(
            xa((s) => {
              const o = i.children[s],
                a = AI(t, s);
              return this.expandSegmentGroup(e, a, o, s).pipe(
                xt((l) => ({ segment: l, outlet: s }))
              );
            }),
            Y1((s, o) => ((s[o.outlet] = o.segment), s), {}),
            Z1()
          );
        }
        expandSegment(e, t, i, r, s, o) {
          return On(i).pipe(
            xa((a) =>
              this.expandSegmentAgainstRoute(e, t, i, a, r, s, o).pipe(
                Do((c) => {
                  if (c instanceof em) return Ge(null);
                  throw c;
                })
              )
            ),
            Ao((a) => !!a),
            Do((a, l) => {
              if (Z0(a)) return OI(t, r, s) ? Ge(new Mt([], {})) : Vd(t);
              throw a;
            })
          );
        }
        expandSegmentAgainstRoute(e, t, i, r, s, o, a) {
          return PI(r, t, s, o)
            ? void 0 === r.redirectTo
              ? this.matchSegmentAgainstRoute(e, t, r, s, o)
              : a && this.allowRedirects
              ? this.expandSegmentAgainstRouteUsingRedirect(e, t, i, r, s, o)
              : Vd(t)
            : Vd(t);
        }
        expandSegmentAgainstRouteUsingRedirect(e, t, i, r, s, o) {
          return "**" === r.path
            ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(e, i, r, o)
            : this.expandRegularSegmentAgainstRouteUsingRedirect(
                e,
                t,
                i,
                r,
                s,
                o
              );
        }
        expandWildCardWithParamsAgainstRouteUsingRedirect(e, t, i, r) {
          const s = this.applyRedirectCommands([], i.redirectTo, {});
          return i.redirectTo.startsWith("/")
            ? FI(s)
            : this.lineralizeSegments(i, s).pipe(
                Un((o) => {
                  const a = new Mt(o, {});
                  return this.expandSegment(e, a, t, o, r, !1);
                })
              );
        }
        expandRegularSegmentAgainstRouteUsingRedirect(e, t, i, r, s, o) {
          const {
            matched: a,
            consumedSegments: l,
            remainingSegments: c,
            positionalParamSegments: u,
          } = $0(t, r, s);
          if (!a) return Vd(t);
          const d = this.applyRedirectCommands(l, r.redirectTo, u);
          return r.redirectTo.startsWith("/")
            ? FI(d)
            : this.lineralizeSegments(r, d).pipe(
                Un((h) => this.expandSegment(e, t, i, h.concat(c), o, !1))
              );
        }
        matchSegmentAgainstRoute(e, t, i, r, s) {
          return "**" === i.path
            ? ((e = TI(i, e)),
              i.loadChildren
                ? (i._loadedRoutes
                    ? Ge({
                        routes: i._loadedRoutes,
                        injector: i._loadedInjector,
                      })
                    : this.configLoader.loadChildren(e, i)
                  ).pipe(
                    xt(
                      (a) => (
                        (i._loadedRoutes = a.routes),
                        (i._loadedInjector = a.injector),
                        new Mt(r, {})
                      )
                    )
                  )
                : Ge(new Mt(r, {})))
            : RI(t, i, r, e).pipe(
                Sr(
                  ({ matched: o, consumedSegments: a, remainingSegments: l }) =>
                    o
                      ? this.getChildConfig((e = i._injector ?? e), i, r).pipe(
                          Un((u) => {
                            const d = u.injector ?? e,
                              h = u.routes,
                              { segmentGroup: f, slicedSegments: p } = $p(
                                t,
                                a,
                                l,
                                h
                              ),
                              _ = new Mt(f.segments, f.children);
                            if (0 === p.length && _.hasChildren())
                              return this.expandChildren(d, h, _).pipe(
                                xt((v) => new Mt(a, v))
                              );
                            if (0 === h.length && 0 === p.length)
                              return Ge(new Mt(a, {}));
                            const m = Er(i) === s;
                            return this.expandSegment(
                              d,
                              _,
                              h,
                              p,
                              m ? ct : s,
                              !0
                            ).pipe(
                              xt(
                                (y) => new Mt(a.concat(y.segments), y.children)
                              )
                            );
                          })
                        )
                      : Vd(t)
                )
              );
        }
        getChildConfig(e, t, i) {
          return t.children
            ? Ge({ routes: t.children, injector: e })
            : t.loadChildren
            ? void 0 !== t._loadedRoutes
              ? Ge({ routes: t._loadedRoutes, injector: t._loadedInjector })
              : (function p6(n, e, t, i) {
                  const r = e.canLoad;
                  return void 0 === r || 0 === r.length
                    ? Ge(!0)
                    : Ge(
                        r.map((o) => {
                          const a = lc(o, n);
                          return Io(
                            (function e6(n) {
                              return n && Ud(n.canLoad);
                            })(a)
                              ? a.canLoad(e, t)
                              : n.runInContext(() => a(e, t))
                          );
                        })
                      ).pipe(cc(), II());
                })(e, t, i).pipe(
                  Un((r) =>
                    r
                      ? this.configLoader.loadChildren(e, t).pipe(
                          si((s) => {
                            (t._loadedRoutes = s.routes),
                              (t._loadedInjector = s.injector);
                          })
                        )
                      : (function x6(n) {
                          return Cd(SI(Jp, 3));
                        })()
                  )
                )
            : Ge({ routes: [], injector: e });
        }
        lineralizeSegments(e, t) {
          let i = [],
            r = t.root;
          for (;;) {
            if (((i = i.concat(r.segments)), 0 === r.numberOfChildren))
              return Ge(i);
            if (r.numberOfChildren > 1 || !r.children[ct])
              return e.redirectTo, Cd(new J(4e3, Jp));
            r = r.children[ct];
          }
        }
        applyRedirectCommands(e, t, i) {
          return this.applyRedirectCreateUrlTree(
            t,
            this.urlSerializer.parse(t),
            e,
            i
          );
        }
        applyRedirectCreateUrlTree(e, t, i, r) {
          const s = this.createSegmentGroup(e, t.root, i, r);
          return new Ro(
            s,
            this.createQueryParams(t.queryParams, this.urlTree.queryParams),
            t.fragment
          );
        }
        createQueryParams(e, t) {
          const i = {};
          return (
            oi(e, (r, s) => {
              if ("string" == typeof r && r.startsWith(":")) {
                const a = r.substring(1);
                i[s] = t[a];
              } else i[s] = r;
            }),
            i
          );
        }
        createSegmentGroup(e, t, i, r) {
          const s = this.createSegments(e, t.segments, i, r);
          let o = {};
          return (
            oi(t.children, (a, l) => {
              o[l] = this.createSegmentGroup(e, a, i, r);
            }),
            new Mt(s, o)
          );
        }
        createSegments(e, t, i, r) {
          return t.map((s) =>
            s.path.startsWith(":")
              ? this.findPosParam(e, s, r)
              : this.findOrReturn(s, i)
          );
        }
        findPosParam(e, t, i) {
          const r = i[t.path.substring(1)];
          if (!r) throw new J(4001, Jp);
          return r;
        }
        findOrReturn(e, t) {
          let i = 0;
          for (const r of t) {
            if (r.path === e.path) return t.splice(i), r;
            i++;
          }
          return e;
        }
      }
      class E6 {}
      class A6 {
        constructor(e, t, i, r, s, o, a) {
          (this.injector = e),
            (this.rootComponentType = t),
            (this.config = i),
            (this.urlTree = r),
            (this.url = s),
            (this.paramsInheritanceStrategy = o),
            (this.urlSerializer = a);
        }
        recognize() {
          const e = $p(
            this.urlTree.root,
            [],
            [],
            this.config.filter((t) => void 0 === t.redirectTo)
          ).segmentGroup;
          return this.processSegmentGroup(
            this.injector,
            this.config,
            e,
            ct
          ).pipe(
            xt((t) => {
              if (null === t) return null;
              const i = new qp(
                  [],
                  Object.freeze({}),
                  Object.freeze({ ...this.urlTree.queryParams }),
                  this.urlTree.fragment,
                  {},
                  ct,
                  this.rootComponentType,
                  null,
                  this.urlTree.root,
                  -1,
                  {}
                ),
                r = new Zs(i, t),
                s = new xI(this.url, r);
              return this.inheritParamsAndData(s._root), s;
            })
          );
        }
        inheritParamsAndData(e) {
          const t = e.value,
            i = bI(t, this.paramsInheritanceStrategy);
          (t.params = Object.freeze(i.params)),
            (t.data = Object.freeze(i.data)),
            e.children.forEach((r) => this.inheritParamsAndData(r));
        }
        processSegmentGroup(e, t, i, r) {
          return 0 === i.segments.length && i.hasChildren()
            ? this.processChildren(e, t, i)
            : this.processSegment(e, t, i, i.segments, r);
        }
        processChildren(e, t, i) {
          return On(Object.keys(i.children)).pipe(
            xa((r) => {
              const s = i.children[r],
                o = AI(t, r);
              return this.processSegmentGroup(e, o, s, r);
            }),
            Y1((r, s) => (r && s ? (r.push(...s), r) : null)),
            (function YW(n, e = !1) {
              return ln((t, i) => {
                let r = 0;
                t.subscribe(
                  en(i, (s) => {
                    const o = n(s, r++);
                    (o || e) && i.next(s), !o && i.complete();
                  })
                );
              });
            })((r) => null !== r),
            kp(null),
            Z1(),
            xt((r) => {
              if (null === r) return null;
              const s = kI(r);
              return (
                (function D6(n) {
                  n.sort((e, t) =>
                    e.value.outlet === ct
                      ? -1
                      : t.value.outlet === ct
                      ? 1
                      : e.value.outlet.localeCompare(t.value.outlet)
                  );
                })(s),
                s
              );
            })
          );
        }
        processSegment(e, t, i, r, s) {
          return On(t).pipe(
            xa((o) =>
              this.processSegmentAgainstRoute(o._injector ?? e, o, i, r, s)
            ),
            Ao((o) => !!o),
            Do((o) => {
              if (Z0(o)) return OI(i, r, s) ? Ge([]) : Ge(null);
              throw o;
            })
          );
        }
        processSegmentAgainstRoute(e, t, i, r, s) {
          if (t.redirectTo || !PI(t, i, r, s)) return Ge(null);
          let o;
          if ("**" === t.path) {
            const a = r.length > 0 ? J1(r).parameters : {},
              l = UI(i) + r.length;
            o = Ge({
              snapshot: new qp(
                r,
                a,
                Object.freeze({ ...this.urlTree.queryParams }),
                this.urlTree.fragment,
                VI(t),
                Er(t),
                t.component ?? t._loadedComponent ?? null,
                t,
                BI(i),
                l,
                zI(t)
              ),
              consumedSegments: [],
              remainingSegments: [],
            });
          } else
            o = RI(i, t, r, e).pipe(
              xt(
                ({
                  matched: a,
                  consumedSegments: l,
                  remainingSegments: c,
                  parameters: u,
                }) => {
                  if (!a) return null;
                  const d = UI(i) + l.length;
                  return {
                    snapshot: new qp(
                      l,
                      u,
                      Object.freeze({ ...this.urlTree.queryParams }),
                      this.urlTree.fragment,
                      VI(t),
                      Er(t),
                      t.component ?? t._loadedComponent ?? null,
                      t,
                      BI(i),
                      d,
                      zI(t)
                    ),
                    consumedSegments: l,
                    remainingSegments: c,
                  };
                }
              )
            );
          return o.pipe(
            Sr((a) => {
              if (null === a) return Ge(null);
              const {
                snapshot: l,
                consumedSegments: c,
                remainingSegments: u,
              } = a;
              e = t._injector ?? e;
              const d = t._loadedInjector ?? e,
                h = (function I6(n) {
                  return n.children
                    ? n.children
                    : n.loadChildren
                    ? n._loadedRoutes
                    : [];
                })(t),
                { segmentGroup: f, slicedSegments: p } = $p(
                  i,
                  c,
                  u,
                  h.filter((m) => void 0 === m.redirectTo)
                );
              if (0 === p.length && f.hasChildren())
                return this.processChildren(d, h, f).pipe(
                  xt((m) => (null === m ? null : [new Zs(l, m)]))
                );
              if (0 === h.length && 0 === p.length) return Ge([new Zs(l, [])]);
              const _ = Er(t) === s;
              return this.processSegment(d, h, f, p, _ ? ct : s).pipe(
                xt((m) => (null === m ? null : [new Zs(l, m)]))
              );
            })
          );
        }
      }
      function R6(n) {
        const e = n.value.routeConfig;
        return e && "" === e.path && void 0 === e.redirectTo;
      }
      function kI(n) {
        const e = [],
          t = new Set();
        for (const i of n) {
          if (!R6(i)) {
            e.push(i);
            continue;
          }
          const r = e.find((s) => i.value.routeConfig === s.value.routeConfig);
          void 0 !== r ? (r.children.push(...i.children), t.add(r)) : e.push(i);
        }
        for (const i of t) {
          const r = kI(i.children);
          e.push(new Zs(i.value, r));
        }
        return e.filter((i) => !t.has(i));
      }
      function BI(n) {
        let e = n;
        for (; e._sourceSegment; ) e = e._sourceSegment;
        return e;
      }
      function UI(n) {
        let e = n,
          t = e._segmentIndexShift ?? 0;
        for (; e._sourceSegment; )
          (e = e._sourceSegment), (t += e._segmentIndexShift ?? 0);
        return t - 1;
      }
      function VI(n) {
        return n.data || {};
      }
      function zI(n) {
        return n.resolve || {};
      }
      function HI(n) {
        return "string" == typeof n.title || null === n.title;
      }
      function Q0(n) {
        return Sr((e) => {
          const t = n(e);
          return t ? On(t).pipe(xt(() => e)) : Ge(e);
        });
      }
      const uc = new ye("ROUTES");
      let J0 = (() => {
        class n {
          constructor() {
            (this.componentLoaders = new WeakMap()),
              (this.childrenLoaders = new WeakMap()),
              (this.compiler = ft(vD));
          }
          loadComponent(t) {
            if (this.componentLoaders.get(t))
              return this.componentLoaders.get(t);
            if (t._loadedComponent) return Ge(t._loadedComponent);
            this.onLoadStartListener && this.onLoadStartListener(t);
            const i = Io(t.loadComponent()).pipe(
                xt(WI),
                si((s) => {
                  this.onLoadEndListener && this.onLoadEndListener(t),
                    (t._loadedComponent = s);
                }),
                I0(() => {
                  this.componentLoaders.delete(t);
                })
              ),
              r = new X1(i, () => new kt()).pipe(A0());
            return this.componentLoaders.set(t, r), r;
          }
          loadChildren(t, i) {
            if (this.childrenLoaders.get(i)) return this.childrenLoaders.get(i);
            if (i._loadedRoutes)
              return Ge({
                routes: i._loadedRoutes,
                injector: i._loadedInjector,
              });
            this.onLoadStartListener && this.onLoadStartListener(i);
            const s = this.loadModuleFactoryOrRoutes(i.loadChildren).pipe(
                xt((a) => {
                  this.onLoadEndListener && this.onLoadEndListener(i);
                  let l,
                    c,
                    u = !1;
                  Array.isArray(a)
                    ? (c = a)
                    : ((l = a.create(t).injector),
                      (c = Q1(l.get(uc, [], $e.Self | $e.Optional))));
                  return { routes: c.map(Y0), injector: l };
                }),
                I0(() => {
                  this.childrenLoaders.delete(i);
                })
              ),
              o = new X1(s, () => new kt()).pipe(A0());
            return this.childrenLoaders.set(i, o), o;
          }
          loadModuleFactoryOrRoutes(t) {
            return Io(t()).pipe(
              xt(WI),
              Un((i) =>
                i instanceof IA || Array.isArray(i)
                  ? Ge(i)
                  : On(this.compiler.compileModuleAsync(i))
              )
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function WI(n) {
        return (function U6(n) {
          return n && "object" == typeof n && "default" in n;
        })(n)
          ? n.default
          : n;
      }
      let nm = (() => {
        class n {
          get hasRequestedNavigation() {
            return 0 !== this.navigationId;
          }
          constructor() {
            (this.currentNavigation = null),
              (this.lastSuccessfulNavigation = null),
              (this.events = new kt()),
              (this.configLoader = ft(J0)),
              (this.environmentInjector = ft(zs)),
              (this.urlSerializer = ft(Dd)),
              (this.rootContexts = ft(Fd)),
              (this.navigationId = 0),
              (this.afterPreactivation = () => Ge(void 0)),
              (this.rootComponentType = null),
              (this.configLoader.onLoadEndListener = (r) =>
                this.events.next(new Cj(r))),
              (this.configLoader.onLoadStartListener = (r) =>
                this.events.next(new Ej(r)));
          }
          complete() {
            this.transitions?.complete();
          }
          handleNavigationRequest(t) {
            const i = ++this.navigationId;
            this.transitions?.next({ ...this.transitions.value, ...t, id: i });
          }
          setupNavigations(t) {
            return (
              (this.transitions = new Mr({
                id: 0,
                targetPageId: 0,
                currentUrlTree: t.currentUrlTree,
                currentRawUrl: t.currentUrlTree,
                extractedUrl: t.urlHandlingStrategy.extract(t.currentUrlTree),
                urlAfterRedirects: t.urlHandlingStrategy.extract(
                  t.currentUrlTree
                ),
                rawUrl: t.currentUrlTree,
                extras: {},
                resolve: null,
                reject: null,
                promise: Promise.resolve(!0),
                source: Od,
                restoredState: null,
                currentSnapshot: t.routerState.snapshot,
                targetSnapshot: null,
                currentRouterState: t.routerState,
                targetRouterState: null,
                guards: { canActivateChecks: [], canDeactivateChecks: [] },
                guardsResult: null,
              })),
              this.transitions.pipe(
                _i((i) => 0 !== i.id),
                xt((i) => ({
                  ...i,
                  extractedUrl: t.urlHandlingStrategy.extract(i.rawUrl),
                })),
                Sr((i) => {
                  let r = !1,
                    s = !1;
                  return Ge(i).pipe(
                    si((o) => {
                      this.currentNavigation = {
                        id: o.id,
                        initialUrl: o.rawUrl,
                        extractedUrl: o.extractedUrl,
                        trigger: o.source,
                        extras: o.extras,
                        previousNavigation: this.lastSuccessfulNavigation
                          ? {
                              ...this.lastSuccessfulNavigation,
                              previousNavigation: null,
                            }
                          : null,
                      };
                    }),
                    Sr((o) => {
                      const a = t.browserUrlTree.toString(),
                        l =
                          !t.navigated ||
                          o.extractedUrl.toString() !== a ||
                          a !== t.currentUrlTree.toString();
                      if (
                        !l &&
                        "reload" !==
                          (o.extras.onSameUrlNavigation ??
                            t.onSameUrlNavigation)
                      ) {
                        const u = "";
                        return (
                          this.events.next(
                            new Xp(o.id, t.serializeUrl(i.rawUrl), u, 0)
                          ),
                          (t.rawUrlTree = o.rawUrl),
                          o.resolve(null),
                          ls
                        );
                      }
                      if (t.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))
                        return (
                          jI(o.source) && (t.browserUrlTree = o.extractedUrl),
                          Ge(o).pipe(
                            Sr((u) => {
                              const d = this.transitions?.getValue();
                              return (
                                this.events.next(
                                  new k0(
                                    u.id,
                                    this.urlSerializer.serialize(
                                      u.extractedUrl
                                    ),
                                    u.source,
                                    u.restoredState
                                  )
                                ),
                                d !== this.transitions?.getValue()
                                  ? ls
                                  : Promise.resolve(u)
                              );
                            }),
                            (function S6(n, e, t, i) {
                              return Sr((r) =>
                                (function w6(n, e, t, i, r) {
                                  return new M6(n, e, t, i, r).apply();
                                })(n, e, t, r.extractedUrl, i).pipe(
                                  xt((s) => ({ ...r, urlAfterRedirects: s }))
                                )
                              );
                            })(
                              this.environmentInjector,
                              this.configLoader,
                              this.urlSerializer,
                              t.config
                            ),
                            si((u) => {
                              (this.currentNavigation = {
                                ...this.currentNavigation,
                                finalUrl: u.urlAfterRedirects,
                              }),
                                (i.urlAfterRedirects = u.urlAfterRedirects);
                            }),
                            (function O6(n, e, t, i, r) {
                              return Un((s) =>
                                (function T6(
                                  n,
                                  e,
                                  t,
                                  i,
                                  r,
                                  s,
                                  o = "emptyOnly"
                                ) {
                                  return new A6(n, e, t, i, r, o, s)
                                    .recognize()
                                    .pipe(
                                      Sr((a) =>
                                        null === a
                                          ? (function C6(n) {
                                              return new Kt((e) => e.error(n));
                                            })(new E6())
                                          : Ge(a)
                                      )
                                    );
                                })(
                                  n,
                                  e,
                                  t,
                                  s.urlAfterRedirects,
                                  i.serialize(s.urlAfterRedirects),
                                  i,
                                  r
                                ).pipe(xt((o) => ({ ...s, targetSnapshot: o })))
                              );
                            })(
                              this.environmentInjector,
                              this.rootComponentType,
                              t.config,
                              this.urlSerializer,
                              t.paramsInheritanceStrategy
                            ),
                            si((u) => {
                              if (
                                ((i.targetSnapshot = u.targetSnapshot),
                                "eager" === t.urlUpdateStrategy)
                              ) {
                                if (!u.extras.skipLocationChange) {
                                  const h = t.urlHandlingStrategy.merge(
                                    u.urlAfterRedirects,
                                    u.rawUrl
                                  );
                                  t.setBrowserUrl(h, u);
                                }
                                t.browserUrlTree = u.urlAfterRedirects;
                              }
                              const d = new bj(
                                u.id,
                                this.urlSerializer.serialize(u.extractedUrl),
                                this.urlSerializer.serialize(
                                  u.urlAfterRedirects
                                ),
                                u.targetSnapshot
                              );
                              this.events.next(d);
                            })
                          )
                        );
                      if (
                        l &&
                        t.urlHandlingStrategy.shouldProcessUrl(t.rawUrlTree)
                      ) {
                        const {
                            id: u,
                            extractedUrl: d,
                            source: h,
                            restoredState: f,
                            extras: p,
                          } = o,
                          _ = new k0(u, this.urlSerializer.serialize(d), h, f);
                        this.events.next(_);
                        const m = yI(d, this.rootComponentType).snapshot;
                        return Ge(
                          (i = {
                            ...o,
                            targetSnapshot: m,
                            urlAfterRedirects: d,
                            extras: {
                              ...p,
                              skipLocationChange: !1,
                              replaceUrl: !1,
                            },
                          })
                        );
                      }
                      {
                        const u = "";
                        return (
                          this.events.next(
                            new Xp(o.id, t.serializeUrl(i.extractedUrl), u, 1)
                          ),
                          (t.rawUrlTree = o.rawUrl),
                          o.resolve(null),
                          ls
                        );
                      }
                    }),
                    si((o) => {
                      const a = new xj(
                        o.id,
                        this.urlSerializer.serialize(o.extractedUrl),
                        this.urlSerializer.serialize(o.urlAfterRedirects),
                        o.targetSnapshot
                      );
                      this.events.next(a);
                    }),
                    xt(
                      (o) =>
                        (i = {
                          ...o,
                          guards: Zj(
                            o.targetSnapshot,
                            o.currentSnapshot,
                            this.rootContexts
                          ),
                        })
                    ),
                    (function o6(n, e) {
                      return Un((t) => {
                        const {
                          targetSnapshot: i,
                          currentSnapshot: r,
                          guards: {
                            canActivateChecks: s,
                            canDeactivateChecks: o,
                          },
                        } = t;
                        return 0 === o.length && 0 === s.length
                          ? Ge({ ...t, guardsResult: !0 })
                          : (function a6(n, e, t, i) {
                              return On(n).pipe(
                                Un((r) =>
                                  (function f6(n, e, t, i, r) {
                                    const s =
                                      e && e.routeConfig
                                        ? e.routeConfig.canDeactivate
                                        : null;
                                    return s && 0 !== s.length
                                      ? Ge(
                                          s.map((a) => {
                                            const l = Nd(e) ?? r,
                                              c = lc(a, l);
                                            return Io(
                                              (function i6(n) {
                                                return n && Ud(n.canDeactivate);
                                              })(c)
                                                ? c.canDeactivate(n, e, t, i)
                                                : l.runInContext(() =>
                                                    c(n, e, t, i)
                                                  )
                                            ).pipe(Ao());
                                          })
                                        ).pipe(cc())
                                      : Ge(!0);
                                  })(r.component, r.route, t, e, i)
                                ),
                                Ao((r) => !0 !== r, !0)
                              );
                            })(o, i, r, n).pipe(
                              Un((a) =>
                                a &&
                                (function Jj(n) {
                                  return "boolean" == typeof n;
                                })(a)
                                  ? (function l6(n, e, t, i) {
                                      return On(e).pipe(
                                        xa((r) =>
                                          Ed(
                                            (function u6(n, e) {
                                              return (
                                                null !== n && e && e(new Tj(n)),
                                                Ge(!0)
                                              );
                                            })(r.route.parent, i),
                                            (function c6(n, e) {
                                              return (
                                                null !== n && e && e(new Dj(n)),
                                                Ge(!0)
                                              );
                                            })(r.route, i),
                                            (function h6(n, e, t) {
                                              const i = e[e.length - 1],
                                                s = e
                                                  .slice(0, e.length - 1)
                                                  .reverse()
                                                  .map((o) =>
                                                    (function Kj(n) {
                                                      const e = n.routeConfig
                                                        ? n.routeConfig
                                                            .canActivateChild
                                                        : null;
                                                      return e && 0 !== e.length
                                                        ? { node: n, guards: e }
                                                        : null;
                                                    })(o)
                                                  )
                                                  .filter((o) => null !== o)
                                                  .map((o) =>
                                                    j1(() =>
                                                      Ge(
                                                        o.guards.map((l) => {
                                                          const c =
                                                              Nd(o.node) ?? t,
                                                            u = lc(l, c);
                                                          return Io(
                                                            (function n6(n) {
                                                              return (
                                                                n &&
                                                                Ud(
                                                                  n.canActivateChild
                                                                )
                                                              );
                                                            })(u)
                                                              ? u.canActivateChild(
                                                                  i,
                                                                  n
                                                                )
                                                              : c.runInContext(
                                                                  () => u(i, n)
                                                                )
                                                          ).pipe(Ao());
                                                        })
                                                      ).pipe(cc())
                                                    )
                                                  );
                                              return Ge(s).pipe(cc());
                                            })(n, r.path, t),
                                            (function d6(n, e, t) {
                                              const i = e.routeConfig
                                                ? e.routeConfig.canActivate
                                                : null;
                                              if (!i || 0 === i.length)
                                                return Ge(!0);
                                              const r = i.map((s) =>
                                                j1(() => {
                                                  const o = Nd(e) ?? t,
                                                    a = lc(s, o);
                                                  return Io(
                                                    (function t6(n) {
                                                      return (
                                                        n && Ud(n.canActivate)
                                                      );
                                                    })(a)
                                                      ? a.canActivate(e, n)
                                                      : o.runInContext(() =>
                                                          a(e, n)
                                                        )
                                                  ).pipe(Ao());
                                                })
                                              );
                                              return Ge(r).pipe(cc());
                                            })(n, r.route, t)
                                          )
                                        ),
                                        Ao((r) => !0 !== r, !0)
                                      );
                                    })(i, s, n, e)
                                  : Ge(a)
                              ),
                              xt((a) => ({ ...t, guardsResult: a }))
                            );
                      });
                    })(this.environmentInjector, (o) => this.events.next(o)),
                    si((o) => {
                      if (
                        ((i.guardsResult = o.guardsResult), Ma(o.guardsResult))
                      )
                        throw MI(0, o.guardsResult);
                      const a = new wj(
                        o.id,
                        this.urlSerializer.serialize(o.extractedUrl),
                        this.urlSerializer.serialize(o.urlAfterRedirects),
                        o.targetSnapshot,
                        !!o.guardsResult
                      );
                      this.events.next(a);
                    }),
                    _i(
                      (o) =>
                        !!o.guardsResult ||
                        (t.restoreHistory(o),
                        this.cancelNavigationTransition(o, "", 3),
                        !1)
                    ),
                    Q0((o) => {
                      if (o.guards.canActivateChecks.length)
                        return Ge(o).pipe(
                          si((a) => {
                            const l = new Mj(
                              a.id,
                              this.urlSerializer.serialize(a.extractedUrl),
                              this.urlSerializer.serialize(a.urlAfterRedirects),
                              a.targetSnapshot
                            );
                            this.events.next(l);
                          }),
                          Sr((a) => {
                            let l = !1;
                            return Ge(a).pipe(
                              (function L6(n, e) {
                                return Un((t) => {
                                  const {
                                    targetSnapshot: i,
                                    guards: { canActivateChecks: r },
                                  } = t;
                                  if (!r.length) return Ge(t);
                                  let s = 0;
                                  return On(r).pipe(
                                    xa((o) =>
                                      (function F6(n, e, t, i) {
                                        const r = n.routeConfig,
                                          s = n._resolve;
                                        return (
                                          void 0 !== r?.title &&
                                            !HI(r) &&
                                            (s[Td] = r.title),
                                          (function N6(n, e, t, i) {
                                            const r = (function k6(n) {
                                              return [
                                                ...Object.keys(n),
                                                ...Object.getOwnPropertySymbols(
                                                  n
                                                ),
                                              ];
                                            })(n);
                                            if (0 === r.length) return Ge({});
                                            const s = {};
                                            return On(r).pipe(
                                              Un((o) =>
                                                (function B6(n, e, t, i) {
                                                  const r = Nd(e) ?? i,
                                                    s = lc(n, r);
                                                  return Io(
                                                    s.resolve
                                                      ? s.resolve(e, t)
                                                      : r.runInContext(() =>
                                                          s(e, t)
                                                        )
                                                  );
                                                })(n[o], e, t, i).pipe(
                                                  Ao(),
                                                  si((a) => {
                                                    s[o] = a;
                                                  })
                                                )
                                              ),
                                              D0(1),
                                              K1(s),
                                              Do((o) => (Z0(o) ? ls : Cd(o)))
                                            );
                                          })(s, n, e, i).pipe(
                                            xt(
                                              (o) => (
                                                (n._resolvedData = o),
                                                (n.data = bI(n, t).resolve),
                                                r &&
                                                  HI(r) &&
                                                  (n.data[Td] = r.title),
                                                null
                                              )
                                            )
                                          )
                                        );
                                      })(o.route, i, n, e)
                                    ),
                                    si(() => s++),
                                    D0(1),
                                    Un((o) => (s === r.length ? Ge(t) : ls))
                                  );
                                });
                              })(
                                t.paramsInheritanceStrategy,
                                this.environmentInjector
                              ),
                              si({
                                next: () => (l = !0),
                                complete: () => {
                                  l ||
                                    (t.restoreHistory(a),
                                    this.cancelNavigationTransition(a, "", 2));
                                },
                              })
                            );
                          }),
                          si((a) => {
                            const l = new Sj(
                              a.id,
                              this.urlSerializer.serialize(a.extractedUrl),
                              this.urlSerializer.serialize(a.urlAfterRedirects),
                              a.targetSnapshot
                            );
                            this.events.next(l);
                          })
                        );
                    }),
                    Q0((o) => {
                      const a = (l) => {
                        const c = [];
                        l.routeConfig?.loadComponent &&
                          !l.routeConfig._loadedComponent &&
                          c.push(
                            this.configLoader.loadComponent(l.routeConfig).pipe(
                              si((u) => {
                                l.component = u;
                              }),
                              xt(() => {})
                            )
                          );
                        for (const u of l.children) c.push(...a(u));
                        return c;
                      };
                      return T0(a(o.targetSnapshot.root)).pipe(kp(), er(1));
                    }),
                    Q0(() => this.afterPreactivation()),
                    xt((o) => {
                      const a = (function Bj(n, e, t) {
                        const i = Ld(n, e._root, t ? t._root : void 0);
                        return new vI(i, e);
                      })(
                        t.routeReuseStrategy,
                        o.targetSnapshot,
                        o.currentRouterState
                      );
                      return (i = { ...o, targetRouterState: a });
                    }),
                    si((o) => {
                      (t.currentUrlTree = o.urlAfterRedirects),
                        (t.rawUrlTree = t.urlHandlingStrategy.merge(
                          o.urlAfterRedirects,
                          o.rawUrl
                        )),
                        (t.routerState = o.targetRouterState),
                        "deferred" === t.urlUpdateStrategy &&
                          (o.extras.skipLocationChange ||
                            t.setBrowserUrl(t.rawUrlTree, o),
                          (t.browserUrlTree = o.urlAfterRedirects));
                    }),
                    ((n, e, t) =>
                      xt(
                        (i) => (
                          new Yj(
                            e,
                            i.targetRouterState,
                            i.currentRouterState,
                            t
                          ).activate(n),
                          i
                        )
                      ))(this.rootContexts, t.routeReuseStrategy, (o) =>
                      this.events.next(o)
                    ),
                    er(1),
                    si({
                      next: (o) => {
                        (r = !0),
                          (this.lastSuccessfulNavigation =
                            this.currentNavigation),
                          (t.navigated = !0),
                          this.events.next(
                            new Sa(
                              o.id,
                              this.urlSerializer.serialize(o.extractedUrl),
                              this.urlSerializer.serialize(t.currentUrlTree)
                            )
                          ),
                          t.titleStrategy?.updateTitle(
                            o.targetRouterState.snapshot
                          ),
                          o.resolve(!0);
                      },
                      complete: () => {
                        r = !0;
                      },
                    }),
                    I0(() => {
                      r || s || this.cancelNavigationTransition(i, "", 1),
                        this.currentNavigation?.id === i.id &&
                          (this.currentNavigation = null);
                    }),
                    Do((o) => {
                      if (((s = !0), CI(o))) {
                        EI(o) || ((t.navigated = !0), t.restoreHistory(i, !0));
                        const a = new jp(
                          i.id,
                          this.urlSerializer.serialize(i.extractedUrl),
                          o.message,
                          o.cancellationCode
                        );
                        if ((this.events.next(a), EI(o))) {
                          const l = t.urlHandlingStrategy.merge(
                              o.url,
                              t.rawUrlTree
                            ),
                            c = {
                              skipLocationChange: i.extras.skipLocationChange,
                              replaceUrl:
                                "eager" === t.urlUpdateStrategy || jI(i.source),
                            };
                          t.scheduleNavigation(l, Od, null, c, {
                            resolve: i.resolve,
                            reject: i.reject,
                            promise: i.promise,
                          });
                        } else i.resolve(!1);
                      } else {
                        t.restoreHistory(i, !0);
                        const a = new B0(
                          i.id,
                          this.urlSerializer.serialize(i.extractedUrl),
                          o,
                          i.targetSnapshot ?? void 0
                        );
                        this.events.next(a);
                        try {
                          i.resolve(t.errorHandler(o));
                        } catch (l) {
                          i.reject(l);
                        }
                      }
                      return ls;
                    })
                  );
                })
              )
            );
          }
          cancelNavigationTransition(t, i, r) {
            const s = new jp(
              t.id,
              this.urlSerializer.serialize(t.extractedUrl),
              i,
              r
            );
            this.events.next(s), t.resolve(!1);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function jI(n) {
        return n !== Od;
      }
      let XI = (() => {
          class n {
            buildTitle(t) {
              let i,
                r = t.root;
              for (; void 0 !== r; )
                (i = this.getResolvedTitleForRoute(r) ?? i),
                  (r = r.children.find((s) => s.outlet === ct));
              return i;
            }
            getResolvedTitleForRoute(t) {
              return t.data[Td];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({
              token: n,
              factory: function () {
                return ft(V6);
              },
              providedIn: "root",
            })),
            n
          );
        })(),
        V6 = (() => {
          class n extends XI {
            constructor(t) {
              super(), (this.title = t);
            }
            updateTitle(t) {
              const i = this.buildTitle(t);
              void 0 !== i && this.title.setTitle(i);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(k1));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        z6 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({
              token: n,
              factory: function () {
                return ft(G6);
              },
              providedIn: "root",
            })),
            n
          );
        })();
      class H6 {
        shouldDetach(e) {
          return !1;
        }
        store(e, t) {}
        shouldAttach(e) {
          return !1;
        }
        retrieve(e) {
          return null;
        }
        shouldReuseRoute(e, t) {
          return e.routeConfig === t.routeConfig;
        }
      }
      let G6 = (() => {
        class n extends H6 {}
        return (
          (n.ɵfac = (function () {
            let e;
            return function (i) {
              return (e || (e = Vn(n)))(i || n);
            };
          })()),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const im = new ye("", { providedIn: "root", factory: () => ({}) });
      let j6 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({
              token: n,
              factory: function () {
                return ft(X6);
              },
              providedIn: "root",
            })),
            n
          );
        })(),
        X6 = (() => {
          class n {
            shouldProcessUrl(t) {
              return !0;
            }
            extract(t) {
              return t;
            }
            merge(t, i) {
              return t;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      function q6(n) {
        throw n;
      }
      function Y6(n, e, t) {
        return e.parse("/");
      }
      const Z6 = {
          paths: "exact",
          fragment: "ignored",
          matrixParams: "ignored",
          queryParams: "exact",
        },
        K6 = {
          paths: "subset",
          fragment: "ignored",
          matrixParams: "ignored",
          queryParams: "subset",
        };
      let tr = (() => {
        class n {
          get navigationId() {
            return this.navigationTransitions.navigationId;
          }
          get browserPageId() {
            if ("computed" === this.canceledNavigationResolution)
              return this.location.getState()?.ɵrouterPageId;
          }
          get events() {
            return this.navigationTransitions.events;
          }
          constructor() {
            (this.disposed = !1),
              (this.currentPageId = 0),
              (this.console = ft(EG)),
              (this.isNgZoneEnabled = !1),
              (this.options = ft(im, { optional: !0 }) || {}),
              (this.errorHandler = this.options.errorHandler || q6),
              (this.malformedUriErrorHandler =
                this.options.malformedUriErrorHandler || Y6),
              (this.navigated = !1),
              (this.lastSuccessfulId = -1),
              (this.urlHandlingStrategy = ft(j6)),
              (this.routeReuseStrategy = ft(z6)),
              (this.urlCreationStrategy = ft(Fj)),
              (this.titleStrategy = ft(XI)),
              (this.onSameUrlNavigation =
                this.options.onSameUrlNavigation || "ignore"),
              (this.paramsInheritanceStrategy =
                this.options.paramsInheritanceStrategy || "emptyOnly"),
              (this.urlUpdateStrategy =
                this.options.urlUpdateStrategy || "deferred"),
              (this.canceledNavigationResolution =
                this.options.canceledNavigationResolution || "replace"),
              (this.config = Q1(ft(uc, { optional: !0 }) ?? [])),
              (this.navigationTransitions = ft(nm)),
              (this.urlSerializer = ft(Dd)),
              (this.location = ft(yp)),
              (this.isNgZoneEnabled =
                ft(wt) instanceof wt && wt.isInAngularZone()),
              this.resetConfig(this.config),
              (this.currentUrlTree = new Ro()),
              (this.rawUrlTree = this.currentUrlTree),
              (this.browserUrlTree = this.currentUrlTree),
              (this.routerState = yI(this.currentUrlTree, null)),
              this.navigationTransitions.setupNavigations(this).subscribe(
                (t) => {
                  (this.lastSuccessfulId = t.id),
                    (this.currentPageId = this.browserPageId ?? 0);
                },
                (t) => {
                  this.console.warn(`Unhandled Navigation Error: ${t}`);
                }
              );
          }
          resetRootComponentType(t) {
            (this.routerState.root.component = t),
              (this.navigationTransitions.rootComponentType = t);
          }
          initialNavigation() {
            if (
              (this.setUpLocationChangeListener(),
              !this.navigationTransitions.hasRequestedNavigation)
            ) {
              const t = this.location.getState();
              this.navigateToSyncWithBrowser(this.location.path(!0), Od, t);
            }
          }
          setUpLocationChangeListener() {
            this.locationSubscription ||
              (this.locationSubscription = this.location.subscribe((t) => {
                const i = "popstate" === t.type ? "popstate" : "hashchange";
                "popstate" === i &&
                  setTimeout(() => {
                    this.navigateToSyncWithBrowser(t.url, i, t.state);
                  }, 0);
              }));
          }
          navigateToSyncWithBrowser(t, i, r) {
            const s = { replaceUrl: !0 },
              o = r?.navigationId ? r : null;
            if (r) {
              const l = { ...r };
              delete l.navigationId,
                delete l.ɵrouterPageId,
                0 !== Object.keys(l).length && (s.state = l);
            }
            const a = this.parseUrl(t);
            this.scheduleNavigation(a, i, o, s);
          }
          get url() {
            return this.serializeUrl(this.currentUrlTree);
          }
          getCurrentNavigation() {
            return this.navigationTransitions.currentNavigation;
          }
          resetConfig(t) {
            (this.config = t.map(Y0)),
              (this.navigated = !1),
              (this.lastSuccessfulId = -1);
          }
          ngOnDestroy() {
            this.dispose();
          }
          dispose() {
            this.navigationTransitions.complete(),
              this.locationSubscription &&
                (this.locationSubscription.unsubscribe(),
                (this.locationSubscription = void 0)),
              (this.disposed = !0);
          }
          createUrlTree(t, i = {}) {
            const {
                relativeTo: r,
                queryParams: s,
                fragment: o,
                queryParamsHandling: a,
                preserveFragment: l,
              } = i,
              c = l ? this.currentUrlTree.fragment : o;
            let u = null;
            switch (a) {
              case "merge":
                u = { ...this.currentUrlTree.queryParams, ...s };
                break;
              case "preserve":
                u = this.currentUrlTree.queryParams;
                break;
              default:
                u = s || null;
            }
            return (
              null !== u && (u = this.removeEmptyProps(u)),
              this.urlCreationStrategy.createUrlTree(
                r,
                this.routerState,
                this.currentUrlTree,
                t,
                u,
                c ?? null
              )
            );
          }
          navigateByUrl(t, i = { skipLocationChange: !1 }) {
            const r = Ma(t) ? t : this.parseUrl(t),
              s = this.urlHandlingStrategy.merge(r, this.rawUrlTree);
            return this.scheduleNavigation(s, Od, null, i);
          }
          navigate(t, i = { skipLocationChange: !1 }) {
            return (
              (function $6(n) {
                for (let e = 0; e < n.length; e++) {
                  const t = n[e];
                  if (null == t) throw new J(4008, false);
                }
              })(t),
              this.navigateByUrl(this.createUrlTree(t, i), i)
            );
          }
          serializeUrl(t) {
            return this.urlSerializer.serialize(t);
          }
          parseUrl(t) {
            let i;
            try {
              i = this.urlSerializer.parse(t);
            } catch (r) {
              i = this.malformedUriErrorHandler(r, this.urlSerializer, t);
            }
            return i;
          }
          isActive(t, i) {
            let r;
            if (((r = !0 === i ? { ...Z6 } : !1 === i ? { ...K6 } : i), Ma(t)))
              return tI(this.currentUrlTree, t, r);
            const s = this.parseUrl(t);
            return tI(this.currentUrlTree, s, r);
          }
          removeEmptyProps(t) {
            return Object.keys(t).reduce((i, r) => {
              const s = t[r];
              return null != s && (i[r] = s), i;
            }, {});
          }
          scheduleNavigation(t, i, r, s, o) {
            if (this.disposed) return Promise.resolve(!1);
            let a, l, c, u;
            return (
              o
                ? ((a = o.resolve), (l = o.reject), (c = o.promise))
                : (c = new Promise((d, h) => {
                    (a = d), (l = h);
                  })),
              (u =
                "computed" === this.canceledNavigationResolution
                  ? r && r.ɵrouterPageId
                    ? r.ɵrouterPageId
                    : (this.browserPageId ?? 0) + 1
                  : 0),
              this.navigationTransitions.handleNavigationRequest({
                targetPageId: u,
                source: i,
                restoredState: r,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.currentUrlTree,
                rawUrl: t,
                extras: s,
                resolve: a,
                reject: l,
                promise: c,
                currentSnapshot: this.routerState.snapshot,
                currentRouterState: this.routerState,
              }),
              c.catch((d) => Promise.reject(d))
            );
          }
          setBrowserUrl(t, i) {
            const r = this.urlSerializer.serialize(t);
            if (this.location.isCurrentPathEqualTo(r) || i.extras.replaceUrl) {
              const o = {
                ...i.extras.state,
                ...this.generateNgRouterState(i.id, this.browserPageId),
              };
              this.location.replaceState(r, "", o);
            } else {
              const s = {
                ...i.extras.state,
                ...this.generateNgRouterState(i.id, i.targetPageId),
              };
              this.location.go(r, "", s);
            }
          }
          restoreHistory(t, i = !1) {
            if ("computed" === this.canceledNavigationResolution) {
              const s =
                this.currentPageId - (this.browserPageId ?? this.currentPageId);
              0 !== s
                ? this.location.historyGo(s)
                : this.currentUrlTree ===
                    this.getCurrentNavigation()?.finalUrl &&
                  0 === s &&
                  (this.resetState(t),
                  (this.browserUrlTree = t.currentUrlTree),
                  this.resetUrlToCurrentUrlTree());
            } else
              "replace" === this.canceledNavigationResolution &&
                (i && this.resetState(t), this.resetUrlToCurrentUrlTree());
          }
          resetState(t) {
            (this.routerState = t.currentRouterState),
              (this.currentUrlTree = t.currentUrlTree),
              (this.rawUrlTree = this.urlHandlingStrategy.merge(
                this.currentUrlTree,
                t.rawUrl
              ));
          }
          resetUrlToCurrentUrlTree() {
            this.location.replaceState(
              this.urlSerializer.serialize(this.rawUrlTree),
              "",
              this.generateNgRouterState(
                this.lastSuccessfulId,
                this.currentPageId
              )
            );
          }
          generateNgRouterState(t, i) {
            return "computed" === this.canceledNavigationResolution
              ? { navigationId: t, ɵrouterPageId: i }
              : { navigationId: t };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      class qI {}
      let e9 = (() => {
        class n {
          constructor(t, i, r, s, o) {
            (this.router = t),
              (this.injector = r),
              (this.preloadingStrategy = s),
              (this.loader = o);
          }
          setUpPreloading() {
            this.subscription = this.router.events
              .pipe(
                _i((t) => t instanceof Sa),
                xa(() => this.preload())
              )
              .subscribe(() => {});
          }
          preload() {
            return this.processRoutes(this.injector, this.router.config);
          }
          ngOnDestroy() {
            this.subscription && this.subscription.unsubscribe();
          }
          processRoutes(t, i) {
            const r = [];
            for (const s of i) {
              s.providers &&
                !s._injector &&
                (s._injector = lp(s.providers, t, `Route: ${s.path}`));
              const o = s._injector ?? t,
                a = s._loadedInjector ?? o;
              ((s.loadChildren && !s._loadedRoutes && void 0 === s.canLoad) ||
                (s.loadComponent && !s._loadedComponent)) &&
                r.push(this.preloadConfig(o, s)),
                (s.children || s._loadedRoutes) &&
                  r.push(this.processRoutes(a, s.children ?? s._loadedRoutes));
            }
            return On(r).pipe(al());
          }
          preloadConfig(t, i) {
            return this.preloadingStrategy.preload(i, () => {
              let r;
              r =
                i.loadChildren && void 0 === i.canLoad
                  ? this.loader.loadChildren(t, i)
                  : Ge(null);
              const s = r.pipe(
                Un((o) =>
                  null === o
                    ? Ge(void 0)
                    : ((i._loadedRoutes = o.routes),
                      (i._loadedInjector = o.injector),
                      this.processRoutes(o.injector ?? t, o.routes))
                )
              );
              return i.loadComponent && !i._loadedComponent
                ? On([s, this.loader.loadComponent(i)]).pipe(al())
                : s;
            });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(tr), re(vD), re(zs), re(qI), re(J0));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const nb = new ye("");
      let YI = (() => {
        class n {
          constructor(t, i, r, s, o = {}) {
            (this.urlSerializer = t),
              (this.transitions = i),
              (this.viewportScroller = r),
              (this.zone = s),
              (this.options = o),
              (this.lastId = 0),
              (this.lastSource = "imperative"),
              (this.restoredId = 0),
              (this.store = {}),
              (o.scrollPositionRestoration =
                o.scrollPositionRestoration || "disabled"),
              (o.anchorScrolling = o.anchorScrolling || "disabled");
          }
          init() {
            "disabled" !== this.options.scrollPositionRestoration &&
              this.viewportScroller.setHistoryScrollRestoration("manual"),
              (this.routerEventsSubscription = this.createScrollEvents()),
              (this.scrollEventsSubscription = this.consumeScrollEvents());
          }
          createScrollEvents() {
            return this.transitions.events.subscribe((t) => {
              t instanceof k0
                ? ((this.store[this.lastId] =
                    this.viewportScroller.getScrollPosition()),
                  (this.lastSource = t.navigationTrigger),
                  (this.restoredId = t.restoredState
                    ? t.restoredState.navigationId
                    : 0))
                : t instanceof Sa &&
                  ((this.lastId = t.id),
                  this.scheduleScrollEvent(
                    t,
                    this.urlSerializer.parse(t.urlAfterRedirects).fragment
                  ));
            });
          }
          consumeScrollEvents() {
            return this.transitions.events.subscribe((t) => {
              t instanceof gI &&
                (t.position
                  ? "top" === this.options.scrollPositionRestoration
                    ? this.viewportScroller.scrollToPosition([0, 0])
                    : "enabled" === this.options.scrollPositionRestoration &&
                      this.viewportScroller.scrollToPosition(t.position)
                  : t.anchor && "enabled" === this.options.anchorScrolling
                  ? this.viewportScroller.scrollToAnchor(t.anchor)
                  : "disabled" !== this.options.scrollPositionRestoration &&
                    this.viewportScroller.scrollToPosition([0, 0]));
            });
          }
          scheduleScrollEvent(t, i) {
            this.zone.runOutsideAngular(() => {
              setTimeout(() => {
                this.zone.run(() => {
                  this.transitions.events.next(
                    new gI(
                      t,
                      "popstate" === this.lastSource
                        ? this.store[this.restoredId]
                        : null,
                      i
                    )
                  );
                });
              }, 0);
            });
          }
          ngOnDestroy() {
            this.routerEventsSubscription?.unsubscribe(),
              this.scrollEventsSubscription?.unsubscribe();
          }
        }
        return (
          (n.ɵfac = function (t) {
            qv();
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      var nr = (() => (
        ((nr = nr || {})[(nr.COMPLETE = 0)] = "COMPLETE"),
        (nr[(nr.FAILED = 1)] = "FAILED"),
        (nr[(nr.REDIRECTING = 2)] = "REDIRECTING"),
        nr
      ))();
      const dc = !1;
      function Po(n, e) {
        return { ɵkind: n, ɵproviders: e };
      }
      const ib = new ye("", { providedIn: "root", factory: () => !1 });
      function KI() {
        const n = ft(Qi);
        return (e) => {
          const t = n.get($l);
          if (e !== t.components[0]) return;
          const i = n.get(tr),
            r = n.get($I);
          1 === n.get(rb) && i.initialNavigation(),
            n.get(QI, null, $e.Optional)?.setUpPreloading(),
            n.get(nb, null, $e.Optional)?.init(),
            i.resetRootComponentType(t.componentTypes[0]),
            r.closed || (r.next(), r.complete(), r.unsubscribe());
        };
      }
      const $I = new ye(dc ? "bootstrap done indicator" : "", {
          factory: () => new kt(),
        }),
        rb = new ye(dc ? "initial navigation" : "", {
          providedIn: "root",
          factory: () => 1,
        });
      function s9() {
        let n = [];
        return (
          (n = dc
            ? [
                {
                  provide: zf,
                  multi: !0,
                  useFactory: () => {
                    const e = ft(tr);
                    return () =>
                      e.events.subscribe((t) => {
                        console.group?.(`Router Event: ${t.constructor.name}`),
                          console.log(
                            (function Rj(n) {
                              if (!("type" in n))
                                return `Unknown Router Event: ${n.constructor.name}`;
                              switch (n.type) {
                                case 14:
                                  return `ActivationEnd(path: '${
                                    n.snapshot.routeConfig?.path || ""
                                  }')`;
                                case 13:
                                  return `ActivationStart(path: '${
                                    n.snapshot.routeConfig?.path || ""
                                  }')`;
                                case 12:
                                  return `ChildActivationEnd(path: '${
                                    n.snapshot.routeConfig?.path || ""
                                  }')`;
                                case 11:
                                  return `ChildActivationStart(path: '${
                                    n.snapshot.routeConfig?.path || ""
                                  }')`;
                                case 8:
                                  return `GuardsCheckEnd(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state}, shouldActivate: ${n.shouldActivate})`;
                                case 7:
                                  return `GuardsCheckStart(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state})`;
                                case 2:
                                  return `NavigationCancel(id: ${n.id}, url: '${n.url}')`;
                                case 16:
                                  return `NavigationSkipped(id: ${n.id}, url: '${n.url}')`;
                                case 1:
                                  return `NavigationEnd(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}')`;
                                case 3:
                                  return `NavigationError(id: ${n.id}, url: '${n.url}', error: ${n.error})`;
                                case 0:
                                  return `NavigationStart(id: ${n.id}, url: '${n.url}')`;
                                case 6:
                                  return `ResolveEnd(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state})`;
                                case 5:
                                  return `ResolveStart(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state})`;
                                case 10:
                                  return `RouteConfigLoadEnd(path: ${n.route.path})`;
                                case 9:
                                  return `RouteConfigLoadStart(path: ${n.route.path})`;
                                case 4:
                                  return `RoutesRecognized(id: ${n.id}, url: '${n.url}', urlAfterRedirects: '${n.urlAfterRedirects}', state: ${n.state})`;
                                case 15:
                                  return `Scroll(anchor: '${
                                    n.anchor
                                  }', position: '${
                                    n.position
                                      ? `${n.position[0]}, ${n.position[1]}`
                                      : null
                                  }')`;
                              }
                            })(t)
                          ),
                          console.log(t),
                          console.groupEnd?.();
                      });
                  },
                },
              ]
            : []),
          Po(1, n)
        );
      }
      const QI = new ye(dc ? "router preloader" : "");
      function o9(n) {
        return Po(0, [
          { provide: QI, useExisting: e9 },
          { provide: qI, useExisting: n },
        ]);
      }
      const zd = !1,
        JI = new ye(
          zd ? "router duplicate forRoot guard" : "ROUTER_FORROOT_GUARD"
        ),
        a9 = [
          yp,
          { provide: Dd, useClass: R0 },
          tr,
          Fd,
          {
            provide: ac,
            useFactory: function ZI(n) {
              return n.routerState.root;
            },
            deps: [tr],
          },
          J0,
          zd ? { provide: ib, useValue: !0 } : [],
        ];
      function l9() {
        return new CD("Router", tr);
      }
      let eR = (() => {
        class n {
          constructor(t) {}
          static forRoot(t, i) {
            return {
              ngModule: n,
              providers: [
                a9,
                zd && i?.enableTracing ? s9().ɵproviders : [],
                { provide: uc, multi: !0, useValue: t },
                {
                  provide: JI,
                  useFactory: h9,
                  deps: [[tr, new Ml(), new Gu()]],
                },
                { provide: im, useValue: i || {} },
                i?.useHash
                  ? { provide: ba, useClass: f5 }
                  : { provide: ba, useClass: ZD },
                {
                  provide: nb,
                  useFactory: () => {
                    const n = ft(P8),
                      e = ft(wt),
                      t = ft(im),
                      i = ft(nm),
                      r = ft(Dd);
                    return (
                      t.scrollOffset && n.setOffset(t.scrollOffset),
                      new YI(r, i, n, e, t)
                    );
                  },
                },
                i?.preloadingStrategy
                  ? o9(i.preloadingStrategy).ɵproviders
                  : [],
                { provide: CD, multi: !0, useFactory: l9 },
                i?.initialNavigation ? f9(i) : [],
                [
                  { provide: tR, useFactory: KI },
                  { provide: ED, multi: !0, useExisting: tR },
                ],
              ],
            };
          }
          static forChild(t) {
            return {
              ngModule: n,
              providers: [{ provide: uc, multi: !0, useValue: t }],
            };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(JI, 8));
          }),
          (n.ɵmod = _n({ type: n })),
          (n.ɵinj = cn({ imports: [X0] })),
          n
        );
      })();
      function h9(n) {
        if (zd && n)
          throw new J(
            4007,
            "The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead."
          );
        return "guarded";
      }
      function f9(n) {
        return [
          "disabled" === n.initialNavigation
            ? Po(3, [
                {
                  provide: hp,
                  multi: !0,
                  useFactory: () => {
                    const e = ft(tr);
                    return () => {
                      e.setUpLocationChangeListener();
                    };
                  },
                },
                { provide: rb, useValue: 2 },
              ]).ɵproviders
            : [],
          "enabledBlocking" === n.initialNavigation
            ? Po(2, [
                { provide: rb, useValue: 0 },
                {
                  provide: hp,
                  multi: !0,
                  deps: [Qi],
                  useFactory: (e) => {
                    const t = e.get(d5, Promise.resolve());
                    return () =>
                      t.then(
                        () =>
                          new Promise((i) => {
                            const r = e.get(tr),
                              s = e.get($I);
                            (function t9(n, e) {
                              n.events
                                .pipe(
                                  _i(
                                    (t) =>
                                      t instanceof Sa ||
                                      t instanceof jp ||
                                      t instanceof B0 ||
                                      t instanceof Xp
                                  ),
                                  xt((t) =>
                                    t instanceof Sa || t instanceof Xp
                                      ? nr.COMPLETE
                                      : t instanceof jp &&
                                        (0 === t.code || 1 === t.code)
                                      ? nr.REDIRECTING
                                      : nr.FAILED
                                  ),
                                  _i((t) => t !== nr.REDIRECTING),
                                  er(1)
                                )
                                .subscribe(() => {
                                  e();
                                });
                            })(r, () => {
                              i(!0);
                            }),
                              (e.get(nm).afterPreactivation = () => (
                                i(!0), s.closed ? Ge(void 0) : s
                              )),
                              r.initialNavigation();
                          })
                      );
                  },
                },
              ]).ɵproviders
            : [],
        ];
      }
      const tR = new ye(zd ? "Router Initializer" : "");
      function nR(n, e, t, i, r, s, o) {
        try {
          var a = n[s](o),
            l = a.value;
        } catch (c) {
          return void t(c);
        }
        a.done ? e(l) : Promise.resolve(l).then(i, r);
      }
      function ai(n) {
        return function () {
          var e = this,
            t = arguments;
          return new Promise(function (i, r) {
            var s = n.apply(e, t);
            function o(l) {
              nR(s, i, r, o, a, "next", l);
            }
            function a(l) {
              nR(s, i, r, o, a, "throw", l);
            }
            o(void 0);
          });
        };
      }
      const hc = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
        fc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
        m9 = 0,
        iR = 1,
        g9 = 2,
        rR = 1,
        _9 = 2,
        Ks = 3,
        $s = 0,
        zi = 1,
        Cr = 2,
        Zr = 0,
        pc = 1,
        ob = 2,
        sR = 3,
        oR = 4,
        v9 = 5,
        mc = 100,
        y9 = 101,
        b9 = 102,
        aR = 103,
        lR = 104,
        x9 = 200,
        w9 = 201,
        M9 = 202,
        S9 = 203,
        cR = 204,
        uR = 205,
        E9 = 206,
        C9 = 207,
        T9 = 208,
        A9 = 209,
        D9 = 210,
        I9 = 0,
        R9 = 1,
        P9 = 2,
        ab = 3,
        O9 = 4,
        L9 = 5,
        F9 = 6,
        N9 = 7,
        rm = 0,
        k9 = 1,
        B9 = 2,
        Qs = 0,
        U9 = 1,
        V9 = 2,
        z9 = 3,
        dR = 4,
        H9 = 5,
        Ea = 301,
        Ca = 302,
        Hd = 303,
        sm = 304,
        Gd = 306,
        Js = 1e3,
        Yn = 1001,
        Wd = 1002,
        hn = 1003,
        om = 1004,
        jd = 1005,
        fn = 1006,
        cb = 1007,
        eo = 1008,
        Oo = 1009,
        G9 = 1010,
        W9 = 1011,
        ub = 1012,
        hR = 1013,
        Lo = 1014,
        to = 1015,
        Hi = 1016,
        fR = 1017,
        pR = 1018,
        Ta = 1020,
        j9 = 1021,
        Tr = 1023,
        X9 = 1024,
        q9 = 1025,
        Aa = 1026,
        gc = 1027,
        Y9 = 1028,
        mR = 1029,
        Z9 = 1030,
        gR = 1031,
        _R = 1033,
        db = 33776,
        hb = 33777,
        fb = 33778,
        pb = 33779,
        vR = 35840,
        yR = 35841,
        bR = 35842,
        xR = 35843,
        K9 = 36196,
        wR = 37492,
        MR = 37496,
        SR = 37808,
        ER = 37809,
        CR = 37810,
        TR = 37811,
        AR = 37812,
        DR = 37813,
        IR = 37814,
        RR = 37815,
        PR = 37816,
        OR = 37817,
        LR = 37818,
        FR = 37819,
        NR = 37820,
        kR = 37821,
        mb = 36492,
        $9 = 36283,
        BR = 36284,
        UR = 36285,
        VR = 36286,
        Xd = 2300,
        _c = 2301,
        vc = 2400,
        yc = 2401,
        J9 = 0,
        WR = 1,
        vb = 2,
        Fo = 3001,
        XR = 3201,
        Da = 0,
        tX = 1,
        Ia = "",
        qe = "srgb",
        Kr = "srgb-linear",
        qR = "display-p3",
        iX = 512,
        rX = 513,
        sX = 514,
        oX = 515,
        aX = 516,
        lX = 517,
        cX = 518,
        uX = 519,
        YR = "300 es",
        bb = 1035,
        no = 2e3;
      class No {
        addEventListener(e, t) {
          void 0 === this._listeners && (this._listeners = {});
          const i = this._listeners;
          void 0 === i[e] && (i[e] = []),
            -1 === i[e].indexOf(t) && i[e].push(t);
        }
        hasEventListener(e, t) {
          if (void 0 === this._listeners) return !1;
          const i = this._listeners;
          return void 0 !== i[e] && -1 !== i[e].indexOf(t);
        }
        removeEventListener(e, t) {
          if (void 0 === this._listeners) return;
          const r = this._listeners[e];
          if (void 0 !== r) {
            const s = r.indexOf(t);
            -1 !== s && r.splice(s, 1);
          }
        }
        dispatchEvent(e) {
          if (void 0 === this._listeners) return;
          const i = this._listeners[e.type];
          if (void 0 !== i) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
            e.target = null;
          }
        }
      }
      const vi = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff",
      ];
      let ZR = 1234567;
      const Ra = Math.PI / 180,
        bc = 180 / Math.PI;
      function ir() {
        const n = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          t = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          vi[255 & n] +
          vi[(n >> 8) & 255] +
          vi[(n >> 16) & 255] +
          vi[(n >> 24) & 255] +
          "-" +
          vi[255 & e] +
          vi[(e >> 8) & 255] +
          "-" +
          vi[((e >> 16) & 15) | 64] +
          vi[(e >> 24) & 255] +
          "-" +
          vi[(63 & t) | 128] +
          vi[(t >> 8) & 255] +
          "-" +
          vi[(t >> 16) & 255] +
          vi[(t >> 24) & 255] +
          vi[255 & i] +
          vi[(i >> 8) & 255] +
          vi[(i >> 16) & 255] +
          vi[(i >> 24) & 255]
        ).toLowerCase();
      }
      function bn(n, e, t) {
        return Math.max(e, Math.min(t, n));
      }
      function xb(n, e) {
        return ((n % e) + e) % e;
      }
      function qd(n, e, t) {
        return (1 - t) * n + t * e;
      }
      function wb(n) {
        return 0 == (n & (n - 1)) && 0 !== n;
      }
      function KR(n) {
        return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
      }
      function um(n) {
        return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
      }
      function rr(n, e) {
        switch (e.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return n / 4294967295;
          case Uint16Array:
            return n / 65535;
          case Uint8Array:
            return n / 255;
          case Int32Array:
            return Math.max(n / 2147483647, -1);
          case Int16Array:
            return Math.max(n / 32767, -1);
          case Int8Array:
            return Math.max(n / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function _t(n, e) {
        switch (e.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return Math.round(4294967295 * n);
          case Uint16Array:
            return Math.round(65535 * n);
          case Uint8Array:
            return Math.round(255 * n);
          case Int32Array:
            return Math.round(2147483647 * n);
          case Int16Array:
            return Math.round(32767 * n);
          case Int8Array:
            return Math.round(127 * n);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const $r = {
        DEG2RAD: Ra,
        RAD2DEG: bc,
        generateUUID: ir,
        clamp: bn,
        euclideanModulo: xb,
        mapLinear: function dX(n, e, t, i, r) {
          return i + ((n - e) * (r - i)) / (t - e);
        },
        inverseLerp: function hX(n, e, t) {
          return n !== e ? (t - n) / (e - n) : 0;
        },
        lerp: qd,
        damp: function fX(n, e, t, i) {
          return qd(n, e, 1 - Math.exp(-t * i));
        },
        pingpong: function pX(n, e = 1) {
          return e - Math.abs(xb(n, 2 * e) - e);
        },
        smoothstep: function mX(n, e, t) {
          return n <= e
            ? 0
            : n >= t
            ? 1
            : (n = (n - e) / (t - e)) * n * (3 - 2 * n);
        },
        smootherstep: function gX(n, e, t) {
          return n <= e
            ? 0
            : n >= t
            ? 1
            : (n = (n - e) / (t - e)) * n * n * (n * (6 * n - 15) + 10);
        },
        randInt: function _X(n, e) {
          return n + Math.floor(Math.random() * (e - n + 1));
        },
        randFloat: function vX(n, e) {
          return n + Math.random() * (e - n);
        },
        randFloatSpread: function yX(n) {
          return n * (0.5 - Math.random());
        },
        seededRandom: function bX(n) {
          void 0 !== n && (ZR = n);
          let e = (ZR += 1831565813);
          return (
            (e = Math.imul(e ^ (e >>> 15), 1 | e)),
            (e ^= e + Math.imul(e ^ (e >>> 7), 61 | e)),
            ((e ^ (e >>> 14)) >>> 0) / 4294967296
          );
        },
        degToRad: function xX(n) {
          return n * Ra;
        },
        radToDeg: function wX(n) {
          return n * bc;
        },
        isPowerOfTwo: wb,
        ceilPowerOfTwo: KR,
        floorPowerOfTwo: um,
        setQuaternionFromProperEuler: function MX(n, e, t, i, r) {
          const s = Math.cos,
            o = Math.sin,
            a = s(t / 2),
            l = o(t / 2),
            c = s((e + i) / 2),
            u = o((e + i) / 2),
            d = s((e - i) / 2),
            h = o((e - i) / 2),
            f = s((i - e) / 2),
            p = o((i - e) / 2);
          switch (r) {
            case "XYX":
              n.set(a * u, l * d, l * h, a * c);
              break;
            case "YZY":
              n.set(l * h, a * u, l * d, a * c);
              break;
            case "ZXZ":
              n.set(l * d, l * h, a * u, a * c);
              break;
            case "XZX":
              n.set(a * u, l * p, l * f, a * c);
              break;
            case "YXY":
              n.set(l * f, a * u, l * p, a * c);
              break;
            case "ZYZ":
              n.set(l * p, l * f, a * u, a * c);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                  r
              );
          }
        },
        normalize: _t,
        denormalize: rr,
      };
      class $ {
        constructor(e = 0, t = 0) {
          ($.prototype.isVector2 = !0), (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            i = this.y,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * i + r[6]),
            (this.y = r[1] * t + r[4] * i + r[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(e, Math.min(t, i))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(bn(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            i = this.y - e.y;
          return t * t + i * i;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, i) {
          return (
            (this.x = e.x + (t.x - e.x) * i),
            (this.y = e.y + (t.y - e.y) * i),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t) {
          return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
        }
        rotateAround(e, t) {
          const i = Math.cos(t),
            r = Math.sin(t),
            s = this.x - e.x,
            o = this.y - e.y;
          return (
            (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class vt {
        constructor(e, t, i, r, s, o, a, l, c) {
          (vt.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            void 0 !== e && this.set(e, t, i, r, s, o, a, l, c);
        }
        set(e, t, i, r, s, o, a, l, c) {
          const u = this.elements;
          return (
            (u[0] = e),
            (u[1] = r),
            (u[2] = a),
            (u[3] = t),
            (u[4] = s),
            (u[5] = l),
            (u[6] = i),
            (u[7] = o),
            (u[8] = c),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            i = e.elements;
          return (
            (t[0] = i[0]),
            (t[1] = i[1]),
            (t[2] = i[2]),
            (t[3] = i[3]),
            (t[4] = i[4]),
            (t[5] = i[5]),
            (t[6] = i[6]),
            (t[7] = i[7]),
            (t[8] = i[8]),
            this
          );
        }
        extractBasis(e, t, i) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            i.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[3],
            l = i[6],
            c = i[1],
            u = i[4],
            d = i[7],
            h = i[2],
            f = i[5],
            p = i[8],
            _ = r[0],
            m = r[3],
            g = r[6],
            y = r[1],
            v = r[4],
            b = r[7],
            x = r[2],
            M = r[5],
            S = r[8];
          return (
            (s[0] = o * _ + a * y + l * x),
            (s[3] = o * m + a * v + l * M),
            (s[6] = o * g + a * b + l * S),
            (s[1] = c * _ + u * y + d * x),
            (s[4] = c * m + u * v + d * M),
            (s[7] = c * g + u * b + d * S),
            (s[2] = h * _ + f * y + p * x),
            (s[5] = h * m + f * v + p * M),
            (s[8] = h * g + f * b + p * S),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8];
          return (
            t * o * u -
            t * a * c -
            i * s * u +
            i * a * l +
            r * s * c -
            r * o * l
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            d = u * o - a * c,
            h = a * l - u * s,
            f = c * s - o * l,
            p = t * d + i * h + r * f;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const _ = 1 / p;
          return (
            (e[0] = d * _),
            (e[1] = (r * c - u * i) * _),
            (e[2] = (a * i - r * o) * _),
            (e[3] = h * _),
            (e[4] = (u * t - r * l) * _),
            (e[5] = (r * s - a * t) * _),
            (e[6] = f * _),
            (e[7] = (i * l - c * t) * _),
            (e[8] = (o * t - i * s) * _),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, i, r, s, o, a) {
          const l = Math.cos(s),
            c = Math.sin(s);
          return (
            this.set(
              i * l,
              i * c,
              -i * (l * o + c * a) + o + e,
              -r * c,
              r * l,
              -r * (-c * o + l * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          return this.premultiply(Mb.makeScale(e, t)), this;
        }
        rotate(e) {
          return this.premultiply(Mb.makeRotation(-e)), this;
        }
        translate(e, t) {
          return this.premultiply(Mb.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
          return (
            e.isVector2
              ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
              : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
            this
          );
        }
        makeRotation(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
          const t = this.elements,
            i = e.elements;
          for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return (
            (e[t] = i[0]),
            (e[t + 1] = i[1]),
            (e[t + 2] = i[2]),
            (e[t + 3] = i[3]),
            (e[t + 4] = i[4]),
            (e[t + 5] = i[5]),
            (e[t + 6] = i[6]),
            (e[t + 7] = i[7]),
            (e[t + 8] = i[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const Mb = new vt();
      function $R(n) {
        for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
        return !1;
      }
      function Yd(n) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", n);
      }
      Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
      const QR = {};
      function Zd(n) {
        n in QR || ((QR[n] = !0), console.warn(n));
      }
      function wc(n) {
        return n < 0.04045
          ? 0.0773993808 * n
          : Math.pow(0.9478672986 * n + 0.0521327014, 2.4);
      }
      function Sb(n) {
        return n < 0.0031308 ? 12.92 * n : 1.055 * Math.pow(n, 0.41666) - 0.055;
      }
      const EX = new vt().fromArray([
          0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974,
          -1e-7, 1e-7, 0.9105199,
        ]),
        CX = new vt().fromArray([
          1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361,
          1e-7, 0, 1.0982735,
        ]),
        DX = {
          [Kr]: (n) => n,
          [qe]: (n) => n.convertSRGBToLinear(),
          [qR]: function TX(n) {
            return n.convertSRGBToLinear().applyMatrix3(CX);
          },
        },
        IX = {
          [Kr]: (n) => n,
          [qe]: (n) => n.convertLinearToSRGB(),
          [qR]: function AX(n) {
            return n.applyMatrix3(EX).convertLinearToSRGB();
          },
        },
        Qr = {
          enabled: !0,
          get legacyMode() {
            return (
              console.warn(
                "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
              ),
              !this.enabled
            );
          },
          set legacyMode(n) {
            console.warn(
              "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
            ),
              (this.enabled = !n);
          },
          get workingColorSpace() {
            return Kr;
          },
          set workingColorSpace(n) {
            console.warn(
              "THREE.ColorManagement: .workingColorSpace is readonly."
            );
          },
          convert: function (n, e, t) {
            if (!1 === this.enabled || e === t || !e || !t) return n;
            const i = DX[e],
              r = IX[t];
            if (void 0 === i || void 0 === r)
              throw new Error(
                `Unsupported color space conversion, "${e}" to "${t}".`
              );
            return r(i(n));
          },
          fromWorkingColorSpace: function (n, e) {
            return this.convert(n, this.workingColorSpace, e);
          },
          toWorkingColorSpace: function (n, e) {
            return this.convert(n, e, this.workingColorSpace);
          },
        };
      let Mc;
      class JR {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            void 0 === Mc && (Mc = Yd("canvas")),
              (Mc.width = e.width),
              (Mc.height = e.height);
            const i = Mc.getContext("2d");
            e instanceof ImageData
              ? i.putImageData(e, 0, 0)
              : i.drawImage(e, 0, 0, e.width, e.height),
              (t = Mc);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (
            (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
            (typeof HTMLCanvasElement < "u" &&
              e instanceof HTMLCanvasElement) ||
            (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
          ) {
            const t = Yd("canvas");
            (t.width = e.width), (t.height = e.height);
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height),
              s = r.data;
            for (let o = 0; o < s.length; o++) s[o] = 255 * wc(s[o] / 255);
            return i.putImageData(r, 0, 0), t;
          }
          if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
              t[i] =
                t instanceof Uint8Array || t instanceof Uint8ClampedArray
                  ? Math.floor(255 * wc(t[i] / 255))
                  : wc(t[i]);
            return { data: t, width: e.width, height: e.height };
          }
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
            ),
            e
          );
        }
      }
      let RX = 0;
      class Sc {
        constructor(e = null) {
          (this.isSource = !0),
            Object.defineProperty(this, "id", { value: RX++ }),
            (this.uuid = ir()),
            (this.data = e),
            (this.version = 0);
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
          const i = { uuid: this.uuid, url: "" },
            r = this.data;
          if (null !== r) {
            let s;
            if (Array.isArray(r)) {
              s = [];
              for (let o = 0, a = r.length; o < a; o++)
                s.push(Eb(r[o].isDataTexture ? r[o].image : r[o]));
            } else s = Eb(r);
            i.url = s;
          }
          return t || (e.images[this.uuid] = i), i;
        }
      }
      function Eb(n) {
        return (typeof HTMLImageElement < "u" &&
          n instanceof HTMLImageElement) ||
          (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
          (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
          ? JR.getDataURL(n)
          : n.data
          ? {
              data: Array.from(n.data),
              width: n.width,
              height: n.height,
              type: n.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let PX = 0,
        Ai = (() => {
          class n extends No {
            constructor(
              t = n.DEFAULT_IMAGE,
              i = n.DEFAULT_MAPPING,
              r = Yn,
              s = Yn,
              o = fn,
              a = eo,
              l = Tr,
              c = Oo,
              u = n.DEFAULT_ANISOTROPY,
              d = Ia
            ) {
              super(),
                (this.isTexture = !0),
                Object.defineProperty(this, "id", { value: PX++ }),
                (this.uuid = ir()),
                (this.name = ""),
                (this.source = new Sc(t)),
                (this.mipmaps = []),
                (this.mapping = i),
                (this.channel = 0),
                (this.wrapS = r),
                (this.wrapT = s),
                (this.magFilter = o),
                (this.minFilter = a),
                (this.anisotropy = u),
                (this.format = l),
                (this.internalFormat = null),
                (this.type = c),
                (this.offset = new $(0, 0)),
                (this.repeat = new $(1, 1)),
                (this.center = new $(0, 0)),
                (this.rotation = 0),
                (this.matrixAutoUpdate = !0),
                (this.matrix = new vt()),
                (this.generateMipmaps = !0),
                (this.premultiplyAlpha = !1),
                (this.flipY = !0),
                (this.unpackAlignment = 4),
                "string" == typeof d
                  ? (this.colorSpace = d)
                  : (Zd(
                      "THREE.Texture: Property .encoding has been replaced by .colorSpace."
                    ),
                    (this.colorSpace = d === Fo ? qe : Ia)),
                (this.userData = {}),
                (this.version = 0),
                (this.onUpdate = null),
                (this.isRenderTargetTexture = !1),
                (this.needsPMREMUpdate = !1);
            }
            get image() {
              return this.source.data;
            }
            set image(t = null) {
              this.source.data = t;
            }
            updateMatrix() {
              this.matrix.setUvTransform(
                this.offset.x,
                this.offset.y,
                this.repeat.x,
                this.repeat.y,
                this.rotation,
                this.center.x,
                this.center.y
              );
            }
            clone() {
              return new this.constructor().copy(this);
            }
            copy(t) {
              return (
                (this.name = t.name),
                (this.source = t.source),
                (this.mipmaps = t.mipmaps.slice(0)),
                (this.mapping = t.mapping),
                (this.channel = t.channel),
                (this.wrapS = t.wrapS),
                (this.wrapT = t.wrapT),
                (this.magFilter = t.magFilter),
                (this.minFilter = t.minFilter),
                (this.anisotropy = t.anisotropy),
                (this.format = t.format),
                (this.internalFormat = t.internalFormat),
                (this.type = t.type),
                this.offset.copy(t.offset),
                this.repeat.copy(t.repeat),
                this.center.copy(t.center),
                (this.rotation = t.rotation),
                (this.matrixAutoUpdate = t.matrixAutoUpdate),
                this.matrix.copy(t.matrix),
                (this.generateMipmaps = t.generateMipmaps),
                (this.premultiplyAlpha = t.premultiplyAlpha),
                (this.flipY = t.flipY),
                (this.unpackAlignment = t.unpackAlignment),
                (this.colorSpace = t.colorSpace),
                (this.userData = JSON.parse(JSON.stringify(t.userData))),
                (this.needsUpdate = !0),
                this
              );
            }
            toJSON(t) {
              const i = void 0 === t || "string" == typeof t;
              if (!i && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
              const r = {
                metadata: {
                  version: 4.6,
                  type: "Texture",
                  generator: "Texture.toJSON",
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(t).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment,
              };
              return (
                Object.keys(this.userData).length > 0 &&
                  (r.userData = this.userData),
                i || (t.textures[this.uuid] = r),
                r
              );
            }
            dispose() {
              this.dispatchEvent({ type: "dispose" });
            }
            transformUv(t) {
              if (300 !== this.mapping) return t;
              if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                switch (this.wrapS) {
                  case Js:
                    t.x = t.x - Math.floor(t.x);
                    break;
                  case Yn:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                  case Wd:
                    t.x =
                      1 === Math.abs(Math.floor(t.x) % 2)
                        ? Math.ceil(t.x) - t.x
                        : t.x - Math.floor(t.x);
                }
              if (t.y < 0 || t.y > 1)
                switch (this.wrapT) {
                  case Js:
                    t.y = t.y - Math.floor(t.y);
                    break;
                  case Yn:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                  case Wd:
                    t.y =
                      1 === Math.abs(Math.floor(t.y) % 2)
                        ? Math.ceil(t.y) - t.y
                        : t.y - Math.floor(t.y);
                }
              return this.flipY && (t.y = 1 - t.y), t;
            }
            set needsUpdate(t) {
              !0 === t && (this.version++, (this.source.needsUpdate = !0));
            }
            get encoding() {
              return (
                Zd(
                  "THREE.Texture: Property .encoding has been replaced by .colorSpace."
                ),
                this.colorSpace === qe ? Fo : 3e3
              );
            }
            set encoding(t) {
              Zd(
                "THREE.Texture: Property .encoding has been replaced by .colorSpace."
              ),
                (this.colorSpace = t === Fo ? qe : Ia);
            }
          }
          return (
            (n.DEFAULT_IMAGE = null),
            (n.DEFAULT_MAPPING = 300),
            (n.DEFAULT_ANISOTROPY = 1),
            n
          );
        })();
      class Ft {
        constructor(e = 0, t = 0, i = 0, r = 1) {
          (Ft.prototype.isVector4 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = i),
            (this.w = r);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, i, r) {
          return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = void 0 !== e.w ? e.w : 1),
            this
          );
        }
        add(e) {
          return (
            (this.x += e.x),
            (this.y += e.y),
            (this.z += e.z),
            (this.w += e.w),
            this
          );
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e) {
          return (
            (this.x -= e.x),
            (this.y -= e.y),
            (this.z -= e.z),
            (this.w -= e.w),
            this
          );
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = this.w,
            o = e.elements;
          return (
            (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
            (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
            (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
            (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, i, r, s;
          const l = e.elements,
            c = l[0],
            u = l[4],
            d = l[8],
            h = l[1],
            f = l[5],
            p = l[9],
            _ = l[2],
            m = l[6],
            g = l[10];
          if (
            Math.abs(u - h) < 0.01 &&
            Math.abs(d - _) < 0.01 &&
            Math.abs(p - m) < 0.01
          ) {
            if (
              Math.abs(u + h) < 0.1 &&
              Math.abs(d + _) < 0.1 &&
              Math.abs(p + m) < 0.1 &&
              Math.abs(c + f + g - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const v = (c + 1) / 2,
              b = (f + 1) / 2,
              x = (g + 1) / 2,
              M = (u + h) / 4,
              S = (d + _) / 4,
              C = (p + m) / 4;
            return (
              v > b && v > x
                ? v < 0.01
                  ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
                  : ((i = Math.sqrt(v)), (r = M / i), (s = S / i))
                : b > x
                ? b < 0.01
                  ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
                  : ((r = Math.sqrt(b)), (i = M / r), (s = C / r))
                : x < 0.01
                ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
                : ((s = Math.sqrt(x)), (i = S / s), (r = C / s)),
              this.set(i, r, s, t),
              this
            );
          }
          let y = Math.sqrt(
            (m - p) * (m - p) + (d - _) * (d - _) + (h - u) * (h - u)
          );
          return (
            Math.abs(y) < 0.001 && (y = 1),
            (this.x = (m - p) / y),
            (this.y = (d - _) / y),
            (this.z = (h - u) / y),
            (this.w = Math.acos((c + f + g - 1) / 2)),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(e, Math.min(t, i))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, i) {
          return (
            (this.x = e.x + (t.x - e.x) * i),
            (this.y = e.y + (t.y - e.y) * i),
            (this.z = e.z + (t.z - e.z) * i),
            (this.w = e.w + (t.w - e.w) * i),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class li extends No {
        constructor(e = 1, t = 1, i = {}) {
          super(),
            (this.isWebGLRenderTarget = !0),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new Ft(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new Ft(0, 0, e, t));
          const r = { width: e, height: t, depth: 1 };
          void 0 !== i.encoding &&
            (Zd(
              "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
            ),
            (i.colorSpace = i.encoding === Fo ? qe : Ia)),
            (this.texture = new Ai(
              r,
              i.mapping,
              i.wrapS,
              i.wrapT,
              i.magFilter,
              i.minFilter,
              i.format,
              i.type,
              i.anisotropy,
              i.colorSpace
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.flipY = !1),
            (this.texture.generateMipmaps =
              void 0 !== i.generateMipmaps && i.generateMipmaps),
            (this.texture.internalFormat =
              void 0 !== i.internalFormat ? i.internalFormat : null),
            (this.texture.minFilter =
              void 0 !== i.minFilter ? i.minFilter : fn),
            (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
            (this.stencilBuffer =
              void 0 !== i.stencilBuffer && i.stencilBuffer),
            (this.depthTexture =
              void 0 !== i.depthTexture ? i.depthTexture : null),
            (this.samples = void 0 !== i.samples ? i.samples : 0);
        }
        setSize(e, t, i = 1) {
          (this.width !== e || this.height !== t || this.depth !== i) &&
            ((this.width = e),
            (this.height = t),
            (this.depth = i),
            (this.texture.image.width = e),
            (this.texture.image.height = t),
            (this.texture.image.depth = i),
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.scissor.copy(e.scissor),
            (this.scissorTest = e.scissorTest),
            this.viewport.copy(e.viewport),
            (this.texture = e.texture.clone()),
            (this.texture.isRenderTargetTexture = !0);
          const t = Object.assign({}, e.texture.image);
          return (
            (this.texture.source = new Sc(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            null !== e.depthTexture &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class Cb extends Ai {
        constructor(e = null, t = 1, i = 1, r = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: e, width: t, height: i, depth: r }),
            (this.magFilter = hn),
            (this.minFilter = hn),
            (this.wrapR = Yn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class eP extends Ai {
        constructor(e = null, t = 1, i = 1, r = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: e, width: t, height: i, depth: r }),
            (this.magFilter = hn),
            (this.minFilter = hn),
            (this.wrapR = Yn),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class An {
        constructor(e = 0, t = 0, i = 0, r = 1) {
          (this.isQuaternion = !0),
            (this._x = e),
            (this._y = t),
            (this._z = i),
            (this._w = r);
        }
        static slerpFlat(e, t, i, r, s, o, a) {
          let l = i[r + 0],
            c = i[r + 1],
            u = i[r + 2],
            d = i[r + 3];
          const h = s[o + 0],
            f = s[o + 1],
            p = s[o + 2],
            _ = s[o + 3];
          if (0 === a)
            return (
              (e[t + 0] = l),
              (e[t + 1] = c),
              (e[t + 2] = u),
              void (e[t + 3] = d)
            );
          if (1 === a)
            return (
              (e[t + 0] = h),
              (e[t + 1] = f),
              (e[t + 2] = p),
              void (e[t + 3] = _)
            );
          if (d !== _ || l !== h || c !== f || u !== p) {
            let m = 1 - a;
            const g = l * h + c * f + u * p + d * _,
              y = g >= 0 ? 1 : -1,
              v = 1 - g * g;
            if (v > Number.EPSILON) {
              const x = Math.sqrt(v),
                M = Math.atan2(x, g * y);
              (m = Math.sin(m * M) / x), (a = Math.sin(a * M) / x);
            }
            const b = a * y;
            if (
              ((l = l * m + h * b),
              (c = c * m + f * b),
              (u = u * m + p * b),
              (d = d * m + _ * b),
              m === 1 - a)
            ) {
              const x = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
              (l *= x), (c *= x), (u *= x), (d *= x);
            }
          }
          (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = d);
        }
        static multiplyQuaternionsFlat(e, t, i, r, s, o) {
          const a = i[r],
            l = i[r + 1],
            c = i[r + 2],
            u = i[r + 3],
            d = s[o],
            h = s[o + 1],
            f = s[o + 2],
            p = s[o + 3];
          return (
            (e[t] = a * p + u * d + l * f - c * h),
            (e[t + 1] = l * p + u * h + c * d - a * f),
            (e[t + 2] = c * p + u * f + a * h - l * d),
            (e[t + 3] = u * p - a * d - l * h - c * f),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, i, r) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = i),
            (this._w = r),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t) {
          const i = e._x,
            r = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(i / 2),
            u = a(r / 2),
            d = a(s / 2),
            h = l(i / 2),
            f = l(r / 2),
            p = l(s / 2);
          switch (o) {
            case "XYZ":
              (this._x = h * u * d + c * f * p),
                (this._y = c * f * d - h * u * p),
                (this._z = c * u * p + h * f * d),
                (this._w = c * u * d - h * f * p);
              break;
            case "YXZ":
              (this._x = h * u * d + c * f * p),
                (this._y = c * f * d - h * u * p),
                (this._z = c * u * p - h * f * d),
                (this._w = c * u * d + h * f * p);
              break;
            case "ZXY":
              (this._x = h * u * d - c * f * p),
                (this._y = c * f * d + h * u * p),
                (this._z = c * u * p + h * f * d),
                (this._w = c * u * d - h * f * p);
              break;
            case "ZYX":
              (this._x = h * u * d - c * f * p),
                (this._y = c * f * d + h * u * p),
                (this._z = c * u * p - h * f * d),
                (this._w = c * u * d + h * f * p);
              break;
            case "YZX":
              (this._x = h * u * d + c * f * p),
                (this._y = c * f * d + h * u * p),
                (this._z = c * u * p - h * f * d),
                (this._w = c * u * d - h * f * p);
              break;
            case "XZY":
              (this._x = h * u * d - c * f * p),
                (this._y = c * f * d - h * u * p),
                (this._z = c * u * p + h * f * d),
                (this._w = c * u * d + h * f * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  o
              );
          }
          return !1 !== t && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const i = t / 2,
            r = Math.sin(i);
          return (
            (this._x = e.x * r),
            (this._y = e.y * r),
            (this._z = e.z * r),
            (this._w = Math.cos(i)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            i = t[0],
            r = t[4],
            s = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            u = t[6],
            d = t[10],
            h = i + a + d;
          if (h > 0) {
            const f = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / f),
              (this._x = (u - l) * f),
              (this._y = (s - c) * f),
              (this._z = (o - r) * f);
          } else if (i > a && i > d) {
            const f = 2 * Math.sqrt(1 + i - a - d);
            (this._w = (u - l) / f),
              (this._x = 0.25 * f),
              (this._y = (r + o) / f),
              (this._z = (s + c) / f);
          } else if (a > d) {
            const f = 2 * Math.sqrt(1 + a - i - d);
            (this._w = (s - c) / f),
              (this._x = (r + o) / f),
              (this._y = 0.25 * f),
              (this._z = (l + u) / f);
          } else {
            const f = 2 * Math.sqrt(1 + d - i - a);
            (this._w = (o - r) / f),
              (this._x = (s + c) / f),
              (this._y = (l + u) / f),
              (this._z = 0.25 * f);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let i = e.dot(t) + 1;
          return (
            i < Number.EPSILON
              ? ((i = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = i))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = i)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = i)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(bn(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const i = this.angleTo(e);
          if (0 === i) return this;
          const r = Math.min(1, t / i);
          return this.slerp(e, r), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            0 === e
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const i = e._x,
            r = e._y,
            s = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            u = t._w;
          return (
            (this._x = i * u + o * a + r * c - s * l),
            (this._y = r * u + o * l + s * a - i * c),
            (this._z = s * u + o * c + i * l - r * a),
            (this._w = o * u - i * a - r * l - s * c),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (0 === t) return this;
          if (1 === t) return this.copy(e);
          const i = this._x,
            r = this._y,
            s = this._z,
            o = this._w;
          let a = o * e._w + i * e._x + r * e._y + s * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = i), (this._y = r), (this._z = s), this
            );
          const l = 1 - a * a;
          if (l <= Number.EPSILON) {
            const f = 1 - t;
            return (
              (this._w = f * o + t * this._w),
              (this._x = f * i + t * this._x),
              (this._y = f * r + t * this._y),
              (this._z = f * s + t * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const c = Math.sqrt(l),
            u = Math.atan2(c, a),
            d = Math.sin((1 - t) * u) / c,
            h = Math.sin(t * u) / c;
          return (
            (this._w = o * d + this._w * h),
            (this._x = i * d + this._x * h),
            (this._y = r * d + this._y * h),
            (this._z = s * d + this._z * h),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, i) {
          return this.copy(e).slerp(t, i);
        }
        random() {
          const e = Math.random(),
            t = Math.sqrt(1 - e),
            i = Math.sqrt(e),
            r = 2 * Math.PI * Math.random(),
            s = 2 * Math.PI * Math.random();
          return this.set(
            t * Math.cos(r),
            i * Math.sin(s),
            i * Math.cos(s),
            t * Math.sin(r)
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this
          );
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class A {
        constructor(e = 0, t = 0, i = 0) {
          (A.prototype.isVector3 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = i);
        }
        set(e, t, i) {
          return (
            void 0 === i && (i = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = i),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return this.applyQuaternion(tP.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(tP.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[3] * i + s[6] * r),
            (this.y = s[1] * t + s[4] * i + s[7] * r),
            (this.z = s[2] * t + s[5] * i + s[8] * r),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements,
            o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
          return (
            (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
            (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
            (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = l * t + o * r - a * i,
            u = l * i + a * t - s * r,
            d = l * r + s * i - o * t,
            h = -s * t - o * i - a * r;
          return (
            (this.x = c * l + h * -s + u * -a - d * -o),
            (this.y = u * l + h * -o + d * -s - c * -a),
            (this.z = d * l + h * -a + c * -o - u * -s),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            i = this.y,
            r = this.z,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[4] * i + s[8] * r),
            (this.y = s[1] * t + s[5] * i + s[9] * r),
            (this.z = s[2] * t + s[6] * i + s[10] * r),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(
            Math.max(e, Math.min(t, i))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, i) {
          return (
            (this.x = e.x + (t.x - e.x) * i),
            (this.y = e.y + (t.y - e.y) * i),
            (this.z = e.z + (t.z - e.z) * i),
            this
          );
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const i = e.x,
            r = e.y,
            s = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
          return (
            (this.x = r * l - s * a),
            (this.y = s * o - i * l),
            (this.z = i * a - r * o),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (0 === t) return this.set(0, 0, 0);
          const i = e.dot(this) / t;
          return this.copy(e).multiplyScalar(i);
        }
        projectOnPlane(e) {
          return Tb.copy(this).projectOnVector(e), this.sub(Tb);
        }
        reflect(e) {
          return this.sub(Tb.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(bn(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            i = this.y - e.y,
            r = this.z - e.z;
          return t * t + i * i + r * r;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, i) {
          const r = Math.sin(t) * e;
          return (
            (this.x = r * Math.sin(i)),
            (this.y = Math.cos(t) * e),
            (this.z = r * Math.cos(i)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, i) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = i),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            i = this.setFromMatrixColumn(e, 1).length(),
            r = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = i), (this.z = r), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, 4 * t);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, 3 * t);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        setFromColor(e) {
          return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const e = 2 * (Math.random() - 0.5),
            t = Math.random() * Math.PI * 2,
            i = Math.sqrt(1 - e ** 2);
          return (
            (this.x = i * Math.cos(t)),
            (this.y = i * Math.sin(t)),
            (this.z = e),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const Tb = new A(),
        tP = new An();
      class Ms {
        constructor(
          e = new A(1 / 0, 1 / 0, 1 / 0),
          t = new A(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.isBox3 = !0), (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(ro.fromArray(e, t));
          return this;
        }
        setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(ro.fromBufferAttribute(e, t));
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const i = ro.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          if ((e.updateWorldMatrix(!1, !1), void 0 !== e.boundingBox))
            null === e.boundingBox && e.computeBoundingBox(),
              Ec.copy(e.boundingBox),
              Ec.applyMatrix4(e.matrixWorld),
              this.union(Ec);
          else {
            const r = e.geometry;
            if (void 0 !== r)
              if (
                t &&
                void 0 !== r.attributes &&
                void 0 !== r.attributes.position
              ) {
                const s = r.attributes.position;
                for (let o = 0, a = s.count; o < a; o++)
                  ro.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(ro);
              } else
                null === r.boundingBox && r.computeBoundingBox(),
                  Ec.copy(r.boundingBox),
                  Ec.applyMatrix4(e.matrixWorld),
                  this.union(Ec);
          }
          const i = e.children;
          for (let r = 0, s = i.length; r < s; r++)
            this.expandByObject(i[r], t);
          return this;
        }
        containsPoint(e) {
          return !(
            e.x < this.min.x ||
            e.x > this.max.x ||
            e.y < this.min.y ||
            e.y > this.max.y ||
            e.z < this.min.z ||
            e.z > this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(e) {
          return !(
            e.max.x < this.min.x ||
            e.min.x > this.max.x ||
            e.max.y < this.min.y ||
            e.min.y > this.max.y ||
            e.max.z < this.min.z ||
            e.min.z > this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, ro),
            ro.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, i;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (i += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (i += e.normal.z * this.min.z)),
            t <= -e.constant && i >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(Kd),
            dm.subVectors(this.max, Kd),
            Cc.subVectors(e.a, Kd),
            Tc.subVectors(e.b, Kd),
            Ac.subVectors(e.c, Kd),
            ko.subVectors(Tc, Cc),
            Bo.subVectors(Ac, Tc),
            Pa.subVectors(Cc, Ac);
          let t = [
            0,
            -ko.z,
            ko.y,
            0,
            -Bo.z,
            Bo.y,
            0,
            -Pa.z,
            Pa.y,
            ko.z,
            0,
            -ko.x,
            Bo.z,
            0,
            -Bo.x,
            Pa.z,
            0,
            -Pa.x,
            -ko.y,
            ko.x,
            0,
            -Bo.y,
            Bo.x,
            0,
            -Pa.y,
            Pa.x,
            0,
          ];
          return (
            !(
              !Ab(t, Cc, Tc, Ac, dm) ||
              ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Ab(t, Cc, Tc, Ac, dm))
            ) &&
            (hm.crossVectors(ko, Bo),
            (t = [hm.x, hm.y, hm.z]),
            Ab(t, Cc, Tc, Ac, dm))
          );
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, ro).distanceTo(e);
        }
        getBoundingSphere(e) {
          return (
            this.isEmpty()
              ? e.makeEmpty()
              : (this.getCenter(e.center),
                (e.radius = 0.5 * this.getSize(ro).length())),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return (
            this.isEmpty() ||
              (io[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              io[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              io[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              io[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              io[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              io[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              io[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              io[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(io)),
            this
          );
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const io = [
          new A(),
          new A(),
          new A(),
          new A(),
          new A(),
          new A(),
          new A(),
          new A(),
        ],
        ro = new A(),
        Ec = new Ms(),
        Cc = new A(),
        Tc = new A(),
        Ac = new A(),
        ko = new A(),
        Bo = new A(),
        Pa = new A(),
        Kd = new A(),
        dm = new A(),
        hm = new A(),
        Oa = new A();
      function Ab(n, e, t, i, r) {
        for (let s = 0, o = n.length - 3; s <= o; s += 3) {
          Oa.fromArray(n, s);
          const a =
              r.x * Math.abs(Oa.x) +
              r.y * Math.abs(Oa.y) +
              r.z * Math.abs(Oa.z),
            l = e.dot(Oa),
            c = t.dot(Oa),
            u = i.dot(Oa);
          if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
        }
        return !0;
      }
      const OX = new Ms(),
        $d = new A(),
        Db = new A();
      class Jr {
        constructor(e = new A(), t = -1) {
          (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const i = this.center;
          void 0 !== t ? i.copy(t) : OX.setFromPoints(e).getCenter(i);
          let r = 0;
          for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
          return (this.radius = Math.sqrt(r)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const i = this.center.distanceToSquared(e);
          return (
            t.copy(e),
            i > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          if (this.isEmpty())
            return this.center.copy(e), (this.radius = 0), this;
          $d.subVectors(e, this.center);
          const t = $d.lengthSq();
          if (t > this.radius * this.radius) {
            const i = Math.sqrt(t),
              r = 0.5 * (i - this.radius);
            this.center.addScaledVector($d, r / i), (this.radius += r);
          }
          return this;
        }
        union(e) {
          return e.isEmpty()
            ? this
            : this.isEmpty()
            ? (this.copy(e), this)
            : (!0 === this.center.equals(e.center)
                ? (this.radius = Math.max(this.radius, e.radius))
                : (Db.subVectors(e.center, this.center).setLength(e.radius),
                  this.expandByPoint($d.copy(e.center).add(Db)),
                  this.expandByPoint($d.copy(e.center).sub(Db))),
              this);
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const so = new A(),
        Ib = new A(),
        fm = new A(),
        Uo = new A(),
        Rb = new A(),
        pm = new A(),
        Pb = new A();
      class Qd {
        constructor(e = new A(), t = new A(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, so)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const i = t.dot(this.direction);
          return i < 0
            ? t.copy(this.origin)
            : t.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = so.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (so.copy(this.origin).addScaledVector(this.direction, t),
              so.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, i, r) {
          Ib.copy(e).add(t).multiplyScalar(0.5),
            fm.copy(t).sub(e).normalize(),
            Uo.copy(this.origin).sub(Ib);
          const s = 0.5 * e.distanceTo(t),
            o = -this.direction.dot(fm),
            a = Uo.dot(this.direction),
            l = -Uo.dot(fm),
            c = Uo.lengthSq(),
            u = Math.abs(1 - o * o);
          let d, h, f, p;
          if (u > 0)
            if (((d = o * l - a), (h = o * a - l), (p = s * u), d >= 0))
              if (h >= -p)
                if (h <= p) {
                  const _ = 1 / u;
                  (d *= _),
                    (h *= _),
                    (f = d * (d + o * h + 2 * a) + h * (o * d + h + 2 * l) + c);
                } else
                  (h = s),
                    (d = Math.max(0, -(o * h + a))),
                    (f = -d * d + h * (h + 2 * l) + c);
              else
                (h = -s),
                  (d = Math.max(0, -(o * h + a))),
                  (f = -d * d + h * (h + 2 * l) + c);
            else
              h <= -p
                ? ((d = Math.max(0, -(-o * s + a))),
                  (h = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
                  (f = -d * d + h * (h + 2 * l) + c))
                : h <= p
                ? ((d = 0),
                  (h = Math.min(Math.max(-s, -l), s)),
                  (f = h * (h + 2 * l) + c))
                : ((d = Math.max(0, -(o * s + a))),
                  (h = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
                  (f = -d * d + h * (h + 2 * l) + c));
          else
            (h = o > 0 ? -s : s),
              (d = Math.max(0, -(o * h + a))),
              (f = -d * d + h * (h + 2 * l) + c);
          return (
            i && i.copy(this.origin).addScaledVector(this.direction, d),
            r && r.copy(Ib).addScaledVector(fm, h),
            f
          );
        }
        intersectSphere(e, t) {
          so.subVectors(e.center, this.origin);
          const i = so.dot(this.direction),
            r = so.dot(so) - i * i,
            s = e.radius * e.radius;
          if (r > s) return null;
          const o = Math.sqrt(s - r),
            a = i - o,
            l = i + o;
          return l < 0 ? null : this.at(a < 0 ? l : a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          const i = -(this.origin.dot(e.normal) + e.constant) / t;
          return i >= 0 ? i : null;
        }
        intersectPlane(e, t) {
          const i = this.distanceToPlane(e);
          return null === i ? null : this.at(i, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return 0 === t || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let i, r, s, o, a, l;
          const c = 1 / this.direction.x,
            u = 1 / this.direction.y,
            d = 1 / this.direction.z,
            h = this.origin;
          return (
            c >= 0
              ? ((i = (e.min.x - h.x) * c), (r = (e.max.x - h.x) * c))
              : ((i = (e.max.x - h.x) * c), (r = (e.min.x - h.x) * c)),
            u >= 0
              ? ((s = (e.min.y - h.y) * u), (o = (e.max.y - h.y) * u))
              : ((s = (e.max.y - h.y) * u), (o = (e.min.y - h.y) * u)),
            i > o ||
            s > r ||
            ((s > i || isNaN(i)) && (i = s),
            (o < r || isNaN(r)) && (r = o),
            d >= 0
              ? ((a = (e.min.z - h.z) * d), (l = (e.max.z - h.z) * d))
              : ((a = (e.max.z - h.z) * d), (l = (e.min.z - h.z) * d)),
            i > l || a > r) ||
            ((a > i || i != i) && (i = a), (l < r || r != r) && (r = l), r < 0)
              ? null
              : this.at(i >= 0 ? i : r, t)
          );
        }
        intersectsBox(e) {
          return null !== this.intersectBox(e, so);
        }
        intersectTriangle(e, t, i, r, s) {
          Rb.subVectors(t, e), pm.subVectors(i, e), Pb.crossVectors(Rb, pm);
          let a,
            o = this.direction.dot(Pb);
          if (o > 0) {
            if (r) return null;
            a = 1;
          } else {
            if (!(o < 0)) return null;
            (a = -1), (o = -o);
          }
          Uo.subVectors(this.origin, e);
          const l = a * this.direction.dot(pm.crossVectors(Uo, pm));
          if (l < 0) return null;
          const c = a * this.direction.dot(Rb.cross(Uo));
          if (c < 0 || l + c > o) return null;
          const u = -a * Uo.dot(Pb);
          return u < 0 ? null : this.at(u / o, s);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Ae {
        constructor(e, t, i, r, s, o, a, l, c, u, d, h, f, p, _, m) {
          (Ae.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            void 0 !== e &&
              this.set(e, t, i, r, s, o, a, l, c, u, d, h, f, p, _, m);
        }
        set(e, t, i, r, s, o, a, l, c, u, d, h, f, p, _, m) {
          const g = this.elements;
          return (
            (g[0] = e),
            (g[4] = t),
            (g[8] = i),
            (g[12] = r),
            (g[1] = s),
            (g[5] = o),
            (g[9] = a),
            (g[13] = l),
            (g[2] = c),
            (g[6] = u),
            (g[10] = d),
            (g[14] = h),
            (g[3] = f),
            (g[7] = p),
            (g[11] = _),
            (g[15] = m),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Ae().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            i = e.elements;
          return (
            (t[0] = i[0]),
            (t[1] = i[1]),
            (t[2] = i[2]),
            (t[3] = i[3]),
            (t[4] = i[4]),
            (t[5] = i[5]),
            (t[6] = i[6]),
            (t[7] = i[7]),
            (t[8] = i[8]),
            (t[9] = i[9]),
            (t[10] = i[10]),
            (t[11] = i[11]),
            (t[12] = i[12]),
            (t[13] = i[13]),
            (t[14] = i[14]),
            (t[15] = i[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            i = e.elements;
          return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, i) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, i) {
          return (
            this.set(
              e.x,
              t.x,
              i.x,
              0,
              e.y,
              t.y,
              i.y,
              0,
              e.z,
              t.z,
              i.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            i = e.elements,
            r = 1 / Dc.setFromMatrixColumn(e, 0).length(),
            s = 1 / Dc.setFromMatrixColumn(e, 1).length(),
            o = 1 / Dc.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = i[0] * r),
            (t[1] = i[1] * r),
            (t[2] = i[2] * r),
            (t[3] = 0),
            (t[4] = i[4] * s),
            (t[5] = i[5] * s),
            (t[6] = i[6] * s),
            (t[7] = 0),
            (t[8] = i[8] * o),
            (t[9] = i[9] * o),
            (t[10] = i[10] * o),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z,
            o = Math.cos(i),
            a = Math.sin(i),
            l = Math.cos(r),
            c = Math.sin(r),
            u = Math.cos(s),
            d = Math.sin(s);
          if ("XYZ" === e.order) {
            const h = o * u,
              f = o * d,
              p = a * u,
              _ = a * d;
            (t[0] = l * u),
              (t[4] = -l * d),
              (t[8] = c),
              (t[1] = f + p * c),
              (t[5] = h - _ * c),
              (t[9] = -a * l),
              (t[2] = _ - h * c),
              (t[6] = p + f * c),
              (t[10] = o * l);
          } else if ("YXZ" === e.order) {
            const h = l * u,
              f = l * d,
              p = c * u,
              _ = c * d;
            (t[0] = h + _ * a),
              (t[4] = p * a - f),
              (t[8] = o * c),
              (t[1] = o * d),
              (t[5] = o * u),
              (t[9] = -a),
              (t[2] = f * a - p),
              (t[6] = _ + h * a),
              (t[10] = o * l);
          } else if ("ZXY" === e.order) {
            const h = l * u,
              f = l * d,
              p = c * u,
              _ = c * d;
            (t[0] = h - _ * a),
              (t[4] = -o * d),
              (t[8] = p + f * a),
              (t[1] = f + p * a),
              (t[5] = o * u),
              (t[9] = _ - h * a),
              (t[2] = -o * c),
              (t[6] = a),
              (t[10] = o * l);
          } else if ("ZYX" === e.order) {
            const h = o * u,
              f = o * d,
              p = a * u,
              _ = a * d;
            (t[0] = l * u),
              (t[4] = p * c - f),
              (t[8] = h * c + _),
              (t[1] = l * d),
              (t[5] = _ * c + h),
              (t[9] = f * c - p),
              (t[2] = -c),
              (t[6] = a * l),
              (t[10] = o * l);
          } else if ("YZX" === e.order) {
            const h = o * l,
              f = o * c,
              p = a * l,
              _ = a * c;
            (t[0] = l * u),
              (t[4] = _ - h * d),
              (t[8] = p * d + f),
              (t[1] = d),
              (t[5] = o * u),
              (t[9] = -a * u),
              (t[2] = -c * u),
              (t[6] = f * d + p),
              (t[10] = h - _ * d);
          } else if ("XZY" === e.order) {
            const h = o * l,
              f = o * c,
              p = a * l,
              _ = a * c;
            (t[0] = l * u),
              (t[4] = -d),
              (t[8] = c * u),
              (t[1] = h * d + _),
              (t[5] = o * u),
              (t[9] = f * d - p),
              (t[2] = p * d - f),
              (t[6] = a * u),
              (t[10] = _ * d + h);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(LX, e, FX);
        }
        lookAt(e, t, i) {
          const r = this.elements;
          return (
            sr.subVectors(e, t),
            0 === sr.lengthSq() && (sr.z = 1),
            sr.normalize(),
            Vo.crossVectors(i, sr),
            0 === Vo.lengthSq() &&
              (1 === Math.abs(i.z) ? (sr.x += 1e-4) : (sr.z += 1e-4),
              sr.normalize(),
              Vo.crossVectors(i, sr)),
            Vo.normalize(),
            mm.crossVectors(sr, Vo),
            (r[0] = Vo.x),
            (r[4] = mm.x),
            (r[8] = sr.x),
            (r[1] = Vo.y),
            (r[5] = mm.y),
            (r[9] = sr.y),
            (r[2] = Vo.z),
            (r[6] = mm.z),
            (r[10] = sr.z),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements,
            r = t.elements,
            s = this.elements,
            o = i[0],
            a = i[4],
            l = i[8],
            c = i[12],
            u = i[1],
            d = i[5],
            h = i[9],
            f = i[13],
            p = i[2],
            _ = i[6],
            m = i[10],
            g = i[14],
            y = i[3],
            v = i[7],
            b = i[11],
            x = i[15],
            M = r[0],
            S = r[4],
            C = r[8],
            w = r[12],
            E = r[1],
            V = r[5],
            j = r[9],
            F = r[13],
            k = r[2],
            z = r[6],
            O = r[10],
            L = r[14],
            U = r[3],
            W = r[7],
            Z = r[11],
            B = r[15];
          return (
            (s[0] = o * M + a * E + l * k + c * U),
            (s[4] = o * S + a * V + l * z + c * W),
            (s[8] = o * C + a * j + l * O + c * Z),
            (s[12] = o * w + a * F + l * L + c * B),
            (s[1] = u * M + d * E + h * k + f * U),
            (s[5] = u * S + d * V + h * z + f * W),
            (s[9] = u * C + d * j + h * O + f * Z),
            (s[13] = u * w + d * F + h * L + f * B),
            (s[2] = p * M + _ * E + m * k + g * U),
            (s[6] = p * S + _ * V + m * z + g * W),
            (s[10] = p * C + _ * j + m * O + g * Z),
            (s[14] = p * w + _ * F + m * L + g * B),
            (s[3] = y * M + v * E + b * k + x * U),
            (s[7] = y * S + v * V + b * z + x * W),
            (s[11] = y * C + v * j + b * O + x * Z),
            (s[15] = y * w + v * F + b * L + x * B),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            i = e[4],
            r = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            u = e[2],
            d = e[6],
            h = e[10],
            f = e[14];
          return (
            e[3] *
              (+s * l * d -
                r * c * d -
                s * a * h +
                i * c * h +
                r * a * f -
                i * l * f) +
            e[7] *
              (+t * l * f -
                t * c * h +
                s * o * h -
                r * o * f +
                r * c * u -
                s * l * u) +
            e[11] *
              (+t * c * d -
                t * a * f -
                s * o * d +
                i * o * f +
                s * a * u -
                i * c * u) +
            e[15] *
              (-r * a * u -
                t * l * d +
                t * a * h +
                r * o * d -
                i * o * h +
                i * l * u)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, i) {
          const r = this.elements;
          return (
            e.isVector3
              ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
              : ((r[12] = e), (r[13] = t), (r[14] = i)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            i = e[1],
            r = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            d = e[9],
            h = e[10],
            f = e[11],
            p = e[12],
            _ = e[13],
            m = e[14],
            g = e[15],
            y =
              d * m * c -
              _ * h * c +
              _ * l * f -
              a * m * f -
              d * l * g +
              a * h * g,
            v =
              p * h * c -
              u * m * c -
              p * l * f +
              o * m * f +
              u * l * g -
              o * h * g,
            b =
              u * _ * c -
              p * d * c +
              p * a * f -
              o * _ * f -
              u * a * g +
              o * d * g,
            x =
              p * d * l -
              u * _ * l -
              p * a * h +
              o * _ * h +
              u * a * m -
              o * d * m,
            M = t * y + i * v + r * b + s * x;
          if (0 === M)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const S = 1 / M;
          return (
            (e[0] = y * S),
            (e[1] =
              (_ * h * s -
                d * m * s -
                _ * r * f +
                i * m * f +
                d * r * g -
                i * h * g) *
              S),
            (e[2] =
              (a * m * s -
                _ * l * s +
                _ * r * c -
                i * m * c -
                a * r * g +
                i * l * g) *
              S),
            (e[3] =
              (d * l * s -
                a * h * s -
                d * r * c +
                i * h * c +
                a * r * f -
                i * l * f) *
              S),
            (e[4] = v * S),
            (e[5] =
              (u * m * s -
                p * h * s +
                p * r * f -
                t * m * f -
                u * r * g +
                t * h * g) *
              S),
            (e[6] =
              (p * l * s -
                o * m * s -
                p * r * c +
                t * m * c +
                o * r * g -
                t * l * g) *
              S),
            (e[7] =
              (o * h * s -
                u * l * s +
                u * r * c -
                t * h * c -
                o * r * f +
                t * l * f) *
              S),
            (e[8] = b * S),
            (e[9] =
              (p * d * s -
                u * _ * s -
                p * i * f +
                t * _ * f +
                u * i * g -
                t * d * g) *
              S),
            (e[10] =
              (o * _ * s -
                p * a * s +
                p * i * c -
                t * _ * c -
                o * i * g +
                t * a * g) *
              S),
            (e[11] =
              (u * a * s -
                o * d * s -
                u * i * c +
                t * d * c +
                o * i * f -
                t * a * f) *
              S),
            (e[12] = x * S),
            (e[13] =
              (u * _ * r -
                p * d * r +
                p * i * h -
                t * _ * h -
                u * i * m +
                t * d * m) *
              S),
            (e[14] =
              (p * a * r -
                o * _ * r -
                p * i * l +
                t * _ * l +
                o * i * m -
                t * a * m) *
              S),
            (e[15] =
              (o * d * r -
                u * a * r +
                u * i * l -
                t * d * l -
                o * i * h +
                t * a * h) *
              S),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            i = e.x,
            r = e.y,
            s = e.z;
          return (
            (t[0] *= i),
            (t[4] *= r),
            (t[8] *= s),
            (t[1] *= i),
            (t[5] *= r),
            (t[9] *= s),
            (t[2] *= i),
            (t[6] *= r),
            (t[10] *= s),
            (t[3] *= i),
            (t[7] *= r),
            (t[11] *= s),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements;
          return Math.sqrt(
            Math.max(
              e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
              e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
              e[8] * e[8] + e[9] * e[9] + e[10] * e[10]
            )
          );
        }
        makeTranslation(e, t, i) {
          return (
            e.isVector3
              ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
              : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
            this
          );
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return (
            this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            i = Math.sin(e);
          return (
            this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const i = Math.cos(t),
            r = Math.sin(t),
            s = 1 - i,
            o = e.x,
            a = e.y,
            l = e.z,
            c = s * o,
            u = s * a;
          return (
            this.set(
              c * o + i,
              c * a - r * l,
              c * l + r * a,
              0,
              c * a + r * l,
              u * a + i,
              u * l - r * o,
              0,
              c * l - r * a,
              u * l + r * o,
              s * l * l + i,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, i) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, i, r, s, o) {
          return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, i) {
          const r = this.elements,
            s = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = s + s,
            u = o + o,
            d = a + a,
            h = s * c,
            f = s * u,
            p = s * d,
            _ = o * u,
            m = o * d,
            g = a * d,
            y = l * c,
            v = l * u,
            b = l * d,
            x = i.x,
            M = i.y,
            S = i.z;
          return (
            (r[0] = (1 - (_ + g)) * x),
            (r[1] = (f + b) * x),
            (r[2] = (p - v) * x),
            (r[3] = 0),
            (r[4] = (f - b) * M),
            (r[5] = (1 - (h + g)) * M),
            (r[6] = (m + y) * M),
            (r[7] = 0),
            (r[8] = (p + v) * S),
            (r[9] = (m - y) * S),
            (r[10] = (1 - (h + _)) * S),
            (r[11] = 0),
            (r[12] = e.x),
            (r[13] = e.y),
            (r[14] = e.z),
            (r[15] = 1),
            this
          );
        }
        decompose(e, t, i) {
          const r = this.elements;
          let s = Dc.set(r[0], r[1], r[2]).length();
          const o = Dc.set(r[4], r[5], r[6]).length(),
            a = Dc.set(r[8], r[9], r[10]).length();
          this.determinant() < 0 && (s = -s),
            (e.x = r[12]),
            (e.y = r[13]),
            (e.z = r[14]),
            es.copy(this);
          const c = 1 / s,
            u = 1 / o,
            d = 1 / a;
          return (
            (es.elements[0] *= c),
            (es.elements[1] *= c),
            (es.elements[2] *= c),
            (es.elements[4] *= u),
            (es.elements[5] *= u),
            (es.elements[6] *= u),
            (es.elements[8] *= d),
            (es.elements[9] *= d),
            (es.elements[10] *= d),
            t.setFromRotationMatrix(es),
            (i.x = s),
            (i.y = o),
            (i.z = a),
            this
          );
        }
        makePerspective(e, t, i, r, s, o, a = no) {
          const l = this.elements,
            c = (2 * s) / (t - e),
            u = (2 * s) / (i - r),
            d = (t + e) / (t - e),
            h = (i + r) / (i - r);
          let f, p;
          if (a === no) (f = -(o + s) / (o - s)), (p = (-2 * o * s) / (o - s));
          else {
            if (2001 !== a)
              throw new Error(
                "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
                  a
              );
            (f = -o / (o - s)), (p = (-o * s) / (o - s));
          }
          return (
            (l[0] = c),
            (l[4] = 0),
            (l[8] = d),
            (l[12] = 0),
            (l[1] = 0),
            (l[5] = u),
            (l[9] = h),
            (l[13] = 0),
            (l[2] = 0),
            (l[6] = 0),
            (l[10] = f),
            (l[14] = p),
            (l[3] = 0),
            (l[7] = 0),
            (l[11] = -1),
            (l[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, i, r, s, o, a = no) {
          const l = this.elements,
            c = 1 / (t - e),
            u = 1 / (i - r),
            d = 1 / (o - s),
            h = (t + e) * c,
            f = (i + r) * u;
          let p, _;
          if (a === no) (p = (o + s) * d), (_ = -2 * d);
          else {
            if (2001 !== a)
              throw new Error(
                "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                  a
              );
            (p = s * d), (_ = -1 * d);
          }
          return (
            (l[0] = 2 * c),
            (l[4] = 0),
            (l[8] = 0),
            (l[12] = -h),
            (l[1] = 0),
            (l[5] = 2 * u),
            (l[9] = 0),
            (l[13] = -f),
            (l[2] = 0),
            (l[6] = 0),
            (l[10] = _),
            (l[14] = -p),
            (l[3] = 0),
            (l[7] = 0),
            (l[11] = 0),
            (l[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            i = e.elements;
          for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return (
            (e[t] = i[0]),
            (e[t + 1] = i[1]),
            (e[t + 2] = i[2]),
            (e[t + 3] = i[3]),
            (e[t + 4] = i[4]),
            (e[t + 5] = i[5]),
            (e[t + 6] = i[6]),
            (e[t + 7] = i[7]),
            (e[t + 8] = i[8]),
            (e[t + 9] = i[9]),
            (e[t + 10] = i[10]),
            (e[t + 11] = i[11]),
            (e[t + 12] = i[12]),
            (e[t + 13] = i[13]),
            (e[t + 14] = i[14]),
            (e[t + 15] = i[15]),
            e
          );
        }
      }
      const Dc = new A(),
        es = new Ae(),
        LX = new A(0, 0, 0),
        FX = new A(1, 1, 1),
        Vo = new A(),
        mm = new A(),
        sr = new A(),
        nP = new Ae(),
        iP = new An();
      let oo = (() => {
        class n {
          constructor(t = 0, i = 0, r = 0, s = n.DEFAULT_ORDER) {
            (this.isEuler = !0),
              (this._x = t),
              (this._y = i),
              (this._z = r),
              (this._order = s);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, i, r, s = this._order) {
            return (
              (this._x = t),
              (this._y = i),
              (this._z = r),
              (this._order = s),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, i = this._order, r = !0) {
            const s = t.elements,
              o = s[0],
              a = s[4],
              l = s[8],
              c = s[1],
              u = s[5],
              d = s[9],
              h = s[2],
              f = s[6],
              p = s[10];
            switch (i) {
              case "XYZ":
                (this._y = Math.asin(bn(l, -1, 1))),
                  Math.abs(l) < 0.9999999
                    ? ((this._x = Math.atan2(-d, p)),
                      (this._z = Math.atan2(-a, o)))
                    : ((this._x = Math.atan2(f, u)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-bn(d, -1, 1))),
                  Math.abs(d) < 0.9999999
                    ? ((this._y = Math.atan2(l, p)),
                      (this._z = Math.atan2(c, u)))
                    : ((this._y = Math.atan2(-h, o)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(bn(f, -1, 1))),
                  Math.abs(f) < 0.9999999
                    ? ((this._y = Math.atan2(-h, p)),
                      (this._z = Math.atan2(-a, u)))
                    : ((this._y = 0), (this._z = Math.atan2(c, o)));
                break;
              case "ZYX":
                (this._y = Math.asin(-bn(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._x = Math.atan2(f, p)),
                      (this._z = Math.atan2(c, o)))
                    : ((this._x = 0), (this._z = Math.atan2(-a, u)));
                break;
              case "YZX":
                (this._z = Math.asin(bn(c, -1, 1))),
                  Math.abs(c) < 0.9999999
                    ? ((this._x = Math.atan2(-d, u)),
                      (this._y = Math.atan2(-h, o)))
                    : ((this._x = 0), (this._y = Math.atan2(l, p)));
                break;
              case "XZY":
                (this._z = Math.asin(-bn(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(f, u)),
                      (this._y = Math.atan2(l, o)))
                    : ((this._x = Math.atan2(-d, p)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                    i
                );
            }
            return (
              (this._order = i), !0 === r && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(t, i, r) {
            return (
              nP.makeRotationFromQuaternion(t),
              this.setFromRotationMatrix(nP, i, r)
            );
          }
          setFromVector3(t, i = this._order) {
            return this.set(t.x, t.y, t.z, i);
          }
          reorder(t) {
            return iP.setFromEuler(this), this.setFromQuaternion(iP, t);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], i = 0) {
            return (
              (t[i] = this._x),
              (t[i + 1] = this._y),
              (t[i + 2] = this._z),
              (t[i + 3] = this._order),
              t
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
          *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order;
          }
        }
        return (n.DEFAULT_ORDER = "XYZ"), n;
      })();
      class Ob {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = ((1 << e) | 0) >>> 0;
        }
        enable(e) {
          this.mask |= (1 << e) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= (1 << e) | 0;
        }
        disable(e) {
          this.mask &= ~((1 << e) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return 0 != (this.mask & e.mask);
        }
        isEnabled(e) {
          return 0 != (this.mask & ((1 << e) | 0));
        }
      }
      let NX = 0;
      const rP = new A(),
        Ic = new An(),
        ao = new Ae(),
        gm = new A(),
        Jd = new A(),
        kX = new A(),
        BX = new An(),
        sP = new A(1, 0, 0),
        oP = new A(0, 1, 0),
        aP = new A(0, 0, 1),
        UX = { type: "added" },
        lP = { type: "removed" };
      let Dn = (() => {
        class n extends No {
          constructor() {
            super(),
              (this.isObject3D = !0),
              Object.defineProperty(this, "id", { value: NX++ }),
              (this.uuid = ir()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = n.DEFAULT_UP.clone());
            const t = new A(),
              i = new oo(),
              r = new An(),
              s = new A(1, 1, 1);
            i._onChange(function o() {
              r.setFromEuler(i, !1);
            }),
              r._onChange(function a() {
                i.setFromQuaternion(r, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: t },
                rotation: { configurable: !0, enumerable: !0, value: i },
                quaternion: { configurable: !0, enumerable: !0, value: r },
                scale: { configurable: !0, enumerable: !0, value: s },
                modelViewMatrix: { value: new Ae() },
                normalMatrix: { value: new vt() },
              }),
              (this.matrix = new Ae()),
              (this.matrixWorld = new Ae()),
              (this.matrixAutoUpdate = n.DEFAULT_MATRIX_AUTO_UPDATE),
              (this.matrixWorldNeedsUpdate = !1),
              (this.matrixWorldAutoUpdate = n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
              (this.layers = new Ob()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(t),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
          }
          setRotationFromAxisAngle(t, i) {
            this.quaternion.setFromAxisAngle(t, i);
          }
          setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
          }
          setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
          }
          setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
          }
          rotateOnAxis(t, i) {
            return (
              Ic.setFromAxisAngle(t, i), this.quaternion.multiply(Ic), this
            );
          }
          rotateOnWorldAxis(t, i) {
            return (
              Ic.setFromAxisAngle(t, i), this.quaternion.premultiply(Ic), this
            );
          }
          rotateX(t) {
            return this.rotateOnAxis(sP, t);
          }
          rotateY(t) {
            return this.rotateOnAxis(oP, t);
          }
          rotateZ(t) {
            return this.rotateOnAxis(aP, t);
          }
          translateOnAxis(t, i) {
            return (
              rP.copy(t).applyQuaternion(this.quaternion),
              this.position.add(rP.multiplyScalar(i)),
              this
            );
          }
          translateX(t) {
            return this.translateOnAxis(sP, t);
          }
          translateY(t) {
            return this.translateOnAxis(oP, t);
          }
          translateZ(t) {
            return this.translateOnAxis(aP, t);
          }
          localToWorld(t) {
            return (
              this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
            );
          }
          worldToLocal(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              t.applyMatrix4(ao.copy(this.matrixWorld).invert())
            );
          }
          lookAt(t, i, r) {
            t.isVector3 ? gm.copy(t) : gm.set(t, i, r);
            const s = this.parent;
            this.updateWorldMatrix(!0, !1),
              Jd.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? ao.lookAt(Jd, gm, this.up)
                : ao.lookAt(gm, Jd, this.up),
              this.quaternion.setFromRotationMatrix(ao),
              s &&
                (ao.extractRotation(s.matrixWorld),
                Ic.setFromRotationMatrix(ao),
                this.quaternion.premultiply(Ic.invert()));
          }
          add(t) {
            if (arguments.length > 1) {
              for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
              return this;
            }
            return t === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t
                ),
                this)
              : (t && t.isObject3D
                  ? (null !== t.parent && t.parent.remove(t),
                    (t.parent = this),
                    this.children.push(t),
                    t.dispatchEvent(UX))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      t
                    ),
                this);
          }
          remove(t) {
            if (arguments.length > 1) {
              for (let r = 0; r < arguments.length; r++)
                this.remove(arguments[r]);
              return this;
            }
            const i = this.children.indexOf(t);
            return (
              -1 !== i &&
                ((t.parent = null),
                this.children.splice(i, 1),
                t.dispatchEvent(lP)),
              this
            );
          }
          removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this), this;
          }
          clear() {
            for (let t = 0; t < this.children.length; t++) {
              const i = this.children[t];
              (i.parent = null), i.dispatchEvent(lP);
            }
            return (this.children.length = 0), this;
          }
          attach(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              ao.copy(this.matrixWorld).invert(),
              null !== t.parent &&
                (t.parent.updateWorldMatrix(!0, !1),
                ao.multiply(t.parent.matrixWorld)),
              t.applyMatrix4(ao),
              this.add(t),
              t.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(t) {
            return this.getObjectByProperty("id", t);
          }
          getObjectByName(t) {
            return this.getObjectByProperty("name", t);
          }
          getObjectByProperty(t, i) {
            if (this[t] === i) return this;
            for (let r = 0, s = this.children.length; r < s; r++) {
              const a = this.children[r].getObjectByProperty(t, i);
              if (void 0 !== a) return a;
            }
          }
          getObjectsByProperty(t, i) {
            let r = [];
            this[t] === i && r.push(this);
            for (let s = 0, o = this.children.length; s < o; s++) {
              const a = this.children[s].getObjectsByProperty(t, i);
              a.length > 0 && (r = r.concat(a));
            }
            return r;
          }
          getWorldPosition(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              t.setFromMatrixPosition(this.matrixWorld)
            );
          }
          getWorldQuaternion(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Jd, t, kX),
              t
            );
          }
          getWorldScale(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(Jd, BX, t),
              t
            );
          }
          getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const i = this.matrixWorld.elements;
            return t.set(i[8], i[9], i[10]).normalize();
          }
          raycast() {}
          traverse(t) {
            t(this);
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) i[r].traverse(t);
          }
          traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) i[r].traverseVisible(t);
          }
          traverseAncestors(t) {
            const i = this.parent;
            null !== i && (t(i), i.traverseAncestors(t));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            const i = this.children;
            for (let r = 0, s = i.length; r < s; r++) {
              const o = i[r];
              (!0 === o.matrixWorldAutoUpdate || !0 === t) &&
                o.updateMatrixWorld(t);
            }
          }
          updateWorldMatrix(t, i) {
            const r = this.parent;
            if (
              (!0 === t &&
                null !== r &&
                !0 === r.matrixWorldAutoUpdate &&
                r.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              !0 === i)
            ) {
              const s = this.children;
              for (let o = 0, a = s.length; o < a; o++) {
                const l = s[o];
                !0 === l.matrixWorldAutoUpdate && l.updateWorldMatrix(!1, !0);
              }
            }
          }
          toJSON(t) {
            const i = void 0 === t || "string" == typeof t,
              r = {};
            i &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {},
              }),
              (r.metadata = {
                version: 4.6,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            const s = {};
            function o(l, c) {
              return void 0 === l[c.uuid] && (l[c.uuid] = c.toJSON(t)), c.uuid;
            }
            if (
              ((s.uuid = this.uuid),
              (s.type = this.type),
              "" !== this.name && (s.name = this.name),
              !0 === this.castShadow && (s.castShadow = !0),
              !0 === this.receiveShadow && (s.receiveShadow = !0),
              !1 === this.visible && (s.visible = !1),
              !1 === this.frustumCulled && (s.frustumCulled = !1),
              0 !== this.renderOrder && (s.renderOrder = this.renderOrder),
              Object.keys(this.userData).length > 0 &&
                (s.userData = this.userData),
              (s.layers = this.layers.mask),
              (s.matrix = this.matrix.toArray()),
              (s.up = this.up.toArray()),
              !1 === this.matrixAutoUpdate && (s.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((s.type = "InstancedMesh"),
                (s.count = this.count),
                (s.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor &&
                  (s.instanceColor = this.instanceColor.toJSON())),
              this.isScene)
            )
              this.background &&
                (this.background.isColor
                  ? (s.background = this.background.toJSON())
                  : this.background.isTexture &&
                    (s.background = this.background.toJSON(t).uuid)),
                this.environment &&
                  this.environment.isTexture &&
                  !0 !== this.environment.isRenderTargetTexture &&
                  (s.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
              s.geometry = o(t.geometries, this.geometry);
              const l = this.geometry.parameters;
              if (void 0 !== l && void 0 !== l.shapes) {
                const c = l.shapes;
                if (Array.isArray(c))
                  for (let u = 0, d = c.length; u < d; u++) o(t.shapes, c[u]);
                else o(t.shapes, c);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((s.bindMode = this.bindMode),
                (s.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (o(t.skeletons, this.skeleton),
                  (s.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const l = [];
                for (let c = 0, u = this.material.length; c < u; c++)
                  l.push(o(t.materials, this.material[c]));
                s.material = l;
              } else s.material = o(t.materials, this.material);
            if (this.children.length > 0) {
              s.children = [];
              for (let l = 0; l < this.children.length; l++)
                s.children.push(this.children[l].toJSON(t).object);
            }
            if (this.animations.length > 0) {
              s.animations = [];
              for (let l = 0; l < this.animations.length; l++)
                s.animations.push(o(t.animations, this.animations[l]));
            }
            if (i) {
              const l = a(t.geometries),
                c = a(t.materials),
                u = a(t.textures),
                d = a(t.images),
                h = a(t.shapes),
                f = a(t.skeletons),
                p = a(t.animations),
                _ = a(t.nodes);
              l.length > 0 && (r.geometries = l),
                c.length > 0 && (r.materials = c),
                u.length > 0 && (r.textures = u),
                d.length > 0 && (r.images = d),
                h.length > 0 && (r.shapes = h),
                f.length > 0 && (r.skeletons = f),
                p.length > 0 && (r.animations = p),
                _.length > 0 && (r.nodes = _);
            }
            return (r.object = s), r;
            function a(l) {
              const c = [];
              for (const u in l) {
                const d = l[u];
                delete d.metadata, c.push(d);
              }
              return c;
            }
          }
          clone(t) {
            return new this.constructor().copy(this, t);
          }
          copy(t, i = !0) {
            if (
              ((this.name = t.name),
              this.up.copy(t.up),
              this.position.copy(t.position),
              (this.rotation.order = t.rotation.order),
              this.quaternion.copy(t.quaternion),
              this.scale.copy(t.scale),
              this.matrix.copy(t.matrix),
              this.matrixWorld.copy(t.matrixWorld),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
              (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
              (this.layers.mask = t.layers.mask),
              (this.visible = t.visible),
              (this.castShadow = t.castShadow),
              (this.receiveShadow = t.receiveShadow),
              (this.frustumCulled = t.frustumCulled),
              (this.renderOrder = t.renderOrder),
              (this.animations = t.animations),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              !0 === i)
            )
              for (let r = 0; r < t.children.length; r++)
                this.add(t.children[r].clone());
            return this;
          }
        }
        return (
          (n.DEFAULT_UP = new A(0, 1, 0)),
          (n.DEFAULT_MATRIX_AUTO_UPDATE = !0),
          (n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0),
          n
        );
      })();
      const ts = new A(),
        lo = new A(),
        Lb = new A(),
        co = new A(),
        Rc = new A(),
        Pc = new A(),
        cP = new A(),
        Fb = new A(),
        Nb = new A(),
        kb = new A();
      let _m = !1;
      class or {
        constructor(e = new A(), t = new A(), i = new A()) {
          (this.a = e), (this.b = t), (this.c = i);
        }
        static getNormal(e, t, i, r) {
          r.subVectors(i, t), ts.subVectors(e, t), r.cross(ts);
          const s = r.lengthSq();
          return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
        }
        static getBarycoord(e, t, i, r, s) {
          ts.subVectors(r, t), lo.subVectors(i, t), Lb.subVectors(e, t);
          const o = ts.dot(ts),
            a = ts.dot(lo),
            l = ts.dot(Lb),
            c = lo.dot(lo),
            u = lo.dot(Lb),
            d = o * c - a * a;
          if (0 === d) return s.set(-2, -1, -1);
          const h = 1 / d,
            f = (c * l - a * u) * h,
            p = (o * u - a * l) * h;
          return s.set(1 - f - p, p, f);
        }
        static containsPoint(e, t, i, r) {
          return (
            this.getBarycoord(e, t, i, r, co),
            co.x >= 0 && co.y >= 0 && co.x + co.y <= 1
          );
        }
        static getUV(e, t, i, r, s, o, a, l) {
          return (
            !1 === _m &&
              (console.warn(
                "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
              ),
              (_m = !0)),
            this.getInterpolation(e, t, i, r, s, o, a, l)
          );
        }
        static getInterpolation(e, t, i, r, s, o, a, l) {
          return (
            this.getBarycoord(e, t, i, r, co),
            l.setScalar(0),
            l.addScaledVector(s, co.x),
            l.addScaledVector(o, co.y),
            l.addScaledVector(a, co.z),
            l
          );
        }
        static isFrontFacing(e, t, i, r) {
          return (
            ts.subVectors(i, t), lo.subVectors(e, t), ts.cross(lo).dot(r) < 0
          );
        }
        set(e, t, i) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
        }
        setFromPointsAndIndices(e, t, i, r) {
          return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
        }
        setFromAttributeAndIndices(e, t, i, r) {
          return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, i),
            this.c.fromBufferAttribute(e, r),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            ts.subVectors(this.c, this.b),
            lo.subVectors(this.a, this.b),
            0.5 * ts.cross(lo).length()
          );
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return or.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return or.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, i, r, s) {
          return (
            !1 === _m &&
              (console.warn(
                "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
              ),
              (_m = !0)),
            or.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
          );
        }
        getInterpolation(e, t, i, r, s) {
          return or.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
        }
        containsPoint(e) {
          return or.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return or.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const i = this.a,
            r = this.b,
            s = this.c;
          let o, a;
          Rc.subVectors(r, i), Pc.subVectors(s, i), Fb.subVectors(e, i);
          const l = Rc.dot(Fb),
            c = Pc.dot(Fb);
          if (l <= 0 && c <= 0) return t.copy(i);
          Nb.subVectors(e, r);
          const u = Rc.dot(Nb),
            d = Pc.dot(Nb);
          if (u >= 0 && d <= u) return t.copy(r);
          const h = l * d - u * c;
          if (h <= 0 && l >= 0 && u <= 0)
            return (o = l / (l - u)), t.copy(i).addScaledVector(Rc, o);
          kb.subVectors(e, s);
          const f = Rc.dot(kb),
            p = Pc.dot(kb);
          if (p >= 0 && f <= p) return t.copy(s);
          const _ = f * c - l * p;
          if (_ <= 0 && c >= 0 && p <= 0)
            return (a = c / (c - p)), t.copy(i).addScaledVector(Pc, a);
          const m = u * p - f * d;
          if (m <= 0 && d - u >= 0 && f - p >= 0)
            return (
              cP.subVectors(s, r),
              (a = (d - u) / (d - u + (f - p))),
              t.copy(r).addScaledVector(cP, a)
            );
          const g = 1 / (m + _ + h);
          return (
            (o = _ * g),
            (a = h * g),
            t.copy(i).addScaledVector(Rc, o).addScaledVector(Pc, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let VX = 0;
      class ar extends No {
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", { value: VX++ }),
            (this.uuid = ir()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = pc),
            (this.side = $s),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = cR),
            (this.blendDst = uR),
            (this.blendEquation = mc),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = ab),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = 7680),
            (this.stencilZFail = 7680),
            (this.stencilZPass = 7680),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (void 0 !== e)
            for (const t in e) {
              const i = e[t];
              if (void 0 === i) {
                console.warn(
                  `THREE.Material: parameter '${t}' has value of undefined.`
                );
                continue;
              }
              const r = this[t];
              void 0 !== r
                ? r && r.isColor
                  ? r.set(i)
                  : r && r.isVector3 && i && i.isVector3
                  ? r.copy(i)
                  : (this[t] = i)
                : console.warn(
                    `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
                  );
            }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          t && (e = { textures: {}, images: {} });
          const i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function r(s) {
            const o = [];
            for (const a in s) {
              const l = s[a];
              delete l.metadata, o.push(l);
            }
            return o;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            void 0 !== this.sheen && (i.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (i.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (i.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (i.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (i.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (i.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (i.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (i.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (i.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (i.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            void 0 !== this.iridescence && (i.iridescence = this.iridescence),
            void 0 !== this.iridescenceIOR &&
              (i.iridescenceIOR = this.iridescenceIOR),
            void 0 !== this.iridescenceThicknessRange &&
              (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
              this.iridescenceMap.isTexture &&
              (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap &&
              this.iridescenceThicknessMap.isTexture &&
              (i.iridescenceThicknessMap =
                this.iridescenceThicknessMap.toJSON(e).uuid),
            void 0 !== this.anisotropy && (i.anisotropy = this.anisotropy),
            void 0 !== this.anisotropyRotation &&
              (i.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
              this.anisotropyMap.isTexture &&
              (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (i.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (i.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((i.lightMap = this.lightMap.toJSON(e).uuid),
              (i.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((i.aoMap = this.aoMap.toJSON(e).uuid),
              (i.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
              (i.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((i.normalMap = this.normalMap.toJSON(e).uuid),
              (i.normalMapType = this.normalMapType),
              (i.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
              (i.displacementScale = this.displacementScale),
              (i.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (i.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (i.specularIntensityMap =
                this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((i.envMap = this.envMap.toJSON(e).uuid),
              void 0 !== this.combine && (i.combine = this.combine)),
            void 0 !== this.envMapIntensity &&
              (i.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (i.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (i.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (i.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.transmission &&
              (i.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            void 0 !== this.thickness && (i.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            void 0 !== this.attenuationDistance &&
              this.attenuationDistance !== 1 / 0 &&
              (i.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (i.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (i.size = this.size),
            null !== this.shadowSide && (i.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (i.sizeAttenuation = this.sizeAttenuation),
            this.blending !== pc && (i.blending = this.blending),
            this.side !== $s && (i.side = this.side),
            this.vertexColors && (i.vertexColors = !0),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = this.transparent),
            (i.depthFunc = this.depthFunc),
            (i.depthTest = this.depthTest),
            (i.depthWrite = this.depthWrite),
            (i.colorWrite = this.colorWrite),
            (i.stencilWrite = this.stencilWrite),
            (i.stencilWriteMask = this.stencilWriteMask),
            (i.stencilFunc = this.stencilFunc),
            (i.stencilRef = this.stencilRef),
            (i.stencilFuncMask = this.stencilFuncMask),
            (i.stencilFail = this.stencilFail),
            (i.stencilZFail = this.stencilZFail),
            (i.stencilZPass = this.stencilZPass),
            void 0 !== this.rotation &&
              0 !== this.rotation &&
              (i.rotation = this.rotation),
            !0 === this.polygonOffset && (i.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (i.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (i.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth &&
              1 !== this.linewidth &&
              (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            !0 === this.alphaHash && (i.alphaHash = this.alphaHash),
            !0 === this.alphaToCoverage &&
              (i.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha &&
              (i.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.forceSinglePass &&
              (i.forceSinglePass = this.forceSinglePass),
            !0 === this.wireframe && (i.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 &&
              (i.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (i.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (i.flatShading = this.flatShading),
            !1 === this.visible && (i.visible = !1),
            !1 === this.toneMapped && (i.toneMapped = !1),
            !1 === this.fog && (i.fog = !1),
            Object.keys(this.userData).length > 0 &&
              (i.userData = this.userData),
            t)
          ) {
            const s = r(e.textures),
              o = r(e.images);
            s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let i = null;
          if (null !== t) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
          }
          return (
            (this.clippingPlanes = i),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaHash = e.alphaHash),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.forceSinglePass = e.forceSinglePass),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
      }
      const uP = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        ns = { h: 0, s: 0, l: 0 },
        vm = { h: 0, s: 0, l: 0 };
      function Bb(n, e, t) {
        return (
          t < 0 && (t += 1),
          t > 1 && (t -= 1),
          t < 1 / 6
            ? n + 6 * (e - n) * t
            : t < 0.5
            ? e
            : t < 2 / 3
            ? n + 6 * (e - n) * (2 / 3 - t)
            : n
        );
      }
      class de {
        constructor(e, t, i) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            this.set(e, t, i)
          );
        }
        set(e, t, i) {
          if (void 0 === t && void 0 === i) {
            const r = e;
            r && r.isColor
              ? this.copy(r)
              : "number" == typeof r
              ? this.setHex(r)
              : "string" == typeof r && this.setStyle(r);
          } else this.setRGB(e, t, i);
          return this;
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = qe) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (255 & e) / 255),
            Qr.toWorkingColorSpace(this, t),
            this
          );
        }
        setRGB(e, t, i, r = Qr.workingColorSpace) {
          return (
            (this.r = e),
            (this.g = t),
            (this.b = i),
            Qr.toWorkingColorSpace(this, r),
            this
          );
        }
        setHSL(e, t, i, r = Qr.workingColorSpace) {
          if (((e = xb(e, 1)), (t = bn(t, 0, 1)), (i = bn(i, 0, 1)), 0 === t))
            this.r = this.g = this.b = i;
          else {
            const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
              o = 2 * i - s;
            (this.r = Bb(o, s, e + 1 / 3)),
              (this.g = Bb(o, s, e)),
              (this.b = Bb(o, s, e - 1 / 3));
          }
          return Qr.toWorkingColorSpace(this, r), this;
        }
        setStyle(e, t = qe) {
          function i(s) {
            void 0 !== s &&
              parseFloat(s) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let r;
          if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
            let s;
            const a = r[2];
            switch (r[1]) {
              case "rgb":
              case "rgba":
                if (
                  (s =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    i(s[4]),
                    this.setRGB(
                      Math.min(255, parseInt(s[1], 10)) / 255,
                      Math.min(255, parseInt(s[2], 10)) / 255,
                      Math.min(255, parseInt(s[3], 10)) / 255,
                      t
                    )
                  );
                if (
                  (s =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    i(s[4]),
                    this.setRGB(
                      Math.min(100, parseInt(s[1], 10)) / 100,
                      Math.min(100, parseInt(s[2], 10)) / 100,
                      Math.min(100, parseInt(s[3], 10)) / 100,
                      t
                    )
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (s =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    i(s[4]),
                    this.setHSL(
                      parseFloat(s[1]) / 360,
                      parseFloat(s[2]) / 100,
                      parseFloat(s[3]) / 100,
                      t
                    )
                  );
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + e);
            }
          } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const s = r[1],
              o = s.length;
            if (3 === o)
              return this.setRGB(
                parseInt(s.charAt(0), 16) / 15,
                parseInt(s.charAt(1), 16) / 15,
                parseInt(s.charAt(2), 16) / 15,
                t
              );
            if (6 === o) return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e);
          } else if (e && e.length > 0) return this.setColorName(e, t);
          return this;
        }
        setColorName(e, t = qe) {
          const i = uP[e.toLowerCase()];
          return (
            void 0 !== i
              ? this.setHex(i, t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = wc(e.r)), (this.g = wc(e.g)), (this.b = wc(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = Sb(e.r)), (this.g = Sb(e.g)), (this.b = Sb(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = qe) {
          return (
            Qr.fromWorkingColorSpace(yi.copy(this), e),
            65536 * Math.round(bn(255 * yi.r, 0, 255)) +
              256 * Math.round(bn(255 * yi.g, 0, 255)) +
              Math.round(bn(255 * yi.b, 0, 255))
          );
        }
        getHexString(e = qe) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = Qr.workingColorSpace) {
          Qr.fromWorkingColorSpace(yi.copy(this), t);
          const i = yi.r,
            r = yi.g,
            s = yi.b,
            o = Math.max(i, r, s),
            a = Math.min(i, r, s);
          let l, c;
          const u = (a + o) / 2;
          if (a === o) (l = 0), (c = 0);
          else {
            const d = o - a;
            switch (((c = u <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
              case i:
                l = (r - s) / d + (r < s ? 6 : 0);
                break;
              case r:
                l = (s - i) / d + 2;
                break;
              case s:
                l = (i - r) / d + 4;
            }
            l /= 6;
          }
          return (e.h = l), (e.s = c), (e.l = u), e;
        }
        getRGB(e, t = Qr.workingColorSpace) {
          return (
            Qr.fromWorkingColorSpace(yi.copy(this), t),
            (e.r = yi.r),
            (e.g = yi.g),
            (e.b = yi.b),
            e
          );
        }
        getStyle(e = qe) {
          Qr.fromWorkingColorSpace(yi.copy(this), e);
          const t = yi.r,
            i = yi.g,
            r = yi.b;
          return e !== qe
            ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
            : `rgb(${Math.round(255 * t)},${Math.round(255 * i)},${Math.round(
                255 * r
              )})`;
        }
        offsetHSL(e, t, i) {
          return (
            this.getHSL(ns),
            (ns.h += e),
            (ns.s += t),
            (ns.l += i),
            this.setHSL(ns.h, ns.s, ns.l),
            this
          );
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, i) {
          return (
            (this.r = e.r + (t.r - e.r) * i),
            (this.g = e.g + (t.g - e.g) * i),
            (this.b = e.b + (t.b - e.b) * i),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(ns), e.getHSL(vm);
          const i = qd(ns.h, vm.h, t),
            r = qd(ns.s, vm.s, t),
            s = qd(ns.l, vm.l, t);
          return this.setHSL(i, r, s), this;
        }
        setFromVector3(e) {
          return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
        }
        applyMatrix3(e) {
          const t = this.r,
            i = this.g,
            r = this.b,
            s = e.elements;
          return (
            (this.r = s[0] * t + s[3] * i + s[6] * r),
            (this.g = s[1] * t + s[4] * i + s[7] * r),
            (this.b = s[2] * t + s[5] * i + s[8] * r),
            this
          );
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const yi = new de();
      de.NAMES = uP;
      class Ar extends ar {
        constructor(e) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = "MeshBasicMaterial"),
            (this.color = new de(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = rm),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const Nn = new A(),
        ym = new $();
      class on {
        constructor(e, t, i = !1) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.isBufferAttribute = !0),
            (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = void 0 !== e ? e.length / t : 0),
            (this.normalized = i),
            (this.usage = 35044),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.gpuType = to),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            (this.gpuType = e.gpuType),
            this
          );
        }
        copyAt(e, t, i) {
          (e *= this.itemSize), (i *= t.itemSize);
          for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (2 === this.itemSize)
            for (let t = 0, i = this.count; t < i; t++)
              ym.fromBufferAttribute(this, t),
                ym.applyMatrix3(e),
                this.setXY(t, ym.x, ym.y);
          else if (3 === this.itemSize)
            for (let t = 0, i = this.count; t < i; t++)
              Nn.fromBufferAttribute(this, t),
                Nn.applyMatrix3(e),
                this.setXYZ(t, Nn.x, Nn.y, Nn.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.count; t < i; t++)
            Nn.fromBufferAttribute(this, t),
              Nn.applyMatrix4(e),
              this.setXYZ(t, Nn.x, Nn.y, Nn.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++)
            Nn.fromBufferAttribute(this, t),
              Nn.applyNormalMatrix(e),
              this.setXYZ(t, Nn.x, Nn.y, Nn.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++)
            Nn.fromBufferAttribute(this, t),
              Nn.transformDirection(e),
              this.setXYZ(t, Nn.x, Nn.y, Nn.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = rr(t, this.array)), t;
        }
        setX(e, t) {
          return (
            this.normalized && (t = _t(t, this.array)),
            (this.array[e * this.itemSize] = t),
            this
          );
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = rr(t, this.array)), t;
        }
        setY(e, t) {
          return (
            this.normalized && (t = _t(t, this.array)),
            (this.array[e * this.itemSize + 1] = t),
            this
          );
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = rr(t, this.array)), t;
        }
        setZ(e, t) {
          return (
            this.normalized && (t = _t(t, this.array)),
            (this.array[e * this.itemSize + 2] = t),
            this
          );
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = rr(t, this.array)), t;
        }
        setW(e, t) {
          return (
            this.normalized && (t = _t(t, this.array)),
            (this.array[e * this.itemSize + 3] = t),
            this
          );
        }
        setXY(e, t, i) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = _t(t, this.array)), (i = _t(i, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            this
          );
        }
        setXYZ(e, t, i, r) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = _t(t, this.array)),
              (i = _t(i, this.array)),
              (r = _t(r, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            (this.array[e + 2] = r),
            this
          );
        }
        setXYZW(e, t, i, r, s) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = _t(t, this.array)),
              (i = _t(i, this.array)),
              (r = _t(r, this.array)),
              (s = _t(s, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = i),
            (this.array[e + 2] = r),
            (this.array[e + 3] = s),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (e.name = this.name),
            35044 !== this.usage && (e.usage = this.usage),
            (0 !== this.updateRange.offset || -1 !== this.updateRange.count) &&
              (e.updateRange = this.updateRange),
            e
          );
        }
      }
      class Ub extends on {
        constructor(e, t, i) {
          super(new Uint16Array(e), t, i);
        }
      }
      class dP extends on {
        constructor(e, t, i) {
          super(new Uint32Array(e), t, i);
        }
      }
      class Ie extends on {
        constructor(e, t, i) {
          super(new Float32Array(e), t, i);
        }
      }
      let HX = 0;
      const Dr = new Ae(),
        Vb = new Dn(),
        Oc = new A(),
        lr = new Ms(),
        th = new Ms(),
        Zn = new A();
      class ut extends No {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", { value: HX++ }),
            (this.uuid = ir()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            (this.index = Array.isArray(e) ? new ($R(e) ? dP : Ub)(e, 1) : e),
            this
          );
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return void 0 !== this.attributes[e];
        }
        addGroup(e, t, i = 0) {
          this.groups.push({ start: e, count: t, materialIndex: i });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const i = this.attributes.normal;
          if (void 0 !== i) {
            const s = new vt().getNormalMatrix(e);
            i.applyNormalMatrix(s), (i.needsUpdate = !0);
          }
          const r = this.attributes.tangent;
          return (
            void 0 !== r && (r.transformDirection(e), (r.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return Dr.makeRotationFromQuaternion(e), this.applyMatrix4(Dr), this;
        }
        rotateX(e) {
          return Dr.makeRotationX(e), this.applyMatrix4(Dr), this;
        }
        rotateY(e) {
          return Dr.makeRotationY(e), this.applyMatrix4(Dr), this;
        }
        rotateZ(e) {
          return Dr.makeRotationZ(e), this.applyMatrix4(Dr), this;
        }
        translate(e, t, i) {
          return Dr.makeTranslation(e, t, i), this.applyMatrix4(Dr), this;
        }
        scale(e, t, i) {
          return Dr.makeScale(e, t, i), this.applyMatrix4(Dr), this;
        }
        lookAt(e) {
          return (
            Vb.lookAt(e), Vb.updateMatrix(), this.applyMatrix4(Vb.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Oc).negate(),
            this.translate(Oc.x, Oc.y, Oc.z),
            this
          );
        }
        setFromPoints(e) {
          const t = [];
          for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0);
          }
          return this.setAttribute("position", new Ie(t, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Ms());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingBox.set(
                new A(-1 / 0, -1 / 0, -1 / 0),
                new A(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== e) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let i = 0, r = t.length; i < r; i++)
                lr.setFromBufferAttribute(t[i]),
                  this.morphTargetsRelative
                    ? (Zn.addVectors(this.boundingBox.min, lr.min),
                      this.boundingBox.expandByPoint(Zn),
                      Zn.addVectors(this.boundingBox.max, lr.max),
                      this.boundingBox.expandByPoint(Zn))
                    : (this.boundingBox.expandByPoint(lr.min),
                      this.boundingBox.expandByPoint(lr.max));
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Jr());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingSphere.set(new A(), 1 / 0)
            );
          if (e) {
            const i = this.boundingSphere.center;
            if ((lr.setFromBufferAttribute(e), t))
              for (let s = 0, o = t.length; s < o; s++)
                th.setFromBufferAttribute(t[s]),
                  this.morphTargetsRelative
                    ? (Zn.addVectors(lr.min, th.min),
                      lr.expandByPoint(Zn),
                      Zn.addVectors(lr.max, th.max),
                      lr.expandByPoint(Zn))
                    : (lr.expandByPoint(th.min), lr.expandByPoint(th.max));
            lr.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
              Zn.fromBufferAttribute(e, s),
                (r = Math.max(r, i.distanceToSquared(Zn)));
            if (t)
              for (let s = 0, o = t.length; s < o; s++) {
                const a = t[s],
                  l = this.morphTargetsRelative;
                for (let c = 0, u = a.count; c < u; c++)
                  Zn.fromBufferAttribute(a, c),
                    l && (Oc.fromBufferAttribute(e, c), Zn.add(Oc)),
                    (r = Math.max(r, i.distanceToSquared(Zn)));
              }
            (this.boundingSphere.radius = Math.sqrt(r)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            null === e ||
            void 0 === t.position ||
            void 0 === t.normal ||
            void 0 === t.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const i = e.array,
            r = t.position.array,
            s = t.normal.array,
            o = t.uv.array,
            a = r.length / 3;
          !1 === this.hasAttribute("tangent") &&
            this.setAttribute("tangent", new on(new Float32Array(4 * a), 4));
          const l = this.getAttribute("tangent").array,
            c = [],
            u = [];
          for (let E = 0; E < a; E++) (c[E] = new A()), (u[E] = new A());
          const d = new A(),
            h = new A(),
            f = new A(),
            p = new $(),
            _ = new $(),
            m = new $(),
            g = new A(),
            y = new A();
          function v(E, V, j) {
            d.fromArray(r, 3 * E),
              h.fromArray(r, 3 * V),
              f.fromArray(r, 3 * j),
              p.fromArray(o, 2 * E),
              _.fromArray(o, 2 * V),
              m.fromArray(o, 2 * j),
              h.sub(d),
              f.sub(d),
              _.sub(p),
              m.sub(p);
            const F = 1 / (_.x * m.y - m.x * _.y);
            isFinite(F) &&
              (g
                .copy(h)
                .multiplyScalar(m.y)
                .addScaledVector(f, -_.y)
                .multiplyScalar(F),
              y
                .copy(f)
                .multiplyScalar(_.x)
                .addScaledVector(h, -m.x)
                .multiplyScalar(F),
              c[E].add(g),
              c[V].add(g),
              c[j].add(g),
              u[E].add(y),
              u[V].add(y),
              u[j].add(y));
          }
          let b = this.groups;
          0 === b.length && (b = [{ start: 0, count: i.length }]);
          for (let E = 0, V = b.length; E < V; ++E) {
            const j = b[E],
              F = j.start;
            for (let z = F, O = F + j.count; z < O; z += 3)
              v(i[z + 0], i[z + 1], i[z + 2]);
          }
          const x = new A(),
            M = new A(),
            S = new A(),
            C = new A();
          function w(E) {
            S.fromArray(s, 3 * E), C.copy(S);
            const V = c[E];
            x.copy(V),
              x.sub(S.multiplyScalar(S.dot(V))).normalize(),
              M.crossVectors(C, V);
            const F = M.dot(u[E]) < 0 ? -1 : 1;
            (l[4 * E] = x.x),
              (l[4 * E + 1] = x.y),
              (l[4 * E + 2] = x.z),
              (l[4 * E + 3] = F);
          }
          for (let E = 0, V = b.length; E < V; ++E) {
            const j = b[E],
              F = j.start;
            for (let z = F, O = F + j.count; z < O; z += 3)
              w(i[z + 0]), w(i[z + 1]), w(i[z + 2]);
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (void 0 !== t) {
            let i = this.getAttribute("normal");
            if (void 0 === i)
              (i = new on(new Float32Array(3 * t.count), 3)),
                this.setAttribute("normal", i);
            else for (let h = 0, f = i.count; h < f; h++) i.setXYZ(h, 0, 0, 0);
            const r = new A(),
              s = new A(),
              o = new A(),
              a = new A(),
              l = new A(),
              c = new A(),
              u = new A(),
              d = new A();
            if (e)
              for (let h = 0, f = e.count; h < f; h += 3) {
                const p = e.getX(h + 0),
                  _ = e.getX(h + 1),
                  m = e.getX(h + 2);
                r.fromBufferAttribute(t, p),
                  s.fromBufferAttribute(t, _),
                  o.fromBufferAttribute(t, m),
                  u.subVectors(o, s),
                  d.subVectors(r, s),
                  u.cross(d),
                  a.fromBufferAttribute(i, p),
                  l.fromBufferAttribute(i, _),
                  c.fromBufferAttribute(i, m),
                  a.add(u),
                  l.add(u),
                  c.add(u),
                  i.setXYZ(p, a.x, a.y, a.z),
                  i.setXYZ(_, l.x, l.y, l.z),
                  i.setXYZ(m, c.x, c.y, c.z);
              }
            else
              for (let h = 0, f = t.count; h < f; h += 3)
                r.fromBufferAttribute(t, h + 0),
                  s.fromBufferAttribute(t, h + 1),
                  o.fromBufferAttribute(t, h + 2),
                  u.subVectors(o, s),
                  d.subVectors(r, s),
                  u.cross(d),
                  i.setXYZ(h + 0, u.x, u.y, u.z),
                  i.setXYZ(h + 1, u.x, u.y, u.z),
                  i.setXYZ(h + 2, u.x, u.y, u.z);
            this.normalizeNormals(), (i.needsUpdate = !0);
          }
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, i = e.count; t < i; t++)
            Zn.fromBufferAttribute(e, t),
              Zn.normalize(),
              e.setXYZ(t, Zn.x, Zn.y, Zn.z);
        }
        toNonIndexed() {
          function e(a, l) {
            const c = a.array,
              u = a.itemSize,
              d = a.normalized,
              h = new c.constructor(l.length * u);
            let f = 0,
              p = 0;
            for (let _ = 0, m = l.length; _ < m; _++) {
              f = a.isInterleavedBufferAttribute
                ? l[_] * a.data.stride + a.offset
                : l[_] * u;
              for (let g = 0; g < u; g++) h[p++] = c[f++];
            }
            return new on(h, u, d);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new ut(),
            i = this.index.array,
            r = this.attributes;
          for (const a in r) {
            const c = e(r[a], i);
            t.setAttribute(a, c);
          }
          const s = this.morphAttributes;
          for (const a in s) {
            const l = [],
              c = s[a];
            for (let u = 0, d = c.length; u < d; u++) {
              const f = e(c[u], i);
              l.push(f);
            }
            t.morphAttributes[a] = l;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const o = this.groups;
          for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const l = this.parameters;
            for (const c in l) void 0 !== l[c] && (e[c] = l[c]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          null !== t &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const i = this.attributes;
          for (const l in i) e.data.attributes[l] = i[l].toJSON(e.data);
          const r = {};
          let s = !1;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
              u = [];
            for (let d = 0, h = c.length; d < h; d++)
              u.push(c[d].toJSON(e.data));
            u.length > 0 && ((r[l] = u), (s = !0));
          }
          s &&
            ((e.data.morphAttributes = r),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const o = this.groups;
          o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
          const a = this.boundingSphere;
          return (
            null !== a &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const i = e.index;
          null !== i && this.setIndex(i.clone(t));
          const r = e.attributes;
          for (const c in r) this.setAttribute(c, r[c].clone(t));
          const s = e.morphAttributes;
          for (const c in s) {
            const u = [],
              d = s[c];
            for (let h = 0, f = d.length; h < f; h++) u.push(d[h].clone(t));
            this.morphAttributes[c] = u;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const o = e.groups;
          for (let c = 0, u = o.length; c < u; c++) {
            const d = o[c];
            this.addGroup(d.start, d.count, d.materialIndex);
          }
          const a = e.boundingBox;
          null !== a && (this.boundingBox = a.clone());
          const l = e.boundingSphere;
          return (
            null !== l && (this.boundingSphere = l.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      const hP = new Ae(),
        La = new Qd(),
        bm = new Jr(),
        fP = new A(),
        Lc = new A(),
        Fc = new A(),
        Nc = new A(),
        zb = new A(),
        xm = new A(),
        wm = new $(),
        Mm = new $(),
        Sm = new $(),
        pP = new A(),
        mP = new A(),
        gP = new A(),
        Em = new A(),
        Cm = new A();
      class Kn extends Dn {
        constructor(e = new ut(), t = new Ar()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            void 0 !== e.morphTargetInfluences &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes,
            i = Object.keys(t);
          if (i.length > 0) {
            const r = t[i[0]];
            if (void 0 !== r) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s].name || String(s);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[a] = s);
              }
            }
          }
        }
        getVertexPosition(e, t) {
          const i = this.geometry,
            s = i.morphAttributes.position,
            o = i.morphTargetsRelative;
          t.fromBufferAttribute(i.attributes.position, e);
          const a = this.morphTargetInfluences;
          if (s && a) {
            xm.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
              const u = a[l];
              0 !== u &&
                (zb.fromBufferAttribute(s[l], e),
                xm.addScaledVector(o ? zb : zb.sub(t), u));
            }
            t.add(xm);
          }
          return t;
        }
        raycast(e, t) {
          const i = this.geometry,
            s = this.matrixWorld;
          void 0 !== this.material &&
            (null === i.boundingSphere && i.computeBoundingSphere(),
            bm.copy(i.boundingSphere),
            bm.applyMatrix4(s),
            La.copy(e.ray).recast(e.near),
            (!1 !== bm.containsPoint(La.origin) ||
              !(
                null === La.intersectSphere(bm, fP) ||
                La.origin.distanceToSquared(fP) > (e.far - e.near) ** 2
              )) &&
              (hP.copy(s).invert(),
              La.copy(e.ray).applyMatrix4(hP),
              (null === i.boundingBox ||
                !1 !== La.intersectsBox(i.boundingBox)) &&
                this._computeIntersections(e, t, La)));
        }
        _computeIntersections(e, t, i) {
          let r;
          const s = this.geometry,
            o = this.material,
            a = s.index,
            l = s.attributes.position,
            c = s.attributes.uv,
            u = s.attributes.uv1,
            d = s.attributes.normal,
            h = s.groups,
            f = s.drawRange;
          if (null !== a)
            if (Array.isArray(o))
              for (let p = 0, _ = h.length; p < _; p++) {
                const m = h[p],
                  g = o[m.materialIndex];
                for (
                  let b = Math.max(m.start, f.start),
                    x = Math.min(
                      a.count,
                      Math.min(m.start + m.count, f.start + f.count)
                    );
                  b < x;
                  b += 3
                )
                  (r = Tm(
                    this,
                    g,
                    e,
                    i,
                    c,
                    u,
                    d,
                    a.getX(b),
                    a.getX(b + 1),
                    a.getX(b + 2)
                  )),
                    r &&
                      ((r.faceIndex = Math.floor(b / 3)),
                      (r.face.materialIndex = m.materialIndex),
                      t.push(r));
              }
            else
              for (
                let m = Math.max(0, f.start),
                  g = Math.min(a.count, f.start + f.count);
                m < g;
                m += 3
              )
                (r = Tm(
                  this,
                  o,
                  e,
                  i,
                  c,
                  u,
                  d,
                  a.getX(m),
                  a.getX(m + 1),
                  a.getX(m + 2)
                )),
                  r && ((r.faceIndex = Math.floor(m / 3)), t.push(r));
          else if (void 0 !== l)
            if (Array.isArray(o))
              for (let p = 0, _ = h.length; p < _; p++) {
                const m = h[p],
                  g = o[m.materialIndex];
                for (
                  let b = Math.max(m.start, f.start),
                    x = Math.min(
                      l.count,
                      Math.min(m.start + m.count, f.start + f.count)
                    );
                  b < x;
                  b += 3
                )
                  (r = Tm(this, g, e, i, c, u, d, b, b + 1, b + 2)),
                    r &&
                      ((r.faceIndex = Math.floor(b / 3)),
                      (r.face.materialIndex = m.materialIndex),
                      t.push(r));
              }
            else
              for (
                let m = Math.max(0, f.start),
                  g = Math.min(l.count, f.start + f.count);
                m < g;
                m += 3
              )
                (r = Tm(this, o, e, i, c, u, d, m, m + 1, m + 2)),
                  r && ((r.faceIndex = Math.floor(m / 3)), t.push(r));
        }
      }
      function Tm(n, e, t, i, r, s, o, a, l, c) {
        n.getVertexPosition(a, Lc),
          n.getVertexPosition(l, Fc),
          n.getVertexPosition(c, Nc);
        const u = (function GX(n, e, t, i, r, s, o, a) {
          let l;
          if (
            ((l =
              e.side === zi
                ? i.intersectTriangle(o, s, r, !0, a)
                : i.intersectTriangle(r, s, o, e.side === $s, a)),
            null === l)
          )
            return null;
          Cm.copy(a), Cm.applyMatrix4(n.matrixWorld);
          const c = t.ray.origin.distanceTo(Cm);
          return c < t.near || c > t.far
            ? null
            : { distance: c, point: Cm.clone(), object: n };
        })(n, e, t, i, Lc, Fc, Nc, Em);
        if (u) {
          r &&
            (wm.fromBufferAttribute(r, a),
            Mm.fromBufferAttribute(r, l),
            Sm.fromBufferAttribute(r, c),
            (u.uv = or.getInterpolation(Em, Lc, Fc, Nc, wm, Mm, Sm, new $()))),
            s &&
              (wm.fromBufferAttribute(s, a),
              Mm.fromBufferAttribute(s, l),
              Sm.fromBufferAttribute(s, c),
              (u.uv1 = or.getInterpolation(
                Em,
                Lc,
                Fc,
                Nc,
                wm,
                Mm,
                Sm,
                new $()
              )),
              (u.uv2 = u.uv1)),
            o &&
              (pP.fromBufferAttribute(o, a),
              mP.fromBufferAttribute(o, l),
              gP.fromBufferAttribute(o, c),
              (u.normal = or.getInterpolation(
                Em,
                Lc,
                Fc,
                Nc,
                pP,
                mP,
                gP,
                new A()
              )),
              u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
          const d = { a, b: l, c, normal: new A(), materialIndex: 0 };
          or.getNormal(Lc, Fc, Nc, d.normal), (u.face = d);
        }
        return u;
      }
      class kc extends ut {
        constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: i,
              widthSegments: r,
              heightSegments: s,
              depthSegments: o,
            });
          const a = this;
          (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
          const l = [],
            c = [],
            u = [],
            d = [];
          let h = 0,
            f = 0;
          function p(_, m, g, y, v, b, x, M, S, C, w) {
            const E = b / S,
              V = x / C,
              j = b / 2,
              F = x / 2,
              k = M / 2,
              z = S + 1,
              O = C + 1;
            let L = 0,
              U = 0;
            const W = new A();
            for (let Z = 0; Z < O; Z++) {
              const B = Z * V - F;
              for (let q = 0; q < z; q++)
                (W[_] = (q * E - j) * y),
                  (W[m] = B * v),
                  (W[g] = k),
                  c.push(W.x, W.y, W.z),
                  (W[_] = 0),
                  (W[m] = 0),
                  (W[g] = M > 0 ? 1 : -1),
                  u.push(W.x, W.y, W.z),
                  d.push(q / S),
                  d.push(1 - Z / C),
                  (L += 1);
            }
            for (let Z = 0; Z < C; Z++)
              for (let B = 0; B < S; B++) {
                const le = h + B + z * (Z + 1),
                  te = h + (B + 1) + z * (Z + 1),
                  ce = h + (B + 1) + z * Z;
                l.push(h + B + z * Z, le, ce), l.push(le, te, ce), (U += 6);
              }
            a.addGroup(f, U, w), (f += U), (h += L);
          }
          p("z", "y", "x", -1, -1, i, t, e, o, s, 0),
            p("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
            p("x", "z", "y", 1, 1, e, i, t, r, o, 2),
            p("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
            p("x", "y", "z", 1, -1, e, t, i, r, s, 4),
            p("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
            this.setIndex(l),
            this.setAttribute("position", new Ie(c, 3)),
            this.setAttribute("normal", new Ie(u, 3)),
            this.setAttribute("uv", new Ie(d, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new kc(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
          );
        }
      }
      function Bc(n) {
        const e = {};
        for (const t in n) {
          e[t] = {};
          for (const i in n[t]) {
            const r = n[t][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? r.isRenderTargetTexture
                ? (console.warn(
                    "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                  ),
                  (e[t][i] = null))
                : (e[t][i] = r.clone())
              : (e[t][i] = Array.isArray(r) ? r.slice() : r);
          }
        }
        return e;
      }
      function Di(n) {
        const e = {};
        for (let t = 0; t < n.length; t++) {
          const i = Bc(n[t]);
          for (const r in i) e[r] = i[r];
        }
        return e;
      }
      function _P(n) {
        return null === n.getRenderTarget() ? n.outputColorSpace : Kr;
      }
      const Uc = { clone: Bc, merge: Di };
      class $n extends ar {
        constructor(e) {
          super(),
            (this.isShaderMaterial = !0),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader =
              "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv1: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== e && this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = Bc(e.uniforms)),
            (this.uniformsGroups = (function WX(n) {
              const e = [];
              for (let t = 0; t < n.length; t++) e.push(n[t].clone());
              return e;
            })(e.uniformsGroups)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            t.uniforms[r] =
              o && o.isTexture
                ? { type: "t", value: o.toJSON(e).uuid }
                : o && o.isColor
                ? { type: "c", value: o.getHex() }
                : o && o.isVector2
                ? { type: "v2", value: o.toArray() }
                : o && o.isVector3
                ? { type: "v3", value: o.toArray() }
                : o && o.isVector4
                ? { type: "v4", value: o.toArray() }
                : o && o.isMatrix3
                ? { type: "m3", value: o.toArray() }
                : o && o.isMatrix4
                ? { type: "m4", value: o.toArray() }
                : { value: o };
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader),
            (t.lights = this.lights),
            (t.clipping = this.clipping);
          const i = {};
          for (const r in this.extensions)
            !0 === this.extensions[r] && (i[r] = !0);
          return Object.keys(i).length > 0 && (t.extensions = i), t;
        }
      }
      class Hb extends Dn {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new Ae()),
            (this.projectionMatrix = new Ae()),
            (this.projectionMatrixInverse = new Ae()),
            (this.coordinateSystem = no);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            (this.coordinateSystem = e.coordinateSystem),
            this
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Wn extends Hb {
        constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = i),
            (this.far = r),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = 2 * bc * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(0.5 * Ra * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return 2 * bc * Math.atan(Math.tan(0.5 * Ra * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, i, r, s, o) {
          (this.aspect = e / t),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(0.5 * Ra * this.fov)) / this.zoom,
            i = 2 * t,
            r = this.aspect * i,
            s = -0.5 * r;
          const o = this.view;
          if (null !== this.view && this.view.enabled) {
            const l = o.fullWidth,
              c = o.fullHeight;
            (s += (o.offsetX * r) / l),
              (t -= (o.offsetY * i) / c),
              (r *= o.width / l),
              (i *= o.height / c);
          }
          const a = this.filmOffset;
          0 !== a && (s += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              s,
              s + r,
              t,
              t - i,
              e,
              this.far,
              this.coordinateSystem
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      class qX extends Dn {
        constructor(e, t, i) {
          super(),
            (this.type = "CubeCamera"),
            (this.renderTarget = i),
            (this.coordinateSystem = null);
          const r = new Wn(-90, 1, e, t);
          (r.layers = this.layers), this.add(r);
          const s = new Wn(-90, 1, e, t);
          (s.layers = this.layers), this.add(s);
          const o = new Wn(-90, 1, e, t);
          (o.layers = this.layers), this.add(o);
          const a = new Wn(-90, 1, e, t);
          (a.layers = this.layers), this.add(a);
          const l = new Wn(-90, 1, e, t);
          (l.layers = this.layers), this.add(l);
          const c = new Wn(-90, 1, e, t);
          (c.layers = this.layers), this.add(c);
        }
        updateCoordinateSystem() {
          const e = this.coordinateSystem,
            t = this.children.concat(),
            [i, r, s, o, a, l] = t;
          for (const c of t) this.remove(c);
          if (e === no)
            i.up.set(0, 1, 0),
              i.lookAt(1, 0, 0),
              r.up.set(0, 1, 0),
              r.lookAt(-1, 0, 0),
              s.up.set(0, 0, -1),
              s.lookAt(0, 1, 0),
              o.up.set(0, 0, 1),
              o.lookAt(0, -1, 0),
              a.up.set(0, 1, 0),
              a.lookAt(0, 0, 1),
              l.up.set(0, 1, 0),
              l.lookAt(0, 0, -1);
          else {
            if (2001 !== e)
              throw new Error(
                "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                  e
              );
            i.up.set(0, -1, 0),
              i.lookAt(-1, 0, 0),
              r.up.set(0, -1, 0),
              r.lookAt(1, 0, 0),
              s.up.set(0, 0, 1),
              s.lookAt(0, 1, 0),
              o.up.set(0, 0, -1),
              o.lookAt(0, -1, 0),
              a.up.set(0, -1, 0),
              a.lookAt(0, 0, 1),
              l.up.set(0, -1, 0),
              l.lookAt(0, 0, -1);
          }
          for (const c of t) this.add(c), c.updateMatrixWorld();
        }
        update(e, t) {
          null === this.parent && this.updateMatrixWorld();
          const i = this.renderTarget;
          this.coordinateSystem !== e.coordinateSystem &&
            ((this.coordinateSystem = e.coordinateSystem),
            this.updateCoordinateSystem());
          const [r, s, o, a, l, c] = this.children,
            u = e.getRenderTarget(),
            d = e.toneMapping,
            h = e.xr.enabled;
          (e.toneMapping = Qs), (e.xr.enabled = !1);
          const f = i.texture.generateMipmaps;
          (i.texture.generateMipmaps = !1),
            e.setRenderTarget(i, 0),
            e.render(t, r),
            e.setRenderTarget(i, 1),
            e.render(t, s),
            e.setRenderTarget(i, 2),
            e.render(t, o),
            e.setRenderTarget(i, 3),
            e.render(t, a),
            e.setRenderTarget(i, 4),
            e.render(t, l),
            (i.texture.generateMipmaps = f),
            e.setRenderTarget(i, 5),
            e.render(t, c),
            e.setRenderTarget(u),
            (e.toneMapping = d),
            (e.xr.enabled = h),
            (i.texture.needsPMREMUpdate = !0);
        }
      }
      class Am extends Ai {
        constructor(e, t, i, r, s, o, a, l, c, u) {
          super(
            (e = void 0 !== e ? e : []),
            (t = void 0 !== t ? t : Ea),
            i,
            r,
            s,
            o,
            a,
            l,
            c,
            u
          ),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class YX extends li {
        constructor(e = 1, t = {}) {
          super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
          const i = { width: e, height: e, depth: 1 },
            r = [i, i, i, i, i, i];
          void 0 !== t.encoding &&
            (Zd(
              "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
            ),
            (t.colorSpace = t.encoding === Fo ? qe : Ia)),
            (this.texture = new Am(
              r,
              t.mapping,
              t.wrapS,
              t.wrapT,
              t.magFilter,
              t.minFilter,
              t.format,
              t.type,
              t.anisotropy,
              t.colorSpace
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== t.generateMipmaps && t.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== t.minFilter ? t.minFilter : fn);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.colorSpace = t.colorSpace),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const i_uniforms = { tEquirect: { value: null } },
            i_vertexShader =
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            i_fragmentShader =
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            r = new kc(5, 5, 5),
            s = new $n({
              name: "CubemapFromEquirect",
              uniforms: Bc(i_uniforms),
              vertexShader: i_vertexShader,
              fragmentShader: i_fragmentShader,
              side: zi,
              blending: Zr,
            });
          s.uniforms.tEquirect.value = t;
          const o = new Kn(r, s),
            a = t.minFilter;
          return (
            t.minFilter === eo && (t.minFilter = fn),
            new qX(1, 10, this).update(e, o),
            (t.minFilter = a),
            o.geometry.dispose(),
            o.material.dispose(),
            this
          );
        }
        clear(e, t, i, r) {
          const s = e.getRenderTarget();
          for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o), e.clear(t, i, r);
          e.setRenderTarget(s);
        }
      }
      const Gb = new A(),
        ZX = new A(),
        KX = new vt();
      class Fa {
        constructor(e = new A(1, 0, 0), t = 0) {
          (this.isPlane = !0), (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, i, r) {
          return this.normal.set(e, t, i), (this.constant = r), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, i) {
          const r = Gb.subVectors(i, t).cross(ZX.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(r, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t
            .copy(e)
            .addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
          const i = e.delta(Gb),
            r = this.normal.dot(i);
          if (0 === r)
            return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
          const s = -(e.start.dot(this.normal) + this.constant) / r;
          return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            i = this.distanceToPoint(e.end);
          return (t < 0 && i > 0) || (i < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const i = t || KX.getNormalMatrix(e),
            r = this.coplanarPoint(Gb).applyMatrix4(e),
            s = this.normal.applyMatrix3(i).normalize();
          return (this.constant = -r.dot(s)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Na = new Jr(),
        Dm = new A();
      class Wb {
        constructor(
          e = new Fa(),
          t = new Fa(),
          i = new Fa(),
          r = new Fa(),
          s = new Fa(),
          o = new Fa()
        ) {
          this.planes = [e, t, i, r, s, o];
        }
        set(e, t, i, r, s, o) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(i),
            a[3].copy(r),
            a[4].copy(s),
            a[5].copy(o),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
          return this;
        }
        setFromProjectionMatrix(e, t = no) {
          const i = this.planes,
            r = e.elements,
            s = r[0],
            o = r[1],
            a = r[2],
            l = r[3],
            c = r[4],
            u = r[5],
            d = r[6],
            h = r[7],
            f = r[8],
            p = r[9],
            _ = r[10],
            m = r[11],
            g = r[12],
            y = r[13],
            v = r[14],
            b = r[15];
          if (
            (i[0].setComponents(l - s, h - c, m - f, b - g).normalize(),
            i[1].setComponents(l + s, h + c, m + f, b + g).normalize(),
            i[2].setComponents(l + o, h + u, m + p, b + y).normalize(),
            i[3].setComponents(l - o, h - u, m - p, b - y).normalize(),
            i[4].setComponents(l - a, h - d, m - _, b - v).normalize(),
            t === no)
          )
            i[5].setComponents(l + a, h + d, m + _, b + v).normalize();
          else {
            if (2001 !== t)
              throw new Error(
                "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                  t
              );
            i[5].setComponents(a, d, _, v).normalize();
          }
          return this;
        }
        intersectsObject(e) {
          if (void 0 !== e.boundingSphere)
            null === e.boundingSphere && e.computeBoundingSphere(),
              Na.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
            const t = e.geometry;
            null === t.boundingSphere && t.computeBoundingSphere(),
              Na.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          }
          return this.intersectsSphere(Na);
        }
        intersectsSprite(e) {
          return (
            Na.center.set(0, 0, 0),
            (Na.radius = 0.7071067811865476),
            Na.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Na)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            i = e.center,
            r = -e.radius;
          for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r) return !1;
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (
              ((Dm.x = r.normal.x > 0 ? e.max.x : e.min.x),
              (Dm.y = r.normal.y > 0 ? e.max.y : e.min.y),
              (Dm.z = r.normal.z > 0 ? e.max.z : e.min.z),
              r.distanceToPoint(Dm) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function vP() {
        let n = null,
          e = !1,
          t = null,
          i = null;
        function r(s, o) {
          t(s, o), (i = n.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== e &&
              null !== t &&
              ((i = n.requestAnimationFrame(r)), (e = !0));
          },
          stop: function () {
            n.cancelAnimationFrame(i), (e = !1);
          },
          setAnimationLoop: function (s) {
            t = s;
          },
          setContext: function (s) {
            n = s;
          },
        };
      }
      function $X(n, e) {
        const t = e.isWebGL2,
          i = new WeakMap();
        return {
          get: function o(c) {
            return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
          },
          remove: function a(c) {
            c.isInterleavedBufferAttribute && (c = c.data);
            const u = i.get(c);
            u && (n.deleteBuffer(u.buffer), i.delete(c));
          },
          update: function l(c, u) {
            if (c.isGLBufferAttribute) {
              const h = i.get(c);
              return void (
                (!h || h.version < c.version) &&
                i.set(c, {
                  buffer: c.buffer,
                  type: c.type,
                  bytesPerElement: c.elementSize,
                  version: c.version,
                })
              );
            }
            c.isInterleavedBufferAttribute && (c = c.data);
            const d = i.get(c);
            void 0 === d
              ? i.set(
                  c,
                  (function r(c, u) {
                    const d = c.array,
                      h = c.usage,
                      f = n.createBuffer();
                    let p;
                    if (
                      (n.bindBuffer(u, f),
                      n.bufferData(u, d, h),
                      c.onUploadCallback(),
                      d instanceof Float32Array)
                    )
                      p = n.FLOAT;
                    else if (d instanceof Uint16Array)
                      if (c.isFloat16BufferAttribute) {
                        if (!t)
                          throw new Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          );
                        p = n.HALF_FLOAT;
                      } else p = n.UNSIGNED_SHORT;
                    else if (d instanceof Int16Array) p = n.SHORT;
                    else if (d instanceof Uint32Array) p = n.UNSIGNED_INT;
                    else if (d instanceof Int32Array) p = n.INT;
                    else if (d instanceof Int8Array) p = n.BYTE;
                    else if (d instanceof Uint8Array) p = n.UNSIGNED_BYTE;
                    else {
                      if (!(d instanceof Uint8ClampedArray))
                        throw new Error(
                          "THREE.WebGLAttributes: Unsupported buffer data format: " +
                            d
                        );
                      p = n.UNSIGNED_BYTE;
                    }
                    return {
                      buffer: f,
                      type: p,
                      bytesPerElement: d.BYTES_PER_ELEMENT,
                      version: c.version,
                    };
                  })(c, u)
                )
              : d.version < c.version &&
                ((function s(c, u, d) {
                  const h = u.array,
                    f = u.updateRange;
                  n.bindBuffer(d, c),
                    -1 === f.count
                      ? n.bufferSubData(d, 0, h)
                      : (t
                          ? n.bufferSubData(
                              d,
                              f.offset * h.BYTES_PER_ELEMENT,
                              h,
                              f.offset,
                              f.count
                            )
                          : n.bufferSubData(
                              d,
                              f.offset * h.BYTES_PER_ELEMENT,
                              h.subarray(f.offset, f.offset + f.count)
                            ),
                        (f.count = -1)),
                    u.onUploadCallback();
                })(d.buffer, c, u),
                (d.version = c.version));
          },
        };
      }
      class Im extends ut {
        constructor(e = 1, t = 1, i = 1, r = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: i,
              heightSegments: r,
            });
          const s = e / 2,
            o = t / 2,
            a = Math.floor(i),
            l = Math.floor(r),
            c = a + 1,
            u = l + 1,
            d = e / a,
            h = t / l,
            f = [],
            p = [],
            _ = [],
            m = [];
          for (let g = 0; g < u; g++) {
            const y = g * h - o;
            for (let v = 0; v < c; v++)
              p.push(v * d - s, -y, 0),
                _.push(0, 0, 1),
                m.push(v / a),
                m.push(1 - g / l);
          }
          for (let g = 0; g < l; g++)
            for (let y = 0; y < a; y++) {
              const b = y + c * (g + 1),
                x = y + 1 + c * (g + 1),
                M = y + 1 + c * g;
              f.push(y + c * g, b, M), f.push(b, x, M);
            }
          this.setIndex(f),
            this.setAttribute("position", new Ie(p, 3)),
            this.setAttribute("normal", new Ie(_, 3)),
            this.setAttribute("uv", new Ie(m, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new Im(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      const yt = {
          alphahash_fragment:
            "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
          alphahash_pars_fragment:
            "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
          alphatest_pars_fragment:
            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex:
            "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
          iridescence_fragment:
            "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          colorspace_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          colorspace_pars_fragment:
            "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_fragment:
            "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
          lights_lambert_pars_fragment:
            "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphcolor_vertex:
            "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          normal_fragment_maps:
            "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex:
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
          iridescence_pars_fragment:
            "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          opaque_fragment:
            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
          uv_pars_fragment:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_pars_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag:
            "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          backgroundCube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          backgroundCube_frag:
            "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag:
            "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
        },
        be = {
          common: {
            diffuse: { value: new de(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            mapTransform: { value: new vt() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new vt() },
            alphaTest: { value: 0 },
          },
          specularmap: {
            specularMap: { value: null },
            specularMapTransform: { value: new vt() },
          },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: {
            aoMap: { value: null },
            aoMapIntensity: { value: 1 },
            aoMapTransform: { value: new vt() },
          },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
            lightMapTransform: { value: new vt() },
          },
          bumpmap: {
            bumpMap: { value: null },
            bumpMapTransform: { value: new vt() },
            bumpScale: { value: 1 },
          },
          normalmap: {
            normalMap: { value: null },
            normalMapTransform: { value: new vt() },
            normalScale: { value: new $(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementMapTransform: { value: new vt() },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          emissivemap: {
            emissiveMap: { value: null },
            emissiveMapTransform: { value: new vt() },
          },
          metalnessmap: {
            metalnessMap: { value: null },
            metalnessMapTransform: { value: new vt() },
          },
          roughnessmap: {
            roughnessMap: { value: null },
            roughnessMapTransform: { value: new vt() },
          },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new de(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new de(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaMapTransform: { value: new vt() },
            alphaTest: { value: 0 },
            uvTransform: { value: new vt() },
          },
          sprite: {
            diffuse: { value: new de(16777215) },
            opacity: { value: 1 },
            center: { value: new $(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            mapTransform: { value: new vt() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new vt() },
            alphaTest: { value: 0 },
          },
        },
        Ss = {
          basic: {
            uniforms: Di([
              be.common,
              be.specularmap,
              be.envmap,
              be.aomap,
              be.lightmap,
              be.fog,
            ]),
            vertexShader: yt.meshbasic_vert,
            fragmentShader: yt.meshbasic_frag,
          },
          lambert: {
            uniforms: Di([
              be.common,
              be.specularmap,
              be.envmap,
              be.aomap,
              be.lightmap,
              be.emissivemap,
              be.bumpmap,
              be.normalmap,
              be.displacementmap,
              be.fog,
              be.lights,
              { emissive: { value: new de(0) } },
            ]),
            vertexShader: yt.meshlambert_vert,
            fragmentShader: yt.meshlambert_frag,
          },
          phong: {
            uniforms: Di([
              be.common,
              be.specularmap,
              be.envmap,
              be.aomap,
              be.lightmap,
              be.emissivemap,
              be.bumpmap,
              be.normalmap,
              be.displacementmap,
              be.fog,
              be.lights,
              {
                emissive: { value: new de(0) },
                specular: { value: new de(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: yt.meshphong_vert,
            fragmentShader: yt.meshphong_frag,
          },
          standard: {
            uniforms: Di([
              be.common,
              be.envmap,
              be.aomap,
              be.lightmap,
              be.emissivemap,
              be.bumpmap,
              be.normalmap,
              be.displacementmap,
              be.roughnessmap,
              be.metalnessmap,
              be.fog,
              be.lights,
              {
                emissive: { value: new de(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: yt.meshphysical_vert,
            fragmentShader: yt.meshphysical_frag,
          },
          toon: {
            uniforms: Di([
              be.common,
              be.aomap,
              be.lightmap,
              be.emissivemap,
              be.bumpmap,
              be.normalmap,
              be.displacementmap,
              be.gradientmap,
              be.fog,
              be.lights,
              { emissive: { value: new de(0) } },
            ]),
            vertexShader: yt.meshtoon_vert,
            fragmentShader: yt.meshtoon_frag,
          },
          matcap: {
            uniforms: Di([
              be.common,
              be.bumpmap,
              be.normalmap,
              be.displacementmap,
              be.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: yt.meshmatcap_vert,
            fragmentShader: yt.meshmatcap_frag,
          },
          points: {
            uniforms: Di([be.points, be.fog]),
            vertexShader: yt.points_vert,
            fragmentShader: yt.points_frag,
          },
          dashed: {
            uniforms: Di([
              be.common,
              be.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: yt.linedashed_vert,
            fragmentShader: yt.linedashed_frag,
          },
          depth: {
            uniforms: Di([be.common, be.displacementmap]),
            vertexShader: yt.depth_vert,
            fragmentShader: yt.depth_frag,
          },
          normal: {
            uniforms: Di([
              be.common,
              be.bumpmap,
              be.normalmap,
              be.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: yt.meshnormal_vert,
            fragmentShader: yt.meshnormal_frag,
          },
          sprite: {
            uniforms: Di([be.sprite, be.fog]),
            vertexShader: yt.sprite_vert,
            fragmentShader: yt.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new vt() },
              t2D: { value: null },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: yt.background_vert,
            fragmentShader: yt.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              backgroundBlurriness: { value: 0 },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: yt.backgroundCube_vert,
            fragmentShader: yt.backgroundCube_frag,
          },
          cube: {
            uniforms: {
              tCube: { value: null },
              tFlip: { value: -1 },
              opacity: { value: 1 },
            },
            vertexShader: yt.cube_vert,
            fragmentShader: yt.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: yt.equirect_vert,
            fragmentShader: yt.equirect_frag,
          },
          distanceRGBA: {
            uniforms: Di([
              be.common,
              be.displacementmap,
              {
                referencePosition: { value: new A() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: yt.distanceRGBA_vert,
            fragmentShader: yt.distanceRGBA_frag,
          },
          shadow: {
            uniforms: Di([
              be.lights,
              be.fog,
              { color: { value: new de(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: yt.shadow_vert,
            fragmentShader: yt.shadow_frag,
          },
        };
      Ss.physical = {
        uniforms: Di([
          Ss.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: new vt() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: new vt() },
            clearcoatNormalScale: { value: new $(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: new vt() },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: new vt() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: new vt() },
            sheen: { value: 0 },
            sheenColor: { value: new de(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: new vt() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: new vt() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: new vt() },
            transmissionSamplerSize: { value: new $() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: new vt() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new de(0) },
            specularColor: { value: new de(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: new vt() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: new vt() },
            anisotropyVector: { value: new $() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: new vt() },
          },
        ]),
        vertexShader: yt.meshphysical_vert,
        fragmentShader: yt.meshphysical_frag,
      };
      const Rm = { r: 0, b: 0, g: 0 };
      function Zq(n, e, t, i, r, s, o) {
        const a = new de(0);
        let c,
          u,
          l = !0 === s ? 0 : 1,
          d = null,
          h = 0,
          f = null;
        function _(m, g) {
          m.getRGB(Rm, _P(n)), i.buffers.color.setClear(Rm.r, Rm.g, Rm.b, g, o);
        }
        return {
          getClearColor: function () {
            return a;
          },
          setClearColor: function (m, g = 1) {
            a.set(m), (l = g), _(a, l);
          },
          getClearAlpha: function () {
            return l;
          },
          setClearAlpha: function (m) {
            (l = m), _(a, l);
          },
          render: function p(m, g) {
            let y = !1,
              v = !0 === g.isScene ? g.background : null;
            switch (
              (v &&
                v.isTexture &&
                (v = (g.backgroundBlurriness > 0 ? t : e).get(v)),
              null === v ? _(a, l) : v && v.isColor && (_(v, 1), (y = !0)),
              n.xr.getEnvironmentBlendMode())
            ) {
              case "opaque":
                y = !0;
                break;
              case "additive":
                i.buffers.color.setClear(0, 0, 0, 1, o), (y = !0);
                break;
              case "alpha-blend":
                i.buffers.color.setClear(0, 0, 0, 0, o), (y = !0);
            }
            (n.autoClear || y) &&
              n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
              v && (v.isCubeTexture || v.mapping === Gd)
                ? (void 0 === u &&
                    ((u = new Kn(
                      new kc(1, 1, 1),
                      new $n({
                        name: "BackgroundCubeMaterial",
                        uniforms: Bc(Ss.backgroundCube.uniforms),
                        vertexShader: Ss.backgroundCube.vertexShader,
                        fragmentShader: Ss.backgroundCube.fragmentShader,
                        side: zi,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    u.geometry.deleteAttribute("normal"),
                    u.geometry.deleteAttribute("uv"),
                    (u.onBeforeRender = function (M, S, C) {
                      this.matrixWorld.copyPosition(C.matrixWorld);
                    }),
                    Object.defineProperty(u.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    r.update(u)),
                  (u.material.uniforms.envMap.value = v),
                  (u.material.uniforms.flipEnvMap.value =
                    v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1),
                  (u.material.uniforms.backgroundBlurriness.value =
                    g.backgroundBlurriness),
                  (u.material.uniforms.backgroundIntensity.value =
                    g.backgroundIntensity),
                  (u.material.toneMapped = v.colorSpace !== qe),
                  (d !== v || h !== v.version || f !== n.toneMapping) &&
                    ((u.material.needsUpdate = !0),
                    (d = v),
                    (h = v.version),
                    (f = n.toneMapping)),
                  u.layers.enableAll(),
                  m.unshift(u, u.geometry, u.material, 0, 0, null))
                : v &&
                  v.isTexture &&
                  (void 0 === c &&
                    ((c = new Kn(
                      new Im(2, 2),
                      new $n({
                        name: "BackgroundMaterial",
                        uniforms: Bc(Ss.background.uniforms),
                        vertexShader: Ss.background.vertexShader,
                        fragmentShader: Ss.background.fragmentShader,
                        side: $s,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    c.geometry.deleteAttribute("normal"),
                    Object.defineProperty(c.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    r.update(c)),
                  (c.material.uniforms.t2D.value = v),
                  (c.material.uniforms.backgroundIntensity.value =
                    g.backgroundIntensity),
                  (c.material.toneMapped = v.colorSpace !== qe),
                  !0 === v.matrixAutoUpdate && v.updateMatrix(),
                  c.material.uniforms.uvTransform.value.copy(v.matrix),
                  (d !== v || h !== v.version || f !== n.toneMapping) &&
                    ((c.material.needsUpdate = !0),
                    (d = v),
                    (h = v.version),
                    (f = n.toneMapping)),
                  c.layers.enableAll(),
                  m.unshift(c, c.geometry, c.material, 0, 0, null));
          },
        };
      }
      function Kq(n, e, t, i) {
        const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
          s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = i.isWebGL2 || null !== s,
          a = {},
          l = m(null);
        let c = l,
          u = !1;
        function f(k) {
          return i.isWebGL2 ? n.bindVertexArray(k) : s.bindVertexArrayOES(k);
        }
        function p(k) {
          return i.isWebGL2
            ? n.deleteVertexArray(k)
            : s.deleteVertexArrayOES(k);
        }
        function m(k) {
          const z = [],
            O = [],
            L = [];
          for (let U = 0; U < r; U++) (z[U] = 0), (O[U] = 0), (L[U] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: z,
            enabledAttributes: O,
            attributeDivisors: L,
            object: k,
            attributes: {},
            index: null,
          };
        }
        function v() {
          const k = c.newAttributes;
          for (let z = 0, O = k.length; z < O; z++) k[z] = 0;
        }
        function b(k) {
          x(k, 0);
        }
        function x(k, z) {
          const L = c.enabledAttributes,
            U = c.attributeDivisors;
          (c.newAttributes[k] = 1),
            0 === L[k] && (n.enableVertexAttribArray(k), (L[k] = 1)),
            U[k] !== z &&
              ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
                i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](k, z),
              (U[k] = z));
        }
        function M() {
          const k = c.newAttributes,
            z = c.enabledAttributes;
          for (let O = 0, L = z.length; O < L; O++)
            z[O] !== k[O] && (n.disableVertexAttribArray(O), (z[O] = 0));
        }
        function S(k, z, O, L, U, W, Z) {
          !0 === Z
            ? n.vertexAttribIPointer(k, z, O, U, W)
            : n.vertexAttribPointer(k, z, O, L, U, W);
        }
        function j() {
          F(), (u = !0), c !== l && ((c = l), f(c.object));
        }
        function F() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: function d(k, z, O, L, U) {
            let W = !1;
            if (o) {
              const Z = (function _(k, z, O) {
                const L = !0 === O.wireframe;
                let U = a[k.id];
                void 0 === U && ((U = {}), (a[k.id] = U));
                let W = U[z.id];
                void 0 === W && ((W = {}), (U[z.id] = W));
                let Z = W[L];
                return (
                  void 0 === Z &&
                    ((Z = m(
                      (function h() {
                        return i.isWebGL2
                          ? n.createVertexArray()
                          : s.createVertexArrayOES();
                      })()
                    )),
                    (W[L] = Z)),
                  Z
                );
              })(L, O, z);
              c !== Z && ((c = Z), f(c.object)),
                (W = (function g(k, z, O, L) {
                  const U = c.attributes,
                    W = z.attributes;
                  let Z = 0;
                  const B = O.getAttributes();
                  for (const q in B)
                    if (B[q].location >= 0) {
                      const te = U[q];
                      let ce = W[q];
                      if (
                        (void 0 === ce &&
                          ("instanceMatrix" === q &&
                            k.instanceMatrix &&
                            (ce = k.instanceMatrix),
                          "instanceColor" === q &&
                            k.instanceColor &&
                            (ce = k.instanceColor)),
                        void 0 === te ||
                          te.attribute !== ce ||
                          (ce && te.data !== ce.data))
                      )
                        return !0;
                      Z++;
                    }
                  return c.attributesNum !== Z || c.index !== L;
                })(k, L, O, U)),
                W &&
                  (function y(k, z, O, L) {
                    const U = {},
                      W = z.attributes;
                    let Z = 0;
                    const B = O.getAttributes();
                    for (const q in B)
                      if (B[q].location >= 0) {
                        let te = W[q];
                        void 0 === te &&
                          ("instanceMatrix" === q &&
                            k.instanceMatrix &&
                            (te = k.instanceMatrix),
                          "instanceColor" === q &&
                            k.instanceColor &&
                            (te = k.instanceColor));
                        const ce = {};
                        (ce.attribute = te),
                          te && te.data && (ce.data = te.data),
                          (U[q] = ce),
                          Z++;
                      }
                    (c.attributes = U), (c.attributesNum = Z), (c.index = L);
                  })(k, L, O, U);
            } else {
              const Z = !0 === z.wireframe;
              (c.geometry !== L.id ||
                c.program !== O.id ||
                c.wireframe !== Z) &&
                ((c.geometry = L.id),
                (c.program = O.id),
                (c.wireframe = Z),
                (W = !0));
            }
            null !== U && t.update(U, n.ELEMENT_ARRAY_BUFFER),
              (W || u) &&
                ((u = !1),
                (function C(k, z, O, L) {
                  if (
                    !1 === i.isWebGL2 &&
                    (k.isInstancedMesh || L.isInstancedBufferGeometry) &&
                    null === e.get("ANGLE_instanced_arrays")
                  )
                    return;
                  v();
                  const U = L.attributes,
                    W = O.getAttributes(),
                    Z = z.defaultAttributeValues;
                  for (const B in W) {
                    const q = W[B];
                    if (q.location >= 0) {
                      let le = U[B];
                      if (
                        (void 0 === le &&
                          ("instanceMatrix" === B &&
                            k.instanceMatrix &&
                            (le = k.instanceMatrix),
                          "instanceColor" === B &&
                            k.instanceColor &&
                            (le = k.instanceColor)),
                        void 0 !== le)
                      ) {
                        const te = le.normalized,
                          ce = le.itemSize,
                          Ce = t.get(le);
                        if (void 0 === Ce) continue;
                        const ve = Ce.buffer,
                          xe = Ce.type,
                          Ze = Ce.bytesPerElement,
                          dt =
                            !0 === i.isWebGL2 &&
                            (xe === n.INT ||
                              xe === n.UNSIGNED_INT ||
                              le.gpuType === hR);
                        if (le.isInterleavedBufferAttribute) {
                          const Ue = le.data,
                            P = Ue.stride,
                            ge = le.offset;
                          if (Ue.isInstancedInterleavedBuffer) {
                            for (let ie = 0; ie < q.locationSize; ie++)
                              x(q.location + ie, Ue.meshPerAttribute);
                            !0 !== k.isInstancedMesh &&
                              void 0 === L._maxInstanceCount &&
                              (L._maxInstanceCount =
                                Ue.meshPerAttribute * Ue.count);
                          } else
                            for (let ie = 0; ie < q.locationSize; ie++)
                              b(q.location + ie);
                          n.bindBuffer(n.ARRAY_BUFFER, ve);
                          for (let ie = 0; ie < q.locationSize; ie++)
                            S(
                              q.location + ie,
                              ce / q.locationSize,
                              xe,
                              te,
                              P * Ze,
                              (ge + (ce / q.locationSize) * ie) * Ze,
                              dt
                            );
                        } else {
                          if (le.isInstancedBufferAttribute) {
                            for (let Ue = 0; Ue < q.locationSize; Ue++)
                              x(q.location + Ue, le.meshPerAttribute);
                            !0 !== k.isInstancedMesh &&
                              void 0 === L._maxInstanceCount &&
                              (L._maxInstanceCount =
                                le.meshPerAttribute * le.count);
                          } else
                            for (let Ue = 0; Ue < q.locationSize; Ue++)
                              b(q.location + Ue);
                          n.bindBuffer(n.ARRAY_BUFFER, ve);
                          for (let Ue = 0; Ue < q.locationSize; Ue++)
                            S(
                              q.location + Ue,
                              ce / q.locationSize,
                              xe,
                              te,
                              ce * Ze,
                              (ce / q.locationSize) * Ue * Ze,
                              dt
                            );
                        }
                      } else if (void 0 !== Z) {
                        const te = Z[B];
                        if (void 0 !== te)
                          switch (te.length) {
                            case 2:
                              n.vertexAttrib2fv(q.location, te);
                              break;
                            case 3:
                              n.vertexAttrib3fv(q.location, te);
                              break;
                            case 4:
                              n.vertexAttrib4fv(q.location, te);
                              break;
                            default:
                              n.vertexAttrib1fv(q.location, te);
                          }
                      }
                    }
                  }
                  M();
                })(k, z, O, L),
                null !== U &&
                  n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(U).buffer));
          },
          reset: j,
          resetDefaultState: F,
          dispose: function w() {
            j();
            for (const k in a) {
              const z = a[k];
              for (const O in z) {
                const L = z[O];
                for (const U in L) p(L[U].object), delete L[U];
                delete z[O];
              }
              delete a[k];
            }
          },
          releaseStatesOfGeometry: function E(k) {
            if (void 0 === a[k.id]) return;
            const z = a[k.id];
            for (const O in z) {
              const L = z[O];
              for (const U in L) p(L[U].object), delete L[U];
              delete z[O];
            }
            delete a[k.id];
          },
          releaseStatesOfProgram: function V(k) {
            for (const z in a) {
              const O = a[z];
              if (void 0 === O[k.id]) continue;
              const L = O[k.id];
              for (const U in L) p(L[U].object), delete L[U];
              delete O[k.id];
            }
          },
          initAttributes: v,
          enableAttribute: b,
          disableUnusedAttributes: M,
        };
      }
      function $q(n, e, t, i) {
        const r = i.isWebGL2;
        let s;
        (this.setMode = function o(c) {
          s = c;
        }),
          (this.render = function a(c, u) {
            n.drawArrays(s, c, u), t.update(u, s, 1);
          }),
          (this.renderInstances = function l(c, u, d) {
            if (0 === d) return;
            let h, f;
            if (r) (h = n), (f = "drawArraysInstanced");
            else if (
              ((h = e.get("ANGLE_instanced_arrays")),
              (f = "drawArraysInstancedANGLE"),
              null === h)
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            h[f](s, c, u, d), t.update(u, s, d);
          });
      }
      function Qq(n, e, t) {
        let i;
        function s(S) {
          if ("highp" === S) {
            if (
              n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT)
                .precision > 0 &&
              n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT)
                .precision > 0
            )
              return "highp";
            S = "mediump";
          }
          return "mediump" === S &&
            n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT)
              .precision > 0 &&
            n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT)
              .precision > 0
            ? "mediump"
            : "lowp";
        }
        const o =
          typeof WebGL2RenderingContext < "u" &&
          "WebGL2RenderingContext" === n.constructor.name;
        let a = void 0 !== t.precision ? t.precision : "highp";
        const l = s(a);
        l !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            l,
            "instead."
          ),
          (a = l));
        const c = o || e.has("WEBGL_draw_buffers"),
          u = !0 === t.logarithmicDepthBuffer,
          d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
          h = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          f = n.getParameter(n.MAX_TEXTURE_SIZE),
          p = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
          _ = n.getParameter(n.MAX_VERTEX_ATTRIBS),
          m = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
          g = n.getParameter(n.MAX_VARYING_VECTORS),
          y = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
          v = h > 0,
          b = o || e.has("OES_texture_float");
        return {
          isWebGL2: o,
          drawBuffers: c,
          getMaxAnisotropy: function r() {
            if (void 0 !== i) return i;
            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
              const S = e.get("EXT_texture_filter_anisotropic");
              i = n.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else i = 0;
            return i;
          },
          getMaxPrecision: s,
          precision: a,
          logarithmicDepthBuffer: u,
          maxTextures: d,
          maxVertexTextures: h,
          maxTextureSize: f,
          maxCubemapSize: p,
          maxAttributes: _,
          maxVertexUniforms: m,
          maxVaryings: g,
          maxFragmentUniforms: y,
          vertexTextures: v,
          floatFragmentTextures: b,
          floatVertexTextures: v && b,
          maxSamples: o ? n.getParameter(n.MAX_SAMPLES) : 0,
        };
      }
      function Jq(n) {
        const e = this;
        let t = null,
          i = 0,
          r = !1,
          s = !1;
        const o = new Fa(),
          a = new vt(),
          l = { value: null, needsUpdate: !1 };
        function u(d, h, f, p) {
          const _ = null !== d ? d.length : 0;
          let m = null;
          if (0 !== _) {
            if (((m = l.value), !0 !== p || null === m)) {
              const g = f + 4 * _,
                y = h.matrixWorldInverse;
              a.getNormalMatrix(y),
                (null === m || m.length < g) && (m = new Float32Array(g));
              for (let v = 0, b = f; v !== _; ++v, b += 4)
                o.copy(d[v]).applyMatrix4(y, a),
                  o.normal.toArray(m, b),
                  (m[b + 3] = o.constant);
            }
            (l.value = m), (l.needsUpdate = !0);
          }
          return (e.numPlanes = _), (e.numIntersection = 0), m;
        }
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (d, h) {
            const f = 0 !== d.length || h || 0 !== i || r;
            return (r = h), (i = d.length), f;
          }),
          (this.beginShadows = function () {
            (s = !0), u(null);
          }),
          (this.endShadows = function () {
            s = !1;
          }),
          (this.setGlobalState = function (d, h) {
            t = u(d, h, 0);
          }),
          (this.setState = function (d, h, f) {
            const p = d.clippingPlanes,
              _ = d.clipIntersection,
              m = d.clipShadows,
              g = n.get(d);
            if (!r || null === p || 0 === p.length || (s && !m))
              s
                ? u(null)
                : (function c() {
                    l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
                      (e.numPlanes = i),
                      (e.numIntersection = 0);
                  })();
            else {
              const y = s ? 0 : i,
                v = 4 * y;
              let b = g.clippingState || null;
              (l.value = b), (b = u(p, h, v, f));
              for (let x = 0; x !== v; ++x) b[x] = t[x];
              (g.clippingState = b),
                (this.numIntersection = _ ? this.numPlanes : 0),
                (this.numPlanes += y);
            }
          });
      }
      function eY(n) {
        let e = new WeakMap();
        function t(o, a) {
          return a === Hd ? (o.mapping = Ea) : a === sm && (o.mapping = Ca), o;
        }
        function r(o) {
          const a = o.target;
          a.removeEventListener("dispose", r);
          const l = e.get(a);
          void 0 !== l && (e.delete(a), l.dispose());
        }
        return {
          get: function i(o) {
            if (o && o.isTexture && !1 === o.isRenderTargetTexture) {
              const a = o.mapping;
              if (a === Hd || a === sm) {
                if (e.has(o)) return t(e.get(o).texture, o.mapping);
                {
                  const l = o.image;
                  if (l && l.height > 0) {
                    const c = new YX(l.height / 2);
                    return (
                      c.fromEquirectangularTexture(n, o),
                      e.set(o, c),
                      o.addEventListener("dispose", r),
                      t(c.texture, o.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return o;
          },
          dispose: function s() {
            e = new WeakMap();
          },
        };
      }
      class Hc extends Hb {
        constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = i),
            (this.bottom = r),
            (this.near = s),
            (this.far = o),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, i, r, s, o) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = i),
            (this.view.offsetY = r),
            (this.view.width = s),
            (this.view.height = o),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            i = (this.right + this.left) / 2,
            r = (this.top + this.bottom) / 2;
          let s = i - e,
            o = i + e,
            a = r + t,
            l = r - t;
          if (null !== this.view && this.view.enabled) {
            const c =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (s += c * this.view.offsetX),
              (o = s + c * this.view.width),
              (a -= u * this.view.offsetY),
              (l = a - u * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            s,
            o,
            a,
            l,
            this.near,
            this.far,
            this.coordinateSystem
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      const yP = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        jb = new Hc(),
        bP = new de();
      let Xb = null;
      const Ba = (1 + Math.sqrt(5)) / 2,
        Wc = 1 / Ba,
        xP = [
          new A(1, 1, 1),
          new A(-1, 1, 1),
          new A(1, 1, -1),
          new A(-1, 1, -1),
          new A(0, Ba, Wc),
          new A(0, Ba, -Wc),
          new A(Wc, 0, Ba),
          new A(-Wc, 0, Ba),
          new A(Ba, Wc, 0),
          new A(-Ba, Wc, 0),
        ];
      class wP {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, i = 0.1, r = 100) {
          (Xb = this._renderer.getRenderTarget()), this._setSize(256);
          const s = this._allocateTargets();
          return (
            (s.depthBuffer = !0),
            this._sceneToCubeUV(e, i, r, s),
            t > 0 && this._blur(s, 0, 0, t),
            this._applyPMREM(s),
            this._cleanup(s),
            s
          );
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          null === this._cubemapMaterial &&
            ((this._cubemapMaterial = EP()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          null === this._equirectMaterial &&
            ((this._equirectMaterial = SP()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(Xb),
            (e.scissorTest = !1),
            Pm(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          this._setSize(
            e.mapping === Ea || e.mapping === Ca
              ? 0 === e.image.length
                ? 16
                : e.image[0].width || e.image[0].image.width
              : e.image.width / 4
          ),
            (Xb = this._renderer.getRenderTarget());
          const i = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, i),
            this._applyPMREM(i),
            this._cleanup(i),
            i
          );
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            i = {
              magFilter: fn,
              minFilter: fn,
              generateMipmaps: !1,
              type: Hi,
              format: Tr,
              colorSpace: Kr,
              depthBuffer: !1,
            },
            r = MP(e, t, i);
          if (
            null === this._pingPongRenderTarget ||
            this._pingPongRenderTarget.width !== e ||
            this._pingPongRenderTarget.height !== t
          ) {
            null !== this._pingPongRenderTarget && this._dispose(),
              (this._pingPongRenderTarget = MP(e, t, i));
            const { _lodMax: s } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = (function tY(n) {
              const e = [],
                t = [],
                i = [];
              let r = n;
              const s = n - 4 + 1 + yP.length;
              for (let o = 0; o < s; o++) {
                const a = Math.pow(2, r);
                t.push(a);
                let l = 1 / a;
                o > n - 4 ? (l = yP[o - n + 4 - 1]) : 0 === o && (l = 0),
                  i.push(l);
                const c = 1 / (a - 2),
                  u = -c,
                  d = 1 + c,
                  h = [u, u, d, u, d, d, u, u, d, d, u, d],
                  f = 6,
                  p = 6,
                  _ = 3,
                  m = 2,
                  g = 1,
                  y = new Float32Array(_ * p * f),
                  v = new Float32Array(m * p * f),
                  b = new Float32Array(g * p * f);
                for (let M = 0; M < f; M++) {
                  const S = ((M % 3) * 2) / 3 - 1,
                    C = M > 2 ? 0 : -1;
                  y.set(
                    [
                      S,
                      C,
                      0,
                      S + 2 / 3,
                      C,
                      0,
                      S + 2 / 3,
                      C + 1,
                      0,
                      S,
                      C,
                      0,
                      S + 2 / 3,
                      C + 1,
                      0,
                      S,
                      C + 1,
                      0,
                    ],
                    _ * p * M
                  ),
                    v.set(h, m * p * M),
                    b.set([M, M, M, M, M, M], g * p * M);
                }
                const x = new ut();
                x.setAttribute("position", new on(y, _)),
                  x.setAttribute("uv", new on(v, m)),
                  x.setAttribute("faceIndex", new on(b, g)),
                  e.push(x),
                  r > 4 && r--;
              }
              return { lodPlanes: e, sizeLods: t, sigmas: i };
            })(s)),
              (this._blurMaterial = (function nY(n, e, t) {
                const i = new Float32Array(20),
                  r = new A(0, 1, 0);
                return new $n({
                  name: "SphericalGaussianBlur",
                  defines: {
                    n: 20,
                    CUBEUV_TEXEL_WIDTH: 1 / e,
                    CUBEUV_TEXEL_HEIGHT: 1 / t,
                    CUBEUV_MAX_MIP: `${n}.0`,
                  },
                  uniforms: {
                    envMap: { value: null },
                    samples: { value: 1 },
                    weights: { value: i },
                    latitudinal: { value: !1 },
                    dTheta: { value: 0 },
                    mipInt: { value: 0 },
                    poleAxis: { value: r },
                  },
                  vertexShader:
                    "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                  fragmentShader:
                    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                  blending: Zr,
                  depthTest: !1,
                  depthWrite: !1,
                });
              })(s, e, t));
          }
          return r;
        }
        _compileMaterial(e) {
          const t = new Kn(this._lodPlanes[0], e);
          this._renderer.compile(t, jb);
        }
        _sceneToCubeUV(e, t, i, r) {
          const a = new Wn(90, 1, t, i),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            u = this._renderer,
            d = u.autoClear,
            h = u.toneMapping;
          u.getClearColor(bP), (u.toneMapping = Qs), (u.autoClear = !1);
          const f = new Ar({
              name: "PMREM.Background",
              side: zi,
              depthWrite: !1,
              depthTest: !1,
            }),
            p = new Kn(new kc(), f);
          let _ = !1;
          const m = e.background;
          m
            ? m.isColor && (f.color.copy(m), (e.background = null), (_ = !0))
            : (f.color.copy(bP), (_ = !0));
          for (let g = 0; g < 6; g++) {
            const y = g % 3;
            0 === y
              ? (a.up.set(0, l[g], 0), a.lookAt(c[g], 0, 0))
              : 1 === y
              ? (a.up.set(0, 0, l[g]), a.lookAt(0, c[g], 0))
              : (a.up.set(0, l[g], 0), a.lookAt(0, 0, c[g]));
            const v = this._cubeSize;
            Pm(r, y * v, g > 2 ? v : 0, v, v),
              u.setRenderTarget(r),
              _ && u.render(p, a),
              u.render(e, a);
          }
          p.geometry.dispose(),
            p.material.dispose(),
            (u.toneMapping = h),
            (u.autoClear = d),
            (e.background = m);
        }
        _textureToCubeUV(e, t) {
          const i = this._renderer,
            r = e.mapping === Ea || e.mapping === Ca;
          r
            ? (null === this._cubemapMaterial && (this._cubemapMaterial = EP()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                !1 === e.isRenderTargetTexture ? -1 : 1))
            : null === this._equirectMaterial &&
              (this._equirectMaterial = SP());
          const s = r ? this._cubemapMaterial : this._equirectMaterial,
            o = new Kn(this._lodPlanes[0], s);
          s.uniforms.envMap.value = e;
          const l = this._cubeSize;
          Pm(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, jb);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            i = t.autoClear;
          t.autoClear = !1;
          for (let r = 1; r < this._lodPlanes.length; r++) {
            const s = Math.sqrt(
              this._sigmas[r] * this._sigmas[r] -
                this._sigmas[r - 1] * this._sigmas[r - 1]
            );
            this._blur(e, r - 1, r, s, xP[(r - 1) % xP.length]);
          }
          t.autoClear = i;
        }
        _blur(e, t, i, r, s) {
          const o = this._pingPongRenderTarget;
          this._halfBlur(e, o, t, i, r, "latitudinal", s),
            this._halfBlur(o, e, i, i, r, "longitudinal", s);
        }
        _halfBlur(e, t, i, r, s, o, a) {
          const l = this._renderer,
            c = this._blurMaterial;
          "latitudinal" !== o &&
            "longitudinal" !== o &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const d = new Kn(this._lodPlanes[r], c),
            h = c.uniforms,
            f = this._sizeLods[i] - 1,
            p = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / 39,
            _ = s / p,
            m = isFinite(s) ? 1 + Math.floor(3 * _) : 20;
          m > 20 &&
            console.warn(
              `sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
            );
          const g = [];
          let y = 0;
          for (let S = 0; S < 20; ++S) {
            const C = S / _,
              w = Math.exp((-C * C) / 2);
            g.push(w), 0 === S ? (y += w) : S < m && (y += 2 * w);
          }
          for (let S = 0; S < g.length; S++) g[S] = g[S] / y;
          (h.envMap.value = e.texture),
            (h.samples.value = m),
            (h.weights.value = g),
            (h.latitudinal.value = "latitudinal" === o),
            a && (h.poleAxis.value = a);
          const { _lodMax: v } = this;
          (h.dTheta.value = p), (h.mipInt.value = v - i);
          const b = this._sizeLods[r];
          Pm(
            t,
            3 * b * (r > v - 4 ? r - v + 4 : 0),
            4 * (this._cubeSize - b),
            3 * b,
            2 * b
          ),
            l.setRenderTarget(t),
            l.render(d, jb);
        }
      }
      function MP(n, e, t) {
        const i = new li(n, e, t);
        return (
          (i.texture.mapping = Gd),
          (i.texture.name = "PMREM.cubeUv"),
          (i.scissorTest = !0),
          i
        );
      }
      function Pm(n, e, t, i, r) {
        n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
      }
      function SP() {
        return new $n({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: Zr,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function EP() {
        return new $n({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: Zr,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function iY(n) {
        let e = new WeakMap(),
          t = null;
        function s(a) {
          const l = a.target;
          l.removeEventListener("dispose", s);
          const c = e.get(l);
          void 0 !== c && (e.delete(l), c.dispose());
        }
        return {
          get: function i(a) {
            if (a && a.isTexture) {
              const l = a.mapping,
                c = l === Hd || l === sm,
                u = l === Ea || l === Ca;
              if (c || u) {
                if (a.isRenderTargetTexture && !0 === a.needsPMREMUpdate) {
                  a.needsPMREMUpdate = !1;
                  let d = e.get(a);
                  return (
                    null === t && (t = new wP(n)),
                    (d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
                    e.set(a, d),
                    d.texture
                  );
                }
                if (e.has(a)) return e.get(a).texture;
                {
                  const d = a.image;
                  if (
                    (c && d && d.height > 0) ||
                    (u &&
                      d &&
                      (function r(a) {
                        let l = 0;
                        for (let u = 0; u < 6; u++) void 0 !== a[u] && l++;
                        return 6 === l;
                      })(d))
                  ) {
                    null === t && (t = new wP(n));
                    const h = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
                    return (
                      e.set(a, h), a.addEventListener("dispose", s), h.texture
                    );
                  }
                  return null;
                }
              }
            }
            return a;
          },
          dispose: function o() {
            (e = new WeakMap()), null !== t && (t.dispose(), (t = null));
          },
        };
      }
      function rY(n) {
        const e = {};
        function t(i) {
          if (void 0 !== e[i]) return e[i];
          let r;
          switch (i) {
            case "WEBGL_depth_texture":
              r =
                n.getExtension("WEBGL_depth_texture") ||
                n.getExtension("MOZ_WEBGL_depth_texture") ||
                n.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              r =
                n.getExtension("EXT_texture_filter_anisotropic") ||
                n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              r =
                n.getExtension("WEBGL_compressed_texture_s3tc") ||
                n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              r =
                n.getExtension("WEBGL_compressed_texture_pvrtc") ||
                n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              r = n.getExtension(i);
          }
          return (e[i] = r), r;
        }
        return {
          has: function (i) {
            return null !== t(i);
          },
          init: function (i) {
            i.isWebGL2
              ? t("EXT_color_buffer_float")
              : (t("WEBGL_depth_texture"),
                t("OES_texture_float"),
                t("OES_texture_half_float"),
                t("OES_texture_half_float_linear"),
                t("OES_standard_derivatives"),
                t("OES_element_index_uint"),
                t("OES_vertex_array_object"),
                t("ANGLE_instanced_arrays")),
              t("OES_texture_float_linear"),
              t("EXT_color_buffer_half_float"),
              t("WEBGL_multisampled_render_to_texture");
          },
          get: function (i) {
            const r = t(i);
            return (
              null === r &&
                console.warn(
                  "THREE.WebGLRenderer: " + i + " extension not supported."
                ),
              r
            );
          },
        };
      }
      function sY(n, e, t, i) {
        const r = {},
          s = new WeakMap();
        function o(d) {
          const h = d.target;
          null !== h.index && e.remove(h.index);
          for (const p in h.attributes) e.remove(h.attributes[p]);
          for (const p in h.morphAttributes) {
            const _ = h.morphAttributes[p];
            for (let m = 0, g = _.length; m < g; m++) e.remove(_[m]);
          }
          h.removeEventListener("dispose", o), delete r[h.id];
          const f = s.get(h);
          f && (e.remove(f), s.delete(h)),
            i.releaseStatesOfGeometry(h),
            !0 === h.isInstancedBufferGeometry && delete h._maxInstanceCount,
            t.memory.geometries--;
        }
        function c(d) {
          const h = [],
            f = d.index,
            p = d.attributes.position;
          let _ = 0;
          if (null !== f) {
            const y = f.array;
            _ = f.version;
            for (let v = 0, b = y.length; v < b; v += 3) {
              const x = y[v + 0],
                M = y[v + 1],
                S = y[v + 2];
              h.push(x, M, M, S, S, x);
            }
          } else {
            _ = p.version;
            for (let v = 0, b = p.array.length / 3 - 1; v < b; v += 3) {
              const x = v + 0,
                M = v + 1,
                S = v + 2;
              h.push(x, M, M, S, S, x);
            }
          }
          const m = new ($R(h) ? dP : Ub)(h, 1);
          m.version = _;
          const g = s.get(d);
          g && e.remove(g), s.set(d, m);
        }
        return {
          get: function a(d, h) {
            return (
              !0 === r[h.id] ||
                (h.addEventListener("dispose", o),
                (r[h.id] = !0),
                t.memory.geometries++),
              h
            );
          },
          update: function l(d) {
            const h = d.attributes;
            for (const p in h) e.update(h[p], n.ARRAY_BUFFER);
            const f = d.morphAttributes;
            for (const p in f) {
              const _ = f[p];
              for (let m = 0, g = _.length; m < g; m++)
                e.update(_[m], n.ARRAY_BUFFER);
            }
          },
          getWireframeAttribute: function u(d) {
            const h = s.get(d);
            if (h) {
              const f = d.index;
              null !== f && h.version < f.version && c(d);
            } else c(d);
            return s.get(d);
          },
        };
      }
      function oY(n, e, t, i) {
        const r = i.isWebGL2;
        let s, a, l;
        (this.setMode = function o(h) {
          s = h;
        }),
          (this.setIndex = function c(h) {
            (a = h.type), (l = h.bytesPerElement);
          }),
          (this.render = function u(h, f) {
            n.drawElements(s, f, a, h * l), t.update(f, s, 1);
          }),
          (this.renderInstances = function d(h, f, p) {
            if (0 === p) return;
            let _, m;
            if (r) (_ = n), (m = "drawElementsInstanced");
            else if (
              ((_ = e.get("ANGLE_instanced_arrays")),
              (m = "drawElementsInstancedANGLE"),
              null === _)
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            _[m](s, f, a, h * l, p), t.update(f, s, p);
          });
      }
      function aY(n) {
        const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function r() {
            (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
          },
          update: function i(s, o, a) {
            switch ((t.calls++, o)) {
              case n.TRIANGLES:
                t.triangles += a * (s / 3);
                break;
              case n.LINES:
                t.lines += a * (s / 2);
                break;
              case n.LINE_STRIP:
                t.lines += a * (s - 1);
                break;
              case n.LINE_LOOP:
                t.lines += a * s;
                break;
              case n.POINTS:
                t.points += a * s;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            }
          },
        };
      }
      function lY(n, e) {
        return n[0] - e[0];
      }
      function cY(n, e) {
        return Math.abs(e[1]) - Math.abs(n[1]);
      }
      function uY(n, e, t) {
        const i = {},
          r = new Float32Array(8),
          s = new WeakMap(),
          o = new Ft(),
          a = [];
        for (let c = 0; c < 8; c++) a[c] = [c, 0];
        return {
          update: function l(c, u, d) {
            const h = c.morphTargetInfluences;
            if (!0 === e.isWebGL2) {
              const f =
                  u.morphAttributes.position ||
                  u.morphAttributes.normal ||
                  u.morphAttributes.color,
                p = void 0 !== f ? f.length : 0;
              let _ = s.get(u);
              if (void 0 === _ || _.count !== p) {
                let k = function () {
                  j.dispose(), s.delete(u), u.removeEventListener("dispose", k);
                };
                void 0 !== _ && _.texture.dispose();
                const y = void 0 !== u.morphAttributes.position,
                  v = void 0 !== u.morphAttributes.normal,
                  b = void 0 !== u.morphAttributes.color,
                  x = u.morphAttributes.position || [],
                  M = u.morphAttributes.normal || [],
                  S = u.morphAttributes.color || [];
                let C = 0;
                !0 === y && (C = 1), !0 === v && (C = 2), !0 === b && (C = 3);
                let w = u.attributes.position.count * C,
                  E = 1;
                w > e.maxTextureSize &&
                  ((E = Math.ceil(w / e.maxTextureSize)),
                  (w = e.maxTextureSize));
                const V = new Float32Array(w * E * 4 * p),
                  j = new Cb(V, w, E, p);
                (j.type = to), (j.needsUpdate = !0);
                const F = 4 * C;
                for (let z = 0; z < p; z++) {
                  const O = x[z],
                    L = M[z],
                    U = S[z],
                    W = w * E * 4 * z;
                  for (let Z = 0; Z < O.count; Z++) {
                    const B = Z * F;
                    !0 === y &&
                      (o.fromBufferAttribute(O, Z),
                      (V[W + B + 0] = o.x),
                      (V[W + B + 1] = o.y),
                      (V[W + B + 2] = o.z),
                      (V[W + B + 3] = 0)),
                      !0 === v &&
                        (o.fromBufferAttribute(L, Z),
                        (V[W + B + 4] = o.x),
                        (V[W + B + 5] = o.y),
                        (V[W + B + 6] = o.z),
                        (V[W + B + 7] = 0)),
                      !0 === b &&
                        (o.fromBufferAttribute(U, Z),
                        (V[W + B + 8] = o.x),
                        (V[W + B + 9] = o.y),
                        (V[W + B + 10] = o.z),
                        (V[W + B + 11] = 4 === U.itemSize ? o.w : 1));
                  }
                }
                (_ = { count: p, texture: j, size: new $(w, E) }),
                  s.set(u, _),
                  u.addEventListener("dispose", k);
              }
              let m = 0;
              for (let y = 0; y < h.length; y++) m += h[y];
              const g = u.morphTargetsRelative ? 1 : 1 - m;
              d.getUniforms().setValue(n, "morphTargetBaseInfluence", g),
                d.getUniforms().setValue(n, "morphTargetInfluences", h),
                d
                  .getUniforms()
                  .setValue(n, "morphTargetsTexture", _.texture, t),
                d.getUniforms().setValue(n, "morphTargetsTextureSize", _.size);
            } else {
              const f = void 0 === h ? 0 : h.length;
              let p = i[u.id];
              if (void 0 === p || p.length !== f) {
                p = [];
                for (let v = 0; v < f; v++) p[v] = [v, 0];
                i[u.id] = p;
              }
              for (let v = 0; v < f; v++) {
                const b = p[v];
                (b[0] = v), (b[1] = h[v]);
              }
              p.sort(cY);
              for (let v = 0; v < 8; v++)
                v < f && p[v][1]
                  ? ((a[v][0] = p[v][0]), (a[v][1] = p[v][1]))
                  : ((a[v][0] = Number.MAX_SAFE_INTEGER), (a[v][1] = 0));
              a.sort(lY);
              const _ = u.morphAttributes.position,
                m = u.morphAttributes.normal;
              let g = 0;
              for (let v = 0; v < 8; v++) {
                const b = a[v],
                  x = b[0],
                  M = b[1];
                x !== Number.MAX_SAFE_INTEGER && M
                  ? (_ &&
                      u.getAttribute("morphTarget" + v) !== _[x] &&
                      u.setAttribute("morphTarget" + v, _[x]),
                    m &&
                      u.getAttribute("morphNormal" + v) !== m[x] &&
                      u.setAttribute("morphNormal" + v, m[x]),
                    (r[v] = M),
                    (g += M))
                  : (_ &&
                      !0 === u.hasAttribute("morphTarget" + v) &&
                      u.deleteAttribute("morphTarget" + v),
                    m &&
                      !0 === u.hasAttribute("morphNormal" + v) &&
                      u.deleteAttribute("morphNormal" + v),
                    (r[v] = 0));
              }
              const y = u.morphTargetsRelative ? 1 : 1 - g;
              d.getUniforms().setValue(n, "morphTargetBaseInfluence", y),
                d.getUniforms().setValue(n, "morphTargetInfluences", r);
            }
          },
        };
      }
      function dY(n, e, t, i) {
        let r = new WeakMap();
        function a(l) {
          const c = l.target;
          c.removeEventListener("dispose", a),
            t.remove(c.instanceMatrix),
            null !== c.instanceColor && t.remove(c.instanceColor);
        }
        return {
          update: function s(l) {
            const c = i.render.frame,
              d = e.get(l, l.geometry);
            if (
              (r.get(d) !== c && (e.update(d), r.set(d, c)),
              l.isInstancedMesh &&
                (!1 === l.hasEventListener("dispose", a) &&
                  l.addEventListener("dispose", a),
                r.get(l) !== c &&
                  (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
                  null !== l.instanceColor &&
                    t.update(l.instanceColor, n.ARRAY_BUFFER),
                  r.set(l, c))),
              l.isSkinnedMesh)
            ) {
              const h = l.skeleton;
              r.get(h) !== c && (h.update(), r.set(h, c));
            }
            return d;
          },
          dispose: function o() {
            r = new WeakMap();
          },
        };
      }
      const CP = new Ai(),
        TP = new Cb(),
        AP = new eP(),
        DP = new Am(),
        IP = [],
        RP = [],
        PP = new Float32Array(16),
        OP = new Float32Array(9),
        LP = new Float32Array(4);
      function jc(n, e, t) {
        const i = n[0];
        if (i <= 0 || i > 0) return n;
        const r = e * t;
        let s = IP[r];
        if (
          (void 0 === s && ((s = new Float32Array(r)), (IP[r] = s)), 0 !== e)
        ) {
          i.toArray(s, 0);
          for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
        }
        return s;
      }
      function jn(n, e) {
        if (n.length !== e.length) return !1;
        for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
        return !0;
      }
      function Xn(n, e) {
        for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
      }
      function Om(n, e) {
        let t = RP[e];
        void 0 === t && ((t = new Int32Array(e)), (RP[e] = t));
        for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
        return t;
      }
      function hY(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
      }
      function fY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (jn(t, e)) return;
          n.uniform2fv(this.addr, e), Xn(t, e);
        }
      }
      function pY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3f(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else if (void 0 !== e.r)
          (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
            (n.uniform3f(this.addr, e.r, e.g, e.b),
            (t[0] = e.r),
            (t[1] = e.g),
            (t[2] = e.b));
        else {
          if (jn(t, e)) return;
          n.uniform3fv(this.addr, e), Xn(t, e);
        }
      }
      function mY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (jn(t, e)) return;
          n.uniform4fv(this.addr, e), Xn(t, e);
        }
      }
      function gY(n, e) {
        const t = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (jn(t, e)) return;
          n.uniformMatrix2fv(this.addr, !1, e), Xn(t, e);
        } else {
          if (jn(t, i)) return;
          LP.set(i), n.uniformMatrix2fv(this.addr, !1, LP), Xn(t, i);
        }
      }
      function _Y(n, e) {
        const t = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (jn(t, e)) return;
          n.uniformMatrix3fv(this.addr, !1, e), Xn(t, e);
        } else {
          if (jn(t, i)) return;
          OP.set(i), n.uniformMatrix3fv(this.addr, !1, OP), Xn(t, i);
        }
      }
      function vY(n, e) {
        const t = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (jn(t, e)) return;
          n.uniformMatrix4fv(this.addr, !1, e), Xn(t, e);
        } else {
          if (jn(t, i)) return;
          PP.set(i), n.uniformMatrix4fv(this.addr, !1, PP), Xn(t, i);
        }
      }
      function yY(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
      }
      function bY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (jn(t, e)) return;
          n.uniform2iv(this.addr, e), Xn(t, e);
        }
      }
      function xY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3i(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else {
          if (jn(t, e)) return;
          n.uniform3iv(this.addr, e), Xn(t, e);
        }
      }
      function wY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (jn(t, e)) return;
          n.uniform4iv(this.addr, e), Xn(t, e);
        }
      }
      function MY(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
      }
      function SY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y) &&
            (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
        else {
          if (jn(t, e)) return;
          n.uniform2uiv(this.addr, e), Xn(t, e);
        }
      }
      function EY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
            (n.uniform3ui(this.addr, e.x, e.y, e.z),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z));
        else {
          if (jn(t, e)) return;
          n.uniform3uiv(this.addr, e), Xn(t, e);
        }
      }
      function CY(n, e) {
        const t = this.cache;
        if (void 0 !== e.x)
          (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
            (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
            (t[0] = e.x),
            (t[1] = e.y),
            (t[2] = e.z),
            (t[3] = e.w));
        else {
          if (jn(t, e)) return;
          n.uniform4uiv(this.addr, e), Xn(t, e);
        }
      }
      function TY(n, e, t) {
        const i = this.cache,
          r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
          t.setTexture2D(e || CP, r);
      }
      function AY(n, e, t) {
        const i = this.cache,
          r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
          t.setTexture3D(e || AP, r);
      }
      function DY(n, e, t) {
        const i = this.cache,
          r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
          t.setTextureCube(e || DP, r);
      }
      function IY(n, e, t) {
        const i = this.cache,
          r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
          t.setTexture2DArray(e || TP, r);
      }
      function PY(n, e) {
        n.uniform1fv(this.addr, e);
      }
      function OY(n, e) {
        const t = jc(e, this.size, 2);
        n.uniform2fv(this.addr, t);
      }
      function LY(n, e) {
        const t = jc(e, this.size, 3);
        n.uniform3fv(this.addr, t);
      }
      function FY(n, e) {
        const t = jc(e, this.size, 4);
        n.uniform4fv(this.addr, t);
      }
      function NY(n, e) {
        const t = jc(e, this.size, 4);
        n.uniformMatrix2fv(this.addr, !1, t);
      }
      function kY(n, e) {
        const t = jc(e, this.size, 9);
        n.uniformMatrix3fv(this.addr, !1, t);
      }
      function BY(n, e) {
        const t = jc(e, this.size, 16);
        n.uniformMatrix4fv(this.addr, !1, t);
      }
      function UY(n, e) {
        n.uniform1iv(this.addr, e);
      }
      function VY(n, e) {
        n.uniform2iv(this.addr, e);
      }
      function zY(n, e) {
        n.uniform3iv(this.addr, e);
      }
      function HY(n, e) {
        n.uniform4iv(this.addr, e);
      }
      function GY(n, e) {
        n.uniform1uiv(this.addr, e);
      }
      function WY(n, e) {
        n.uniform2uiv(this.addr, e);
      }
      function jY(n, e) {
        n.uniform3uiv(this.addr, e);
      }
      function XY(n, e) {
        n.uniform4uiv(this.addr, e);
      }
      function qY(n, e, t) {
        const i = this.cache,
          r = e.length,
          s = Om(t, r);
        jn(i, s) || (n.uniform1iv(this.addr, s), Xn(i, s));
        for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || CP, s[o]);
      }
      function YY(n, e, t) {
        const i = this.cache,
          r = e.length,
          s = Om(t, r);
        jn(i, s) || (n.uniform1iv(this.addr, s), Xn(i, s));
        for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || AP, s[o]);
      }
      function ZY(n, e, t) {
        const i = this.cache,
          r = e.length,
          s = Om(t, r);
        jn(i, s) || (n.uniform1iv(this.addr, s), Xn(i, s));
        for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || DP, s[o]);
      }
      function KY(n, e, t) {
        const i = this.cache,
          r = e.length,
          s = Om(t, r);
        jn(i, s) || (n.uniform1iv(this.addr, s), Xn(i, s));
        for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || TP, s[o]);
      }
      class QY {
        constructor(e, t, i) {
          (this.id = e),
            (this.addr = i),
            (this.cache = []),
            (this.setValue = (function RY(n) {
              switch (n) {
                case 5126:
                  return hY;
                case 35664:
                  return fY;
                case 35665:
                  return pY;
                case 35666:
                  return mY;
                case 35674:
                  return gY;
                case 35675:
                  return _Y;
                case 35676:
                  return vY;
                case 5124:
                case 35670:
                  return yY;
                case 35667:
                case 35671:
                  return bY;
                case 35668:
                case 35672:
                  return xY;
                case 35669:
                case 35673:
                  return wY;
                case 5125:
                  return MY;
                case 36294:
                  return SY;
                case 36295:
                  return EY;
                case 36296:
                  return CY;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return TY;
                case 35679:
                case 36299:
                case 36307:
                  return AY;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return DY;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return IY;
              }
            })(t.type));
        }
      }
      class JY {
        constructor(e, t, i) {
          (this.id = e),
            (this.addr = i),
            (this.cache = []),
            (this.size = t.size),
            (this.setValue = (function $Y(n) {
              switch (n) {
                case 5126:
                  return PY;
                case 35664:
                  return OY;
                case 35665:
                  return LY;
                case 35666:
                  return FY;
                case 35674:
                  return NY;
                case 35675:
                  return kY;
                case 35676:
                  return BY;
                case 5124:
                case 35670:
                  return UY;
                case 35667:
                case 35671:
                  return VY;
                case 35668:
                case 35672:
                  return zY;
                case 35669:
                case 35673:
                  return HY;
                case 5125:
                  return GY;
                case 36294:
                  return WY;
                case 36295:
                  return jY;
                case 36296:
                  return XY;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return qY;
                case 35679:
                case 36299:
                case 36307:
                  return YY;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return ZY;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return KY;
              }
            })(t.type));
        }
      }
      class eZ {
        constructor(e) {
          (this.id = e), (this.seq = []), (this.map = {});
        }
        setValue(e, t, i) {
          const r = this.seq;
          for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i);
          }
        }
      }
      const Yb = /(\w+)(\])?(\[|\.)?/g;
      function FP(n, e) {
        n.seq.push(e), (n.map[e.id] = e);
      }
      function tZ(n, e, t) {
        const i = n.name,
          r = i.length;
        for (Yb.lastIndex = 0; ; ) {
          const s = Yb.exec(i);
          let a = s[1];
          const c = s[3];
          if (
            ("]" === s[2] && (a |= 0),
            void 0 === c || ("[" === c && Yb.lastIndex + 2 === r))
          ) {
            FP(t, void 0 === c ? new QY(a, n, e) : new JY(a, n, e));
            break;
          }
          {
            let d = t.map[a];
            void 0 === d && ((d = new eZ(a)), FP(t, d)), (t = d);
          }
        }
      }
      class Lm {
        constructor(e, t) {
          (this.seq = []), (this.map = {});
          const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
          for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r);
            tZ(s, e.getUniformLocation(t, s.name), this);
          }
        }
        setValue(e, t, i, r) {
          const s = this.map[t];
          void 0 !== s && s.setValue(e, i, r);
        }
        setOptional(e, t, i) {
          const r = t[i];
          void 0 !== r && this.setValue(e, i, r);
        }
        static upload(e, t, i, r) {
          for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s],
              l = i[a.id];
            !1 !== l.needsUpdate && a.setValue(e, l.value, r);
          }
        }
        static seqWithValue(e, t) {
          const i = [];
          for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o);
          }
          return i;
        }
      }
      function NP(n, e, t) {
        const i = n.createShader(e);
        return n.shaderSource(i, t), n.compileShader(i), i;
      }
      let nZ = 0;
      function kP(n, e, t) {
        const i = n.getShaderParameter(e, n.COMPILE_STATUS),
          r = n.getShaderInfoLog(e).trim();
        if (i && "" === r) return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
          const o = parseInt(s[1]);
          return (
            t.toUpperCase() +
            "\n\n" +
            r +
            "\n\n" +
            (function iZ(n, e) {
              const t = n.split("\n"),
                i = [],
                r = Math.max(e - 6, 0),
                s = Math.min(e + 6, t.length);
              for (let o = r; o < s; o++) {
                const a = o + 1;
                i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
              }
              return i.join("\n");
            })(n.getShaderSource(e), o)
          );
        }
        return r;
      }
      function sZ(n, e) {
        const t = (function rZ(n) {
          switch (n) {
            case Kr:
              return ["Linear", "( value )"];
            case qe:
              return ["sRGB", "( value )"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported color space:", n),
                ["Linear", "( value )"]
              );
          }
        })(e);
        return (
          "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
        );
      }
      function oZ(n, e) {
        let t;
        switch (e) {
          case U9:
            t = "Linear";
            break;
          case V9:
            t = "Reinhard";
            break;
          case z9:
            t = "OptimizedCineon";
            break;
          case dR:
            t = "ACESFilmic";
            break;
          case H9:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (t = "Linear");
        }
        return (
          "vec3 " +
          n +
          "( vec3 color ) { return " +
          t +
          "ToneMapping( color ); }"
        );
      }
      function nh(n) {
        return "" !== n;
      }
      function BP(n, e) {
        const t =
          e.numSpotLightShadows +
          e.numSpotLightMaps -
          e.numSpotLightShadowsWithMaps;
        return n
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            e.numSpotLightShadowsWithMaps
          )
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function UP(n, e) {
        return n
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const uZ = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Zb(n) {
        return n.replace(uZ, hZ);
      }
      const dZ = new Map([
        ["encodings_fragment", "colorspace_fragment"],
        ["encodings_pars_fragment", "colorspace_pars_fragment"],
        ["output_fragment", "opaque_fragment"],
      ]);
      function hZ(n, e) {
        let t = yt[e];
        if (void 0 === t) {
          const i = dZ.get(e);
          if (void 0 === i)
            throw new Error("Can not resolve #include <" + e + ">");
          (t = yt[i]),
            console.warn(
              'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
              e,
              i
            );
        }
        return Zb(t);
      }
      const fZ =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function VP(n) {
        return n.replace(fZ, pZ);
      }
      function pZ(n, e, t, i) {
        let r = "";
        for (let s = parseInt(e); s < parseInt(t); s++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, s);
        return r;
      }
      function zP(n) {
        let e =
          "precision " +
          n.precision +
          " float;\nprecision " +
          n.precision +
          " int;";
        return (
          "highp" === n.precision
            ? (e += "\n#define HIGH_PRECISION")
            : "mediump" === n.precision
            ? (e += "\n#define MEDIUM_PRECISION")
            : "lowp" === n.precision && (e += "\n#define LOW_PRECISION"),
          e
        );
      }
      function bZ(n, e, t, i) {
        const r = n.getContext(),
          s = t.defines;
        let o = t.vertexShader,
          a = t.fragmentShader;
        const l = (function mZ(n) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return (
              n.shadowMapType === rR
                ? (e = "SHADOWMAP_TYPE_PCF")
                : n.shadowMapType === _9
                ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                : n.shadowMapType === Ks && (e = "SHADOWMAP_TYPE_VSM"),
              e
            );
          })(t),
          c = (function gZ(n) {
            let e = "ENVMAP_TYPE_CUBE";
            if (n.envMap)
              switch (n.envMapMode) {
                case Ea:
                case Ca:
                  e = "ENVMAP_TYPE_CUBE";
                  break;
                case Gd:
                  e = "ENVMAP_TYPE_CUBE_UV";
              }
            return e;
          })(t),
          u = (function _Z(n) {
            let e = "ENVMAP_MODE_REFLECTION";
            return (
              n.envMap && n.envMapMode === Ca && (e = "ENVMAP_MODE_REFRACTION"),
              e
            );
          })(t),
          d = (function vZ(n) {
            let e = "ENVMAP_BLENDING_NONE";
            if (n.envMap)
              switch (n.combine) {
                case rm:
                  e = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case k9:
                  e = "ENVMAP_BLENDING_MIX";
                  break;
                case B9:
                  e = "ENVMAP_BLENDING_ADD";
              }
            return e;
          })(t),
          h = (function yZ(n) {
            const e = n.envMapCubeUVHeight;
            if (null === e) return null;
            const t = Math.log2(e) - 2,
              i = 1 / e;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
              texelHeight: i,
              maxMip: t,
            };
          })(t),
          f = t.isWebGL2
            ? ""
            : (function aZ(n) {
                return [
                  n.extensionDerivatives ||
                  n.envMapCubeUVHeight ||
                  n.bumpMap ||
                  n.normalMapTangentSpace ||
                  n.clearcoatNormalMap ||
                  n.flatShading ||
                  "physical" === n.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
                  n.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
                  n.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(nh)
                  .join("\n");
              })(t),
          p = (function lZ(n) {
            const e = [];
            for (const t in n) {
              const i = n[t];
              !1 !== i && e.push("#define " + t + " " + i);
            }
            return e.join("\n");
          })(s),
          _ = r.createProgram();
        let m,
          g,
          y = t.glslVersion ? "#version " + t.glslVersion + "\n" : "";
        t.isRawShaderMaterial
          ? ((m = [
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              p,
            ]
              .filter(nh)
              .join("\n")),
            m.length > 0 && (m += "\n"),
            (g = [
              f,
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              p,
            ]
              .filter(nh)
              .join("\n")),
            g.length > 0 && (g += "\n"))
          : ((m = [
              zP(t),
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              p,
              t.instancing ? "#define USE_INSTANCING" : "",
              t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + u : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              t.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              t.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaHash ? "#define USE_ALPHAHASH" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              t.mapUv ? "#define MAP_UV " + t.mapUv : "",
              t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
              t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
              t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
              t.emissiveMapUv
                ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv
                : "",
              t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
              t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
              t.displacementMapUv
                ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
                : "",
              t.metalnessMapUv
                ? "#define METALNESSMAP_UV " + t.metalnessMapUv
                : "",
              t.roughnessMapUv
                ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv
                : "",
              t.anisotropyMapUv
                ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
                : "",
              t.clearcoatMapUv
                ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv
                : "",
              t.clearcoatNormalMapUv
                ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
                : "",
              t.clearcoatRoughnessMapUv
                ? "#define CLEARCOAT_ROUGHNESSMAP_UV " +
                  t.clearcoatRoughnessMapUv
                : "",
              t.iridescenceMapUv
                ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
                : "",
              t.iridescenceThicknessMapUv
                ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
                  t.iridescenceThicknessMapUv
                : "",
              t.sheenColorMapUv
                ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
                : "",
              t.sheenRoughnessMapUv
                ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
                : "",
              t.specularMapUv
                ? "#define SPECULARMAP_UV " + t.specularMapUv
                : "",
              t.specularColorMapUv
                ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
                : "",
              t.specularIntensityMapUv
                ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
                : "",
              t.transmissionMapUv
                ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
                : "",
              t.thicknessMapUv
                ? "#define THICKNESSMAP_UV " + t.thicknessMapUv
                : "",
              t.vertexTangents && !1 === t.flatShading
                ? "#define USE_TANGENT"
                : "",
              t.vertexColors ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUv1s ? "#define USE_UV1" : "",
              t.vertexUv2s ? "#define USE_UV2" : "",
              t.vertexUv3s ? "#define USE_UV3" : "",
              t.pointsUvs ? "#define USE_POINTS_UV" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.skinning ? "#define USE_SKINNING" : "",
              t.morphTargets ? "#define USE_MORPHTARGETS" : "",
              t.morphNormals && !1 === t.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
                : "",
              t.morphTargetsCount > 0 && t.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
                : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_UV1",
              "\tattribute vec2 uv1;",
              "#endif",
              "#ifdef USE_UV2",
              "\tattribute vec2 uv2;",
              "#endif",
              "#ifdef USE_UV3",
              "\tattribute vec2 uv3;",
              "#endif",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(nh)
              .join("\n")),
            (g = [
              f,
              zP(t),
              "#define SHADER_TYPE " + t.shaderType,
              "#define SHADER_NAME " + t.shaderName,
              p,
              t.useFog && t.fog ? "#define USE_FOG" : "",
              t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
              t.map ? "#define USE_MAP" : "",
              t.matcap ? "#define USE_MATCAP" : "",
              t.envMap ? "#define USE_ENVMAP" : "",
              t.envMap ? "#define " + c : "",
              t.envMap ? "#define " + u : "",
              t.envMap ? "#define " + d : "",
              h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
              h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
              h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
              t.lightMap ? "#define USE_LIGHTMAP" : "",
              t.aoMap ? "#define USE_AOMAP" : "",
              t.bumpMap ? "#define USE_BUMPMAP" : "",
              t.normalMap ? "#define USE_NORMALMAP" : "",
              t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              t.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              t.anisotropy ? "#define USE_ANISOTROPY" : "",
              t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              t.clearcoat ? "#define USE_CLEARCOAT" : "",
              t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              t.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              t.iridescence ? "#define USE_IRIDESCENCE" : "",
              t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              t.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              t.specularMap ? "#define USE_SPECULARMAP" : "",
              t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              t.metalnessMap ? "#define USE_METALNESSMAP" : "",
              t.alphaMap ? "#define USE_ALPHAMAP" : "",
              t.alphaTest ? "#define USE_ALPHATEST" : "",
              t.alphaHash ? "#define USE_ALPHAHASH" : "",
              t.sheen ? "#define USE_SHEEN" : "",
              t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              t.transmission ? "#define USE_TRANSMISSION" : "",
              t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              t.vertexTangents && !1 === t.flatShading
                ? "#define USE_TANGENT"
                : "",
              t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
              t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              t.vertexUv1s ? "#define USE_UV1" : "",
              t.vertexUv2s ? "#define USE_UV2" : "",
              t.vertexUv3s ? "#define USE_UV3" : "",
              t.pointsUvs ? "#define USE_POINTS_UV" : "",
              t.gradientMap ? "#define USE_GRADIENTMAP" : "",
              t.flatShading ? "#define FLAT_SHADED" : "",
              t.doubleSided ? "#define DOUBLE_SIDED" : "",
              t.flipSided ? "#define FLIP_SIDED" : "",
              t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              t.shadowMapEnabled ? "#define " + l : "",
              t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
              t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              t.toneMapping !== Qs ? "#define TONE_MAPPING" : "",
              t.toneMapping !== Qs ? yt.tonemapping_pars_fragment : "",
              t.toneMapping !== Qs ? oZ("toneMapping", t.toneMapping) : "",
              t.dithering ? "#define DITHERING" : "",
              t.opaque ? "#define OPAQUE" : "",
              yt.colorspace_pars_fragment,
              sZ("linearToOutputTexel", t.outputColorSpace),
              t.useDepthPacking
                ? "#define DEPTH_PACKING " + t.depthPacking
                : "",
              "\n",
            ]
              .filter(nh)
              .join("\n"))),
          (o = Zb(o)),
          (o = BP(o, t)),
          (o = UP(o, t)),
          (a = Zb(a)),
          (a = BP(a, t)),
          (a = UP(a, t)),
          (o = VP(o)),
          (a = VP(a)),
          t.isWebGL2 &&
            !0 !== t.isRawShaderMaterial &&
            ((y = "#version 300 es\n"),
            (m =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              m),
            (g =
              [
                "#define varying in",
                t.glslVersion === YR
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                t.glslVersion === YR ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              g));
        const b = y + g + a,
          x = NP(r, r.VERTEX_SHADER, y + m + o),
          M = NP(r, r.FRAGMENT_SHADER, b);
        if (
          (r.attachShader(_, x),
          r.attachShader(_, M),
          void 0 !== t.index0AttributeName
            ? r.bindAttribLocation(_, 0, t.index0AttributeName)
            : !0 === t.morphTargets && r.bindAttribLocation(_, 0, "position"),
          r.linkProgram(_),
          n.debug.checkShaderErrors)
        ) {
          const w = r.getProgramInfoLog(_).trim(),
            E = r.getShaderInfoLog(x).trim(),
            V = r.getShaderInfoLog(M).trim();
          let j = !0,
            F = !0;
          if (!1 === r.getProgramParameter(_, r.LINK_STATUS))
            if (((j = !1), "function" == typeof n.debug.onShaderError))
              n.debug.onShaderError(r, _, x, M);
            else {
              const k = kP(r, x, "vertex"),
                z = kP(r, M, "fragment");
              console.error(
                "THREE.WebGLProgram: Shader Error " +
                  r.getError() +
                  " - VALIDATE_STATUS " +
                  r.getProgramParameter(_, r.VALIDATE_STATUS) +
                  "\n\nProgram Info Log: " +
                  w +
                  "\n" +
                  k +
                  "\n" +
                  z
              );
            }
          else
            "" !== w
              ? console.warn("THREE.WebGLProgram: Program Info Log:", w)
              : ("" === E || "" === V) && (F = !1);
          F &&
            (this.diagnostics = {
              runnable: j,
              programLog: w,
              vertexShader: { log: E, prefix: m },
              fragmentShader: { log: V, prefix: g },
            });
        }
        let S, C;
        return (
          r.deleteShader(x),
          r.deleteShader(M),
          (this.getUniforms = function () {
            return void 0 === S && (S = new Lm(r, _)), S;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === C &&
                (C = (function cZ(n, e) {
                  const t = {},
                    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
                  for (let r = 0; r < i; r++) {
                    const s = n.getActiveAttrib(e, r),
                      o = s.name;
                    let a = 1;
                    s.type === n.FLOAT_MAT2 && (a = 2),
                      s.type === n.FLOAT_MAT3 && (a = 3),
                      s.type === n.FLOAT_MAT4 && (a = 4),
                      (t[o] = {
                        type: s.type,
                        location: n.getAttribLocation(e, o),
                        locationSize: a,
                      });
                  }
                  return t;
                })(r, _)),
              C
            );
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(_),
              (this.program = void 0);
          }),
          (this.type = t.shaderType),
          (this.name = t.shaderName),
          (this.id = nZ++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = _),
          (this.vertexShader = x),
          (this.fragmentShader = M),
          this
        );
      }
      let xZ = 0;
      class wZ {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const i = e.fragmentShader,
            r = this._getShaderStage(e.vertexShader),
            s = this._getShaderStage(i),
            o = this._getShaderCacheForMaterial(e);
          return (
            !1 === o.has(r) && (o.add(r), r.usedTimes++),
            !1 === o.has(s) && (o.add(s), s.usedTimes++),
            this
          );
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const i of t)
            i.usedTimes--, 0 === i.usedTimes && this.shaderCache.delete(i.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let i = t.get(e);
          return void 0 === i && ((i = new Set()), t.set(e, i)), i;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let i = t.get(e);
          return void 0 === i && ((i = new MZ(e)), t.set(e, i)), i;
        }
      }
      class MZ {
        constructor(e) {
          (this.id = xZ++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function SZ(n, e, t, i, r, s, o) {
        const a = new Ob(),
          l = new wZ(),
          c = [],
          u = r.isWebGL2,
          d = r.logarithmicDepthBuffer,
          h = r.vertexTextures;
        let f = r.precision;
        const p = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function _(w) {
          return 0 === w ? "uv" : `uv${w}`;
        }
        return {
          getParameters: function m(w, E, V, j, F) {
            const k = j.fog,
              z = F.geometry,
              L = (w.isMeshStandardMaterial ? t : e).get(
                w.envMap || (w.isMeshStandardMaterial ? j.environment : null)
              ),
              U = L && L.mapping === Gd ? L.image.height : null,
              W = p[w.type];
            null !== w.precision &&
              ((f = r.getMaxPrecision(w.precision)),
              f !== w.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  w.precision,
                  "not supported, using",
                  f,
                  "instead."
                ));
            const Z =
                z.morphAttributes.position ||
                z.morphAttributes.normal ||
                z.morphAttributes.color,
              B = void 0 !== Z ? Z.length : 0;
            let le,
              te,
              ce,
              Ce,
              q = 0;
            if (
              (void 0 !== z.morphAttributes.position && (q = 1),
              void 0 !== z.morphAttributes.normal && (q = 2),
              void 0 !== z.morphAttributes.color && (q = 3),
              W)
            ) {
              const Rs = Ss[W];
              (le = Rs.vertexShader), (te = Rs.fragmentShader);
            } else
              (le = w.vertexShader),
                (te = w.fragmentShader),
                l.update(w),
                (ce = l.getVertexShaderID(w)),
                (Ce = l.getFragmentShaderID(w));
            const ve = n.getRenderTarget(),
              xe = !0 === F.isInstancedMesh,
              Ze = !!w.map,
              Ue = !!L,
              P = !!w.aoMap,
              ge = !!w.lightMap,
              ie = !!w.bumpMap,
              pe = !!w.normalMap,
              oe = !!w.displacementMap,
              ze = !!w.emissiveMap,
              Pe = !!w.metalnessMap,
              Oe = !!w.roughnessMap,
              et = w.anisotropy > 0,
              Tt = w.clearcoat > 0,
              an = w.iridescence > 0,
              I = w.sheen > 0,
              T = w.transmission > 0,
              Q = et && !!w.anisotropyMap,
              fe = Tt && !!w.clearcoatMap,
              he = Tt && !!w.clearcoatNormalMap,
              R = Tt && !!w.clearcoatRoughnessMap,
              ae = an && !!w.iridescenceMap,
              ue = an && !!w.iridescenceThicknessMap,
              Y = I && !!w.sheenColorMap,
              ke = I && !!w.sheenRoughnessMap,
              We = !!w.specularMap,
              Ve = !!w.specularColorMap,
              Be = !!w.specularIntensityMap,
              Fe = T && !!w.transmissionMap,
              tt = T && !!w.thicknessMap,
              N = !!w.alphaMap,
              _e = !!w.extensions,
              Te = !!z.attributes.uv1,
              Nt = !!z.attributes.uv2,
              gn = !!z.attributes.uv3;
            return {
              isWebGL2: u,
              shaderID: W,
              shaderType: w.type,
              shaderName: w.name,
              vertexShader: le,
              fragmentShader: te,
              defines: w.defines,
              customVertexShaderID: ce,
              customFragmentShaderID: Ce,
              isRawShaderMaterial: !0 === w.isRawShaderMaterial,
              glslVersion: w.glslVersion,
              precision: f,
              instancing: xe,
              instancingColor: xe && null !== F.instanceColor,
              supportsVertexTextures: h,
              outputColorSpace:
                null === ve
                  ? n.outputColorSpace
                  : !0 === ve.isXRRenderTarget
                  ? ve.texture.colorSpace
                  : Kr,
              map: Ze,
              matcap: !!w.matcap,
              envMap: Ue,
              envMapMode: Ue && L.mapping,
              envMapCubeUVHeight: U,
              aoMap: P,
              lightMap: ge,
              bumpMap: ie,
              normalMap: pe,
              displacementMap: h && oe,
              emissiveMap: ze,
              normalMapObjectSpace: pe && w.normalMapType === tX,
              normalMapTangentSpace: pe && w.normalMapType === Da,
              metalnessMap: Pe,
              roughnessMap: Oe,
              anisotropy: et,
              anisotropyMap: Q,
              clearcoat: Tt,
              clearcoatMap: fe,
              clearcoatNormalMap: he,
              clearcoatRoughnessMap: R,
              iridescence: an,
              iridescenceMap: ae,
              iridescenceThicknessMap: ue,
              sheen: I,
              sheenColorMap: Y,
              sheenRoughnessMap: ke,
              specularMap: We,
              specularColorMap: Ve,
              specularIntensityMap: Be,
              transmission: T,
              transmissionMap: Fe,
              thicknessMap: tt,
              gradientMap: !!w.gradientMap,
              opaque: !1 === w.transparent && w.blending === pc,
              alphaMap: N,
              alphaTest: w.alphaTest > 0,
              alphaHash: !!w.alphaHash,
              combine: w.combine,
              mapUv: Ze && _(w.map.channel),
              aoMapUv: P && _(w.aoMap.channel),
              lightMapUv: ge && _(w.lightMap.channel),
              bumpMapUv: ie && _(w.bumpMap.channel),
              normalMapUv: pe && _(w.normalMap.channel),
              displacementMapUv: oe && _(w.displacementMap.channel),
              emissiveMapUv: ze && _(w.emissiveMap.channel),
              metalnessMapUv: Pe && _(w.metalnessMap.channel),
              roughnessMapUv: Oe && _(w.roughnessMap.channel),
              anisotropyMapUv: Q && _(w.anisotropyMap.channel),
              clearcoatMapUv: fe && _(w.clearcoatMap.channel),
              clearcoatNormalMapUv: he && _(w.clearcoatNormalMap.channel),
              clearcoatRoughnessMapUv: R && _(w.clearcoatRoughnessMap.channel),
              iridescenceMapUv: ae && _(w.iridescenceMap.channel),
              iridescenceThicknessMapUv:
                ue && _(w.iridescenceThicknessMap.channel),
              sheenColorMapUv: Y && _(w.sheenColorMap.channel),
              sheenRoughnessMapUv: ke && _(w.sheenRoughnessMap.channel),
              specularMapUv: We && _(w.specularMap.channel),
              specularColorMapUv: Ve && _(w.specularColorMap.channel),
              specularIntensityMapUv: Be && _(w.specularIntensityMap.channel),
              transmissionMapUv: Fe && _(w.transmissionMap.channel),
              thicknessMapUv: tt && _(w.thicknessMap.channel),
              alphaMapUv: N && _(w.alphaMap.channel),
              vertexTangents: !!z.attributes.tangent && (pe || et),
              vertexColors: w.vertexColors,
              vertexAlphas:
                !0 === w.vertexColors &&
                !!z.attributes.color &&
                4 === z.attributes.color.itemSize,
              vertexUv1s: Te,
              vertexUv2s: Nt,
              vertexUv3s: gn,
              pointsUvs: !0 === F.isPoints && !!z.attributes.uv && (Ze || N),
              fog: !!k,
              useFog: !0 === w.fog,
              fogExp2: k && k.isFogExp2,
              flatShading: !0 === w.flatShading,
              sizeAttenuation: !0 === w.sizeAttenuation,
              logarithmicDepthBuffer: d,
              skinning: !0 === F.isSkinnedMesh,
              morphTargets: void 0 !== z.morphAttributes.position,
              morphNormals: void 0 !== z.morphAttributes.normal,
              morphColors: void 0 !== z.morphAttributes.color,
              morphTargetsCount: B,
              morphTextureStride: q,
              numDirLights: E.directional.length,
              numPointLights: E.point.length,
              numSpotLights: E.spot.length,
              numSpotLightMaps: E.spotLightMap.length,
              numRectAreaLights: E.rectArea.length,
              numHemiLights: E.hemi.length,
              numDirLightShadows: E.directionalShadowMap.length,
              numPointLightShadows: E.pointShadowMap.length,
              numSpotLightShadows: E.spotShadowMap.length,
              numSpotLightShadowsWithMaps: E.numSpotLightShadowsWithMaps,
              numClippingPlanes: o.numPlanes,
              numClipIntersection: o.numIntersection,
              dithering: w.dithering,
              shadowMapEnabled: n.shadowMap.enabled && V.length > 0,
              shadowMapType: n.shadowMap.type,
              toneMapping: w.toneMapped ? n.toneMapping : Qs,
              useLegacyLights: n.useLegacyLights,
              premultipliedAlpha: w.premultipliedAlpha,
              doubleSided: w.side === Cr,
              flipSided: w.side === zi,
              useDepthPacking: w.depthPacking >= 0,
              depthPacking: w.depthPacking || 0,
              index0AttributeName: w.index0AttributeName,
              extensionDerivatives: _e && !0 === w.extensions.derivatives,
              extensionFragDepth: _e && !0 === w.extensions.fragDepth,
              extensionDrawBuffers: _e && !0 === w.extensions.drawBuffers,
              extensionShaderTextureLOD:
                _e && !0 === w.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                u || i.has("EXT_shader_texture_lod"),
              customProgramCacheKey: w.customProgramCacheKey(),
            };
          },
          getProgramCacheKey: function g(w) {
            const E = [];
            if (
              (w.shaderID
                ? E.push(w.shaderID)
                : (E.push(w.customVertexShaderID),
                  E.push(w.customFragmentShaderID)),
              void 0 !== w.defines)
            )
              for (const V in w.defines) E.push(V), E.push(w.defines[V]);
            return (
              !1 === w.isRawShaderMaterial &&
                ((function y(w, E) {
                  w.push(E.precision),
                    w.push(E.outputColorSpace),
                    w.push(E.envMapMode),
                    w.push(E.envMapCubeUVHeight),
                    w.push(E.mapUv),
                    w.push(E.alphaMapUv),
                    w.push(E.lightMapUv),
                    w.push(E.aoMapUv),
                    w.push(E.bumpMapUv),
                    w.push(E.normalMapUv),
                    w.push(E.displacementMapUv),
                    w.push(E.emissiveMapUv),
                    w.push(E.metalnessMapUv),
                    w.push(E.roughnessMapUv),
                    w.push(E.anisotropyMapUv),
                    w.push(E.clearcoatMapUv),
                    w.push(E.clearcoatNormalMapUv),
                    w.push(E.clearcoatRoughnessMapUv),
                    w.push(E.iridescenceMapUv),
                    w.push(E.iridescenceThicknessMapUv),
                    w.push(E.sheenColorMapUv),
                    w.push(E.sheenRoughnessMapUv),
                    w.push(E.specularMapUv),
                    w.push(E.specularColorMapUv),
                    w.push(E.specularIntensityMapUv),
                    w.push(E.transmissionMapUv),
                    w.push(E.thicknessMapUv),
                    w.push(E.combine),
                    w.push(E.fogExp2),
                    w.push(E.sizeAttenuation),
                    w.push(E.morphTargetsCount),
                    w.push(E.morphAttributeCount),
                    w.push(E.numDirLights),
                    w.push(E.numPointLights),
                    w.push(E.numSpotLights),
                    w.push(E.numSpotLightMaps),
                    w.push(E.numHemiLights),
                    w.push(E.numRectAreaLights),
                    w.push(E.numDirLightShadows),
                    w.push(E.numPointLightShadows),
                    w.push(E.numSpotLightShadows),
                    w.push(E.numSpotLightShadowsWithMaps),
                    w.push(E.shadowMapType),
                    w.push(E.toneMapping),
                    w.push(E.numClippingPlanes),
                    w.push(E.numClipIntersection),
                    w.push(E.depthPacking);
                })(E, w),
                (function v(w, E) {
                  a.disableAll(),
                    E.isWebGL2 && a.enable(0),
                    E.supportsVertexTextures && a.enable(1),
                    E.instancing && a.enable(2),
                    E.instancingColor && a.enable(3),
                    E.matcap && a.enable(4),
                    E.envMap && a.enable(5),
                    E.normalMapObjectSpace && a.enable(6),
                    E.normalMapTangentSpace && a.enable(7),
                    E.clearcoat && a.enable(8),
                    E.iridescence && a.enable(9),
                    E.alphaTest && a.enable(10),
                    E.vertexColors && a.enable(11),
                    E.vertexAlphas && a.enable(12),
                    E.vertexUv1s && a.enable(13),
                    E.vertexUv2s && a.enable(14),
                    E.vertexUv3s && a.enable(15),
                    E.vertexTangents && a.enable(16),
                    E.anisotropy && a.enable(17),
                    w.push(a.mask),
                    a.disableAll(),
                    E.fog && a.enable(0),
                    E.useFog && a.enable(1),
                    E.flatShading && a.enable(2),
                    E.logarithmicDepthBuffer && a.enable(3),
                    E.skinning && a.enable(4),
                    E.morphTargets && a.enable(5),
                    E.morphNormals && a.enable(6),
                    E.morphColors && a.enable(7),
                    E.premultipliedAlpha && a.enable(8),
                    E.shadowMapEnabled && a.enable(9),
                    E.useLegacyLights && a.enable(10),
                    E.doubleSided && a.enable(11),
                    E.flipSided && a.enable(12),
                    E.useDepthPacking && a.enable(13),
                    E.dithering && a.enable(14),
                    E.transmission && a.enable(15),
                    E.sheen && a.enable(16),
                    E.opaque && a.enable(17),
                    E.pointsUvs && a.enable(18),
                    w.push(a.mask);
                })(E, w),
                E.push(n.outputColorSpace)),
              E.push(w.customProgramCacheKey),
              E.join()
            );
          },
          getUniforms: function b(w) {
            const E = p[w.type];
            let V;
            return (V = E ? Uc.clone(Ss[E].uniforms) : w.uniforms), V;
          },
          acquireProgram: function x(w, E) {
            let V;
            for (let j = 0, F = c.length; j < F; j++) {
              const k = c[j];
              if (k.cacheKey === E) {
                (V = k), ++V.usedTimes;
                break;
              }
            }
            return void 0 === V && ((V = new bZ(n, E, w, s)), c.push(V)), V;
          },
          releaseProgram: function M(w) {
            if (0 == --w.usedTimes) {
              const E = c.indexOf(w);
              (c[E] = c[c.length - 1]), c.pop(), w.destroy();
            }
          },
          releaseShaderCache: function S(w) {
            l.remove(w);
          },
          programs: c,
          dispose: function C() {
            l.dispose();
          },
        };
      }
      function EZ() {
        let n = new WeakMap();
        return {
          get: function e(s) {
            let o = n.get(s);
            return void 0 === o && ((o = {}), n.set(s, o)), o;
          },
          remove: function t(s) {
            n.delete(s);
          },
          update: function i(s, o, a) {
            n.get(s)[o] = a;
          },
          dispose: function r() {
            n = new WeakMap();
          },
        };
      }
      function CZ(n, e) {
        return n.groupOrder !== e.groupOrder
          ? n.groupOrder - e.groupOrder
          : n.renderOrder !== e.renderOrder
          ? n.renderOrder - e.renderOrder
          : n.material.id !== e.material.id
          ? n.material.id - e.material.id
          : n.z !== e.z
          ? n.z - e.z
          : n.id - e.id;
      }
      function HP(n, e) {
        return n.groupOrder !== e.groupOrder
          ? n.groupOrder - e.groupOrder
          : n.renderOrder !== e.renderOrder
          ? n.renderOrder - e.renderOrder
          : n.z !== e.z
          ? e.z - n.z
          : n.id - e.id;
      }
      function GP() {
        const n = [];
        let e = 0;
        const t = [],
          i = [],
          r = [];
        function o(d, h, f, p, _, m) {
          let g = n[e];
          return (
            void 0 === g
              ? ((g = {
                  id: d.id,
                  object: d,
                  geometry: h,
                  material: f,
                  groupOrder: p,
                  renderOrder: d.renderOrder,
                  z: _,
                  group: m,
                }),
                (n[e] = g))
              : ((g.id = d.id),
                (g.object = d),
                (g.geometry = h),
                (g.material = f),
                (g.groupOrder = p),
                (g.renderOrder = d.renderOrder),
                (g.z = _),
                (g.group = m)),
            e++,
            g
          );
        }
        return {
          opaque: t,
          transmissive: i,
          transparent: r,
          init: function s() {
            (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
          },
          push: function a(d, h, f, p, _, m) {
            const g = o(d, h, f, p, _, m);
            f.transmission > 0
              ? i.push(g)
              : !0 === f.transparent
              ? r.push(g)
              : t.push(g);
          },
          unshift: function l(d, h, f, p, _, m) {
            const g = o(d, h, f, p, _, m);
            f.transmission > 0
              ? i.unshift(g)
              : !0 === f.transparent
              ? r.unshift(g)
              : t.unshift(g);
          },
          finish: function u() {
            for (let d = e, h = n.length; d < h; d++) {
              const f = n[d];
              if (null === f.id) break;
              (f.id = null),
                (f.object = null),
                (f.geometry = null),
                (f.material = null),
                (f.group = null);
            }
          },
          sort: function c(d, h) {
            t.length > 1 && t.sort(d || CZ),
              i.length > 1 && i.sort(h || HP),
              r.length > 1 && r.sort(h || HP);
          },
        };
      }
      function TZ() {
        let n = new WeakMap();
        return {
          get: function e(i, r) {
            const s = n.get(i);
            let o;
            return (
              void 0 === s
                ? ((o = new GP()), n.set(i, [o]))
                : r >= s.length
                ? ((o = new GP()), s.push(o))
                : (o = s[r]),
              o
            );
          },
          dispose: function t() {
            n = new WeakMap();
          },
        };
      }
      function AZ() {
        const n = {};
        return {
          get: function (e) {
            if (void 0 !== n[e.id]) return n[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = { direction: new A(), color: new de() };
                break;
              case "SpotLight":
                t = {
                  position: new A(),
                  direction: new A(),
                  color: new de(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                t = {
                  position: new A(),
                  color: new de(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new A(),
                  skyColor: new de(),
                  groundColor: new de(),
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new de(),
                  position: new A(),
                  halfWidth: new A(),
                  halfHeight: new A(),
                };
            }
            return (n[e.id] = t), t;
          },
        };
      }
      let IZ = 0;
      function RZ(n, e) {
        return (
          (e.castShadow ? 2 : 0) -
          (n.castShadow ? 2 : 0) +
          (e.map ? 1 : 0) -
          (n.map ? 1 : 0)
        );
      }
      function PZ(n, e) {
        const t = new AZ(),
          i = (function DZ() {
            const n = {};
            return {
              get: function (e) {
                if (void 0 !== n[e.id]) return n[e.id];
                let t;
                switch (e.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    t = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new $(),
                    };
                    break;
                  case "PointLight":
                    t = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new $(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (n[e.id] = t), t;
              },
            };
          })(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
          };
        for (let u = 0; u < 9; u++) r.probe.push(new A());
        const s = new A(),
          o = new Ae(),
          a = new Ae();
        return {
          setup: function l(u, d) {
            let h = 0,
              f = 0,
              p = 0;
            for (let V = 0; V < 9; V++) r.probe[V].set(0, 0, 0);
            let _ = 0,
              m = 0,
              g = 0,
              y = 0,
              v = 0,
              b = 0,
              x = 0,
              M = 0,
              S = 0,
              C = 0;
            u.sort(RZ);
            const w = !0 === d ? Math.PI : 1;
            for (let V = 0, j = u.length; V < j; V++) {
              const F = u[V],
                k = F.color,
                z = F.intensity,
                O = F.distance,
                L = F.shadow && F.shadow.map ? F.shadow.map.texture : null;
              if (F.isAmbientLight)
                (h += k.r * z * w), (f += k.g * z * w), (p += k.b * z * w);
              else if (F.isLightProbe)
                for (let U = 0; U < 9; U++)
                  r.probe[U].addScaledVector(F.sh.coefficients[U], z);
              else if (F.isDirectionalLight) {
                const U = t.get(F);
                if (
                  (U.color.copy(F.color).multiplyScalar(F.intensity * w),
                  F.castShadow)
                ) {
                  const W = F.shadow,
                    Z = i.get(F);
                  (Z.shadowBias = W.bias),
                    (Z.shadowNormalBias = W.normalBias),
                    (Z.shadowRadius = W.radius),
                    (Z.shadowMapSize = W.mapSize),
                    (r.directionalShadow[_] = Z),
                    (r.directionalShadowMap[_] = L),
                    (r.directionalShadowMatrix[_] = F.shadow.matrix),
                    b++;
                }
                (r.directional[_] = U), _++;
              } else if (F.isSpotLight) {
                const U = t.get(F);
                U.position.setFromMatrixPosition(F.matrixWorld),
                  U.color.copy(k).multiplyScalar(z * w),
                  (U.distance = O),
                  (U.coneCos = Math.cos(F.angle)),
                  (U.penumbraCos = Math.cos(F.angle * (1 - F.penumbra))),
                  (U.decay = F.decay),
                  (r.spot[g] = U);
                const W = F.shadow;
                if (
                  (F.map &&
                    ((r.spotLightMap[S] = F.map),
                    S++,
                    W.updateMatrices(F),
                    F.castShadow && C++),
                  (r.spotLightMatrix[g] = W.matrix),
                  F.castShadow)
                ) {
                  const Z = i.get(F);
                  (Z.shadowBias = W.bias),
                    (Z.shadowNormalBias = W.normalBias),
                    (Z.shadowRadius = W.radius),
                    (Z.shadowMapSize = W.mapSize),
                    (r.spotShadow[g] = Z),
                    (r.spotShadowMap[g] = L),
                    M++;
                }
                g++;
              } else if (F.isRectAreaLight) {
                const U = t.get(F);
                U.color.copy(k).multiplyScalar(z),
                  U.halfWidth.set(0.5 * F.width, 0, 0),
                  U.halfHeight.set(0, 0.5 * F.height, 0),
                  (r.rectArea[y] = U),
                  y++;
              } else if (F.isPointLight) {
                const U = t.get(F);
                if (
                  (U.color.copy(F.color).multiplyScalar(F.intensity * w),
                  (U.distance = F.distance),
                  (U.decay = F.decay),
                  F.castShadow)
                ) {
                  const W = F.shadow,
                    Z = i.get(F);
                  (Z.shadowBias = W.bias),
                    (Z.shadowNormalBias = W.normalBias),
                    (Z.shadowRadius = W.radius),
                    (Z.shadowMapSize = W.mapSize),
                    (Z.shadowCameraNear = W.camera.near),
                    (Z.shadowCameraFar = W.camera.far),
                    (r.pointShadow[m] = Z),
                    (r.pointShadowMap[m] = L),
                    (r.pointShadowMatrix[m] = F.shadow.matrix),
                    x++;
                }
                (r.point[m] = U), m++;
              } else if (F.isHemisphereLight) {
                const U = t.get(F);
                U.skyColor.copy(F.color).multiplyScalar(z * w),
                  U.groundColor.copy(F.groundColor).multiplyScalar(z * w),
                  (r.hemi[v] = U),
                  v++;
              }
            }
            y > 0 &&
              (e.isWebGL2 || !0 === n.has("OES_texture_float_linear")
                ? ((r.rectAreaLTC1 = be.LTC_FLOAT_1),
                  (r.rectAreaLTC2 = be.LTC_FLOAT_2))
                : !0 === n.has("OES_texture_half_float_linear")
                ? ((r.rectAreaLTC1 = be.LTC_HALF_1),
                  (r.rectAreaLTC2 = be.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
              (r.ambient[0] = h),
              (r.ambient[1] = f),
              (r.ambient[2] = p);
            const E = r.hash;
            (E.directionalLength !== _ ||
              E.pointLength !== m ||
              E.spotLength !== g ||
              E.rectAreaLength !== y ||
              E.hemiLength !== v ||
              E.numDirectionalShadows !== b ||
              E.numPointShadows !== x ||
              E.numSpotShadows !== M ||
              E.numSpotMaps !== S) &&
              ((r.directional.length = _),
              (r.spot.length = g),
              (r.rectArea.length = y),
              (r.point.length = m),
              (r.hemi.length = v),
              (r.directionalShadow.length = b),
              (r.directionalShadowMap.length = b),
              (r.pointShadow.length = x),
              (r.pointShadowMap.length = x),
              (r.spotShadow.length = M),
              (r.spotShadowMap.length = M),
              (r.directionalShadowMatrix.length = b),
              (r.pointShadowMatrix.length = x),
              (r.spotLightMatrix.length = M + S - C),
              (r.spotLightMap.length = S),
              (r.numSpotLightShadowsWithMaps = C),
              (E.directionalLength = _),
              (E.pointLength = m),
              (E.spotLength = g),
              (E.rectAreaLength = y),
              (E.hemiLength = v),
              (E.numDirectionalShadows = b),
              (E.numPointShadows = x),
              (E.numSpotShadows = M),
              (E.numSpotMaps = S),
              (r.version = IZ++));
          },
          setupView: function c(u, d) {
            let h = 0,
              f = 0,
              p = 0,
              _ = 0,
              m = 0;
            const g = d.matrixWorldInverse;
            for (let y = 0, v = u.length; y < v; y++) {
              const b = u[y];
              if (b.isDirectionalLight) {
                const x = r.directional[h];
                x.direction.setFromMatrixPosition(b.matrixWorld),
                  s.setFromMatrixPosition(b.target.matrixWorld),
                  x.direction.sub(s),
                  x.direction.transformDirection(g),
                  h++;
              } else if (b.isSpotLight) {
                const x = r.spot[p];
                x.position.setFromMatrixPosition(b.matrixWorld),
                  x.position.applyMatrix4(g),
                  x.direction.setFromMatrixPosition(b.matrixWorld),
                  s.setFromMatrixPosition(b.target.matrixWorld),
                  x.direction.sub(s),
                  x.direction.transformDirection(g),
                  p++;
              } else if (b.isRectAreaLight) {
                const x = r.rectArea[_];
                x.position.setFromMatrixPosition(b.matrixWorld),
                  x.position.applyMatrix4(g),
                  a.identity(),
                  o.copy(b.matrixWorld),
                  o.premultiply(g),
                  a.extractRotation(o),
                  x.halfWidth.set(0.5 * b.width, 0, 0),
                  x.halfHeight.set(0, 0.5 * b.height, 0),
                  x.halfWidth.applyMatrix4(a),
                  x.halfHeight.applyMatrix4(a),
                  _++;
              } else if (b.isPointLight) {
                const x = r.point[f];
                x.position.setFromMatrixPosition(b.matrixWorld),
                  x.position.applyMatrix4(g),
                  f++;
              } else if (b.isHemisphereLight) {
                const x = r.hemi[m];
                x.direction.setFromMatrixPosition(b.matrixWorld),
                  x.direction.transformDirection(g),
                  m++;
              }
            }
          },
          state: r,
        };
      }
      function WP(n, e) {
        const t = new PZ(n, e),
          i = [],
          r = [];
        return {
          init: function s() {
            (i.length = 0), (r.length = 0);
          },
          state: { lightsArray: i, shadowsArray: r, lights: t },
          setupLights: function l(d) {
            t.setup(i, d);
          },
          setupLightsView: function c(d) {
            t.setupView(i, d);
          },
          pushLight: function o(d) {
            i.push(d);
          },
          pushShadow: function a(d) {
            r.push(d);
          },
        };
      }
      function OZ(n, e) {
        let t = new WeakMap();
        return {
          get: function i(s, o = 0) {
            const a = t.get(s);
            let l;
            return (
              void 0 === a
                ? ((l = new WP(n, e)), t.set(s, [l]))
                : o >= a.length
                ? ((l = new WP(n, e)), a.push(l))
                : (l = a[o]),
              l
            );
          },
          dispose: function r() {
            t = new WeakMap();
          },
        };
      }
      class Kb extends ar {
        constructor(e) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = 3200),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      class jP extends ar {
        constructor(e) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = "MeshDistanceMaterial"),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      const LZ = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        FZ =
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      function NZ(n, e, t) {
        let i = new Wb();
        const r = new $(),
          s = new $(),
          o = new Ft(),
          a = new Kb({ depthPacking: XR }),
          l = new jP(),
          c = {},
          u = t.maxTextureSize,
          d = { [$s]: zi, [zi]: $s, [Cr]: Cr },
          h = new $n({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new $() },
              radius: { value: 4 },
            },
            vertexShader: LZ,
            fragmentShader: FZ,
          }),
          f = h.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const p = new ut();
        p.setAttribute(
          "position",
          new on(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const _ = new Kn(p, h),
          m = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = rR);
        let g = this.type;
        function y(x, M) {
          const S = e.update(_);
          h.defines.VSM_SAMPLES !== x.blurSamples &&
            ((h.defines.VSM_SAMPLES = x.blurSamples),
            (f.defines.VSM_SAMPLES = x.blurSamples),
            (h.needsUpdate = !0),
            (f.needsUpdate = !0)),
            null === x.mapPass && (x.mapPass = new li(r.x, r.y)),
            (h.uniforms.shadow_pass.value = x.map.texture),
            (h.uniforms.resolution.value = x.mapSize),
            (h.uniforms.radius.value = x.radius),
            n.setRenderTarget(x.mapPass),
            n.clear(),
            n.renderBufferDirect(M, null, S, h, _, null),
            (f.uniforms.shadow_pass.value = x.mapPass.texture),
            (f.uniforms.resolution.value = x.mapSize),
            (f.uniforms.radius.value = x.radius),
            n.setRenderTarget(x.map),
            n.clear(),
            n.renderBufferDirect(M, null, S, f, _, null);
        }
        function v(x, M, S, C) {
          let w = null;
          const E =
            !0 === S.isPointLight
              ? x.customDistanceMaterial
              : x.customDepthMaterial;
          if (void 0 !== E) w = E;
          else if (
            ((w = !0 === S.isPointLight ? l : a),
            (n.localClippingEnabled &&
              !0 === M.clipShadows &&
              Array.isArray(M.clippingPlanes) &&
              0 !== M.clippingPlanes.length) ||
              (M.displacementMap && 0 !== M.displacementScale) ||
              (M.alphaMap && M.alphaTest > 0) ||
              (M.map && M.alphaTest > 0))
          ) {
            const V = w.uuid,
              j = M.uuid;
            let F = c[V];
            void 0 === F && ((F = {}), (c[V] = F));
            let k = F[j];
            void 0 === k && ((k = w.clone()), (F[j] = k)), (w = k);
          }
          return (
            (w.visible = M.visible),
            (w.wireframe = M.wireframe),
            (w.side =
              C === Ks
                ? null !== M.shadowSide
                  ? M.shadowSide
                  : M.side
                : null !== M.shadowSide
                ? M.shadowSide
                : d[M.side]),
            (w.alphaMap = M.alphaMap),
            (w.alphaTest = M.alphaTest),
            (w.map = M.map),
            (w.clipShadows = M.clipShadows),
            (w.clippingPlanes = M.clippingPlanes),
            (w.clipIntersection = M.clipIntersection),
            (w.displacementMap = M.displacementMap),
            (w.displacementScale = M.displacementScale),
            (w.displacementBias = M.displacementBias),
            (w.wireframeLinewidth = M.wireframeLinewidth),
            (w.linewidth = M.linewidth),
            !0 === S.isPointLight &&
              !0 === w.isMeshDistanceMaterial &&
              (n.properties.get(w).light = S),
            w
          );
        }
        function b(x, M, S, C, w) {
          if (!1 === x.visible) return;
          if (
            x.layers.test(M.layers) &&
            (x.isMesh || x.isLine || x.isPoints) &&
            (x.castShadow || (x.receiveShadow && w === Ks)) &&
            (!x.frustumCulled || i.intersectsObject(x))
          ) {
            x.modelViewMatrix.multiplyMatrices(
              S.matrixWorldInverse,
              x.matrixWorld
            );
            const j = e.update(x),
              F = x.material;
            if (Array.isArray(F)) {
              const k = j.groups;
              for (let z = 0, O = k.length; z < O; z++) {
                const L = k[z],
                  U = F[L.materialIndex];
                if (U && U.visible) {
                  const W = v(x, U, C, w);
                  n.renderBufferDirect(S, null, j, W, x, L);
                }
              }
            } else if (F.visible) {
              const k = v(x, F, C, w);
              n.renderBufferDirect(S, null, j, k, x, null);
            }
          }
          const V = x.children;
          for (let j = 0, F = V.length; j < F; j++) b(V[j], M, S, C, w);
        }
        this.render = function (x, M, S) {
          if (
            !1 === m.enabled ||
            (!1 === m.autoUpdate && !1 === m.needsUpdate) ||
            0 === x.length
          )
            return;
          const C = n.getRenderTarget(),
            w = n.getActiveCubeFace(),
            E = n.getActiveMipmapLevel(),
            V = n.state;
          V.setBlending(Zr),
            V.buffers.color.setClear(1, 1, 1, 1),
            V.buffers.depth.setTest(!0),
            V.setScissorTest(!1);
          const j = g !== Ks && this.type === Ks,
            F = g === Ks && this.type !== Ks;
          for (let k = 0, z = x.length; k < z; k++) {
            const O = x[k],
              L = O.shadow;
            if (void 0 === L) {
              console.warn("THREE.WebGLShadowMap:", O, "has no shadow.");
              continue;
            }
            if (!1 === L.autoUpdate && !1 === L.needsUpdate) continue;
            r.copy(L.mapSize);
            const U = L.getFrameExtents();
            if (
              (r.multiply(U),
              s.copy(L.mapSize),
              (r.x > u || r.y > u) &&
                (r.x > u &&
                  ((s.x = Math.floor(u / U.x)),
                  (r.x = s.x * U.x),
                  (L.mapSize.x = s.x)),
                r.y > u &&
                  ((s.y = Math.floor(u / U.y)),
                  (r.y = s.y * U.y),
                  (L.mapSize.y = s.y))),
              null === L.map || !0 === j || !0 === F)
            ) {
              const Z =
                this.type !== Ks ? { minFilter: hn, magFilter: hn } : {};
              null !== L.map && L.map.dispose(),
                (L.map = new li(r.x, r.y, Z)),
                (L.map.texture.name = O.name + ".shadowMap"),
                L.camera.updateProjectionMatrix();
            }
            n.setRenderTarget(L.map), n.clear();
            const W = L.getViewportCount();
            for (let Z = 0; Z < W; Z++) {
              const B = L.getViewport(Z);
              o.set(s.x * B.x, s.y * B.y, s.x * B.z, s.y * B.w),
                V.viewport(o),
                L.updateMatrices(O, Z),
                (i = L.getFrustum()),
                b(M, S, L.camera, O, this.type);
            }
            !0 !== L.isPointLightShadow && this.type === Ks && y(L, S),
              (L.needsUpdate = !1);
          }
          (g = this.type), (m.needsUpdate = !1), n.setRenderTarget(C, w, E);
        };
      }
      function kZ(n, e, t) {
        const i = t.isWebGL2,
          a = new (function r() {
            let N = !1;
            const we = new Ft();
            let K = null;
            const _e = new Ft(0, 0, 0, 0);
            return {
              setMask: function (Te) {
                K !== Te && !N && (n.colorMask(Te, Te, Te, Te), (K = Te));
              },
              setLocked: function (Te) {
                N = Te;
              },
              setClear: function (Te, Nt, gn, Jn, Rs) {
                !0 === Rs && ((Te *= Jn), (Nt *= Jn), (gn *= Jn)),
                  we.set(Te, Nt, gn, Jn),
                  !1 === _e.equals(we) &&
                    (n.clearColor(Te, Nt, gn, Jn), _e.copy(we));
              },
              reset: function () {
                (N = !1), (K = null), _e.set(-1, 0, 0, 0);
              },
            };
          })(),
          l = new (function s() {
            let N = !1,
              we = null,
              K = null,
              _e = null;
            return {
              setTest: function (Te) {
                Te ? ve(n.DEPTH_TEST) : xe(n.DEPTH_TEST);
              },
              setMask: function (Te) {
                we !== Te && !N && (n.depthMask(Te), (we = Te));
              },
              setFunc: function (Te) {
                if (K !== Te) {
                  switch (Te) {
                    case I9:
                      n.depthFunc(n.NEVER);
                      break;
                    case R9:
                      n.depthFunc(n.ALWAYS);
                      break;
                    case P9:
                      n.depthFunc(n.LESS);
                      break;
                    case ab:
                      n.depthFunc(n.LEQUAL);
                      break;
                    case O9:
                      n.depthFunc(n.EQUAL);
                      break;
                    case L9:
                      n.depthFunc(n.GEQUAL);
                      break;
                    case F9:
                      n.depthFunc(n.GREATER);
                      break;
                    case N9:
                      n.depthFunc(n.NOTEQUAL);
                      break;
                    default:
                      n.depthFunc(n.LEQUAL);
                  }
                  K = Te;
                }
              },
              setLocked: function (Te) {
                N = Te;
              },
              setClear: function (Te) {
                _e !== Te && (n.clearDepth(Te), (_e = Te));
              },
              reset: function () {
                (N = !1), (we = null), (K = null), (_e = null);
              },
            };
          })(),
          c = new (function o() {
            let N = !1,
              we = null,
              K = null,
              _e = null,
              Te = null,
              Nt = null,
              gn = null,
              Jn = null,
              Rs = null;
            return {
              setTest: function (wn) {
                N || (wn ? ve(n.STENCIL_TEST) : xe(n.STENCIL_TEST));
              },
              setMask: function (wn) {
                we !== wn && !N && (n.stencilMask(wn), (we = wn));
              },
              setFunc: function (wn, Ps, Oi) {
                (K !== wn || _e !== Ps || Te !== Oi) &&
                  (n.stencilFunc(wn, Ps, Oi), (K = wn), (_e = Ps), (Te = Oi));
              },
              setOp: function (wn, Ps, Oi) {
                (Nt !== wn || gn !== Ps || Jn !== Oi) &&
                  (n.stencilOp(wn, Ps, Oi), (Nt = wn), (gn = Ps), (Jn = Oi));
              },
              setLocked: function (wn) {
                N = wn;
              },
              setClear: function (wn) {
                Rs !== wn && (n.clearStencil(wn), (Rs = wn));
              },
              reset: function () {
                (N = !1),
                  (we = null),
                  (K = null),
                  (_e = null),
                  (Te = null),
                  (Nt = null),
                  (gn = null),
                  (Jn = null),
                  (Rs = null);
              },
            };
          })(),
          u = new WeakMap(),
          d = new WeakMap();
        let h = {},
          f = {},
          p = new WeakMap(),
          _ = [],
          m = null,
          g = !1,
          y = null,
          v = null,
          b = null,
          x = null,
          M = null,
          S = null,
          C = null,
          w = !1,
          E = null,
          V = null,
          j = null,
          F = null,
          k = null;
        const z = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let O = !1,
          L = 0;
        const U = n.getParameter(n.VERSION);
        -1 !== U.indexOf("WebGL")
          ? ((L = parseFloat(/^WebGL (\d)/.exec(U)[1])), (O = L >= 1))
          : -1 !== U.indexOf("OpenGL ES") &&
            ((L = parseFloat(/^OpenGL ES (\d)/.exec(U)[1])), (O = L >= 2));
        let W = null,
          Z = {};
        const B = n.getParameter(n.SCISSOR_BOX),
          q = n.getParameter(n.VIEWPORT),
          le = new Ft().fromArray(B),
          te = new Ft().fromArray(q);
        function ce(N, we, K, _e) {
          const Te = new Uint8Array(4),
            Nt = n.createTexture();
          n.bindTexture(N, Nt),
            n.texParameteri(N, n.TEXTURE_MIN_FILTER, n.NEAREST),
            n.texParameteri(N, n.TEXTURE_MAG_FILTER, n.NEAREST);
          for (let gn = 0; gn < K; gn++)
            !i || (N !== n.TEXTURE_3D && N !== n.TEXTURE_2D_ARRAY)
              ? n.texImage2D(
                  we + gn,
                  0,
                  n.RGBA,
                  1,
                  1,
                  0,
                  n.RGBA,
                  n.UNSIGNED_BYTE,
                  Te
                )
              : n.texImage3D(
                  we,
                  0,
                  n.RGBA,
                  1,
                  1,
                  _e,
                  0,
                  n.RGBA,
                  n.UNSIGNED_BYTE,
                  Te
                );
          return Nt;
        }
        const Ce = {};
        function ve(N) {
          !0 !== h[N] && (n.enable(N), (h[N] = !0));
        }
        function xe(N) {
          !1 !== h[N] && (n.disable(N), (h[N] = !1));
        }
        (Ce[n.TEXTURE_2D] = ce(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
          (Ce[n.TEXTURE_CUBE_MAP] = ce(
            n.TEXTURE_CUBE_MAP,
            n.TEXTURE_CUBE_MAP_POSITIVE_X,
            6
          )),
          i &&
            ((Ce[n.TEXTURE_2D_ARRAY] = ce(
              n.TEXTURE_2D_ARRAY,
              n.TEXTURE_2D_ARRAY,
              1,
              1
            )),
            (Ce[n.TEXTURE_3D] = ce(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
          a.setClear(0, 0, 0, 1),
          l.setClear(1),
          c.setClear(0),
          ve(n.DEPTH_TEST),
          l.setFunc(ab),
          oe(!1),
          ze(iR),
          ve(n.CULL_FACE),
          ie(Zr);
        const P = {
          [mc]: n.FUNC_ADD,
          [y9]: n.FUNC_SUBTRACT,
          [b9]: n.FUNC_REVERSE_SUBTRACT,
        };
        if (i) (P[aR] = n.MIN), (P[lR] = n.MAX);
        else {
          const N = e.get("EXT_blend_minmax");
          null !== N && ((P[aR] = N.MIN_EXT), (P[lR] = N.MAX_EXT));
        }
        const ge = {
          [x9]: n.ZERO,
          [w9]: n.ONE,
          [M9]: n.SRC_COLOR,
          [cR]: n.SRC_ALPHA,
          [D9]: n.SRC_ALPHA_SATURATE,
          [T9]: n.DST_COLOR,
          [E9]: n.DST_ALPHA,
          [S9]: n.ONE_MINUS_SRC_COLOR,
          [uR]: n.ONE_MINUS_SRC_ALPHA,
          [A9]: n.ONE_MINUS_DST_COLOR,
          [C9]: n.ONE_MINUS_DST_ALPHA,
        };
        function ie(N, we, K, _e, Te, Nt, gn, Jn) {
          if (N !== Zr) {
            if ((!1 === g && (ve(n.BLEND), (g = !0)), N === v9))
              (Te = Te || we),
                (Nt = Nt || K),
                (gn = gn || _e),
                (we !== v || Te !== M) &&
                  (n.blendEquationSeparate(P[we], P[Te]), (v = we), (M = Te)),
                (K !== b || _e !== x || Nt !== S || gn !== C) &&
                  (n.blendFuncSeparate(ge[K], ge[_e], ge[Nt], ge[gn]),
                  (b = K),
                  (x = _e),
                  (S = Nt),
                  (C = gn)),
                (y = N),
                (w = !1);
            else if (N !== y || Jn !== w) {
              if (
                ((v !== mc || M !== mc) &&
                  (n.blendEquation(n.FUNC_ADD), (v = mc), (M = mc)),
                Jn)
              )
                switch (N) {
                  case pc:
                    n.blendFuncSeparate(
                      n.ONE,
                      n.ONE_MINUS_SRC_ALPHA,
                      n.ONE,
                      n.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case ob:
                    n.blendFunc(n.ONE, n.ONE);
                    break;
                  case sR:
                    n.blendFuncSeparate(
                      n.ZERO,
                      n.ONE_MINUS_SRC_COLOR,
                      n.ZERO,
                      n.ONE
                    );
                    break;
                  case oR:
                    n.blendFuncSeparate(
                      n.ZERO,
                      n.SRC_COLOR,
                      n.ZERO,
                      n.SRC_ALPHA
                    );
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", N);
                }
              else
                switch (N) {
                  case pc:
                    n.blendFuncSeparate(
                      n.SRC_ALPHA,
                      n.ONE_MINUS_SRC_ALPHA,
                      n.ONE,
                      n.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case ob:
                    n.blendFunc(n.SRC_ALPHA, n.ONE);
                    break;
                  case sR:
                    n.blendFuncSeparate(
                      n.ZERO,
                      n.ONE_MINUS_SRC_COLOR,
                      n.ZERO,
                      n.ONE
                    );
                    break;
                  case oR:
                    n.blendFunc(n.ZERO, n.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", N);
                }
              (b = null), (x = null), (S = null), (C = null), (y = N), (w = Jn);
            }
          } else !0 === g && (xe(n.BLEND), (g = !1));
        }
        function oe(N) {
          E !== N && (n.frontFace(N ? n.CW : n.CCW), (E = N));
        }
        function ze(N) {
          N !== m9
            ? (ve(n.CULL_FACE),
              N !== V &&
                n.cullFace(
                  N === iR ? n.BACK : N === g9 ? n.FRONT : n.FRONT_AND_BACK
                ))
            : xe(n.CULL_FACE),
            (V = N);
        }
        function Oe(N, we, K) {
          N
            ? (ve(n.POLYGON_OFFSET_FILL),
              (F !== we || k !== K) &&
                (n.polygonOffset(we, K), (F = we), (k = K)))
            : xe(n.POLYGON_OFFSET_FILL);
        }
        return {
          buffers: { color: a, depth: l, stencil: c },
          enable: ve,
          disable: xe,
          bindFramebuffer: function Ze(N, we) {
            return (
              f[N] !== we &&
              (n.bindFramebuffer(N, we),
              (f[N] = we),
              i &&
                (N === n.DRAW_FRAMEBUFFER && (f[n.FRAMEBUFFER] = we),
                N === n.FRAMEBUFFER && (f[n.DRAW_FRAMEBUFFER] = we)),
              !0)
            );
          },
          drawBuffers: function dt(N, we) {
            let K = _,
              _e = !1;
            if (N)
              if (
                ((K = p.get(we)),
                void 0 === K && ((K = []), p.set(we, K)),
                N.isWebGLMultipleRenderTargets)
              ) {
                const Te = N.texture;
                if (K.length !== Te.length || K[0] !== n.COLOR_ATTACHMENT0) {
                  for (let Nt = 0, gn = Te.length; Nt < gn; Nt++)
                    K[Nt] = n.COLOR_ATTACHMENT0 + Nt;
                  (K.length = Te.length), (_e = !0);
                }
              } else
                K[0] !== n.COLOR_ATTACHMENT0 &&
                  ((K[0] = n.COLOR_ATTACHMENT0), (_e = !0));
            else K[0] !== n.BACK && ((K[0] = n.BACK), (_e = !0));
            _e &&
              (t.isWebGL2
                ? n.drawBuffers(K)
                : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(K));
          },
          useProgram: function Ue(N) {
            return m !== N && (n.useProgram(N), (m = N), !0);
          },
          setBlending: ie,
          setMaterial: function pe(N, we) {
            N.side === Cr ? xe(n.CULL_FACE) : ve(n.CULL_FACE);
            let K = N.side === zi;
            we && (K = !K),
              oe(K),
              N.blending === pc && !1 === N.transparent
                ? ie(Zr)
                : ie(
                    N.blending,
                    N.blendEquation,
                    N.blendSrc,
                    N.blendDst,
                    N.blendEquationAlpha,
                    N.blendSrcAlpha,
                    N.blendDstAlpha,
                    N.premultipliedAlpha
                  ),
              l.setFunc(N.depthFunc),
              l.setTest(N.depthTest),
              l.setMask(N.depthWrite),
              a.setMask(N.colorWrite);
            const _e = N.stencilWrite;
            c.setTest(_e),
              _e &&
                (c.setMask(N.stencilWriteMask),
                c.setFunc(N.stencilFunc, N.stencilRef, N.stencilFuncMask),
                c.setOp(N.stencilFail, N.stencilZFail, N.stencilZPass)),
              Oe(N.polygonOffset, N.polygonOffsetFactor, N.polygonOffsetUnits),
              !0 === N.alphaToCoverage
                ? ve(n.SAMPLE_ALPHA_TO_COVERAGE)
                : xe(n.SAMPLE_ALPHA_TO_COVERAGE);
          },
          setFlipSided: oe,
          setCullFace: ze,
          setLineWidth: function Pe(N) {
            N !== j && (O && n.lineWidth(N), (j = N));
          },
          setPolygonOffset: Oe,
          setScissorTest: function et(N) {
            N ? ve(n.SCISSOR_TEST) : xe(n.SCISSOR_TEST);
          },
          activeTexture: function Tt(N) {
            void 0 === N && (N = n.TEXTURE0 + z - 1),
              W !== N && (n.activeTexture(N), (W = N));
          },
          bindTexture: function an(N, we, K) {
            void 0 === K && (K = null === W ? n.TEXTURE0 + z - 1 : W);
            let _e = Z[K];
            void 0 === _e &&
              ((_e = { type: void 0, texture: void 0 }), (Z[K] = _e)),
              (_e.type !== N || _e.texture !== we) &&
                (W !== K && (n.activeTexture(K), (W = K)),
                n.bindTexture(N, we || Ce[N]),
                (_e.type = N),
                (_e.texture = we));
          },
          unbindTexture: function I() {
            const N = Z[W];
            void 0 !== N &&
              void 0 !== N.type &&
              (n.bindTexture(N.type, null),
              (N.type = void 0),
              (N.texture = void 0));
          },
          compressedTexImage2D: function T() {
            try {
              n.compressedTexImage2D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          compressedTexImage3D: function Q() {
            try {
              n.compressedTexImage3D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          texImage2D: function ke() {
            try {
              n.texImage2D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          texImage3D: function We() {
            try {
              n.texImage3D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          updateUBOMapping: function Fe(N, we) {
            let K = d.get(we);
            void 0 === K && ((K = new WeakMap()), d.set(we, K));
            let _e = K.get(N);
            void 0 === _e &&
              ((_e = n.getUniformBlockIndex(we, N.name)), K.set(N, _e));
          },
          uniformBlockBinding: function tt(N, we) {
            const _e = d.get(we).get(N);
            u.get(we) !== _e &&
              (n.uniformBlockBinding(we, _e, N.__bindingPointIndex),
              u.set(we, _e));
          },
          texStorage2D: function ue() {
            try {
              n.texStorage2D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          texStorage3D: function Y() {
            try {
              n.texStorage3D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          texSubImage2D: function fe() {
            try {
              n.texSubImage2D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          texSubImage3D: function he() {
            try {
              n.texSubImage3D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          compressedTexSubImage2D: function R() {
            try {
              n.compressedTexSubImage2D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          compressedTexSubImage3D: function ae() {
            try {
              n.compressedTexSubImage3D.apply(n, arguments);
            } catch (N) {
              console.error("THREE.WebGLState:", N);
            }
          },
          scissor: function Ve(N) {
            !1 === le.equals(N) && (n.scissor(N.x, N.y, N.z, N.w), le.copy(N));
          },
          viewport: function Be(N) {
            !1 === te.equals(N) && (n.viewport(N.x, N.y, N.z, N.w), te.copy(N));
          },
          reset: function Dt() {
            n.disable(n.BLEND),
              n.disable(n.CULL_FACE),
              n.disable(n.DEPTH_TEST),
              n.disable(n.POLYGON_OFFSET_FILL),
              n.disable(n.SCISSOR_TEST),
              n.disable(n.STENCIL_TEST),
              n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
              n.blendEquation(n.FUNC_ADD),
              n.blendFunc(n.ONE, n.ZERO),
              n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
              n.colorMask(!0, !0, !0, !0),
              n.clearColor(0, 0, 0, 0),
              n.depthMask(!0),
              n.depthFunc(n.LESS),
              n.clearDepth(1),
              n.stencilMask(4294967295),
              n.stencilFunc(n.ALWAYS, 0, 4294967295),
              n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
              n.clearStencil(0),
              n.cullFace(n.BACK),
              n.frontFace(n.CCW),
              n.polygonOffset(0, 0),
              n.activeTexture(n.TEXTURE0),
              n.bindFramebuffer(n.FRAMEBUFFER, null),
              !0 === i &&
                (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
              n.useProgram(null),
              n.lineWidth(1),
              n.scissor(0, 0, n.canvas.width, n.canvas.height),
              n.viewport(0, 0, n.canvas.width, n.canvas.height),
              (h = {}),
              (W = null),
              (Z = {}),
              (f = {}),
              (p = new WeakMap()),
              (_ = []),
              (m = null),
              (g = !1),
              (y = null),
              (v = null),
              (b = null),
              (x = null),
              (M = null),
              (S = null),
              (C = null),
              (w = !1),
              (E = null),
              (V = null),
              (j = null),
              (F = null),
              (k = null),
              le.set(0, 0, n.canvas.width, n.canvas.height),
              te.set(0, 0, n.canvas.width, n.canvas.height),
              a.reset(),
              l.reset(),
              c.reset();
          },
        };
      }
      function BZ(n, e, t, i, r, s, o) {
        const a = r.isWebGL2,
          l = r.maxTextures,
          c = r.maxCubemapSize,
          u = r.maxTextureSize,
          d = r.maxSamples,
          h = e.has("WEBGL_multisampled_render_to_texture")
            ? e.get("WEBGL_multisampled_render_to_texture")
            : null,
          f =
            !(typeof navigator > "u") &&
            /OculusBrowser/g.test(navigator.userAgent),
          p = new WeakMap();
        let _;
        const m = new WeakMap();
        let g = !1;
        try {
          g =
            typeof OffscreenCanvas < "u" &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch {}
        function y(I, T) {
          return g ? new OffscreenCanvas(I, T) : Yd("canvas");
        }
        function v(I, T, Q, fe) {
          let he = 1;
          if (
            ((I.width > fe || I.height > fe) &&
              (he = fe / Math.max(I.width, I.height)),
            he < 1 || !0 === T)
          ) {
            if (
              (typeof HTMLImageElement < "u" &&
                I instanceof HTMLImageElement) ||
              (typeof HTMLCanvasElement < "u" &&
                I instanceof HTMLCanvasElement) ||
              (typeof ImageBitmap < "u" && I instanceof ImageBitmap)
            ) {
              const R = T ? um : Math.floor,
                ae = R(he * I.width),
                ue = R(he * I.height);
              void 0 === _ && (_ = y(ae, ue));
              const Y = Q ? y(ae, ue) : _;
              return (
                (Y.width = ae),
                (Y.height = ue),
                Y.getContext("2d").drawImage(I, 0, 0, ae, ue),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    I.width +
                    "x" +
                    I.height +
                    ") to (" +
                    ae +
                    "x" +
                    ue +
                    ")."
                ),
                Y
              );
            }
            return (
              "data" in I &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    I.width +
                    "x" +
                    I.height +
                    ")."
                ),
              I
            );
          }
          return I;
        }
        function b(I) {
          return wb(I.width) && wb(I.height);
        }
        function M(I, T) {
          return (
            I.generateMipmaps && T && I.minFilter !== hn && I.minFilter !== fn
          );
        }
        function S(I) {
          n.generateMipmap(I);
        }
        function C(I, T, Q, fe, he = !1) {
          if (!1 === a) return T;
          if (null !== I) {
            if (void 0 !== n[I]) return n[I];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                I +
                "'"
            );
          }
          let R = T;
          return (
            T === n.RED &&
              (Q === n.FLOAT && (R = n.R32F),
              Q === n.HALF_FLOAT && (R = n.R16F),
              Q === n.UNSIGNED_BYTE && (R = n.R8)),
            T === n.RG &&
              (Q === n.FLOAT && (R = n.RG32F),
              Q === n.HALF_FLOAT && (R = n.RG16F),
              Q === n.UNSIGNED_BYTE && (R = n.RG8)),
            T === n.RGBA &&
              (Q === n.FLOAT && (R = n.RGBA32F),
              Q === n.HALF_FLOAT && (R = n.RGBA16F),
              Q === n.UNSIGNED_BYTE &&
                (R = fe === qe && !1 === he ? n.SRGB8_ALPHA8 : n.RGBA8),
              Q === n.UNSIGNED_SHORT_4_4_4_4 && (R = n.RGBA4),
              Q === n.UNSIGNED_SHORT_5_5_5_1 && (R = n.RGB5_A1)),
            (R === n.R16F ||
              R === n.R32F ||
              R === n.RG16F ||
              R === n.RG32F ||
              R === n.RGBA16F ||
              R === n.RGBA32F) &&
              e.get("EXT_color_buffer_float"),
            R
          );
        }
        function w(I, T, Q) {
          return !0 === M(I, Q) ||
            (I.isFramebufferTexture && I.minFilter !== hn && I.minFilter !== fn)
            ? Math.log2(Math.max(T.width, T.height)) + 1
            : void 0 !== I.mipmaps && I.mipmaps.length > 0
            ? I.mipmaps.length
            : I.isCompressedTexture && Array.isArray(I.image)
            ? T.mipmaps.length
            : 1;
        }
        function E(I) {
          return I === hn || I === om || I === jd ? n.NEAREST : n.LINEAR;
        }
        function V(I) {
          const T = I.target;
          T.removeEventListener("dispose", V),
            (function F(I) {
              const T = i.get(I);
              if (void 0 === T.__webglInit) return;
              const Q = I.source,
                fe = m.get(Q);
              if (fe) {
                const he = fe[T.__cacheKey];
                he.usedTimes--,
                  0 === he.usedTimes && k(I),
                  0 === Object.keys(fe).length && m.delete(Q);
              }
              i.remove(I);
            })(T),
            T.isVideoTexture && p.delete(T);
        }
        function j(I) {
          const T = I.target;
          T.removeEventListener("dispose", j),
            (function z(I) {
              const T = I.texture,
                Q = i.get(I),
                fe = i.get(T);
              if (
                (void 0 !== fe.__webglTexture &&
                  (n.deleteTexture(fe.__webglTexture), o.memory.textures--),
                I.depthTexture && I.depthTexture.dispose(),
                I.isWebGLCubeRenderTarget)
              )
                for (let he = 0; he < 6; he++)
                  n.deleteFramebuffer(Q.__webglFramebuffer[he]),
                    Q.__webglDepthbuffer &&
                      n.deleteRenderbuffer(Q.__webglDepthbuffer[he]);
              else {
                if (
                  (n.deleteFramebuffer(Q.__webglFramebuffer),
                  Q.__webglDepthbuffer &&
                    n.deleteRenderbuffer(Q.__webglDepthbuffer),
                  Q.__webglMultisampledFramebuffer &&
                    n.deleteFramebuffer(Q.__webglMultisampledFramebuffer),
                  Q.__webglColorRenderbuffer)
                )
                  for (let he = 0; he < Q.__webglColorRenderbuffer.length; he++)
                    Q.__webglColorRenderbuffer[he] &&
                      n.deleteRenderbuffer(Q.__webglColorRenderbuffer[he]);
                Q.__webglDepthRenderbuffer &&
                  n.deleteRenderbuffer(Q.__webglDepthRenderbuffer);
              }
              if (I.isWebGLMultipleRenderTargets)
                for (let he = 0, R = T.length; he < R; he++) {
                  const ae = i.get(T[he]);
                  ae.__webglTexture &&
                    (n.deleteTexture(ae.__webglTexture), o.memory.textures--),
                    i.remove(T[he]);
                }
              i.remove(T), i.remove(I);
            })(T);
        }
        function k(I) {
          const T = i.get(I);
          n.deleteTexture(T.__webglTexture),
            delete m.get(I.source)[T.__cacheKey],
            o.memory.textures--;
        }
        let O = 0;
        function Z(I, T) {
          const Q = i.get(I);
          if (
            (I.isVideoTexture &&
              (function Tt(I) {
                const T = o.render.frame;
                p.get(I) !== T && (p.set(I, T), I.update());
              })(I),
            !1 === I.isRenderTargetTexture &&
              I.version > 0 &&
              Q.__version !== I.version)
          ) {
            const fe = I.image;
            if (null === fe)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else {
              if (!1 !== fe.complete) return void Ze(Q, I, T);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          t.bindTexture(n.TEXTURE_2D, Q.__webglTexture, n.TEXTURE0 + T);
        }
        const te = {
            [Js]: n.REPEAT,
            [Yn]: n.CLAMP_TO_EDGE,
            [Wd]: n.MIRRORED_REPEAT,
          },
          ce = {
            [hn]: n.NEAREST,
            [om]: n.NEAREST_MIPMAP_NEAREST,
            [jd]: n.NEAREST_MIPMAP_LINEAR,
            [fn]: n.LINEAR,
            [cb]: n.LINEAR_MIPMAP_NEAREST,
            [eo]: n.LINEAR_MIPMAP_LINEAR,
          },
          Ce = {
            [iX]: n.NEVER,
            [uX]: n.ALWAYS,
            [rX]: n.LESS,
            [oX]: n.LEQUAL,
            [sX]: n.EQUAL,
            [cX]: n.GEQUAL,
            [aX]: n.GREATER,
            [lX]: n.NOTEQUAL,
          };
        function ve(I, T, Q) {
          if (
            (Q
              ? (n.texParameteri(I, n.TEXTURE_WRAP_S, te[T.wrapS]),
                n.texParameteri(I, n.TEXTURE_WRAP_T, te[T.wrapT]),
                (I === n.TEXTURE_3D || I === n.TEXTURE_2D_ARRAY) &&
                  n.texParameteri(I, n.TEXTURE_WRAP_R, te[T.wrapR]),
                n.texParameteri(I, n.TEXTURE_MAG_FILTER, ce[T.magFilter]),
                n.texParameteri(I, n.TEXTURE_MIN_FILTER, ce[T.minFilter]))
              : (n.texParameteri(I, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
                n.texParameteri(I, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
                (I === n.TEXTURE_3D || I === n.TEXTURE_2D_ARRAY) &&
                  n.texParameteri(I, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
                (T.wrapS !== Yn || T.wrapT !== Yn) &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                n.texParameteri(I, n.TEXTURE_MAG_FILTER, E(T.magFilter)),
                n.texParameteri(I, n.TEXTURE_MIN_FILTER, E(T.minFilter)),
                T.minFilter !== hn &&
                  T.minFilter !== fn &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            T.compareFunction &&
              (n.texParameteri(
                I,
                n.TEXTURE_COMPARE_MODE,
                n.COMPARE_REF_TO_TEXTURE
              ),
              n.texParameteri(
                I,
                n.TEXTURE_COMPARE_FUNC,
                Ce[T.compareFunction]
              )),
            !0 === e.has("EXT_texture_filter_anisotropic"))
          ) {
            const fe = e.get("EXT_texture_filter_anisotropic");
            if (
              T.magFilter === hn ||
              (T.minFilter !== jd && T.minFilter !== eo) ||
              (T.type === to && !1 === e.has("OES_texture_float_linear")) ||
              (!1 === a &&
                T.type === Hi &&
                !1 === e.has("OES_texture_half_float_linear"))
            )
              return;
            (T.anisotropy > 1 || i.get(T).__currentAnisotropy) &&
              (n.texParameterf(
                I,
                fe.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(T.anisotropy, r.getMaxAnisotropy())
              ),
              (i.get(T).__currentAnisotropy = T.anisotropy));
          }
        }
        function xe(I, T) {
          let Q = !1;
          void 0 === I.__webglInit &&
            ((I.__webglInit = !0), T.addEventListener("dispose", V));
          const fe = T.source;
          let he = m.get(fe);
          void 0 === he && ((he = {}), m.set(fe, he));
          const R = (function W(I) {
            const T = [];
            return (
              T.push(I.wrapS),
              T.push(I.wrapT),
              T.push(I.wrapR || 0),
              T.push(I.magFilter),
              T.push(I.minFilter),
              T.push(I.anisotropy),
              T.push(I.internalFormat),
              T.push(I.format),
              T.push(I.type),
              T.push(I.generateMipmaps),
              T.push(I.premultiplyAlpha),
              T.push(I.flipY),
              T.push(I.unpackAlignment),
              T.push(I.colorSpace),
              T.join()
            );
          })(T);
          if (R !== I.__cacheKey) {
            void 0 === he[R] &&
              ((he[R] = { texture: n.createTexture(), usedTimes: 0 }),
              o.memory.textures++,
              (Q = !0)),
              he[R].usedTimes++;
            const ae = he[I.__cacheKey];
            void 0 !== ae &&
              (he[I.__cacheKey].usedTimes--, 0 === ae.usedTimes && k(T)),
              (I.__cacheKey = R),
              (I.__webglTexture = he[R].texture);
          }
          return Q;
        }
        function Ze(I, T, Q) {
          let fe = n.TEXTURE_2D;
          (T.isDataArrayTexture || T.isCompressedArrayTexture) &&
            (fe = n.TEXTURE_2D_ARRAY),
            T.isData3DTexture && (fe = n.TEXTURE_3D);
          const he = xe(I, T),
            R = T.source;
          t.bindTexture(fe, I.__webglTexture, n.TEXTURE0 + Q);
          const ae = i.get(R);
          if (R.version !== ae.__version || !0 === he) {
            t.activeTexture(n.TEXTURE0 + Q),
              n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, T.flipY),
              n.pixelStorei(
                n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                T.premultiplyAlpha
              ),
              n.pixelStorei(n.UNPACK_ALIGNMENT, T.unpackAlignment),
              n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
            const ue =
              (function x(I) {
                return (
                  !a &&
                  (I.wrapS !== Yn ||
                    I.wrapT !== Yn ||
                    (I.minFilter !== hn && I.minFilter !== fn))
                );
              })(T) && !1 === b(T.image);
            let Y = v(T.image, ue, !1, u);
            Y = an(T, Y);
            const ke = b(Y) || a,
              We = s.convert(T.format, T.colorSpace);
            let Fe,
              Ve = s.convert(T.type),
              Be = C(T.internalFormat, We, Ve, T.colorSpace);
            ve(fe, T, ke);
            const tt = T.mipmaps,
              Dt = a && !0 !== T.isVideoTexture,
              N = void 0 === ae.__version || !0 === he,
              we = w(T, Y, ke);
            if (T.isDepthTexture)
              (Be = n.DEPTH_COMPONENT),
                a
                  ? (Be =
                      T.type === to
                        ? n.DEPTH_COMPONENT32F
                        : T.type === Lo
                        ? n.DEPTH_COMPONENT24
                        : T.type === Ta
                        ? n.DEPTH24_STENCIL8
                        : n.DEPTH_COMPONENT16)
                  : T.type === to &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                T.format === Aa &&
                  Be === n.DEPTH_COMPONENT &&
                  T.type !== ub &&
                  T.type !== Lo &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (T.type = Lo),
                  (Ve = s.convert(T.type))),
                T.format === gc &&
                  Be === n.DEPTH_COMPONENT &&
                  ((Be = n.DEPTH_STENCIL),
                  T.type !== Ta &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (T.type = Ta),
                    (Ve = s.convert(T.type)))),
                N &&
                  (Dt
                    ? t.texStorage2D(n.TEXTURE_2D, 1, Be, Y.width, Y.height)
                    : t.texImage2D(
                        n.TEXTURE_2D,
                        0,
                        Be,
                        Y.width,
                        Y.height,
                        0,
                        We,
                        Ve,
                        null
                      ));
            else if (T.isDataTexture)
              if (tt.length > 0 && ke) {
                Dt &&
                  N &&
                  t.texStorage2D(
                    n.TEXTURE_2D,
                    we,
                    Be,
                    tt[0].width,
                    tt[0].height
                  );
                for (let K = 0, _e = tt.length; K < _e; K++)
                  (Fe = tt[K]),
                    Dt
                      ? t.texSubImage2D(
                          n.TEXTURE_2D,
                          K,
                          0,
                          0,
                          Fe.width,
                          Fe.height,
                          We,
                          Ve,
                          Fe.data
                        )
                      : t.texImage2D(
                          n.TEXTURE_2D,
                          K,
                          Be,
                          Fe.width,
                          Fe.height,
                          0,
                          We,
                          Ve,
                          Fe.data
                        );
                T.generateMipmaps = !1;
              } else
                Dt
                  ? (N &&
                      t.texStorage2D(n.TEXTURE_2D, we, Be, Y.width, Y.height),
                    t.texSubImage2D(
                      n.TEXTURE_2D,
                      0,
                      0,
                      0,
                      Y.width,
                      Y.height,
                      We,
                      Ve,
                      Y.data
                    ))
                  : t.texImage2D(
                      n.TEXTURE_2D,
                      0,
                      Be,
                      Y.width,
                      Y.height,
                      0,
                      We,
                      Ve,
                      Y.data
                    );
            else if (T.isCompressedTexture)
              if (T.isCompressedArrayTexture) {
                Dt &&
                  N &&
                  t.texStorage3D(
                    n.TEXTURE_2D_ARRAY,
                    we,
                    Be,
                    tt[0].width,
                    tt[0].height,
                    Y.depth
                  );
                for (let K = 0, _e = tt.length; K < _e; K++)
                  (Fe = tt[K]),
                    T.format !== Tr
                      ? null !== We
                        ? Dt
                          ? t.compressedTexSubImage3D(
                              n.TEXTURE_2D_ARRAY,
                              K,
                              0,
                              0,
                              0,
                              Fe.width,
                              Fe.height,
                              Y.depth,
                              We,
                              Fe.data,
                              0,
                              0
                            )
                          : t.compressedTexImage3D(
                              n.TEXTURE_2D_ARRAY,
                              K,
                              Be,
                              Fe.width,
                              Fe.height,
                              Y.depth,
                              0,
                              Fe.data,
                              0,
                              0
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : Dt
                      ? t.texSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          K,
                          0,
                          0,
                          0,
                          Fe.width,
                          Fe.height,
                          Y.depth,
                          We,
                          Ve,
                          Fe.data
                        )
                      : t.texImage3D(
                          n.TEXTURE_2D_ARRAY,
                          K,
                          Be,
                          Fe.width,
                          Fe.height,
                          Y.depth,
                          0,
                          We,
                          Ve,
                          Fe.data
                        );
              } else {
                Dt &&
                  N &&
                  t.texStorage2D(
                    n.TEXTURE_2D,
                    we,
                    Be,
                    tt[0].width,
                    tt[0].height
                  );
                for (let K = 0, _e = tt.length; K < _e; K++)
                  (Fe = tt[K]),
                    T.format !== Tr
                      ? null !== We
                        ? Dt
                          ? t.compressedTexSubImage2D(
                              n.TEXTURE_2D,
                              K,
                              0,
                              0,
                              Fe.width,
                              Fe.height,
                              We,
                              Fe.data
                            )
                          : t.compressedTexImage2D(
                              n.TEXTURE_2D,
                              K,
                              Be,
                              Fe.width,
                              Fe.height,
                              0,
                              Fe.data
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : Dt
                      ? t.texSubImage2D(
                          n.TEXTURE_2D,
                          K,
                          0,
                          0,
                          Fe.width,
                          Fe.height,
                          We,
                          Ve,
                          Fe.data
                        )
                      : t.texImage2D(
                          n.TEXTURE_2D,
                          K,
                          Be,
                          Fe.width,
                          Fe.height,
                          0,
                          We,
                          Ve,
                          Fe.data
                        );
              }
            else if (T.isDataArrayTexture)
              Dt
                ? (N &&
                    t.texStorage3D(
                      n.TEXTURE_2D_ARRAY,
                      we,
                      Be,
                      Y.width,
                      Y.height,
                      Y.depth
                    ),
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    0,
                    0,
                    0,
                    0,
                    Y.width,
                    Y.height,
                    Y.depth,
                    We,
                    Ve,
                    Y.data
                  ))
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    0,
                    Be,
                    Y.width,
                    Y.height,
                    Y.depth,
                    0,
                    We,
                    Ve,
                    Y.data
                  );
            else if (T.isData3DTexture)
              Dt
                ? (N &&
                    t.texStorage3D(
                      n.TEXTURE_3D,
                      we,
                      Be,
                      Y.width,
                      Y.height,
                      Y.depth
                    ),
                  t.texSubImage3D(
                    n.TEXTURE_3D,
                    0,
                    0,
                    0,
                    0,
                    Y.width,
                    Y.height,
                    Y.depth,
                    We,
                    Ve,
                    Y.data
                  ))
                : t.texImage3D(
                    n.TEXTURE_3D,
                    0,
                    Be,
                    Y.width,
                    Y.height,
                    Y.depth,
                    0,
                    We,
                    Ve,
                    Y.data
                  );
            else if (T.isFramebufferTexture) {
              if (N)
                if (Dt) t.texStorage2D(n.TEXTURE_2D, we, Be, Y.width, Y.height);
                else {
                  let K = Y.width,
                    _e = Y.height;
                  for (let Te = 0; Te < we; Te++)
                    t.texImage2D(n.TEXTURE_2D, Te, Be, K, _e, 0, We, Ve, null),
                      (K >>= 1),
                      (_e >>= 1);
                }
            } else if (tt.length > 0 && ke) {
              Dt &&
                N &&
                t.texStorage2D(n.TEXTURE_2D, we, Be, tt[0].width, tt[0].height);
              for (let K = 0, _e = tt.length; K < _e; K++)
                (Fe = tt[K]),
                  Dt
                    ? t.texSubImage2D(n.TEXTURE_2D, K, 0, 0, We, Ve, Fe)
                    : t.texImage2D(n.TEXTURE_2D, K, Be, We, Ve, Fe);
              T.generateMipmaps = !1;
            } else
              Dt
                ? (N && t.texStorage2D(n.TEXTURE_2D, we, Be, Y.width, Y.height),
                  t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, We, Ve, Y))
                : t.texImage2D(n.TEXTURE_2D, 0, Be, We, Ve, Y);
            M(T, ke) && S(fe),
              (ae.__version = R.version),
              T.onUpdate && T.onUpdate(T);
          }
          I.__version = T.version;
        }
        function Ue(I, T, Q, fe, he) {
          const R = s.convert(Q.format, Q.colorSpace),
            ae = s.convert(Q.type),
            ue = C(Q.internalFormat, R, ae, Q.colorSpace);
          i.get(T).__hasExternalTextures ||
            (he === n.TEXTURE_3D || he === n.TEXTURE_2D_ARRAY
              ? t.texImage3D(
                  he,
                  0,
                  ue,
                  T.width,
                  T.height,
                  T.depth,
                  0,
                  R,
                  ae,
                  null
                )
              : t.texImage2D(he, 0, ue, T.width, T.height, 0, R, ae, null)),
            t.bindFramebuffer(n.FRAMEBUFFER, I),
            et(T)
              ? h.framebufferTexture2DMultisampleEXT(
                  n.FRAMEBUFFER,
                  fe,
                  he,
                  i.get(Q).__webglTexture,
                  0,
                  Oe(T)
                )
              : (he === n.TEXTURE_2D ||
                  (he >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
                    he <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                n.framebufferTexture2D(
                  n.FRAMEBUFFER,
                  fe,
                  he,
                  i.get(Q).__webglTexture,
                  0
                ),
            t.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function P(I, T, Q) {
          if (
            (n.bindRenderbuffer(n.RENDERBUFFER, I),
            T.depthBuffer && !T.stencilBuffer)
          ) {
            let fe = n.DEPTH_COMPONENT16;
            if (Q || et(T)) {
              const he = T.depthTexture;
              he &&
                he.isDepthTexture &&
                (he.type === to
                  ? (fe = n.DEPTH_COMPONENT32F)
                  : he.type === Lo && (fe = n.DEPTH_COMPONENT24));
              const R = Oe(T);
              et(T)
                ? h.renderbufferStorageMultisampleEXT(
                    n.RENDERBUFFER,
                    R,
                    fe,
                    T.width,
                    T.height
                  )
                : n.renderbufferStorageMultisample(
                    n.RENDERBUFFER,
                    R,
                    fe,
                    T.width,
                    T.height
                  );
            } else n.renderbufferStorage(n.RENDERBUFFER, fe, T.width, T.height);
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.DEPTH_ATTACHMENT,
              n.RENDERBUFFER,
              I
            );
          } else if (T.depthBuffer && T.stencilBuffer) {
            const fe = Oe(T);
            Q && !1 === et(T)
              ? n.renderbufferStorageMultisample(
                  n.RENDERBUFFER,
                  fe,
                  n.DEPTH24_STENCIL8,
                  T.width,
                  T.height
                )
              : et(T)
              ? h.renderbufferStorageMultisampleEXT(
                  n.RENDERBUFFER,
                  fe,
                  n.DEPTH24_STENCIL8,
                  T.width,
                  T.height
                )
              : n.renderbufferStorage(
                  n.RENDERBUFFER,
                  n.DEPTH_STENCIL,
                  T.width,
                  T.height
                ),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.DEPTH_STENCIL_ATTACHMENT,
                n.RENDERBUFFER,
                I
              );
          } else {
            const fe =
              !0 === T.isWebGLMultipleRenderTargets ? T.texture : [T.texture];
            for (let he = 0; he < fe.length; he++) {
              const R = fe[he],
                ae = s.convert(R.format, R.colorSpace),
                ue = s.convert(R.type),
                Y = C(R.internalFormat, ae, ue, R.colorSpace),
                ke = Oe(T);
              Q && !1 === et(T)
                ? n.renderbufferStorageMultisample(
                    n.RENDERBUFFER,
                    ke,
                    Y,
                    T.width,
                    T.height
                  )
                : et(T)
                ? h.renderbufferStorageMultisampleEXT(
                    n.RENDERBUFFER,
                    ke,
                    Y,
                    T.width,
                    T.height
                  )
                : n.renderbufferStorage(n.RENDERBUFFER, Y, T.width, T.height);
            }
          }
          n.bindRenderbuffer(n.RENDERBUFFER, null);
        }
        function ie(I) {
          const T = i.get(I),
            Q = !0 === I.isWebGLCubeRenderTarget;
          if (I.depthTexture && !T.__autoAllocateDepthBuffer) {
            if (Q)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            !(function ge(I, T) {
              if (T && T.isWebGLCubeRenderTarget)
                throw new Error(
                  "Depth Texture with cube render targets is not supported"
                );
              if (
                (t.bindFramebuffer(n.FRAMEBUFFER, I),
                !T.depthTexture || !T.depthTexture.isDepthTexture)
              )
                throw new Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                );
              (!i.get(T.depthTexture).__webglTexture ||
                T.depthTexture.image.width !== T.width ||
                T.depthTexture.image.height !== T.height) &&
                ((T.depthTexture.image.width = T.width),
                (T.depthTexture.image.height = T.height),
                (T.depthTexture.needsUpdate = !0)),
                Z(T.depthTexture, 0);
              const fe = i.get(T.depthTexture).__webglTexture,
                he = Oe(T);
              if (T.depthTexture.format === Aa)
                et(T)
                  ? h.framebufferTexture2DMultisampleEXT(
                      n.FRAMEBUFFER,
                      n.DEPTH_ATTACHMENT,
                      n.TEXTURE_2D,
                      fe,
                      0,
                      he
                    )
                  : n.framebufferTexture2D(
                      n.FRAMEBUFFER,
                      n.DEPTH_ATTACHMENT,
                      n.TEXTURE_2D,
                      fe,
                      0
                    );
              else {
                if (T.depthTexture.format !== gc)
                  throw new Error("Unknown depthTexture format");
                et(T)
                  ? h.framebufferTexture2DMultisampleEXT(
                      n.FRAMEBUFFER,
                      n.DEPTH_STENCIL_ATTACHMENT,
                      n.TEXTURE_2D,
                      fe,
                      0,
                      he
                    )
                  : n.framebufferTexture2D(
                      n.FRAMEBUFFER,
                      n.DEPTH_STENCIL_ATTACHMENT,
                      n.TEXTURE_2D,
                      fe,
                      0
                    );
              }
            })(T.__webglFramebuffer, I);
          } else if (Q) {
            T.__webglDepthbuffer = [];
            for (let fe = 0; fe < 6; fe++)
              t.bindFramebuffer(n.FRAMEBUFFER, T.__webglFramebuffer[fe]),
                (T.__webglDepthbuffer[fe] = n.createRenderbuffer()),
                P(T.__webglDepthbuffer[fe], I, !1);
          } else
            t.bindFramebuffer(n.FRAMEBUFFER, T.__webglFramebuffer),
              (T.__webglDepthbuffer = n.createRenderbuffer()),
              P(T.__webglDepthbuffer, I, !1);
          t.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function Oe(I) {
          return Math.min(d, I.samples);
        }
        function et(I) {
          const T = i.get(I);
          return (
            a &&
            I.samples > 0 &&
            !0 === e.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== T.__useRenderToTexture
          );
        }
        function an(I, T) {
          const Q = I.colorSpace,
            fe = I.format,
            he = I.type;
          return (
            !0 === I.isCompressedTexture ||
              I.format === bb ||
              (Q !== Kr &&
                Q !== Ia &&
                (Q === qe
                  ? !1 === a
                    ? !0 === e.has("EXT_sRGB") && fe === Tr
                      ? ((I.format = bb),
                        (I.minFilter = fn),
                        (I.generateMipmaps = !1))
                      : (T = JR.sRGBToLinear(T))
                    : (fe !== Tr || he !== Oo) &&
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture color space:",
                      Q
                    ))),
            T
          );
        }
        (this.allocateTextureUnit = function U() {
          const I = O;
          return (
            I >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  I +
                  " texture units while this GPU supports only " +
                  l
              ),
            (O += 1),
            I
          );
        }),
          (this.resetTextureUnits = function L() {
            O = 0;
          }),
          (this.setTexture2D = Z),
          (this.setTexture2DArray = function B(I, T) {
            const Q = i.get(I);
            I.version > 0 && Q.__version !== I.version
              ? Ze(Q, I, T)
              : t.bindTexture(
                  n.TEXTURE_2D_ARRAY,
                  Q.__webglTexture,
                  n.TEXTURE0 + T
                );
          }),
          (this.setTexture3D = function q(I, T) {
            const Q = i.get(I);
            I.version > 0 && Q.__version !== I.version
              ? Ze(Q, I, T)
              : t.bindTexture(n.TEXTURE_3D, Q.__webglTexture, n.TEXTURE0 + T);
          }),
          (this.setTextureCube = function le(I, T) {
            const Q = i.get(I);
            I.version > 0 && Q.__version !== I.version
              ? (function dt(I, T, Q) {
                  if (6 !== T.image.length) return;
                  const fe = xe(I, T),
                    he = T.source;
                  t.bindTexture(
                    n.TEXTURE_CUBE_MAP,
                    I.__webglTexture,
                    n.TEXTURE0 + Q
                  );
                  const R = i.get(he);
                  if (he.version !== R.__version || !0 === fe) {
                    t.activeTexture(n.TEXTURE0 + Q),
                      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, T.flipY),
                      n.pixelStorei(
                        n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        T.premultiplyAlpha
                      ),
                      n.pixelStorei(n.UNPACK_ALIGNMENT, T.unpackAlignment),
                      n.pixelStorei(
                        n.UNPACK_COLORSPACE_CONVERSION_WEBGL,
                        n.NONE
                      );
                    const ae =
                        T.isCompressedTexture || T.image[0].isCompressedTexture,
                      ue = T.image[0] && T.image[0].isDataTexture,
                      Y = [];
                    for (let K = 0; K < 6; K++)
                      (Y[K] =
                        ae || ue
                          ? ue
                            ? T.image[K].image
                            : T.image[K]
                          : v(T.image[K], !1, !0, c)),
                        (Y[K] = an(T, Y[K]));
                    const ke = Y[0],
                      We = b(ke) || a,
                      Ve = s.convert(T.format, T.colorSpace),
                      Be = s.convert(T.type),
                      Fe = C(T.internalFormat, Ve, Be, T.colorSpace),
                      tt = a && !0 !== T.isVideoTexture,
                      Dt = void 0 === R.__version || !0 === fe;
                    let we,
                      N = w(T, ke, We);
                    if ((ve(n.TEXTURE_CUBE_MAP, T, We), ae)) {
                      tt &&
                        Dt &&
                        t.texStorage2D(
                          n.TEXTURE_CUBE_MAP,
                          N,
                          Fe,
                          ke.width,
                          ke.height
                        );
                      for (let K = 0; K < 6; K++) {
                        we = Y[K].mipmaps;
                        for (let _e = 0; _e < we.length; _e++) {
                          const Te = we[_e];
                          T.format !== Tr
                            ? null !== Ve
                              ? tt
                                ? t.compressedTexSubImage2D(
                                    n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                    _e,
                                    0,
                                    0,
                                    Te.width,
                                    Te.height,
                                    Ve,
                                    Te.data
                                  )
                                : t.compressedTexImage2D(
                                    n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                    _e,
                                    Fe,
                                    Te.width,
                                    Te.height,
                                    0,
                                    Te.data
                                  )
                              : console.warn(
                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                )
                            : tt
                            ? t.texSubImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                _e,
                                0,
                                0,
                                Te.width,
                                Te.height,
                                Ve,
                                Be,
                                Te.data
                              )
                            : t.texImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                _e,
                                Fe,
                                Te.width,
                                Te.height,
                                0,
                                Ve,
                                Be,
                                Te.data
                              );
                        }
                      }
                    } else {
                      (we = T.mipmaps),
                        tt &&
                          Dt &&
                          (we.length > 0 && N++,
                          t.texStorage2D(
                            n.TEXTURE_CUBE_MAP,
                            N,
                            Fe,
                            Y[0].width,
                            Y[0].height
                          ));
                      for (let K = 0; K < 6; K++)
                        if (ue) {
                          tt
                            ? t.texSubImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                0,
                                0,
                                0,
                                Y[K].width,
                                Y[K].height,
                                Ve,
                                Be,
                                Y[K].data
                              )
                            : t.texImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                0,
                                Fe,
                                Y[K].width,
                                Y[K].height,
                                0,
                                Ve,
                                Be,
                                Y[K].data
                              );
                          for (let _e = 0; _e < we.length; _e++) {
                            const Nt = we[_e].image[K].image;
                            tt
                              ? t.texSubImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                  _e + 1,
                                  0,
                                  0,
                                  Nt.width,
                                  Nt.height,
                                  Ve,
                                  Be,
                                  Nt.data
                                )
                              : t.texImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                  _e + 1,
                                  Fe,
                                  Nt.width,
                                  Nt.height,
                                  0,
                                  Ve,
                                  Be,
                                  Nt.data
                                );
                          }
                        } else {
                          tt
                            ? t.texSubImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                0,
                                0,
                                0,
                                Ve,
                                Be,
                                Y[K]
                              )
                            : t.texImage2D(
                                n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                0,
                                Fe,
                                Ve,
                                Be,
                                Y[K]
                              );
                          for (let _e = 0; _e < we.length; _e++) {
                            const Te = we[_e];
                            tt
                              ? t.texSubImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                  _e + 1,
                                  0,
                                  0,
                                  Ve,
                                  Be,
                                  Te.image[K]
                                )
                              : t.texImage2D(
                                  n.TEXTURE_CUBE_MAP_POSITIVE_X + K,
                                  _e + 1,
                                  Fe,
                                  Ve,
                                  Be,
                                  Te.image[K]
                                );
                          }
                        }
                    }
                    M(T, We) && S(n.TEXTURE_CUBE_MAP),
                      (R.__version = he.version),
                      T.onUpdate && T.onUpdate(T);
                  }
                  I.__version = T.version;
                })(Q, I, T)
              : t.bindTexture(
                  n.TEXTURE_CUBE_MAP,
                  Q.__webglTexture,
                  n.TEXTURE0 + T
                );
          }),
          (this.rebindTextures = function pe(I, T, Q) {
            const fe = i.get(I);
            void 0 !== T &&
              Ue(
                fe.__webglFramebuffer,
                I,
                I.texture,
                n.COLOR_ATTACHMENT0,
                n.TEXTURE_2D
              ),
              void 0 !== Q && ie(I);
          }),
          (this.setupRenderTarget = function oe(I) {
            const T = I.texture,
              Q = i.get(I),
              fe = i.get(T);
            I.addEventListener("dispose", j),
              !0 !== I.isWebGLMultipleRenderTargets &&
                (void 0 === fe.__webglTexture &&
                  (fe.__webglTexture = n.createTexture()),
                (fe.__version = T.version),
                o.memory.textures++);
            const he = !0 === I.isWebGLCubeRenderTarget,
              R = !0 === I.isWebGLMultipleRenderTargets,
              ae = b(I) || a;
            if (he) {
              Q.__webglFramebuffer = [];
              for (let ue = 0; ue < 6; ue++)
                Q.__webglFramebuffer[ue] = n.createFramebuffer();
            } else {
              if (((Q.__webglFramebuffer = n.createFramebuffer()), R))
                if (r.drawBuffers) {
                  const ue = I.texture;
                  for (let Y = 0, ke = ue.length; Y < ke; Y++) {
                    const We = i.get(ue[Y]);
                    void 0 === We.__webglTexture &&
                      ((We.__webglTexture = n.createTexture()),
                      o.memory.textures++);
                  }
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                  );
              if (a && I.samples > 0 && !1 === et(I)) {
                const ue = R ? T : [T];
                (Q.__webglMultisampledFramebuffer = n.createFramebuffer()),
                  (Q.__webglColorRenderbuffer = []),
                  t.bindFramebuffer(
                    n.FRAMEBUFFER,
                    Q.__webglMultisampledFramebuffer
                  );
                for (let Y = 0; Y < ue.length; Y++) {
                  const ke = ue[Y];
                  (Q.__webglColorRenderbuffer[Y] = n.createRenderbuffer()),
                    n.bindRenderbuffer(
                      n.RENDERBUFFER,
                      Q.__webglColorRenderbuffer[Y]
                    );
                  const We = s.convert(ke.format, ke.colorSpace),
                    Ve = s.convert(ke.type),
                    Be = C(
                      ke.internalFormat,
                      We,
                      Ve,
                      ke.colorSpace,
                      !0 === I.isXRRenderTarget
                    ),
                    Fe = Oe(I);
                  n.renderbufferStorageMultisample(
                    n.RENDERBUFFER,
                    Fe,
                    Be,
                    I.width,
                    I.height
                  ),
                    n.framebufferRenderbuffer(
                      n.FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + Y,
                      n.RENDERBUFFER,
                      Q.__webglColorRenderbuffer[Y]
                    );
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                  I.depthBuffer &&
                    ((Q.__webglDepthRenderbuffer = n.createRenderbuffer()),
                    P(Q.__webglDepthRenderbuffer, I, !0)),
                  t.bindFramebuffer(n.FRAMEBUFFER, null);
              }
            }
            if (he) {
              t.bindTexture(n.TEXTURE_CUBE_MAP, fe.__webglTexture),
                ve(n.TEXTURE_CUBE_MAP, T, ae);
              for (let ue = 0; ue < 6; ue++)
                Ue(
                  Q.__webglFramebuffer[ue],
                  I,
                  T,
                  n.COLOR_ATTACHMENT0,
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ue
                );
              M(T, ae) && S(n.TEXTURE_CUBE_MAP), t.unbindTexture();
            } else if (R) {
              const ue = I.texture;
              for (let Y = 0, ke = ue.length; Y < ke; Y++) {
                const We = ue[Y],
                  Ve = i.get(We);
                t.bindTexture(n.TEXTURE_2D, Ve.__webglTexture),
                  ve(n.TEXTURE_2D, We, ae),
                  Ue(
                    Q.__webglFramebuffer,
                    I,
                    We,
                    n.COLOR_ATTACHMENT0 + Y,
                    n.TEXTURE_2D
                  ),
                  M(We, ae) && S(n.TEXTURE_2D);
              }
              t.unbindTexture();
            } else {
              let ue = n.TEXTURE_2D;
              (I.isWebGL3DRenderTarget || I.isWebGLArrayRenderTarget) &&
                (a
                  ? (ue = I.isWebGL3DRenderTarget
                      ? n.TEXTURE_3D
                      : n.TEXTURE_2D_ARRAY)
                  : console.error(
                      "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                    )),
                t.bindTexture(ue, fe.__webglTexture),
                ve(ue, T, ae),
                Ue(Q.__webglFramebuffer, I, T, n.COLOR_ATTACHMENT0, ue),
                M(T, ae) && S(ue),
                t.unbindTexture();
            }
            I.depthBuffer && ie(I);
          }),
          (this.updateRenderTargetMipmap = function ze(I) {
            const T = b(I) || a,
              Q =
                !0 === I.isWebGLMultipleRenderTargets ? I.texture : [I.texture];
            for (let fe = 0, he = Q.length; fe < he; fe++) {
              const R = Q[fe];
              if (M(R, T)) {
                const ae = I.isWebGLCubeRenderTarget
                    ? n.TEXTURE_CUBE_MAP
                    : n.TEXTURE_2D,
                  ue = i.get(R).__webglTexture;
                t.bindTexture(ae, ue), S(ae), t.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function Pe(I) {
            if (a && I.samples > 0 && !1 === et(I)) {
              const T = I.isWebGLMultipleRenderTargets
                  ? I.texture
                  : [I.texture],
                Q = I.width,
                fe = I.height;
              let he = n.COLOR_BUFFER_BIT;
              const R = [],
                ae = I.stencilBuffer
                  ? n.DEPTH_STENCIL_ATTACHMENT
                  : n.DEPTH_ATTACHMENT,
                ue = i.get(I),
                Y = !0 === I.isWebGLMultipleRenderTargets;
              if (Y)
                for (let ke = 0; ke < T.length; ke++)
                  t.bindFramebuffer(
                    n.FRAMEBUFFER,
                    ue.__webglMultisampledFramebuffer
                  ),
                    n.framebufferRenderbuffer(
                      n.FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + ke,
                      n.RENDERBUFFER,
                      null
                    ),
                    t.bindFramebuffer(n.FRAMEBUFFER, ue.__webglFramebuffer),
                    n.framebufferTexture2D(
                      n.DRAW_FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + ke,
                      n.TEXTURE_2D,
                      null,
                      0
                    );
              t.bindFramebuffer(
                n.READ_FRAMEBUFFER,
                ue.__webglMultisampledFramebuffer
              ),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ue.__webglFramebuffer);
              for (let ke = 0; ke < T.length; ke++) {
                R.push(n.COLOR_ATTACHMENT0 + ke), I.depthBuffer && R.push(ae);
                const We =
                  void 0 !== ue.__ignoreDepthValues && ue.__ignoreDepthValues;
                if (
                  (!1 === We &&
                    (I.depthBuffer && (he |= n.DEPTH_BUFFER_BIT),
                    I.stencilBuffer && (he |= n.STENCIL_BUFFER_BIT)),
                  Y &&
                    n.framebufferRenderbuffer(
                      n.READ_FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0,
                      n.RENDERBUFFER,
                      ue.__webglColorRenderbuffer[ke]
                    ),
                  !0 === We &&
                    (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [ae]),
                    n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [ae])),
                  Y)
                ) {
                  const Ve = i.get(T[ke]).__webglTexture;
                  n.framebufferTexture2D(
                    n.DRAW_FRAMEBUFFER,
                    n.COLOR_ATTACHMENT0,
                    n.TEXTURE_2D,
                    Ve,
                    0
                  );
                }
                n.blitFramebuffer(0, 0, Q, fe, 0, 0, Q, fe, he, n.NEAREST),
                  f && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, R);
              }
              if (
                (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                Y)
              )
                for (let ke = 0; ke < T.length; ke++) {
                  t.bindFramebuffer(
                    n.FRAMEBUFFER,
                    ue.__webglMultisampledFramebuffer
                  ),
                    n.framebufferRenderbuffer(
                      n.FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + ke,
                      n.RENDERBUFFER,
                      ue.__webglColorRenderbuffer[ke]
                    );
                  const We = i.get(T[ke]).__webglTexture;
                  t.bindFramebuffer(n.FRAMEBUFFER, ue.__webglFramebuffer),
                    n.framebufferTexture2D(
                      n.DRAW_FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + ke,
                      n.TEXTURE_2D,
                      We,
                      0
                    );
                }
              t.bindFramebuffer(
                n.DRAW_FRAMEBUFFER,
                ue.__webglMultisampledFramebuffer
              );
            }
          }),
          (this.setupDepthRenderbuffer = ie),
          (this.setupFrameBufferTexture = Ue),
          (this.useMultisampledRTT = et);
      }
      function UZ(n, e, t) {
        const i = t.isWebGL2;
        return {
          convert: function r(s, o = Ia) {
            let a;
            if (s === Oo) return n.UNSIGNED_BYTE;
            if (s === fR) return n.UNSIGNED_SHORT_4_4_4_4;
            if (s === pR) return n.UNSIGNED_SHORT_5_5_5_1;
            if (s === G9) return n.BYTE;
            if (s === W9) return n.SHORT;
            if (s === ub) return n.UNSIGNED_SHORT;
            if (s === hR) return n.INT;
            if (s === Lo) return n.UNSIGNED_INT;
            if (s === to) return n.FLOAT;
            if (s === Hi)
              return i
                ? n.HALF_FLOAT
                : ((a = e.get("OES_texture_half_float")),
                  null !== a ? a.HALF_FLOAT_OES : null);
            if (s === j9) return n.ALPHA;
            if (s === Tr) return n.RGBA;
            if (s === X9) return n.LUMINANCE;
            if (s === q9) return n.LUMINANCE_ALPHA;
            if (s === Aa) return n.DEPTH_COMPONENT;
            if (s === gc) return n.DEPTH_STENCIL;
            if (s === bb)
              return (
                (a = e.get("EXT_sRGB")), null !== a ? a.SRGB_ALPHA_EXT : null
              );
            if (s === Y9) return n.RED;
            if (s === mR) return n.RED_INTEGER;
            if (s === Z9) return n.RG;
            if (s === gR) return n.RG_INTEGER;
            if (s === _R) return n.RGBA_INTEGER;
            if (s === db || s === hb || s === fb || s === pb)
              if (o === qe) {
                if (
                  ((a = e.get("WEBGL_compressed_texture_s3tc_srgb")),
                  null === a)
                )
                  return null;
                if (s === db) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (s === hb) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (s === fb) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (s === pb) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (((a = e.get("WEBGL_compressed_texture_s3tc")), null === a))
                  return null;
                if (s === db) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (s === hb) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (s === fb) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (s === pb) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            if (s === vR || s === yR || s === bR || s === xR) {
              if (((a = e.get("WEBGL_compressed_texture_pvrtc")), null === a))
                return null;
              if (s === vR) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (s === yR) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (s === bR) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (s === xR) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (s === K9)
              return (
                (a = e.get("WEBGL_compressed_texture_etc1")),
                null !== a ? a.COMPRESSED_RGB_ETC1_WEBGL : null
              );
            if (s === wR || s === MR) {
              if (((a = e.get("WEBGL_compressed_texture_etc")), null === a))
                return null;
              if (s === wR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ETC2
                  : a.COMPRESSED_RGB8_ETC2;
              if (s === MR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : a.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              s === SR ||
              s === ER ||
              s === CR ||
              s === TR ||
              s === AR ||
              s === DR ||
              s === IR ||
              s === RR ||
              s === PR ||
              s === OR ||
              s === LR ||
              s === FR ||
              s === NR ||
              s === kR
            ) {
              if (((a = e.get("WEBGL_compressed_texture_astc")), null === a))
                return null;
              if (s === SR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (s === ER)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (s === CR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (s === TR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (s === AR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (s === DR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (s === IR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (s === RR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (s === PR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (s === OR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (s === LR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (s === FR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (s === NR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (s === kR)
                return o === qe
                  ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (s === mb) {
              if (((a = e.get("EXT_texture_compression_bptc")), null === a))
                return null;
              if (s === mb)
                return o === qe
                  ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            if (s === $9 || s === BR || s === UR || s === VR) {
              if (((a = e.get("EXT_texture_compression_rgtc")), null === a))
                return null;
              if (s === mb) return a.COMPRESSED_RED_RGTC1_EXT;
              if (s === BR) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (s === UR) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (s === VR) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            }
            return s === Ta
              ? i
                ? n.UNSIGNED_INT_24_8
                : ((a = e.get("WEBGL_depth_texture")),
                  null !== a ? a.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0 !== n[s]
              ? n[s]
              : null;
          },
        };
      }
      class VZ extends Wn {
        constructor(e = []) {
          super(), (this.isArrayCamera = !0), (this.cameras = e);
        }
      }
      class Es extends Dn {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      }
      const zZ = { type: "move" };
      class $b {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new Es()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new Es()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new A()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new A())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new Es()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new A()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new A())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            null !== this._hand && this._hand.dispatchEvent(e),
            this
          );
        }
        connect(e) {
          if (e && e.hand) {
            const t = this._hand;
            if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
          }
          return this.dispatchEvent({ type: "connected", data: e }), this;
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, i) {
          let r = null,
            s = null,
            o = null;
          const a = this._targetRay,
            l = this._grip,
            c = this._hand;
          if (e && "visible-blurred" !== t.session.visibilityState) {
            if (c && e.hand) {
              o = !0;
              for (const _ of e.hand.values()) {
                const m = t.getJointPose(_, i),
                  g = this._getHandJoint(c, _);
                null !== m &&
                  (g.matrix.fromArray(m.transform.matrix),
                  g.matrix.decompose(g.position, g.rotation, g.scale),
                  (g.matrixWorldNeedsUpdate = !0),
                  (g.jointRadius = m.radius)),
                  (g.visible = null !== m);
              }
              const h = c.joints["index-finger-tip"].position.distanceTo(
                  c.joints["thumb-tip"].position
                ),
                f = 0.02,
                p = 0.005;
              c.inputState.pinching && h > f + p
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  h <= f - p &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              null !== l &&
                e.gripSpace &&
                ((s = t.getPose(e.gripSpace, i)),
                null !== s &&
                  (l.matrix.fromArray(s.transform.matrix),
                  l.matrix.decompose(l.position, l.rotation, l.scale),
                  (l.matrixWorldNeedsUpdate = !0),
                  s.linearVelocity
                    ? ((l.hasLinearVelocity = !0),
                      l.linearVelocity.copy(s.linearVelocity))
                    : (l.hasLinearVelocity = !1),
                  s.angularVelocity
                    ? ((l.hasAngularVelocity = !0),
                      l.angularVelocity.copy(s.angularVelocity))
                    : (l.hasAngularVelocity = !1)));
            null !== a &&
              ((r = t.getPose(e.targetRaySpace, i)),
              null === r && null !== s && (r = s),
              null !== r &&
                (a.matrix.fromArray(r.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                (a.matrixWorldNeedsUpdate = !0),
                r.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(r.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                r.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(r.angularVelocity))
                  : (a.hasAngularVelocity = !1),
                this.dispatchEvent(zZ)));
          }
          return (
            null !== a && (a.visible = null !== r),
            null !== l && (l.visible = null !== s),
            null !== c && (c.visible = null !== o),
            this
          );
        }
        _getHandJoint(e, t) {
          if (void 0 === e.joints[t.jointName]) {
            const i = new Es();
            (i.matrixAutoUpdate = !1),
              (i.visible = !1),
              (e.joints[t.jointName] = i),
              e.add(i);
          }
          return e.joints[t.jointName];
        }
      }
      class HZ extends Ai {
        constructor(e, t, i, r, s, o, a, l, c, u) {
          if ((u = void 0 !== u ? u : Aa) !== Aa && u !== gc)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === i && u === Aa && (i = Lo),
            void 0 === i && u === gc && (i = Ta),
            super(null, r, s, o, a, l, u, i, c),
            (this.isDepthTexture = !0),
            (this.image = { width: e, height: t }),
            (this.magFilter = void 0 !== a ? a : hn),
            (this.minFilter = void 0 !== l ? l : hn),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
        }
        copy(e) {
          return (
            super.copy(e), (this.compareFunction = e.compareFunction), this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.compareFunction &&
              (t.compareFunction = this.compareFunction),
            t
          );
        }
      }
      class GZ extends No {
        constructor(e, t) {
          super();
          const i = this;
          let r = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = 1,
            c = null,
            u = null,
            d = null,
            h = null,
            f = null,
            p = null;
          const _ = t.getContextAttributes();
          let m = null,
            g = null;
          const y = [],
            v = [],
            b = new Wn();
          b.layers.enable(1), (b.viewport = new Ft());
          const x = new Wn();
          x.layers.enable(2), (x.viewport = new Ft());
          const M = [b, x],
            S = new VZ();
          S.layers.enable(1), S.layers.enable(2);
          let C = null,
            w = null;
          function E(B) {
            const q = v.indexOf(B.inputSource);
            if (-1 === q) return;
            const le = y[q];
            void 0 !== le &&
              (le.update(B.inputSource, B.frame, c || o),
              le.dispatchEvent({ type: B.type, data: B.inputSource }));
          }
          function V() {
            r.removeEventListener("select", E),
              r.removeEventListener("selectstart", E),
              r.removeEventListener("selectend", E),
              r.removeEventListener("squeeze", E),
              r.removeEventListener("squeezestart", E),
              r.removeEventListener("squeezeend", E),
              r.removeEventListener("end", V),
              r.removeEventListener("inputsourceschange", j);
            for (let B = 0; B < y.length; B++) {
              const q = v[B];
              null !== q && ((v[B] = null), y[B].disconnect(q));
            }
            (C = null),
              (w = null),
              e.setRenderTarget(m),
              (f = null),
              (h = null),
              (d = null),
              (r = null),
              (g = null),
              Z.stop(),
              (i.isPresenting = !1),
              i.dispatchEvent({ type: "sessionend" });
          }
          function j(B) {
            for (let q = 0; q < B.removed.length; q++) {
              const le = B.removed[q],
                te = v.indexOf(le);
              te >= 0 && ((v[te] = null), y[te].disconnect(le));
            }
            for (let q = 0; q < B.added.length; q++) {
              const le = B.added[q];
              let te = v.indexOf(le);
              if (-1 === te) {
                for (let Ce = 0; Ce < y.length; Ce++) {
                  if (Ce >= v.length) {
                    v.push(le), (te = Ce);
                    break;
                  }
                  if (null === v[Ce]) {
                    (v[Ce] = le), (te = Ce);
                    break;
                  }
                }
                if (-1 === te) break;
              }
              const ce = y[te];
              ce && ce.connect(le);
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (B) {
              let q = y[B];
              return (
                void 0 === q && ((q = new $b()), (y[B] = q)),
                q.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (B) {
              let q = y[B];
              return (
                void 0 === q && ((q = new $b()), (y[B] = q)), q.getGripSpace()
              );
            }),
            (this.getHand = function (B) {
              let q = y[B];
              return (
                void 0 === q && ((q = new $b()), (y[B] = q)), q.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (B) {
              (s = B),
                !0 === i.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
            }),
            (this.setReferenceSpaceType = function (B) {
              (a = B),
                !0 === i.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return c || o;
            }),
            (this.setReferenceSpace = function (B) {
              c = B;
            }),
            (this.getBaseLayer = function () {
              return null !== h ? h : f;
            }),
            (this.getBinding = function () {
              return d;
            }),
            (this.getFrame = function () {
              return p;
            }),
            (this.getSession = function () {
              return r;
            }),
            (this.setSession = (function () {
              var B = ai(function* (q) {
                if (((r = q), null !== r)) {
                  if (
                    ((m = e.getRenderTarget()),
                    r.addEventListener("select", E),
                    r.addEventListener("selectstart", E),
                    r.addEventListener("selectend", E),
                    r.addEventListener("squeeze", E),
                    r.addEventListener("squeezestart", E),
                    r.addEventListener("squeezeend", E),
                    r.addEventListener("end", V),
                    r.addEventListener("inputsourceschange", j),
                    !0 !== _.xrCompatible && (yield t.makeXRCompatible()),
                    void 0 === r.renderState.layers ||
                      !1 === e.capabilities.isWebGL2)
                  )
                    (f = new XRWebGLLayer(r, t, {
                      antialias: void 0 !== r.renderState.layers || _.antialias,
                      alpha: !0,
                      depth: _.depth,
                      stencil: _.stencil,
                      framebufferScaleFactor: s,
                    })),
                      r.updateRenderState({ baseLayer: f }),
                      (g = new li(f.framebufferWidth, f.framebufferHeight, {
                        format: Tr,
                        type: Oo,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: _.stencil,
                      }));
                  else {
                    let le = null,
                      te = null,
                      ce = null;
                    _.depth &&
                      ((ce = _.stencil
                        ? t.DEPTH24_STENCIL8
                        : t.DEPTH_COMPONENT24),
                      (le = _.stencil ? gc : Aa),
                      (te = _.stencil ? Ta : Lo));
                    const Ce = {
                      colorFormat: t.RGBA8,
                      depthFormat: ce,
                      scaleFactor: s,
                    };
                    (d = new XRWebGLBinding(r, t)),
                      (h = d.createProjectionLayer(Ce)),
                      r.updateRenderState({ layers: [h] }),
                      (g = new li(h.textureWidth, h.textureHeight, {
                        format: Tr,
                        type: Oo,
                        depthTexture: new HZ(
                          h.textureWidth,
                          h.textureHeight,
                          te,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          le
                        ),
                        stencilBuffer: _.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: _.antialias ? 4 : 0,
                      })),
                      (e.properties.get(g).__ignoreDepthValues =
                        h.ignoreDepthValues);
                  }
                  (g.isXRRenderTarget = !0),
                    this.setFoveation(l),
                    (c = null),
                    (o = yield r.requestReferenceSpace(a)),
                    Z.setContext(r),
                    Z.start(),
                    (i.isPresenting = !0),
                    i.dispatchEvent({ type: "sessionstart" });
                }
              });
              return function (q) {
                return B.apply(this, arguments);
              };
            })()),
            (this.getEnvironmentBlendMode = function () {
              if (null !== r) return r.environmentBlendMode;
            });
          const F = new A(),
            k = new A();
          function O(B, q) {
            null === q
              ? B.matrixWorld.copy(B.matrix)
              : B.matrixWorld.multiplyMatrices(q.matrixWorld, B.matrix),
              B.matrixWorldInverse.copy(B.matrixWorld).invert();
          }
          (this.updateCamera = function (B) {
            if (null === r) return;
            (S.near = x.near = b.near = B.near),
              (S.far = x.far = b.far = B.far),
              (C !== S.near || w !== S.far) &&
                (r.updateRenderState({ depthNear: S.near, depthFar: S.far }),
                (C = S.near),
                (w = S.far));
            const q = B.parent,
              le = S.cameras;
            O(S, q);
            for (let te = 0; te < le.length; te++) O(le[te], q);
            2 === le.length
              ? (function z(B, q, le) {
                  F.setFromMatrixPosition(q.matrixWorld),
                    k.setFromMatrixPosition(le.matrixWorld);
                  const te = F.distanceTo(k),
                    ce = q.projectionMatrix.elements,
                    Ce = le.projectionMatrix.elements,
                    ve = ce[14] / (ce[10] - 1),
                    xe = ce[14] / (ce[10] + 1),
                    Ze = (ce[9] + 1) / ce[5],
                    dt = (ce[9] - 1) / ce[5],
                    Ue = (ce[8] - 1) / ce[0],
                    P = (Ce[8] + 1) / Ce[0],
                    ge = ve * Ue,
                    ie = ve * P,
                    pe = te / (-Ue + P),
                    oe = pe * -Ue;
                  q.matrixWorld.decompose(B.position, B.quaternion, B.scale),
                    B.translateX(oe),
                    B.translateZ(pe),
                    B.matrixWorld.compose(B.position, B.quaternion, B.scale),
                    B.matrixWorldInverse.copy(B.matrixWorld).invert();
                  const ze = ve + pe,
                    Pe = xe + pe;
                  B.projectionMatrix.makePerspective(
                    ge - oe,
                    ie + (te - oe),
                    ((Ze * xe) / Pe) * ze,
                    ((dt * xe) / Pe) * ze,
                    ze,
                    Pe
                  ),
                    B.projectionMatrixInverse.copy(B.projectionMatrix).invert();
                })(S, b, x)
              : S.projectionMatrix.copy(b.projectionMatrix),
              (function L(B, q, le) {
                null === le
                  ? B.matrix.copy(q.matrixWorld)
                  : (B.matrix.copy(le.matrixWorld),
                    B.matrix.invert(),
                    B.matrix.multiply(q.matrixWorld)),
                  B.matrix.decompose(B.position, B.quaternion, B.scale),
                  B.updateMatrixWorld(!0);
                const te = B.children;
                for (let ce = 0, Ce = te.length; ce < Ce; ce++)
                  te[ce].updateMatrixWorld(!0);
                B.projectionMatrix.copy(q.projectionMatrix),
                  B.projectionMatrixInverse.copy(q.projectionMatrixInverse),
                  B.isPerspectiveCamera &&
                    ((B.fov =
                      2 * bc * Math.atan(1 / B.projectionMatrix.elements[5])),
                    (B.zoom = 1));
              })(B, S, q);
          }),
            (this.getCamera = function () {
              return S;
            }),
            (this.getFoveation = function () {
              if (null !== h || null !== f) return l;
            }),
            (this.setFoveation = function (B) {
              (l = B),
                null !== h && (h.fixedFoveation = B),
                null !== f &&
                  void 0 !== f.fixedFoveation &&
                  (f.fixedFoveation = B);
            });
          let U = null;
          const Z = new vP();
          Z.setAnimationLoop(function W(B, q) {
            if (((u = q.getViewerPose(c || o)), (p = q), null !== u)) {
              const le = u.views;
              null !== f &&
                (e.setRenderTargetFramebuffer(g, f.framebuffer),
                e.setRenderTarget(g));
              let te = !1;
              le.length !== S.cameras.length &&
                ((S.cameras.length = 0), (te = !0));
              for (let ce = 0; ce < le.length; ce++) {
                const Ce = le[ce];
                let ve = null;
                if (null !== f) ve = f.getViewport(Ce);
                else {
                  const Ze = d.getViewSubImage(h, Ce);
                  (ve = Ze.viewport),
                    0 === ce &&
                      (e.setRenderTargetTextures(
                        g,
                        Ze.colorTexture,
                        h.ignoreDepthValues ? void 0 : Ze.depthStencilTexture
                      ),
                      e.setRenderTarget(g));
                }
                let xe = M[ce];
                void 0 === xe &&
                  ((xe = new Wn()),
                  xe.layers.enable(ce),
                  (xe.viewport = new Ft()),
                  (M[ce] = xe)),
                  xe.matrix.fromArray(Ce.transform.matrix),
                  xe.matrix.decompose(xe.position, xe.quaternion, xe.scale),
                  xe.projectionMatrix.fromArray(Ce.projectionMatrix),
                  xe.projectionMatrixInverse.copy(xe.projectionMatrix).invert(),
                  xe.viewport.set(ve.x, ve.y, ve.width, ve.height),
                  0 === ce &&
                    (S.matrix.copy(xe.matrix),
                    S.matrix.decompose(S.position, S.quaternion, S.scale)),
                  !0 === te && S.cameras.push(xe);
              }
            }
            for (let le = 0; le < y.length; le++) {
              const te = v[le],
                ce = y[le];
              null !== te && void 0 !== ce && ce.update(te, q, c || o);
            }
            U && U(B, q),
              q.detectedPlanes &&
                i.dispatchEvent({ type: "planesdetected", data: q }),
              (p = null);
          }),
            (this.setAnimationLoop = function (B) {
              U = B;
            }),
            (this.dispose = function () {});
        }
      }
      function WZ(n, e) {
        function t(m, g) {
          !0 === m.matrixAutoUpdate && m.updateMatrix(), g.value.copy(m.matrix);
        }
        function s(m, g) {
          (m.opacity.value = g.opacity),
            g.color && m.diffuse.value.copy(g.color),
            g.emissive &&
              m.emissive.value
                .copy(g.emissive)
                .multiplyScalar(g.emissiveIntensity),
            g.map && ((m.map.value = g.map), t(g.map, m.mapTransform)),
            g.alphaMap &&
              ((m.alphaMap.value = g.alphaMap),
              t(g.alphaMap, m.alphaMapTransform)),
            g.bumpMap &&
              ((m.bumpMap.value = g.bumpMap),
              t(g.bumpMap, m.bumpMapTransform),
              (m.bumpScale.value = g.bumpScale),
              g.side === zi && (m.bumpScale.value *= -1)),
            g.normalMap &&
              ((m.normalMap.value = g.normalMap),
              t(g.normalMap, m.normalMapTransform),
              m.normalScale.value.copy(g.normalScale),
              g.side === zi && m.normalScale.value.negate()),
            g.displacementMap &&
              ((m.displacementMap.value = g.displacementMap),
              t(g.displacementMap, m.displacementMapTransform),
              (m.displacementScale.value = g.displacementScale),
              (m.displacementBias.value = g.displacementBias)),
            g.emissiveMap &&
              ((m.emissiveMap.value = g.emissiveMap),
              t(g.emissiveMap, m.emissiveMapTransform)),
            g.specularMap &&
              ((m.specularMap.value = g.specularMap),
              t(g.specularMap, m.specularMapTransform)),
            g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
          const y = e.get(g).envMap;
          if (
            (y &&
              ((m.envMap.value = y),
              (m.flipEnvMap.value =
                y.isCubeTexture && !1 === y.isRenderTargetTexture ? -1 : 1),
              (m.reflectivity.value = g.reflectivity),
              (m.ior.value = g.ior),
              (m.refractionRatio.value = g.refractionRatio)),
            g.lightMap)
          ) {
            m.lightMap.value = g.lightMap;
            const v = !0 === n.useLegacyLights ? Math.PI : 1;
            (m.lightMapIntensity.value = g.lightMapIntensity * v),
              t(g.lightMap, m.lightMapTransform);
          }
          g.aoMap &&
            ((m.aoMap.value = g.aoMap),
            (m.aoMapIntensity.value = g.aoMapIntensity),
            t(g.aoMap, m.aoMapTransform));
        }
        return {
          refreshFogUniforms: function i(m, g) {
            g.color.getRGB(m.fogColor.value, _P(n)),
              g.isFog
                ? ((m.fogNear.value = g.near), (m.fogFar.value = g.far))
                : g.isFogExp2 && (m.fogDensity.value = g.density);
          },
          refreshMaterialUniforms: function r(m, g, y, v, b) {
            g.isMeshBasicMaterial || g.isMeshLambertMaterial
              ? s(m, g)
              : g.isMeshToonMaterial
              ? (s(m, g),
                (function d(m, g) {
                  g.gradientMap && (m.gradientMap.value = g.gradientMap);
                })(m, g))
              : g.isMeshPhongMaterial
              ? (s(m, g),
                (function u(m, g) {
                  m.specular.value.copy(g.specular),
                    (m.shininess.value = Math.max(g.shininess, 1e-4));
                })(m, g))
              : g.isMeshStandardMaterial
              ? (s(m, g),
                (function h(m, g) {
                  (m.metalness.value = g.metalness),
                    g.metalnessMap &&
                      ((m.metalnessMap.value = g.metalnessMap),
                      t(g.metalnessMap, m.metalnessMapTransform)),
                    (m.roughness.value = g.roughness),
                    g.roughnessMap &&
                      ((m.roughnessMap.value = g.roughnessMap),
                      t(g.roughnessMap, m.roughnessMapTransform)),
                    e.get(g).envMap &&
                      (m.envMapIntensity.value = g.envMapIntensity);
                })(m, g),
                g.isMeshPhysicalMaterial &&
                  (function f(m, g, y) {
                    (m.ior.value = g.ior),
                      g.sheen > 0 &&
                        (m.sheenColor.value
                          .copy(g.sheenColor)
                          .multiplyScalar(g.sheen),
                        (m.sheenRoughness.value = g.sheenRoughness),
                        g.sheenColorMap &&
                          ((m.sheenColorMap.value = g.sheenColorMap),
                          t(g.sheenColorMap, m.sheenColorMapTransform)),
                        g.sheenRoughnessMap &&
                          ((m.sheenRoughnessMap.value = g.sheenRoughnessMap),
                          t(
                            g.sheenRoughnessMap,
                            m.sheenRoughnessMapTransform
                          ))),
                      g.clearcoat > 0 &&
                        ((m.clearcoat.value = g.clearcoat),
                        (m.clearcoatRoughness.value = g.clearcoatRoughness),
                        g.clearcoatMap &&
                          ((m.clearcoatMap.value = g.clearcoatMap),
                          t(g.clearcoatMap, m.clearcoatMapTransform)),
                        g.clearcoatRoughnessMap &&
                          ((m.clearcoatRoughnessMap.value =
                            g.clearcoatRoughnessMap),
                          t(
                            g.clearcoatRoughnessMap,
                            m.clearcoatRoughnessMapTransform
                          )),
                        g.clearcoatNormalMap &&
                          ((m.clearcoatNormalMap.value = g.clearcoatNormalMap),
                          t(
                            g.clearcoatNormalMap,
                            m.clearcoatNormalMapTransform
                          ),
                          m.clearcoatNormalScale.value.copy(
                            g.clearcoatNormalScale
                          ),
                          g.side === zi &&
                            m.clearcoatNormalScale.value.negate())),
                      g.iridescence > 0 &&
                        ((m.iridescence.value = g.iridescence),
                        (m.iridescenceIOR.value = g.iridescenceIOR),
                        (m.iridescenceThicknessMinimum.value =
                          g.iridescenceThicknessRange[0]),
                        (m.iridescenceThicknessMaximum.value =
                          g.iridescenceThicknessRange[1]),
                        g.iridescenceMap &&
                          ((m.iridescenceMap.value = g.iridescenceMap),
                          t(g.iridescenceMap, m.iridescenceMapTransform)),
                        g.iridescenceThicknessMap &&
                          ((m.iridescenceThicknessMap.value =
                            g.iridescenceThicknessMap),
                          t(
                            g.iridescenceThicknessMap,
                            m.iridescenceThicknessMapTransform
                          ))),
                      g.transmission > 0 &&
                        ((m.transmission.value = g.transmission),
                        (m.transmissionSamplerMap.value = y.texture),
                        m.transmissionSamplerSize.value.set(y.width, y.height),
                        g.transmissionMap &&
                          ((m.transmissionMap.value = g.transmissionMap),
                          t(g.transmissionMap, m.transmissionMapTransform)),
                        (m.thickness.value = g.thickness),
                        g.thicknessMap &&
                          ((m.thicknessMap.value = g.thicknessMap),
                          t(g.thicknessMap, m.thicknessMapTransform)),
                        (m.attenuationDistance.value = g.attenuationDistance),
                        m.attenuationColor.value.copy(g.attenuationColor)),
                      g.anisotropy > 0 &&
                        (m.anisotropyVector.value.set(
                          g.anisotropy * Math.cos(g.anisotropyRotation),
                          g.anisotropy * Math.sin(g.anisotropyRotation)
                        ),
                        g.anisotropyMap &&
                          ((m.anisotropyMap.value = g.anisotropyMap),
                          t(g.anisotropyMap, m.anisotropyMapTransform))),
                      (m.specularIntensity.value = g.specularIntensity),
                      m.specularColor.value.copy(g.specularColor),
                      g.specularColorMap &&
                        ((m.specularColorMap.value = g.specularColorMap),
                        t(g.specularColorMap, m.specularColorMapTransform)),
                      g.specularIntensityMap &&
                        ((m.specularIntensityMap.value =
                          g.specularIntensityMap),
                        t(
                          g.specularIntensityMap,
                          m.specularIntensityMapTransform
                        ));
                  })(m, g, b))
              : g.isMeshMatcapMaterial
              ? (s(m, g),
                (function p(m, g) {
                  g.matcap && (m.matcap.value = g.matcap);
                })(m, g))
              : g.isMeshDepthMaterial
              ? s(m, g)
              : g.isMeshDistanceMaterial
              ? (s(m, g),
                (function _(m, g) {
                  const y = e.get(g).light;
                  m.referencePosition.value.setFromMatrixPosition(
                    y.matrixWorld
                  ),
                    (m.nearDistance.value = y.shadow.camera.near),
                    (m.farDistance.value = y.shadow.camera.far);
                })(m, g))
              : g.isMeshNormalMaterial
              ? s(m, g)
              : g.isLineBasicMaterial
              ? ((function o(m, g) {
                  m.diffuse.value.copy(g.color),
                    (m.opacity.value = g.opacity),
                    g.map && ((m.map.value = g.map), t(g.map, m.mapTransform));
                })(m, g),
                g.isLineDashedMaterial &&
                  (function a(m, g) {
                    (m.dashSize.value = g.dashSize),
                      (m.totalSize.value = g.dashSize + g.gapSize),
                      (m.scale.value = g.scale);
                  })(m, g))
              : g.isPointsMaterial
              ? (function l(m, g, y, v) {
                  m.diffuse.value.copy(g.color),
                    (m.opacity.value = g.opacity),
                    (m.size.value = g.size * y),
                    (m.scale.value = 0.5 * v),
                    g.map && ((m.map.value = g.map), t(g.map, m.uvTransform)),
                    g.alphaMap &&
                      ((m.alphaMap.value = g.alphaMap),
                      t(g.alphaMap, m.alphaMapTransform)),
                    g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
                })(m, g, y, v)
              : g.isSpriteMaterial
              ? (function c(m, g) {
                  m.diffuse.value.copy(g.color),
                    (m.opacity.value = g.opacity),
                    (m.rotation.value = g.rotation),
                    g.map && ((m.map.value = g.map), t(g.map, m.mapTransform)),
                    g.alphaMap &&
                      ((m.alphaMap.value = g.alphaMap),
                      t(g.alphaMap, m.alphaMapTransform)),
                    g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest);
                })(m, g)
              : g.isShadowMaterial
              ? (m.color.value.copy(g.color), (m.opacity.value = g.opacity))
              : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
          },
        };
      }
      function jZ(n, e, t, i) {
        let r = {},
          s = {},
          o = [];
        const a = t.isWebGL2
          ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS)
          : 0;
        function f(y, v, b) {
          const x = y.value;
          if (void 0 === b[v]) {
            if ("number" == typeof x) b[v] = x;
            else {
              const M = Array.isArray(x) ? x : [x],
                S = [];
              for (let C = 0; C < M.length; C++) S.push(M[C].clone());
              b[v] = S;
            }
            return !0;
          }
          if ("number" == typeof x) {
            if (b[v] !== x) return (b[v] = x), !0;
          } else {
            const M = Array.isArray(b[v]) ? b[v] : [b[v]],
              S = Array.isArray(x) ? x : [x];
            for (let C = 0; C < M.length; C++) {
              const w = M[C];
              if (!1 === w.equals(S[C])) return w.copy(S[C]), !0;
            }
          }
          return !1;
        }
        function _(y) {
          const v = { boundary: 0, storage: 0 };
          return (
            "number" == typeof y
              ? ((v.boundary = 4), (v.storage = 4))
              : y.isVector2
              ? ((v.boundary = 8), (v.storage = 8))
              : y.isVector3 || y.isColor
              ? ((v.boundary = 16), (v.storage = 12))
              : y.isVector4
              ? ((v.boundary = 16), (v.storage = 16))
              : y.isMatrix3
              ? ((v.boundary = 48), (v.storage = 48))
              : y.isMatrix4
              ? ((v.boundary = 64), (v.storage = 64))
              : y.isTexture
              ? console.warn(
                  "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                )
              : console.warn(
                  "THREE.WebGLRenderer: Unsupported uniform value type.",
                  y
                ),
            v
          );
        }
        function m(y) {
          const v = y.target;
          v.removeEventListener("dispose", m);
          const b = o.indexOf(v.__bindingPointIndex);
          o.splice(b, 1),
            n.deleteBuffer(r[v.id]),
            delete r[v.id],
            delete s[v.id];
        }
        return {
          bind: function l(y, v) {
            i.uniformBlockBinding(y, v.program);
          },
          update: function c(y, v) {
            let b = r[y.id];
            void 0 === b &&
              ((function p(y) {
                const v = y.uniforms;
                let b = 0;
                let M = 0;
                for (let S = 0, C = v.length; S < C; S++) {
                  const w = v[S],
                    E = { boundary: 0, storage: 0 },
                    V = Array.isArray(w.value) ? w.value : [w.value];
                  for (let j = 0, F = V.length; j < F; j++) {
                    const z = _(V[j]);
                    (E.boundary += z.boundary), (E.storage += z.storage);
                  }
                  (w.__data = new Float32Array(
                    E.storage / Float32Array.BYTES_PER_ELEMENT
                  )),
                    (w.__offset = b),
                    S > 0 &&
                      ((M = b % 16),
                      0 !== M &&
                        16 - M - E.boundary < 0 &&
                        ((b += 16 - M), (w.__offset = b))),
                    (b += E.storage);
                }
                (M = b % 16),
                  M > 0 && (b += 16 - M),
                  (y.__size = b),
                  (y.__cache = {});
              })(y),
              (b = (function u(y) {
                const v = (function d() {
                  for (let y = 0; y < a; y++)
                    if (-1 === o.indexOf(y)) return o.push(y), y;
                  return (
                    console.error(
                      "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                    ),
                    0
                  );
                })();
                y.__bindingPointIndex = v;
                const b = n.createBuffer(),
                  x = y.__size,
                  M = y.usage;
                return (
                  n.bindBuffer(n.UNIFORM_BUFFER, b),
                  n.bufferData(n.UNIFORM_BUFFER, x, M),
                  n.bindBuffer(n.UNIFORM_BUFFER, null),
                  n.bindBufferBase(n.UNIFORM_BUFFER, v, b),
                  b
                );
              })(y)),
              (r[y.id] = b),
              y.addEventListener("dispose", m)),
              i.updateUBOMapping(y, v.program);
            const M = e.render.frame;
            s[y.id] !== M &&
              ((function h(y) {
                const b = y.uniforms,
                  x = y.__cache;
                n.bindBuffer(n.UNIFORM_BUFFER, r[y.id]);
                for (let M = 0, S = b.length; M < S; M++) {
                  const C = b[M];
                  if (!0 === f(C, M, x)) {
                    const w = C.__offset,
                      E = Array.isArray(C.value) ? C.value : [C.value];
                    let V = 0;
                    for (let j = 0; j < E.length; j++) {
                      const F = E[j],
                        k = _(F);
                      "number" == typeof F
                        ? ((C.__data[0] = F),
                          n.bufferSubData(n.UNIFORM_BUFFER, w + V, C.__data))
                        : F.isMatrix3
                        ? ((C.__data[0] = F.elements[0]),
                          (C.__data[1] = F.elements[1]),
                          (C.__data[2] = F.elements[2]),
                          (C.__data[3] = F.elements[0]),
                          (C.__data[4] = F.elements[3]),
                          (C.__data[5] = F.elements[4]),
                          (C.__data[6] = F.elements[5]),
                          (C.__data[7] = F.elements[0]),
                          (C.__data[8] = F.elements[6]),
                          (C.__data[9] = F.elements[7]),
                          (C.__data[10] = F.elements[8]),
                          (C.__data[11] = F.elements[0]))
                        : (F.toArray(C.__data, V),
                          (V += k.storage / Float32Array.BYTES_PER_ELEMENT));
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, w, C.__data);
                  }
                }
                n.bindBuffer(n.UNIFORM_BUFFER, null);
              })(y),
              (s[y.id] = M));
          },
          dispose: function g() {
            for (const y in r) n.deleteBuffer(r[y]);
            (o = []), (r = {}), (s = {});
          },
        };
      }
      function XZ() {
        const n = Yd("canvas");
        return (n.style.display = "block"), n;
      }
      class XP {
        constructor(e = {}) {
          const {
            canvas: t = XZ(),
            context: i = null,
            depth: r = !0,
            stencil: s = !0,
            alpha: o = !1,
            antialias: a = !1,
            premultipliedAlpha: l = !0,
            preserveDrawingBuffer: c = !1,
            powerPreference: u = "default",
            failIfMajorPerformanceCaveat: d = !1,
          } = e;
          let h;
          (this.isWebGLRenderer = !0),
            (h = null !== i ? i.getContextAttributes().alpha : o);
          const f = new Uint32Array(4),
            p = new Int32Array(4);
          let _ = null,
            m = null;
          const g = [],
            y = [];
          (this.domElement = t),
            (this.debug = { checkShaderErrors: !0, onShaderError: null }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this.outputColorSpace = qe),
            (this.useLegacyLights = !0),
            (this.toneMapping = Qs),
            (this.toneMappingExposure = 1);
          const v = this;
          let b = !1,
            x = 0,
            M = 0,
            S = null,
            C = -1,
            w = null;
          const E = new Ft(),
            V = new Ft();
          let j = null;
          const F = new de(0);
          let k = 0,
            z = t.width,
            O = t.height,
            L = 1,
            U = null,
            W = null;
          const Z = new Ft(0, 0, z, O),
            B = new Ft(0, 0, z, O);
          let q = !1;
          const le = new Wb();
          let te = !1,
            ce = !1,
            Ce = null;
          const ve = new Ae(),
            xe = new $(),
            Ze = new A(),
            dt = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          function Ue() {
            return null === S ? L : 1;
          }
          let ie,
            pe,
            oe,
            ze,
            Pe,
            Oe,
            et,
            Tt,
            an,
            I,
            T,
            Q,
            fe,
            he,
            R,
            ae,
            ue,
            Y,
            ke,
            We,
            Ve,
            Be,
            Fe,
            tt,
            P = i;
          function ge(D, X) {
            for (let ee = 0; ee < D.length; ee++) {
              const ne = t.getContext(D[ee], X);
              if (null !== ne) return ne;
            }
            return null;
          }
          try {
            const D = {
              alpha: !0,
              depth: r,
              stencil: s,
              antialias: a,
              premultipliedAlpha: l,
              preserveDrawingBuffer: c,
              powerPreference: u,
              failIfMajorPerformanceCaveat: d,
            };
            if (
              ("setAttribute" in t &&
                t.setAttribute("data-engine", "three.js r154"),
              t.addEventListener("webglcontextlost", we, !1),
              t.addEventListener("webglcontextrestored", K, !1),
              t.addEventListener("webglcontextcreationerror", _e, !1),
              null === P)
            ) {
              const X = ["webgl2", "webgl", "experimental-webgl"];
              if (
                (!0 === v.isWebGL1Renderer && X.shift(),
                (P = ge(X, D)),
                null === P)
              )
                throw ge(X)
                  ? new Error(
                      "Error creating WebGL context with your selected attributes."
                    )
                  : new Error("Error creating WebGL context.");
            }
            typeof WebGLRenderingContext < "u" &&
              P instanceof WebGLRenderingContext &&
              console.warn(
                "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
              ),
              void 0 === P.getShaderPrecisionFormat &&
                (P.getShaderPrecisionFormat = function () {
                  return { rangeMin: 1, rangeMax: 1, precision: 1 };
                });
          } catch (D) {
            throw (console.error("THREE.WebGLRenderer: " + D.message), D);
          }
          function Dt() {
            (ie = new rY(P)),
              (pe = new Qq(P, ie, e)),
              ie.init(pe),
              (Be = new UZ(P, ie, pe)),
              (oe = new kZ(P, ie, pe)),
              (ze = new aY(P)),
              (Pe = new EZ()),
              (Oe = new BZ(P, ie, oe, Pe, pe, Be, ze)),
              (et = new eY(v)),
              (Tt = new iY(v)),
              (an = new $X(P, pe)),
              (Fe = new Kq(P, ie, an, pe)),
              (I = new sY(P, an, ze, Fe)),
              (T = new dY(P, I, an, ze)),
              (ke = new uY(P, pe, Oe)),
              (ae = new Jq(Pe)),
              (Q = new SZ(v, et, Tt, ie, pe, Fe, ae)),
              (fe = new WZ(v, Pe)),
              (he = new TZ()),
              (R = new OZ(ie, pe)),
              (Y = new Zq(v, et, Tt, oe, T, h, l)),
              (ue = new NZ(v, T, pe)),
              (tt = new jZ(P, ze, pe, oe)),
              (We = new $q(P, ie, ze, pe)),
              (Ve = new oY(P, ie, ze, pe)),
              (ze.programs = Q.programs),
              (v.capabilities = pe),
              (v.extensions = ie),
              (v.properties = Pe),
              (v.renderLists = he),
              (v.shadowMap = ue),
              (v.state = oe),
              (v.info = ze);
          }
          Dt();
          const N = new GZ(v, P);
          function we(D) {
            D.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (b = !0);
          }
          function K() {
            console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
            const D = ze.autoReset,
              X = ue.enabled,
              ee = ue.autoUpdate,
              H = ue.needsUpdate,
              ne = ue.type;
            Dt(),
              (ze.autoReset = D),
              (ue.enabled = X),
              (ue.autoUpdate = ee),
              (ue.needsUpdate = H),
              (ue.type = ne);
          }
          function _e(D) {
            console.error(
              "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
              D.statusMessage
            );
          }
          function Te(D) {
            const X = D.target;
            X.removeEventListener("dispose", Te),
              (function Nt(D) {
                (function gn(D) {
                  const X = Pe.get(D).programs;
                  void 0 !== X &&
                    (X.forEach(function (ee) {
                      Q.releaseProgram(ee);
                    }),
                    D.isShaderMaterial && Q.releaseShaderCache(D));
                })(D),
                  Pe.remove(D);
              })(X);
          }
          (this.xr = N),
            (this.getContext = function () {
              return P;
            }),
            (this.getContextAttributes = function () {
              return P.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const D = ie.get("WEBGL_lose_context");
              D && D.loseContext();
            }),
            (this.forceContextRestore = function () {
              const D = ie.get("WEBGL_lose_context");
              D && D.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return L;
            }),
            (this.setPixelRatio = function (D) {
              void 0 !== D && ((L = D), this.setSize(z, O, !1));
            }),
            (this.getSize = function (D) {
              return D.set(z, O);
            }),
            (this.setSize = function (D, X, ee = !0) {
              N.isPresenting
                ? console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                  )
                : ((z = D),
                  (O = X),
                  (t.width = Math.floor(D * L)),
                  (t.height = Math.floor(X * L)),
                  !0 === ee &&
                    ((t.style.width = D + "px"), (t.style.height = X + "px")),
                  this.setViewport(0, 0, D, X));
            }),
            (this.getDrawingBufferSize = function (D) {
              return D.set(z * L, O * L).floor();
            }),
            (this.setDrawingBufferSize = function (D, X, ee) {
              (z = D),
                (O = X),
                (L = ee),
                (t.width = Math.floor(D * ee)),
                (t.height = Math.floor(X * ee)),
                this.setViewport(0, 0, D, X);
            }),
            (this.getCurrentViewport = function (D) {
              return D.copy(E);
            }),
            (this.getViewport = function (D) {
              return D.copy(Z);
            }),
            (this.setViewport = function (D, X, ee, H) {
              D.isVector4 ? Z.set(D.x, D.y, D.z, D.w) : Z.set(D, X, ee, H),
                oe.viewport(E.copy(Z).multiplyScalar(L).floor());
            }),
            (this.getScissor = function (D) {
              return D.copy(B);
            }),
            (this.setScissor = function (D, X, ee, H) {
              D.isVector4 ? B.set(D.x, D.y, D.z, D.w) : B.set(D, X, ee, H),
                oe.scissor(V.copy(B).multiplyScalar(L).floor());
            }),
            (this.getScissorTest = function () {
              return q;
            }),
            (this.setScissorTest = function (D) {
              oe.setScissorTest((q = D));
            }),
            (this.setOpaqueSort = function (D) {
              U = D;
            }),
            (this.setTransparentSort = function (D) {
              W = D;
            }),
            (this.getClearColor = function (D) {
              return D.copy(Y.getClearColor());
            }),
            (this.setClearColor = function () {
              Y.setClearColor.apply(Y, arguments);
            }),
            (this.getClearAlpha = function () {
              return Y.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              Y.setClearAlpha.apply(Y, arguments);
            }),
            (this.clear = function (D = !0, X = !0, ee = !0) {
              let H = 0;
              if (D) {
                let ne = !1;
                if (null !== S) {
                  const Ne = S.texture.format;
                  ne = Ne === _R || Ne === gR || Ne === mR;
                }
                if (ne) {
                  const Ne = S.texture.type,
                    Qe =
                      Ne === Oo ||
                      Ne === Lo ||
                      Ne === ub ||
                      Ne === Ta ||
                      Ne === fR ||
                      Ne === pR,
                    nt = Y.getClearColor(),
                    ot = Y.getClearAlpha(),
                    At = nt.r,
                    ht = nt.g,
                    bt = nt.b;
                  Qe
                    ? ((f[0] = At),
                      (f[1] = ht),
                      (f[2] = bt),
                      (f[3] = ot),
                      P.clearBufferuiv(P.COLOR, 0, f))
                    : ((p[0] = At),
                      (p[1] = ht),
                      (p[2] = bt),
                      (p[3] = ot),
                      P.clearBufferiv(P.COLOR, 0, p));
                } else H |= P.COLOR_BUFFER_BIT;
              }
              X && (H |= P.DEPTH_BUFFER_BIT),
                ee && (H |= P.STENCIL_BUFFER_BIT),
                P.clear(H);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              t.removeEventListener("webglcontextlost", we, !1),
                t.removeEventListener("webglcontextrestored", K, !1),
                t.removeEventListener("webglcontextcreationerror", _e, !1),
                he.dispose(),
                R.dispose(),
                Pe.dispose(),
                et.dispose(),
                Tt.dispose(),
                T.dispose(),
                Fe.dispose(),
                tt.dispose(),
                Q.dispose(),
                N.dispose(),
                N.removeEventListener("sessionstart", wn),
                N.removeEventListener("sessionend", Ps),
                Ce && (Ce.dispose(), (Ce = null)),
                Oi.stop();
            }),
            (this.renderBufferDirect = function (D, X, ee, H, ne, Ne) {
              null === X && (X = dt);
              const Qe = ne.isMesh && ne.matrixWorld.determinant() < 0,
                nt = (function yse(D, X, ee, H, ne) {
                  !0 !== X.isScene && (X = dt), Oe.resetTextureUnits();
                  const Ne = X.fog,
                    nt =
                      null === S
                        ? v.outputColorSpace
                        : !0 === S.isXRRenderTarget
                        ? S.texture.colorSpace
                        : Kr,
                    ot = (H.isMeshStandardMaterial ? Tt : et).get(
                      H.envMap ||
                        (H.isMeshStandardMaterial ? X.environment : null)
                    ),
                    At =
                      !0 === H.vertexColors &&
                      !!ee.attributes.color &&
                      4 === ee.attributes.color.itemSize,
                    ht =
                      !!ee.attributes.tangent &&
                      (!!H.normalMap || H.anisotropy > 0),
                    bt = !!ee.morphAttributes.position,
                    Mn = !!ee.morphAttributes.normal,
                    Pn = !!ee.morphAttributes.color,
                    as = H.toneMapped ? v.toneMapping : Qs,
                    yo =
                      ee.morphAttributes.position ||
                      ee.morphAttributes.normal ||
                      ee.morphAttributes.color,
                    Bn = void 0 !== yo ? yo.length : 0,
                    Pt = Pe.get(H),
                    kM = m.state.lights;
                  !0 !== te ||
                    (!0 !== ce && D === w) ||
                    ae.setState(H, D, D === w && H.id === C);
                  let ei = !1;
                  H.version === Pt.__version
                    ? ((Pt.needsLights &&
                        Pt.lightsStateVersion !== kM.state.version) ||
                        Pt.outputColorSpace !== nt ||
                        (ne.isInstancedMesh && !1 === Pt.instancing) ||
                        (!ne.isInstancedMesh && !0 === Pt.instancing) ||
                        (ne.isSkinnedMesh && !1 === Pt.skinning) ||
                        (!ne.isSkinnedMesh && !0 === Pt.skinning) ||
                        Pt.envMap !== ot ||
                        (!0 === H.fog && Pt.fog !== Ne) ||
                        (void 0 !== Pt.numClippingPlanes &&
                          (Pt.numClippingPlanes !== ae.numPlanes ||
                            Pt.numIntersection !== ae.numIntersection)) ||
                        Pt.vertexAlphas !== At ||
                        Pt.vertexTangents !== ht ||
                        Pt.morphTargets !== bt ||
                        Pt.morphNormals !== Mn ||
                        Pt.morphColors !== Pn ||
                        Pt.toneMapping !== as ||
                        (!0 === pe.isWebGL2 && Pt.morphTargetsCount !== Bn)) &&
                      (ei = !0)
                    : ((ei = !0), (Pt.__version = H.version));
                  let rl = Pt.currentProgram;
                  !0 === ei && (rl = m_(H, X, ne));
                  let JN = !1,
                    $h = !1,
                    BM = !1;
                  const Li = rl.getUniforms(),
                    sl = Pt.uniforms;
                  if (
                    (oe.useProgram(rl.program) &&
                      ((JN = !0), ($h = !0), (BM = !0)),
                    H.id !== C && ((C = H.id), ($h = !0)),
                    JN || w !== D)
                  ) {
                    if (
                      (Li.setValue(P, "projectionMatrix", D.projectionMatrix),
                      pe.logarithmicDepthBuffer &&
                        Li.setValue(
                          P,
                          "logDepthBufFC",
                          2 / (Math.log(D.far + 1) / Math.LN2)
                        ),
                      w !== D && ((w = D), ($h = !0), (BM = !0)),
                      H.isShaderMaterial ||
                        H.isMeshPhongMaterial ||
                        H.isMeshToonMaterial ||
                        H.isMeshStandardMaterial ||
                        H.envMap)
                    ) {
                      const hr = Li.map.cameraPosition;
                      void 0 !== hr &&
                        hr.setValue(P, Ze.setFromMatrixPosition(D.matrixWorld));
                    }
                    (H.isMeshPhongMaterial ||
                      H.isMeshToonMaterial ||
                      H.isMeshLambertMaterial ||
                      H.isMeshBasicMaterial ||
                      H.isMeshStandardMaterial ||
                      H.isShaderMaterial) &&
                      Li.setValue(
                        P,
                        "isOrthographic",
                        !0 === D.isOrthographicCamera
                      ),
                      (H.isMeshPhongMaterial ||
                        H.isMeshToonMaterial ||
                        H.isMeshLambertMaterial ||
                        H.isMeshBasicMaterial ||
                        H.isMeshStandardMaterial ||
                        H.isShaderMaterial ||
                        H.isShadowMaterial ||
                        ne.isSkinnedMesh) &&
                        Li.setValue(P, "viewMatrix", D.matrixWorldInverse);
                  }
                  if (ne.isSkinnedMesh) {
                    Li.setOptional(P, ne, "bindMatrix"),
                      Li.setOptional(P, ne, "bindMatrixInverse");
                    const hr = ne.skeleton;
                    hr &&
                      (pe.floatVertexTextures
                        ? (null === hr.boneTexture && hr.computeBoneTexture(),
                          Li.setValue(P, "boneTexture", hr.boneTexture, Oe),
                          Li.setValue(P, "boneTextureSize", hr.boneTextureSize))
                        : console.warn(
                            "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                          ));
                  }
                  const UM = ee.morphAttributes;
                  if (
                    ((void 0 !== UM.position ||
                      void 0 !== UM.normal ||
                      (void 0 !== UM.color && !0 === pe.isWebGL2)) &&
                      ke.update(ne, ee, rl),
                    ($h || Pt.receiveShadow !== ne.receiveShadow) &&
                      ((Pt.receiveShadow = ne.receiveShadow),
                      Li.setValue(P, "receiveShadow", ne.receiveShadow)),
                    H.isMeshGouraudMaterial &&
                      null !== H.envMap &&
                      ((sl.envMap.value = ot),
                      (sl.flipEnvMap.value =
                        ot.isCubeTexture && !1 === ot.isRenderTargetTexture
                          ? -1
                          : 1)),
                    $h &&
                      (Li.setValue(
                        P,
                        "toneMappingExposure",
                        v.toneMappingExposure
                      ),
                      Pt.needsLights &&
                        (function bse(D, X) {
                          (D.ambientLightColor.needsUpdate = X),
                            (D.lightProbe.needsUpdate = X),
                            (D.directionalLights.needsUpdate = X),
                            (D.directionalLightShadows.needsUpdate = X),
                            (D.pointLights.needsUpdate = X),
                            (D.pointLightShadows.needsUpdate = X),
                            (D.spotLights.needsUpdate = X),
                            (D.spotLightShadows.needsUpdate = X),
                            (D.rectAreaLights.needsUpdate = X),
                            (D.hemisphereLights.needsUpdate = X);
                        })(sl, BM),
                      Ne && !0 === H.fog && fe.refreshFogUniforms(sl, Ne),
                      fe.refreshMaterialUniforms(sl, H, L, O, Ce),
                      Lm.upload(P, Pt.uniformsList, sl, Oe)),
                    H.isShaderMaterial &&
                      !0 === H.uniformsNeedUpdate &&
                      (Lm.upload(P, Pt.uniformsList, sl, Oe),
                      (H.uniformsNeedUpdate = !1)),
                    H.isSpriteMaterial && Li.setValue(P, "center", ne.center),
                    Li.setValue(P, "modelViewMatrix", ne.modelViewMatrix),
                    Li.setValue(P, "normalMatrix", ne.normalMatrix),
                    Li.setValue(P, "modelMatrix", ne.matrixWorld),
                    H.isShaderMaterial || H.isRawShaderMaterial)
                  ) {
                    const hr = H.uniformsGroups;
                    for (let VM = 0, wse = hr.length; VM < wse; VM++)
                      if (pe.isWebGL2) {
                        const ek = hr[VM];
                        tt.update(ek, rl), tt.bind(ek, rl);
                      } else
                        console.warn(
                          "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                        );
                  }
                  return rl;
                })(D, X, ee, H, ne);
              oe.setMaterial(H, Qe);
              let ot = ee.index,
                At = 1;
              !0 === H.wireframe &&
                ((ot = I.getWireframeAttribute(ee)), (At = 2));
              const ht = ee.drawRange,
                bt = ee.attributes.position;
              let Mn = ht.start * At,
                Pn = (ht.start + ht.count) * At;
              null !== Ne &&
                ((Mn = Math.max(Mn, Ne.start * At)),
                (Pn = Math.min(Pn, (Ne.start + Ne.count) * At))),
                null !== ot
                  ? ((Mn = Math.max(Mn, 0)), (Pn = Math.min(Pn, ot.count)))
                  : null != bt &&
                    ((Mn = Math.max(Mn, 0)), (Pn = Math.min(Pn, bt.count)));
              const as = Pn - Mn;
              if (as < 0 || as === 1 / 0) return;
              Fe.setup(ne, H, nt, ee, ot);
              let yo,
                Bn = We;
              if (
                (null !== ot && ((yo = an.get(ot)), (Bn = Ve), Bn.setIndex(yo)),
                ne.isMesh)
              )
                !0 === H.wireframe
                  ? (oe.setLineWidth(H.wireframeLinewidth * Ue()),
                    Bn.setMode(P.LINES))
                  : Bn.setMode(P.TRIANGLES);
              else if (ne.isLine) {
                let Pt = H.linewidth;
                void 0 === Pt && (Pt = 1),
                  oe.setLineWidth(Pt * Ue()),
                  Bn.setMode(
                    ne.isLineSegments
                      ? P.LINES
                      : ne.isLineLoop
                      ? P.LINE_LOOP
                      : P.LINE_STRIP
                  );
              } else
                ne.isPoints
                  ? Bn.setMode(P.POINTS)
                  : ne.isSprite && Bn.setMode(P.TRIANGLES);
              if (ne.isInstancedMesh) Bn.renderInstances(Mn, as, ne.count);
              else if (ee.isInstancedBufferGeometry) {
                const kM = Math.min(
                  ee.instanceCount,
                  void 0 !== ee._maxInstanceCount ? ee._maxInstanceCount : 1 / 0
                );
                Bn.renderInstances(Mn, as, kM);
              } else Bn.render(Mn, as);
            }),
            (this.compile = function (D, X) {
              function ee(H, ne, Ne) {
                !0 === H.transparent &&
                H.side === Cr &&
                !1 === H.forceSinglePass
                  ? ((H.side = zi),
                    (H.needsUpdate = !0),
                    m_(H, ne, Ne),
                    (H.side = $s),
                    (H.needsUpdate = !0),
                    m_(H, ne, Ne),
                    (H.side = Cr))
                  : m_(H, ne, Ne);
              }
              (m = R.get(D)),
                m.init(),
                y.push(m),
                D.traverseVisible(function (H) {
                  H.isLight &&
                    H.layers.test(X.layers) &&
                    (m.pushLight(H), H.castShadow && m.pushShadow(H));
                }),
                m.setupLights(v.useLegacyLights),
                D.traverse(function (H) {
                  const ne = H.material;
                  if (ne)
                    if (Array.isArray(ne))
                      for (let Ne = 0; Ne < ne.length; Ne++) ee(ne[Ne], D, H);
                    else ee(ne, D, H);
                }),
                y.pop(),
                (m = null);
            });
          let Jn = null;
          function wn() {
            Oi.stop();
          }
          function Ps() {
            Oi.start();
          }
          const Oi = new vP();
          function ZN(D, X, ee, H) {
            if (!1 === D.visible) return;
            if (D.layers.test(X.layers))
              if (D.isGroup) ee = D.renderOrder;
              else if (D.isLOD) !0 === D.autoUpdate && D.update(X);
              else if (D.isLight)
                m.pushLight(D), D.castShadow && m.pushShadow(D);
              else if (D.isSprite) {
                if (!D.frustumCulled || le.intersectsSprite(D)) {
                  H && Ze.setFromMatrixPosition(D.matrixWorld).applyMatrix4(ve);
                  const Qe = T.update(D),
                    nt = D.material;
                  nt.visible && _.push(D, Qe, nt, ee, Ze.z, null);
                }
              } else if (
                (D.isMesh || D.isLine || D.isPoints) &&
                (!D.frustumCulled || le.intersectsObject(D))
              ) {
                const Qe = T.update(D),
                  nt = D.material;
                if (
                  (H &&
                    (void 0 !== D.boundingSphere
                      ? (null === D.boundingSphere && D.computeBoundingSphere(),
                        Ze.copy(D.boundingSphere.center))
                      : (null === Qe.boundingSphere &&
                          Qe.computeBoundingSphere(),
                        Ze.copy(Qe.boundingSphere.center)),
                    Ze.applyMatrix4(D.matrixWorld).applyMatrix4(ve)),
                  Array.isArray(nt))
                ) {
                  const ot = Qe.groups;
                  for (let At = 0, ht = ot.length; At < ht; At++) {
                    const bt = ot[At],
                      Mn = nt[bt.materialIndex];
                    Mn && Mn.visible && _.push(D, Qe, Mn, ee, Ze.z, bt);
                  }
                } else nt.visible && _.push(D, Qe, nt, ee, Ze.z, null);
              }
            const Ne = D.children;
            for (let Qe = 0, nt = Ne.length; Qe < nt; Qe++)
              ZN(Ne[Qe], X, ee, H);
          }
          function KN(D, X, ee, H) {
            const ne = D.opaque,
              Ne = D.transmissive,
              Qe = D.transparent;
            m.setupLightsView(ee),
              !0 === te && ae.setGlobalState(v.clippingPlanes, ee),
              Ne.length > 0 &&
                (function vse(D, X, ee, H) {
                  const ne = pe.isWebGL2;
                  null === Ce &&
                    (Ce = new li(1, 1, {
                      generateMipmaps: !0,
                      type: ie.has("EXT_color_buffer_half_float") ? Hi : Oo,
                      minFilter: eo,
                      samples: ne ? 4 : 0,
                    })),
                    v.getDrawingBufferSize(xe),
                    ne
                      ? Ce.setSize(xe.x, xe.y)
                      : Ce.setSize(um(xe.x), um(xe.y));
                  const Ne = v.getRenderTarget();
                  v.setRenderTarget(Ce),
                    v.getClearColor(F),
                    (k = v.getClearAlpha()),
                    k < 1 && v.setClearColor(16777215, 0.5),
                    v.clear();
                  const Qe = v.toneMapping;
                  (v.toneMapping = Qs),
                    p_(D, ee, H),
                    Oe.updateMultisampleRenderTarget(Ce),
                    Oe.updateRenderTargetMipmap(Ce);
                  let nt = !1;
                  for (let ot = 0, At = X.length; ot < At; ot++) {
                    const ht = X[ot],
                      bt = ht.object,
                      Mn = ht.geometry,
                      Pn = ht.material,
                      as = ht.group;
                    if (Pn.side === Cr && bt.layers.test(H.layers)) {
                      const yo = Pn.side;
                      (Pn.side = zi),
                        (Pn.needsUpdate = !0),
                        $N(bt, ee, H, Mn, Pn, as),
                        (Pn.side = yo),
                        (Pn.needsUpdate = !0),
                        (nt = !0);
                    }
                  }
                  !0 === nt &&
                    (Oe.updateMultisampleRenderTarget(Ce),
                    Oe.updateRenderTargetMipmap(Ce)),
                    v.setRenderTarget(Ne),
                    v.setClearColor(F, k),
                    (v.toneMapping = Qe);
                })(ne, Ne, X, ee),
              H && oe.viewport(E.copy(H)),
              ne.length > 0 && p_(ne, X, ee),
              Ne.length > 0 && p_(Ne, X, ee),
              Qe.length > 0 && p_(Qe, X, ee),
              oe.buffers.depth.setTest(!0),
              oe.buffers.depth.setMask(!0),
              oe.buffers.color.setMask(!0),
              oe.setPolygonOffset(!1);
          }
          function p_(D, X, ee) {
            const H = !0 === X.isScene ? X.overrideMaterial : null;
            for (let ne = 0, Ne = D.length; ne < Ne; ne++) {
              const Qe = D[ne],
                nt = Qe.object,
                ot = Qe.geometry,
                At = null === H ? Qe.material : H,
                ht = Qe.group;
              nt.layers.test(ee.layers) && $N(nt, X, ee, ot, At, ht);
            }
          }
          function $N(D, X, ee, H, ne, Ne) {
            D.onBeforeRender(v, X, ee, H, ne, Ne),
              D.modelViewMatrix.multiplyMatrices(
                ee.matrixWorldInverse,
                D.matrixWorld
              ),
              D.normalMatrix.getNormalMatrix(D.modelViewMatrix),
              ne.onBeforeRender(v, X, ee, H, D, Ne),
              !0 === ne.transparent &&
              ne.side === Cr &&
              !1 === ne.forceSinglePass
                ? ((ne.side = zi),
                  (ne.needsUpdate = !0),
                  v.renderBufferDirect(ee, X, H, ne, D, Ne),
                  (ne.side = $s),
                  (ne.needsUpdate = !0),
                  v.renderBufferDirect(ee, X, H, ne, D, Ne),
                  (ne.side = Cr))
                : v.renderBufferDirect(ee, X, H, ne, D, Ne),
              D.onAfterRender(v, X, ee, H, ne, Ne);
          }
          function m_(D, X, ee) {
            !0 !== X.isScene && (X = dt);
            const H = Pe.get(D),
              ne = m.state.lights,
              Qe = ne.state.version,
              nt = Q.getParameters(D, ne.state, m.state.shadowsArray, X, ee),
              ot = Q.getProgramCacheKey(nt);
            let At = H.programs;
            (H.environment = D.isMeshStandardMaterial ? X.environment : null),
              (H.fog = X.fog),
              (H.envMap = (D.isMeshStandardMaterial ? Tt : et).get(
                D.envMap || H.environment
              )),
              void 0 === At &&
                (D.addEventListener("dispose", Te),
                (At = new Map()),
                (H.programs = At));
            let ht = At.get(ot);
            if (void 0 !== ht) {
              if (H.currentProgram === ht && H.lightsStateVersion === Qe)
                return QN(D, nt), ht;
            } else
              (nt.uniforms = Q.getUniforms(D)),
                D.onBuild(ee, nt, v),
                D.onBeforeCompile(nt, v),
                (ht = Q.acquireProgram(nt, ot)),
                At.set(ot, ht),
                (H.uniforms = nt.uniforms);
            const bt = H.uniforms;
            ((!D.isShaderMaterial && !D.isRawShaderMaterial) ||
              !0 === D.clipping) &&
              (bt.clippingPlanes = ae.uniform),
              QN(D, nt),
              (H.needsLights = (function xse(D) {
                return (
                  D.isMeshLambertMaterial ||
                  D.isMeshToonMaterial ||
                  D.isMeshPhongMaterial ||
                  D.isMeshStandardMaterial ||
                  D.isShadowMaterial ||
                  (D.isShaderMaterial && !0 === D.lights)
                );
              })(D)),
              (H.lightsStateVersion = Qe),
              H.needsLights &&
                ((bt.ambientLightColor.value = ne.state.ambient),
                (bt.lightProbe.value = ne.state.probe),
                (bt.directionalLights.value = ne.state.directional),
                (bt.directionalLightShadows.value = ne.state.directionalShadow),
                (bt.spotLights.value = ne.state.spot),
                (bt.spotLightShadows.value = ne.state.spotShadow),
                (bt.rectAreaLights.value = ne.state.rectArea),
                (bt.ltc_1.value = ne.state.rectAreaLTC1),
                (bt.ltc_2.value = ne.state.rectAreaLTC2),
                (bt.pointLights.value = ne.state.point),
                (bt.pointLightShadows.value = ne.state.pointShadow),
                (bt.hemisphereLights.value = ne.state.hemi),
                (bt.directionalShadowMap.value = ne.state.directionalShadowMap),
                (bt.directionalShadowMatrix.value =
                  ne.state.directionalShadowMatrix),
                (bt.spotShadowMap.value = ne.state.spotShadowMap),
                (bt.spotLightMatrix.value = ne.state.spotLightMatrix),
                (bt.spotLightMap.value = ne.state.spotLightMap),
                (bt.pointShadowMap.value = ne.state.pointShadowMap),
                (bt.pointShadowMatrix.value = ne.state.pointShadowMatrix));
            const Mn = ht.getUniforms(),
              Pn = Lm.seqWithValue(Mn.seq, bt);
            return (H.currentProgram = ht), (H.uniformsList = Pn), ht;
          }
          function QN(D, X) {
            const ee = Pe.get(D);
            (ee.outputColorSpace = X.outputColorSpace),
              (ee.instancing = X.instancing),
              (ee.skinning = X.skinning),
              (ee.morphTargets = X.morphTargets),
              (ee.morphNormals = X.morphNormals),
              (ee.morphColors = X.morphColors),
              (ee.morphTargetsCount = X.morphTargetsCount),
              (ee.numClippingPlanes = X.numClippingPlanes),
              (ee.numIntersection = X.numClipIntersection),
              (ee.vertexAlphas = X.vertexAlphas),
              (ee.vertexTangents = X.vertexTangents),
              (ee.toneMapping = X.toneMapping);
          }
          Oi.setAnimationLoop(function Rs(D) {
            Jn && Jn(D);
          }),
            typeof self < "u" && Oi.setContext(self),
            (this.setAnimationLoop = function (D) {
              (Jn = D),
                N.setAnimationLoop(D),
                null === D ? Oi.stop() : Oi.start();
            }),
            N.addEventListener("sessionstart", wn),
            N.addEventListener("sessionend", Ps),
            (this.render = function (D, X) {
              if (void 0 === X || !0 === X.isCamera) {
                if (!0 !== b) {
                  if (
                    (!0 === D.matrixWorldAutoUpdate && D.updateMatrixWorld(),
                    null === X.parent &&
                      !0 === X.matrixWorldAutoUpdate &&
                      X.updateMatrixWorld(),
                    !0 === N.enabled &&
                      !0 === N.isPresenting &&
                      (!0 === N.cameraAutoUpdate && N.updateCamera(X),
                      (X = N.getCamera())),
                    !0 === D.isScene && D.onBeforeRender(v, D, X, S),
                    (m = R.get(D, y.length)),
                    m.init(),
                    y.push(m),
                    ve.multiplyMatrices(
                      X.projectionMatrix,
                      X.matrixWorldInverse
                    ),
                    le.setFromProjectionMatrix(ve),
                    (ce = this.localClippingEnabled),
                    (te = ae.init(this.clippingPlanes, ce)),
                    (_ = he.get(D, g.length)),
                    _.init(),
                    g.push(_),
                    ZN(D, X, 0, v.sortObjects),
                    _.finish(),
                    !0 === v.sortObjects && _.sort(U, W),
                    this.info.render.frame++,
                    !0 === te && ae.beginShadows(),
                    ue.render(m.state.shadowsArray, D, X),
                    !0 === te && ae.endShadows(),
                    !0 === this.info.autoReset && this.info.reset(),
                    Y.render(_, D),
                    m.setupLights(v.useLegacyLights),
                    X.isArrayCamera)
                  ) {
                    const H = X.cameras;
                    for (let ne = 0, Ne = H.length; ne < Ne; ne++) {
                      const Qe = H[ne];
                      KN(_, D, Qe, Qe.viewport);
                    }
                  } else KN(_, D, X);
                  null !== S &&
                    (Oe.updateMultisampleRenderTarget(S),
                    Oe.updateRenderTargetMipmap(S)),
                    !0 === D.isScene && D.onAfterRender(v, D, X),
                    Fe.resetDefaultState(),
                    (C = -1),
                    (w = null),
                    y.pop(),
                    (m = y.length > 0 ? y[y.length - 1] : null),
                    g.pop(),
                    (_ = g.length > 0 ? g[g.length - 1] : null);
                }
              } else
                console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
            }),
            (this.getActiveCubeFace = function () {
              return x;
            }),
            (this.getActiveMipmapLevel = function () {
              return M;
            }),
            (this.getRenderTarget = function () {
              return S;
            }),
            (this.setRenderTargetTextures = function (D, X, ee) {
              (Pe.get(D.texture).__webglTexture = X),
                (Pe.get(D.depthTexture).__webglTexture = ee);
              const H = Pe.get(D);
              (H.__hasExternalTextures = !0),
                H.__hasExternalTextures &&
                  ((H.__autoAllocateDepthBuffer = void 0 === ee),
                  H.__autoAllocateDepthBuffer ||
                    (!0 === ie.has("WEBGL_multisampled_render_to_texture") &&
                      (console.warn(
                        "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                      ),
                      (H.__useRenderToTexture = !1))));
            }),
            (this.setRenderTargetFramebuffer = function (D, X) {
              const ee = Pe.get(D);
              (ee.__webglFramebuffer = X),
                (ee.__useDefaultFramebuffer = void 0 === X);
            }),
            (this.setRenderTarget = function (D, X = 0, ee = 0) {
              (S = D), (x = X), (M = ee);
              let H = !0,
                ne = null,
                Ne = !1,
                Qe = !1;
              if (D) {
                const ot = Pe.get(D);
                void 0 !== ot.__useDefaultFramebuffer
                  ? (oe.bindFramebuffer(P.FRAMEBUFFER, null), (H = !1))
                  : void 0 === ot.__webglFramebuffer
                  ? Oe.setupRenderTarget(D)
                  : ot.__hasExternalTextures &&
                    Oe.rebindTextures(
                      D,
                      Pe.get(D.texture).__webglTexture,
                      Pe.get(D.depthTexture).__webglTexture
                    );
                const At = D.texture;
                (At.isData3DTexture ||
                  At.isDataArrayTexture ||
                  At.isCompressedArrayTexture) &&
                  (Qe = !0);
                const ht = Pe.get(D).__webglFramebuffer;
                D.isWebGLCubeRenderTarget
                  ? ((ne = ht[X]), (Ne = !0))
                  : (ne =
                      pe.isWebGL2 &&
                      D.samples > 0 &&
                      !1 === Oe.useMultisampledRTT(D)
                        ? Pe.get(D).__webglMultisampledFramebuffer
                        : ht),
                  E.copy(D.viewport),
                  V.copy(D.scissor),
                  (j = D.scissorTest);
              } else
                E.copy(Z).multiplyScalar(L).floor(),
                  V.copy(B).multiplyScalar(L).floor(),
                  (j = q);
              if (
                (oe.bindFramebuffer(P.FRAMEBUFFER, ne) &&
                  pe.drawBuffers &&
                  H &&
                  oe.drawBuffers(D, ne),
                oe.viewport(E),
                oe.scissor(V),
                oe.setScissorTest(j),
                Ne)
              ) {
                const ot = Pe.get(D.texture);
                P.framebufferTexture2D(
                  P.FRAMEBUFFER,
                  P.COLOR_ATTACHMENT0,
                  P.TEXTURE_CUBE_MAP_POSITIVE_X + X,
                  ot.__webglTexture,
                  ee
                );
              } else if (Qe) {
                const ot = Pe.get(D.texture);
                P.framebufferTextureLayer(
                  P.FRAMEBUFFER,
                  P.COLOR_ATTACHMENT0,
                  ot.__webglTexture,
                  ee || 0,
                  X || 0
                );
              }
              C = -1;
            }),
            (this.readRenderTargetPixels = function (D, X, ee, H, ne, Ne, Qe) {
              if (!D || !D.isWebGLRenderTarget)
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let nt = Pe.get(D).__webglFramebuffer;
              if (
                (D.isWebGLCubeRenderTarget && void 0 !== Qe && (nt = nt[Qe]),
                nt)
              ) {
                oe.bindFramebuffer(P.FRAMEBUFFER, nt);
                try {
                  const ot = D.texture,
                    At = ot.format,
                    ht = ot.type;
                  if (
                    At !== Tr &&
                    Be.convert(At) !==
                      P.getParameter(P.IMPLEMENTATION_COLOR_READ_FORMAT)
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  const bt =
                    ht === Hi &&
                    (ie.has("EXT_color_buffer_half_float") ||
                      (pe.isWebGL2 && ie.has("EXT_color_buffer_float")));
                  if (
                    !(
                      ht === Oo ||
                      Be.convert(ht) ===
                        P.getParameter(P.IMPLEMENTATION_COLOR_READ_TYPE) ||
                      (ht === to &&
                        (pe.isWebGL2 ||
                          ie.has("OES_texture_float") ||
                          ie.has("WEBGL_color_buffer_float"))) ||
                      bt
                    )
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  X >= 0 &&
                    X <= D.width - H &&
                    ee >= 0 &&
                    ee <= D.height - ne &&
                    P.readPixels(
                      X,
                      ee,
                      H,
                      ne,
                      Be.convert(At),
                      Be.convert(ht),
                      Ne
                    );
                } finally {
                  const ot = null !== S ? Pe.get(S).__webglFramebuffer : null;
                  oe.bindFramebuffer(P.FRAMEBUFFER, ot);
                }
              }
            }),
            (this.copyFramebufferToTexture = function (D, X, ee = 0) {
              const H = Math.pow(2, -ee),
                ne = Math.floor(X.image.width * H),
                Ne = Math.floor(X.image.height * H);
              Oe.setTexture2D(X, 0),
                P.copyTexSubImage2D(P.TEXTURE_2D, ee, 0, 0, D.x, D.y, ne, Ne),
                oe.unbindTexture();
            }),
            (this.copyTextureToTexture = function (D, X, ee, H = 0) {
              const ne = X.image.width,
                Ne = X.image.height,
                Qe = Be.convert(ee.format),
                nt = Be.convert(ee.type);
              Oe.setTexture2D(ee, 0),
                P.pixelStorei(P.UNPACK_FLIP_Y_WEBGL, ee.flipY),
                P.pixelStorei(
                  P.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  ee.premultiplyAlpha
                ),
                P.pixelStorei(P.UNPACK_ALIGNMENT, ee.unpackAlignment),
                X.isDataTexture
                  ? P.texSubImage2D(
                      P.TEXTURE_2D,
                      H,
                      D.x,
                      D.y,
                      ne,
                      Ne,
                      Qe,
                      nt,
                      X.image.data
                    )
                  : X.isCompressedTexture
                  ? P.compressedTexSubImage2D(
                      P.TEXTURE_2D,
                      H,
                      D.x,
                      D.y,
                      X.mipmaps[0].width,
                      X.mipmaps[0].height,
                      Qe,
                      X.mipmaps[0].data
                    )
                  : P.texSubImage2D(P.TEXTURE_2D, H, D.x, D.y, Qe, nt, X.image),
                0 === H && ee.generateMipmaps && P.generateMipmap(P.TEXTURE_2D),
                oe.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (D, X, ee, H, ne = 0) {
              if (v.isWebGL1Renderer)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                );
              const Ne = D.max.x - D.min.x + 1,
                Qe = D.max.y - D.min.y + 1,
                nt = D.max.z - D.min.z + 1,
                ot = Be.convert(H.format),
                At = Be.convert(H.type);
              let ht;
              if (H.isData3DTexture) Oe.setTexture3D(H, 0), (ht = P.TEXTURE_3D);
              else {
                if (!H.isDataArrayTexture)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                  );
                Oe.setTexture2DArray(H, 0), (ht = P.TEXTURE_2D_ARRAY);
              }
              P.pixelStorei(P.UNPACK_FLIP_Y_WEBGL, H.flipY),
                P.pixelStorei(
                  P.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  H.premultiplyAlpha
                ),
                P.pixelStorei(P.UNPACK_ALIGNMENT, H.unpackAlignment);
              const bt = P.getParameter(P.UNPACK_ROW_LENGTH),
                Mn = P.getParameter(P.UNPACK_IMAGE_HEIGHT),
                Pn = P.getParameter(P.UNPACK_SKIP_PIXELS),
                as = P.getParameter(P.UNPACK_SKIP_ROWS),
                yo = P.getParameter(P.UNPACK_SKIP_IMAGES),
                Bn = ee.isCompressedTexture ? ee.mipmaps[0] : ee.image;
              P.pixelStorei(P.UNPACK_ROW_LENGTH, Bn.width),
                P.pixelStorei(P.UNPACK_IMAGE_HEIGHT, Bn.height),
                P.pixelStorei(P.UNPACK_SKIP_PIXELS, D.min.x),
                P.pixelStorei(P.UNPACK_SKIP_ROWS, D.min.y),
                P.pixelStorei(P.UNPACK_SKIP_IMAGES, D.min.z),
                ee.isDataTexture || ee.isData3DTexture
                  ? P.texSubImage3D(
                      ht,
                      ne,
                      X.x,
                      X.y,
                      X.z,
                      Ne,
                      Qe,
                      nt,
                      ot,
                      At,
                      Bn.data
                    )
                  : ee.isCompressedArrayTexture
                  ? (console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                    ),
                    P.compressedTexSubImage3D(
                      ht,
                      ne,
                      X.x,
                      X.y,
                      X.z,
                      Ne,
                      Qe,
                      nt,
                      ot,
                      Bn.data
                    ))
                  : P.texSubImage3D(
                      ht,
                      ne,
                      X.x,
                      X.y,
                      X.z,
                      Ne,
                      Qe,
                      nt,
                      ot,
                      At,
                      Bn
                    ),
                P.pixelStorei(P.UNPACK_ROW_LENGTH, bt),
                P.pixelStorei(P.UNPACK_IMAGE_HEIGHT, Mn),
                P.pixelStorei(P.UNPACK_SKIP_PIXELS, Pn),
                P.pixelStorei(P.UNPACK_SKIP_ROWS, as),
                P.pixelStorei(P.UNPACK_SKIP_IMAGES, yo),
                0 === ne && H.generateMipmaps && P.generateMipmap(ht),
                oe.unbindTexture();
            }),
            (this.initTexture = function (D) {
              D.isCubeTexture
                ? Oe.setTextureCube(D, 0)
                : D.isData3DTexture
                ? Oe.setTexture3D(D, 0)
                : D.isDataArrayTexture || D.isCompressedArrayTexture
                ? Oe.setTexture2DArray(D, 0)
                : Oe.setTexture2D(D, 0),
                oe.unbindTexture();
            }),
            (this.resetState = function () {
              (x = 0), (M = 0), (S = null), oe.reset(), Fe.reset();
            }),
            typeof __THREE_DEVTOOLS__ < "u" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        get coordinateSystem() {
          return no;
        }
        get physicallyCorrectLights() {
          return (
            console.warn(
              "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
            ),
            !this.useLegacyLights
          );
        }
        set physicallyCorrectLights(e) {
          console.warn(
            "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
          ),
            (this.useLegacyLights = !e);
        }
        get outputEncoding() {
          return (
            console.warn(
              "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
            ),
            this.outputColorSpace === qe ? Fo : 3e3
          );
        }
        set outputEncoding(e) {
          console.warn(
            "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
          ),
            (this.outputColorSpace = e === Fo ? qe : Kr);
        }
      }
      (class qZ extends XP {}).prototype.isWebGL1Renderer = !0;
      class qP extends Dn {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.overrideMaterial = null),
            typeof __THREE_DEVTOOLS__ < "u" &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment &&
              (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            (this.backgroundBlurriness = e.backgroundBlurriness),
            (this.backgroundIntensity = e.backgroundIntensity),
            null !== e.overrideMaterial &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
              (t.object.backgroundBlurriness = this.backgroundBlurriness),
            1 !== this.backgroundIntensity &&
              (t.object.backgroundIntensity = this.backgroundIntensity),
            t
          );
        }
      }
      class ex {
        constructor(e, t) {
          (this.isInterleavedBuffer = !0),
            (this.array = e),
            (this.stride = t),
            (this.count = void 0 !== e ? e.length / t : 0),
            (this.usage = 35044),
            (this.updateRange = { offset: 0, count: -1 }),
            (this.version = 0),
            (this.uuid = ir());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, i) {
          (e *= this.stride), (i *= t.stride);
          for (let r = 0, s = this.stride; r < s; r++)
            this.array[e + r] = t.array[i + r];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = ir()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            i = new this.constructor(t, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = ir()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
              (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
                new Uint32Array(this.array.buffer)
              )),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      const Ii = new A();
      class Ua {
        constructor(e, t, i, r = !1) {
          (this.isInterleavedBufferAttribute = !0),
            (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = i),
            (this.normalized = r);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.data.count; t < i; t++)
            Ii.fromBufferAttribute(this, t),
              Ii.applyMatrix4(e),
              this.setXYZ(t, Ii.x, Ii.y, Ii.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++)
            Ii.fromBufferAttribute(this, t),
              Ii.applyNormalMatrix(e),
              this.setXYZ(t, Ii.x, Ii.y, Ii.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++)
            Ii.fromBufferAttribute(this, t),
              Ii.transformDirection(e),
              this.setXYZ(t, Ii.x, Ii.y, Ii.z);
          return this;
        }
        setX(e, t) {
          return (
            this.normalized && (t = _t(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset] = t),
            this
          );
        }
        setY(e, t) {
          return (
            this.normalized && (t = _t(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 1] = t),
            this
          );
        }
        setZ(e, t) {
          return (
            this.normalized && (t = _t(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 2] = t),
            this
          );
        }
        setW(e, t) {
          return (
            this.normalized && (t = _t(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 3] = t),
            this
          );
        }
        getX(e) {
          let t = this.data.array[e * this.data.stride + this.offset];
          return this.normalized && (t = rr(t, this.array)), t;
        }
        getY(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 1];
          return this.normalized && (t = rr(t, this.array)), t;
        }
        getZ(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 2];
          return this.normalized && (t = rr(t, this.array)), t;
        }
        getW(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 3];
          return this.normalized && (t = rr(t, this.array)), t;
        }
        setXY(e, t, i) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = _t(t, this.array)), (i = _t(i, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            this
          );
        }
        setXYZ(e, t, i, r) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = _t(t, this.array)),
              (i = _t(i, this.array)),
              (r = _t(r, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            (this.data.array[e + 2] = r),
            this
          );
        }
        setXYZW(e, t, i, r, s) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = _t(t, this.array)),
              (i = _t(i, this.array)),
              (r = _t(r, this.array)),
              (s = _t(s, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = i),
            (this.data.array[e + 2] = r),
            (this.data.array[e + 3] = s),
            this
          );
        }
        clone(e) {
          if (void 0 === e) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
            );
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const r = i * this.data.stride + this.offset;
              for (let s = 0; s < this.itemSize; s++)
                t.push(this.data.array[r + s]);
            }
            return new on(
              new this.array.constructor(t),
              this.itemSize,
              this.normalized
            );
          }
          return (
            void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] &&
              (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Ua(
              e.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized
            )
          );
        }
        toJSON(e) {
          if (void 0 === e) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
            );
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const r = i * this.data.stride + this.offset;
              for (let s = 0; s < this.itemSize; s++)
                t.push(this.data.array[r + s]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized,
            };
          }
          return (
            void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] &&
              (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          );
        }
      }
      const JP = new A(),
        eO = new Ft(),
        tO = new Ft(),
        KZ = new A(),
        nO = new Ae(),
        Kc = new A(),
        nx = new Jr(),
        iO = new Ae(),
        ix = new Qd();
      class rx extends Kn {
        constructor(e, t) {
          super(e, t),
            (this.isSkinnedMesh = !0),
            (this.type = "SkinnedMesh"),
            (this.bindMode = "attached"),
            (this.bindMatrix = new Ae()),
            (this.bindMatrixInverse = new Ae()),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        }
        computeBoundingBox() {
          const e = this.geometry;
          null === this.boundingBox && (this.boundingBox = new Ms()),
            this.boundingBox.makeEmpty();
          const t = e.getAttribute("position");
          for (let i = 0; i < t.count; i++)
            Kc.fromBufferAttribute(t, i),
              this.applyBoneTransform(i, Kc),
              this.boundingBox.expandByPoint(Kc);
        }
        computeBoundingSphere() {
          const e = this.geometry;
          null === this.boundingSphere && (this.boundingSphere = new Jr()),
            this.boundingSphere.makeEmpty();
          const t = e.getAttribute("position");
          for (let i = 0; i < t.count; i++)
            Kc.fromBufferAttribute(t, i),
              this.applyBoneTransform(i, Kc),
              this.boundingSphere.expandByPoint(Kc);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        }
        raycast(e, t) {
          const r = this.matrixWorld;
          void 0 !== this.material &&
            (null === this.boundingSphere && this.computeBoundingSphere(),
            nx.copy(this.boundingSphere),
            nx.applyMatrix4(r),
            !1 !== e.ray.intersectsSphere(nx) &&
              (iO.copy(r).invert(),
              ix.copy(e.ray).applyMatrix4(iO),
              (null === this.boundingBox ||
                !1 !== ix.intersectsBox(this.boundingBox)) &&
                this._computeIntersections(e, t, ix)));
        }
        getVertexPosition(e, t) {
          return (
            super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            void 0 === t &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new Ft(),
            t = this.geometry.attributes.skinWeight;
          for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
              t.setXYZW(i, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        applyBoneTransform(e, t) {
          const i = this.skeleton,
            r = this.geometry;
          eO.fromBufferAttribute(r.attributes.skinIndex, e),
            tO.fromBufferAttribute(r.attributes.skinWeight, e),
            JP.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let s = 0; s < 4; s++) {
            const o = tO.getComponent(s);
            if (0 !== o) {
              const a = eO.getComponent(s);
              nO.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
                t.addScaledVector(KZ.copy(JP).applyMatrix4(nO), o);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
        boneTransform(e, t) {
          return (
            console.warn(
              "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
            ),
            this.applyBoneTransform(e, t)
          );
        }
      }
      class oh extends Dn {
        constructor() {
          super(), (this.isBone = !0), (this.type = "Bone");
        }
      }
      class ah extends Ai {
        constructor(
          e = null,
          t = 1,
          i = 1,
          r,
          s,
          o,
          a,
          l,
          c = hn,
          u = hn,
          d,
          h
        ) {
          super(null, o, a, l, c, u, r, s, d, h),
            (this.isDataTexture = !0),
            (this.image = { data: e, width: t, height: i }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      const rO = new Ae(),
        $Z = new Ae();
      class lh {
        constructor(e = [], t = []) {
          (this.uuid = ir()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            (this.boneTextureSize = 0),
            this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(16 * e.length)),
            0 === t.length)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let i = 0, r = this.bones.length; i < r; i++)
              this.boneInverses.push(new Ae());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new Ae();
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(i);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i &&
              (i.parent && i.parent.isBone
                ? (i.matrix.copy(i.parent.matrixWorld).invert(),
                  i.matrix.multiply(i.matrixWorld))
                : i.matrix.copy(i.matrixWorld),
              i.matrix.decompose(i.position, i.quaternion, i.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            i = this.boneMatrices,
            r = this.boneTexture;
          for (let s = 0, o = e.length; s < o; s++)
            rO.multiplyMatrices(e[s] ? e[s].matrixWorld : $Z, t[s]),
              rO.toArray(i, 16 * s);
          null !== r && (r.needsUpdate = !0);
        }
        clone() {
          return new lh(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(4 * this.bones.length);
          (e = KR(e)), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const i = new ah(t, e, e, Tr, to);
          return (
            (i.needsUpdate = !0),
            (this.boneMatrices = t),
            (this.boneTexture = i),
            (this.boneTextureSize = e),
            this
          );
        }
        getBoneByName(e) {
          for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e) return r;
          }
        }
        dispose() {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            void 0 === o &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", s),
              (o = new oh())),
              this.bones.push(o),
              this.boneInverses.push(new Ae().fromArray(e.boneInverses[i]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            i = this.boneInverses;
          for (let r = 0, s = t.length; r < s; r++)
            e.bones.push(t[r].uuid), e.boneInverses.push(i[r].toArray());
          return e;
        }
      }
      class ch extends on {
        constructor(e, t, i, r = 1) {
          super(e, t, i),
            (this.isInstancedBufferAttribute = !0),
            (this.meshPerAttribute = r);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      const $c = new Ae(),
        sO = new Ae(),
        Um = [],
        oO = new Ms(),
        QZ = new Ae(),
        uh = new Kn(),
        dh = new Jr();
      class aO extends Kn {
        constructor(e, t, i) {
          super(e, t),
            (this.isInstancedMesh = !0),
            (this.instanceMatrix = new ch(new Float32Array(16 * i), 16)),
            (this.instanceColor = null),
            (this.count = i),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          for (let r = 0; r < i; r++) this.setMatrixAt(r, QZ);
        }
        computeBoundingBox() {
          const e = this.geometry,
            t = this.count;
          null === this.boundingBox && (this.boundingBox = new Ms()),
            null === e.boundingBox && e.computeBoundingBox(),
            this.boundingBox.makeEmpty();
          for (let i = 0; i < t; i++)
            this.getMatrixAt(i, $c),
              oO.copy(e.boundingBox).applyMatrix4($c),
              this.boundingBox.union(oO);
        }
        computeBoundingSphere() {
          const e = this.geometry,
            t = this.count;
          null === this.boundingSphere && (this.boundingSphere = new Jr()),
            null === e.boundingSphere && e.computeBoundingSphere(),
            this.boundingSphere.makeEmpty();
          for (let i = 0; i < t; i++)
            this.getMatrixAt(i, $c),
              dh.copy(e.boundingSphere).applyMatrix4($c),
              this.boundingSphere.union(dh);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.instanceMatrix.copy(e.instanceMatrix),
            null !== e.instanceColor &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, 3 * e);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, 16 * e);
        }
        raycast(e, t) {
          const i = this.matrixWorld,
            r = this.count;
          if (
            ((uh.geometry = this.geometry),
            (uh.material = this.material),
            void 0 !== uh.material &&
              (null === this.boundingSphere && this.computeBoundingSphere(),
              dh.copy(this.boundingSphere),
              dh.applyMatrix4(i),
              !1 !== e.ray.intersectsSphere(dh)))
          )
            for (let s = 0; s < r; s++) {
              this.getMatrixAt(s, $c),
                sO.multiplyMatrices(i, $c),
                (uh.matrixWorld = sO),
                uh.raycast(e, Um);
              for (let o = 0, a = Um.length; o < a; o++) {
                const l = Um[o];
                (l.instanceId = s), (l.object = this), t.push(l);
              }
              Um.length = 0;
            }
        }
        setColorAt(e, t) {
          null === this.instanceColor &&
            (this.instanceColor = new ch(
              new Float32Array(3 * this.instanceMatrix.count),
              3
            )),
            t.toArray(this.instanceColor.array, 3 * e);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, 16 * e);
        }
        updateMorphTargets() {}
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class Ri extends ar {
        constructor(e) {
          super(),
            (this.isLineBasicMaterial = !0),
            (this.type = "LineBasicMaterial"),
            (this.color = new de(16777215)),
            (this.map = null),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const lO = new A(),
        cO = new A(),
        uO = new Ae(),
        sx = new Qd(),
        Vm = new Jr();
      class zo extends Dn {
        constructor(e = new ut(), t = new Ri()) {
          super(),
            (this.isLine = !0),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (null === e.index) {
            const t = e.attributes.position,
              i = [0];
            for (let r = 1, s = t.count; r < s; r++)
              lO.fromBufferAttribute(t, r - 1),
                cO.fromBufferAttribute(t, r),
                (i[r] = i[r - 1]),
                (i[r] += lO.distanceTo(cO));
            e.setAttribute("lineDistance", new Ie(i, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
        raycast(e, t) {
          const i = this.geometry,
            r = this.matrixWorld,
            s = e.params.Line.threshold,
            o = i.drawRange;
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            Vm.copy(i.boundingSphere),
            Vm.applyMatrix4(r),
            (Vm.radius += s),
            !1 === e.ray.intersectsSphere(Vm))
          )
            return;
          uO.copy(r).invert(), sx.copy(e.ray).applyMatrix4(uO);
          const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = new A(),
            u = new A(),
            d = new A(),
            h = new A(),
            f = this.isLineSegments ? 2 : 1,
            p = i.index,
            m = i.attributes.position;
          if (null !== p)
            for (
              let v = Math.max(0, o.start),
                b = Math.min(p.count, o.start + o.count) - 1;
              v < b;
              v += f
            ) {
              const x = p.getX(v),
                M = p.getX(v + 1);
              if (
                (c.fromBufferAttribute(m, x),
                u.fromBufferAttribute(m, M),
                sx.distanceSqToSegment(c, u, h, d) > l)
              )
                continue;
              h.applyMatrix4(this.matrixWorld);
              const C = e.ray.origin.distanceTo(h);
              C < e.near ||
                C > e.far ||
                t.push({
                  distance: C,
                  point: d.clone().applyMatrix4(this.matrixWorld),
                  index: v,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
          else
            for (
              let v = Math.max(0, o.start),
                b = Math.min(m.count, o.start + o.count) - 1;
              v < b;
              v += f
            ) {
              if (
                (c.fromBufferAttribute(m, v),
                u.fromBufferAttribute(m, v + 1),
                sx.distanceSqToSegment(c, u, h, d) > l)
              )
                continue;
              h.applyMatrix4(this.matrixWorld);
              const M = e.ray.origin.distanceTo(h);
              M < e.near ||
                M > e.far ||
                t.push({
                  distance: M,
                  point: d.clone().applyMatrix4(this.matrixWorld),
                  index: v,
                  face: null,
                  faceIndex: null,
                  object: this,
                });
            }
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes,
            i = Object.keys(t);
          if (i.length > 0) {
            const r = t[i[0]];
            if (void 0 !== r) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s].name || String(s);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[a] = s);
              }
            }
          }
        }
      }
      const dO = new A(),
        hO = new A();
      class ox extends zo {
        constructor(e, t) {
          super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (null === e.index) {
            const t = e.attributes.position,
              i = [];
            for (let r = 0, s = t.count; r < s; r += 2)
              dO.fromBufferAttribute(t, r),
                hO.fromBufferAttribute(t, r + 1),
                (i[r] = 0 === r ? 0 : i[r - 1]),
                (i[r + 1] = i[r] + dO.distanceTo(hO));
            e.setAttribute("lineDistance", new Ie(i, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
      }
      class fO extends zo {
        constructor(e, t) {
          super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
        }
      }
      class ax extends ar {
        constructor(e) {
          super(),
            (this.isPointsMaterial = !0),
            (this.type = "PointsMaterial"),
            (this.color = new de(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
          );
        }
      }
      const pO = new Ae(),
        lx = new Qd(),
        zm = new Jr(),
        Hm = new A();
      class mO extends Dn {
        constructor(e = new ut(), t = new ax()) {
          super(),
            (this.isPoints = !0),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.material = e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const i = this.geometry,
            r = this.matrixWorld,
            s = e.params.Points.threshold,
            o = i.drawRange;
          if (
            (null === i.boundingSphere && i.computeBoundingSphere(),
            zm.copy(i.boundingSphere),
            zm.applyMatrix4(r),
            (zm.radius += s),
            !1 === e.ray.intersectsSphere(zm))
          )
            return;
          pO.copy(r).invert(), lx.copy(e.ray).applyMatrix4(pO);
          const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = i.index,
            d = i.attributes.position;
          if (null !== c)
            for (
              let p = Math.max(0, o.start),
                _ = Math.min(c.count, o.start + o.count);
              p < _;
              p++
            ) {
              const m = c.getX(p);
              Hm.fromBufferAttribute(d, m), gO(Hm, m, l, r, e, t, this);
            }
          else
            for (
              let p = Math.max(0, o.start),
                _ = Math.min(d.count, o.start + o.count);
              p < _;
              p++
            )
              Hm.fromBufferAttribute(d, p), gO(Hm, p, l, r, e, t, this);
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes,
            i = Object.keys(t);
          if (i.length > 0) {
            const r = t[i[0]];
            if (void 0 !== r) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let s = 0, o = r.length; s < o; s++) {
                const a = r[s].name || String(s);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[a] = s);
              }
            }
          }
        }
      }
      function gO(n, e, t, i, r, s, o) {
        const a = lx.distanceSqToPoint(n);
        if (a < t) {
          const l = new A();
          lx.closestPointToPoint(n, l), l.applyMatrix4(i);
          const c = r.ray.origin.distanceTo(l);
          if (c < r.near || c > r.far) return;
          s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o,
          });
        }
      }
      class is {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const i = this.getUtoTmapping(e);
          return this.getPoint(i, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let i,
            r = this.getPoint(0),
            s = 0;
          t.push(0);
          for (let o = 1; o <= e; o++)
            (i = this.getPoint(o / e)),
              (s += i.distanceTo(r)),
              t.push(s),
              (r = i);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const i = this.getLengths();
          let r = 0;
          const s = i.length;
          let o;
          o = t || e * i[s - 1];
          let c,
            a = 0,
            l = s - 1;
          for (; a <= l; )
            if (((r = Math.floor(a + (l - a) / 2)), (c = i[r] - o), c < 0))
              a = r + 1;
            else {
              if (!(c > 0)) {
                l = r;
                break;
              }
              l = r - 1;
            }
          if (((r = l), i[r] === o)) return r / (s - 1);
          const u = i[r];
          return (r + (o - u) / (i[r + 1] - u)) / (s - 1);
        }
        getTangent(e, t) {
          let r = e - 1e-4,
            s = e + 1e-4;
          r < 0 && (r = 0), s > 1 && (s = 1);
          const o = this.getPoint(r),
            a = this.getPoint(s),
            l = t || (o.isVector2 ? new $() : new A());
          return l.copy(a).sub(o).normalize(), l;
        }
        getTangentAt(e, t) {
          const i = this.getUtoTmapping(e);
          return this.getTangent(i, t);
        }
        computeFrenetFrames(e, t) {
          const i = new A(),
            r = [],
            s = [],
            o = [],
            a = new A(),
            l = new Ae();
          for (let f = 0; f <= e; f++) r[f] = this.getTangentAt(f / e, new A());
          (s[0] = new A()), (o[0] = new A());
          let c = Number.MAX_VALUE;
          const u = Math.abs(r[0].x),
            d = Math.abs(r[0].y),
            h = Math.abs(r[0].z);
          u <= c && ((c = u), i.set(1, 0, 0)),
            d <= c && ((c = d), i.set(0, 1, 0)),
            h <= c && i.set(0, 0, 1),
            a.crossVectors(r[0], i).normalize(),
            s[0].crossVectors(r[0], a),
            o[0].crossVectors(r[0], s[0]);
          for (let f = 1; f <= e; f++) {
            if (
              ((s[f] = s[f - 1].clone()),
              (o[f] = o[f - 1].clone()),
              a.crossVectors(r[f - 1], r[f]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const p = Math.acos(bn(r[f - 1].dot(r[f]), -1, 1));
              s[f].applyMatrix4(l.makeRotationAxis(a, p));
            }
            o[f].crossVectors(r[f], s[f]);
          }
          if (!0 === t) {
            let f = Math.acos(bn(s[0].dot(s[e]), -1, 1));
            (f /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (f = -f);
            for (let p = 1; p <= e; p++)
              s[p].applyMatrix4(l.makeRotationAxis(r[p], f * p)),
                o[p].crossVectors(r[p], s[p]);
          }
          return { tangents: r, normals: s, binormals: o };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class eg extends ar {
        constructor(e) {
          super(),
            (this.isMeshStandardMaterial = !0),
            (this.defines = { STANDARD: "" }),
            (this.type = "MeshStandardMaterial"),
            (this.color = new de(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new de(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Da),
            (this.normalScale = new $(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      class fo extends eg {
        constructor(e) {
          super(),
            (this.isMeshPhysicalMaterial = !0),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.type = "MeshPhysicalMaterial"),
            (this.anisotropyRotation = 0),
            (this.anisotropyMap = null),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new $(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return bn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (t) {
                this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
              },
            }),
            (this.iridescenceMap = null),
            (this.iridescenceIOR = 1.3),
            (this.iridescenceThicknessRange = [100, 400]),
            (this.iridescenceThicknessMap = null),
            (this.sheenColor = new de(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 1 / 0),
            (this.attenuationColor = new de(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new de(1, 1, 1)),
            (this.specularColorMap = null),
            (this._anisotropy = 0),
            (this._clearcoat = 0),
            (this._iridescence = 0),
            (this._sheen = 0),
            (this._transmission = 0),
            this.setValues(e);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(e) {
          this._anisotropy > 0 != e > 0 && this.version++,
            (this._anisotropy = e);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e) {
          this._iridescence > 0 != e > 0 && this.version++,
            (this._iridescence = e);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++,
            (this._transmission = e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.anisotropy = e.anisotropy),
            (this.anisotropyRotation = e.anisotropyRotation),
            (this.anisotropyMap = e.anisotropyMap),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.ior = e.ior),
            (this.iridescence = e.iridescence),
            (this.iridescenceMap = e.iridescenceMap),
            (this.iridescenceIOR = e.iridescenceIOR),
            (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
            (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
          );
        }
      }
      class tg extends ar {
        constructor(e) {
          super(),
            (this.isMeshPhongMaterial = !0),
            (this.type = "MeshPhongMaterial"),
            (this.color = new de(16777215)),
            (this.specular = new de(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new de(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Da),
            (this.normalScale = new $(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = rm),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      class IO extends ar {
        constructor(e) {
          super(),
            (this.isMeshLambertMaterial = !0),
            (this.type = "MeshLambertMaterial"),
            (this.color = new de(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new de(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = Da),
            (this.normalScale = new $(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = rm),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      function Ir(n, e, t) {
        return Rx(n)
          ? new n.constructor(n.subarray(e, void 0 !== t ? t : n.length))
          : n.slice(e, t);
      }
      function Ha(n, e, t) {
        return !n || (!t && n.constructor === e)
          ? n
          : "number" == typeof e.BYTES_PER_ELEMENT
          ? new e(n)
          : Array.prototype.slice.call(n);
      }
      function Rx(n) {
        return ArrayBuffer.isView(n) && !(n instanceof DataView);
      }
      function RO(n) {
        const t = n.length,
          i = new Array(t);
        for (let r = 0; r !== t; ++r) i[r] = r;
        return (
          i.sort(function e(r, s) {
            return n[r] - n[s];
          }),
          i
        );
      }
      function Px(n, e, t) {
        const i = n.length,
          r = new n.constructor(i);
        for (let s = 0, o = 0; o !== i; ++s) {
          const a = t[s] * e;
          for (let l = 0; l !== e; ++l) r[o++] = n[a + l];
        }
        return r;
      }
      function Ox(n, e, t, i) {
        let r = 1,
          s = n[0];
        for (; void 0 !== s && void 0 === s[i]; ) s = n[r++];
        if (void 0 === s) return;
        let o = s[i];
        if (void 0 !== o)
          if (Array.isArray(o))
            do {
              (o = s[i]),
                void 0 !== o && (e.push(s.time), t.push.apply(t, o)),
                (s = n[r++]);
            } while (void 0 !== s);
          else if (void 0 !== o.toArray)
            do {
              (o = s[i]),
                void 0 !== o && (e.push(s.time), o.toArray(t, t.length)),
                (s = n[r++]);
            } while (void 0 !== s);
          else
            do {
              (o = s[i]),
                void 0 !== o && (e.push(s.time), t.push(o)),
                (s = n[r++]);
            } while (void 0 !== s);
      }
      class vh {
        constructor(e, t, i, r) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== r ? r : new t.constructor(i)),
            (this.sampleValues = t),
            (this.valueSize = i),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let i = this._cachedIndex,
            r = t[i],
            s = t[i - 1];
          e: {
            t: {
              let o;
              n: {
                i: if (!(e < r)) {
                  for (let a = i + 2; ; ) {
                    if (void 0 === r) {
                      if (e < s) break i;
                      return (
                        (i = t.length),
                        (this._cachedIndex = i),
                        this.copySampleValue_(i - 1)
                      );
                    }
                    if (i === a) break;
                    if (((s = r), (r = t[++i]), e < r)) break t;
                  }
                  o = t.length;
                  break n;
                }
                if (e >= s) break e;
                {
                  const a = t[1];
                  e < a && ((i = 2), (s = a));
                  for (let l = i - 2; ; ) {
                    if (void 0 === s)
                      return (this._cachedIndex = 0), this.copySampleValue_(0);
                    if (i === l) break;
                    if (((r = s), (s = t[--i - 1]), e >= s)) break t;
                  }
                  (o = i), (i = 0);
                }
              }
              for (; i < o; ) {
                const a = (i + o) >>> 1;
                e < t[a] ? (o = a) : (i = a + 1);
              }
              if (((r = t[i]), (s = t[i - 1]), void 0 === s))
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (void 0 === r)
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
            }
            (this._cachedIndex = i), this.intervalChanged_(i, s, r);
          }
          return this.interpolate_(i, s, e, r);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            i = this.sampleValues,
            r = this.valueSize,
            s = e * r;
          for (let o = 0; o !== r; ++o) t[o] = i[s + o];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class HK extends vh {
        constructor(e, t, i, r) {
          super(e, t, i, r),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: vc, endingEnd: vc });
        }
        intervalChanged_(e, t, i) {
          const r = this.parameterPositions;
          let s = e - 2,
            o = e + 1,
            a = r[s],
            l = r[o];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case yc:
                (s = e), (a = 2 * t - i);
                break;
              case 2402:
                (s = r.length - 2), (a = t + r[s] - r[s + 1]);
                break;
              default:
                (s = e), (a = i);
            }
          if (void 0 === l)
            switch (this.getSettings_().endingEnd) {
              case yc:
                (o = e), (l = 2 * i - t);
                break;
              case 2402:
                (o = 1), (l = i + r[1] - r[0]);
                break;
              default:
                (o = e - 1), (l = t);
            }
          const c = 0.5 * (i - t),
            u = this.valueSize;
          (this._weightPrev = c / (t - a)),
            (this._weightNext = c / (l - i)),
            (this._offsetPrev = s * u),
            (this._offsetNext = o * u);
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = this._offsetPrev,
            d = this._offsetNext,
            h = this._weightPrev,
            f = this._weightNext,
            p = (i - t) / (r - t),
            _ = p * p,
            m = _ * p,
            g = -h * m + 2 * h * _ - h * p,
            y = (1 + h) * m + (-1.5 - 2 * h) * _ + (-0.5 + h) * p + 1,
            v = (-1 - f) * m + (1.5 + f) * _ + 0.5 * p,
            b = f * m - f * _;
          for (let x = 0; x !== a; ++x)
            s[x] = g * o[u + x] + y * o[c + x] + v * o[l + x] + b * o[d + x];
          return s;
        }
      }
      class PO extends vh {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = (i - t) / (r - t),
            d = 1 - u;
          for (let h = 0; h !== a; ++h) s[h] = o[c + h] * d + o[l + h] * u;
          return s;
        }
      }
      class GK extends vh {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class Cs {
        constructor(e, t, i, r) {
          if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === t || 0 === t.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = Ha(t, this.TimeBufferType)),
            (this.values = Ha(i, this.ValueBufferType)),
            this.setInterpolation(r || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let i;
          if (t.toJSON !== this.toJSON) i = t.toJSON(e);
          else {
            i = {
              name: e.name,
              times: Ha(e.times, Array),
              values: Ha(e.values, Array),
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r);
          }
          return (i.type = e.ValueTypeName), i;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new GK(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new PO(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new HK(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case Xd:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case _c:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case 2302:
              t = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === t) {
            const i =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (e === this.DefaultInterpolation) throw new Error(i);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", i), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Xd;
            case this.InterpolantFactoryMethodLinear:
              return _c;
            case this.InterpolantFactoryMethodSmooth:
              return 2302;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (0 !== e) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
          }
          return this;
        }
        scale(e) {
          if (1 !== e) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
          }
          return this;
        }
        trim(e, t) {
          const i = this.times,
            r = i.length;
          let s = 0,
            o = r - 1;
          for (; s !== r && i[s] < e; ) ++s;
          for (; -1 !== o && i[o] > t; ) --o;
          if ((++o, 0 !== s || o !== r)) {
            s >= o && ((o = Math.max(o, 1)), (s = o - 1));
            const a = this.getValueSize();
            (this.times = Ir(i, s, o)),
              (this.values = Ir(this.values, s * a, o * a));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const i = this.times,
            r = this.values,
            s = i.length;
          0 === s &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let o = null;
          for (let a = 0; a !== s; a++) {
            const l = i[a];
            if ("number" == typeof l && isNaN(l)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                a,
                l
              ),
                (e = !1);
              break;
            }
            if (null !== o && o > l) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                a,
                l,
                o
              ),
                (e = !1);
              break;
            }
            o = l;
          }
          if (void 0 !== r && Rx(r))
            for (let a = 0, l = r.length; a !== l; ++a) {
              const c = r[a];
              if (isNaN(c)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  a,
                  c
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = Ir(this.times),
            t = Ir(this.values),
            i = this.getValueSize(),
            r = 2302 === this.getInterpolation(),
            s = e.length - 1;
          let o = 1;
          for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a];
            if (c !== e[a + 1] && (1 !== a || c !== e[0]))
              if (r) l = !0;
              else {
                const d = a * i,
                  h = d - i,
                  f = d + i;
                for (let p = 0; p !== i; ++p) {
                  const _ = t[d + p];
                  if (_ !== t[h + p] || _ !== t[f + p]) {
                    l = !0;
                    break;
                  }
                }
              }
            if (l) {
              if (a !== o) {
                e[o] = e[a];
                const d = a * i,
                  h = o * i;
                for (let f = 0; f !== i; ++f) t[h + f] = t[d + f];
              }
              ++o;
            }
          }
          if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, l = o * i, c = 0; c !== i; ++c)
              t[l + c] = t[a + c];
            ++o;
          }
          return (
            o !== e.length
              ? ((this.times = Ir(e, 0, o)), (this.values = Ir(t, 0, o * i)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = Ir(this.times, 0),
            t = Ir(this.values, 0),
            r = new (0, this.constructor)(this.name, e, t);
          return (r.createInterpolant = this.createInterpolant), r;
        }
      }
      (Cs.prototype.TimeBufferType = Float32Array),
        (Cs.prototype.ValueBufferType = Float32Array),
        (Cs.prototype.DefaultInterpolation = _c);
      class eu extends Cs {}
      (eu.prototype.ValueTypeName = "bool"),
        (eu.prototype.ValueBufferType = Array),
        (eu.prototype.DefaultInterpolation = Xd),
        (eu.prototype.InterpolantFactoryMethodLinear = void 0),
        (eu.prototype.InterpolantFactoryMethodSmooth = void 0);
      class OO extends Cs {}
      OO.prototype.ValueTypeName = "color";
      class Ga extends Cs {}
      Ga.prototype.ValueTypeName = "number";
      class WK extends vh {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (i - t) / (r - t);
          let c = e * a;
          for (let u = c + a; c !== u; c += 4)
            An.slerpFlat(s, 0, o, c - a, o, c, l);
          return s;
        }
      }
      class Ho extends Cs {
        InterpolantFactoryMethodLinear(e) {
          return new WK(this.times, this.values, this.getValueSize(), e);
        }
      }
      (Ho.prototype.ValueTypeName = "quaternion"),
        (Ho.prototype.DefaultInterpolation = _c),
        (Ho.prototype.InterpolantFactoryMethodSmooth = void 0);
      class tu extends Cs {}
      (tu.prototype.ValueTypeName = "string"),
        (tu.prototype.ValueBufferType = Array),
        (tu.prototype.DefaultInterpolation = Xd),
        (tu.prototype.InterpolantFactoryMethodLinear = void 0),
        (tu.prototype.InterpolantFactoryMethodSmooth = void 0);
      class nu extends Cs {}
      nu.prototype.ValueTypeName = "vector";
      class iu {
        constructor(e, t = -1, i, r = 2500) {
          (this.name = e),
            (this.tracks = i),
            (this.duration = t),
            (this.blendMode = r),
            (this.uuid = ir()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            i = e.tracks,
            r = 1 / (e.fps || 1);
          for (let o = 0, a = i.length; o !== a; ++o) t.push(XK(i[o]).scale(r));
          const s = new this(e.name, e.duration, t, e.blendMode);
          return (s.uuid = e.uuid), s;
        }
        static toJSON(e) {
          const t = [],
            i = e.tracks,
            r = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let s = 0, o = i.length; s !== o; ++s) t.push(Cs.toJSON(i[s]));
          return r;
        }
        static CreateFromMorphTargetSequence(e, t, i, r) {
          const s = t.length,
            o = [];
          for (let a = 0; a < s; a++) {
            let l = [],
              c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
            const u = RO(l);
            (l = Px(l, 1, u)),
              (c = Px(c, 1, u)),
              !r && 0 === l[0] && (l.push(s), c.push(c[0])),
              o.push(
                new Ga(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(
                  1 / i
                )
              );
          }
          return new this(e, -1, o);
        }
        static findByName(e, t) {
          let i = e;
          Array.isArray(e) ||
            (i = (e.geometry && e.geometry.animations) || e.animations);
          for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, i) {
          const r = {},
            s = /^([\w-]*?)([\d]+)$/;
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              u = c.name.match(s);
            if (u && u.length > 1) {
              const d = u[1];
              let h = r[d];
              h || (r[d] = h = []), h.push(c);
            }
          }
          const o = [];
          for (const a in r)
            o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
          return o;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const i = function (d, h, f, p, _) {
              if (0 !== f.length) {
                const m = [],
                  g = [];
                Ox(f, m, g, p), 0 !== m.length && _.push(new d(h, m, g));
              }
            },
            r = [],
            s = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
          let l = e.length || -1;
          const c = e.hierarchy || [];
          for (let d = 0; d < c.length; d++) {
            const h = c[d].keys;
            if (h && 0 !== h.length)
              if (h[0].morphTargets) {
                const f = {};
                let p;
                for (p = 0; p < h.length; p++)
                  if (h[p].morphTargets)
                    for (let _ = 0; _ < h[p].morphTargets.length; _++)
                      f[h[p].morphTargets[_]] = -1;
                for (const _ in f) {
                  const m = [],
                    g = [];
                  for (let y = 0; y !== h[p].morphTargets.length; ++y) {
                    const v = h[p];
                    m.push(v.time), g.push(v.morphTarget === _ ? 1 : 0);
                  }
                  r.push(new Ga(".morphTargetInfluence[" + _ + "]", m, g));
                }
                l = f.length * o;
              } else {
                const f = ".bones[" + t[d].name + "]";
                i(nu, f + ".position", h, "pos", r),
                  i(Ho, f + ".quaternion", h, "rot", r),
                  i(nu, f + ".scale", h, "scl", r);
              }
          }
          return 0 === r.length ? null : new this(s, l, r, a);
        }
        resetDuration() {
          let t = 0;
          for (let i = 0, r = this.tracks.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1]);
          }
          return (this.duration = t), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function XK(n) {
        if (void 0 === n.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const e = (function jK(n) {
          switch (n.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Ga;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return nu;
            case "color":
              return OO;
            case "quaternion":
              return Ho;
            case "bool":
            case "boolean":
              return eu;
            case "string":
              return tu;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
        })(n.type);
        if (void 0 === n.times) {
          const t = [],
            i = [];
          Ox(n.keys, t, i, "value"), (n.times = t), (n.values = i);
        }
        return void 0 !== e.parse
          ? e.parse(n)
          : new e(n.name, n.times, n.values, n.interpolation);
      }
      const ru = {
        enabled: !1,
        files: {},
        add: function (n, e) {
          !1 !== this.enabled && (this.files[n] = e);
        },
        get: function (n) {
          if (!1 !== this.enabled) return this.files[n];
        },
        remove: function (n) {
          delete this.files[n];
        },
        clear: function () {
          this.files = {};
        },
      };
      class LO {
        constructor(e, t, i) {
          const r = this;
          let l,
            s = !1,
            o = 0,
            a = 0;
          const c = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = i),
            (this.itemStart = function (u) {
              a++,
                !1 === s && void 0 !== r.onStart && r.onStart(u, o, a),
                (s = !0);
            }),
            (this.itemEnd = function (u) {
              o++,
                void 0 !== r.onProgress && r.onProgress(u, o, a),
                o === a && ((s = !1), void 0 !== r.onLoad && r.onLoad());
            }),
            (this.itemError = function (u) {
              void 0 !== r.onError && r.onError(u);
            }),
            (this.resolveURL = function (u) {
              return l ? l(u) : u;
            }),
            (this.setURLModifier = function (u) {
              return (l = u), this;
            }),
            (this.addHandler = function (u, d) {
              return c.push(u, d), this;
            }),
            (this.removeHandler = function (u) {
              const d = c.indexOf(u);
              return -1 !== d && c.splice(d, 2), this;
            }),
            (this.getHandler = function (u) {
              for (let d = 0, h = c.length; d < h; d += 2) {
                const f = c[d],
                  p = c[d + 1];
                if ((f.global && (f.lastIndex = 0), f.test(u))) return p;
              }
              return null;
            });
        }
      }
      const qK = new LO();
      let po = (() => {
        class n {
          constructor(t) {
            (this.manager = void 0 !== t ? t : qK),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(t, i) {
            const r = this;
            return new Promise(function (s, o) {
              r.load(t, s, i, o);
            });
          }
          parse() {}
          setCrossOrigin(t) {
            return (this.crossOrigin = t), this;
          }
          setWithCredentials(t) {
            return (this.withCredentials = t), this;
          }
          setPath(t) {
            return (this.path = t), this;
          }
          setResourcePath(t) {
            return (this.resourcePath = t), this;
          }
          setRequestHeader(t) {
            return (this.requestHeader = t), this;
          }
        }
        return (n.DEFAULT_MATERIAL_NAME = "__DEFAULT"), n;
      })();
      const mo = {};
      class YK extends Error {
        constructor(e, t) {
          super(e), (this.response = t);
        }
      }
      class cr extends po {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const s = ru.get(e);
          if (void 0 !== s)
            return (
              this.manager.itemStart(e),
              setTimeout(() => {
                t && t(s), this.manager.itemEnd(e);
              }, 0),
              s
            );
          if (void 0 !== mo[e])
            return void mo[e].push({ onLoad: t, onProgress: i, onError: r });
          (mo[e] = []), mo[e].push({ onLoad: t, onProgress: i, onError: r });
          const o = new Request(e, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            a = this.mimeType,
            l = this.responseType;
          fetch(o)
            .then((c) => {
              if (200 === c.status || 0 === c.status) {
                if (
                  (0 === c.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  typeof ReadableStream > "u" ||
                    void 0 === c.body ||
                    void 0 === c.body.getReader)
                )
                  return c;
                const u = mo[e],
                  d = c.body.getReader(),
                  h =
                    c.headers.get("Content-Length") ||
                    c.headers.get("X-File-Size"),
                  f = h ? parseInt(h) : 0,
                  p = 0 !== f;
                let _ = 0;
                const m = new ReadableStream({
                  start(g) {
                    !(function y() {
                      d.read().then(({ done: v, value: b }) => {
                        if (v) g.close();
                        else {
                          _ += b.byteLength;
                          const x = new ProgressEvent("progress", {
                            lengthComputable: p,
                            loaded: _,
                            total: f,
                          });
                          for (let M = 0, S = u.length; M < S; M++) {
                            const C = u[M];
                            C.onProgress && C.onProgress(x);
                          }
                          g.enqueue(b), y();
                        }
                      });
                    })();
                  },
                });
                return new Response(m);
              }
              throw new YK(
                `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
                c
              );
            })
            .then((c) => {
              switch (l) {
                case "arraybuffer":
                  return c.arrayBuffer();
                case "blob":
                  return c.blob();
                case "document":
                  return c
                    .text()
                    .then((u) => new DOMParser().parseFromString(u, a));
                case "json":
                  return c.json();
                default:
                  if (void 0 === a) return c.text();
                  {
                    const d = /charset="?([^;"\s]*)"?/i.exec(a),
                      h = d && d[1] ? d[1].toLowerCase() : void 0,
                      f = new TextDecoder(h);
                    return c.arrayBuffer().then((p) => f.decode(p));
                  }
              }
            })
            .then((c) => {
              ru.add(e, c);
              const u = mo[e];
              delete mo[e];
              for (let d = 0, h = u.length; d < h; d++) {
                const f = u[d];
                f.onLoad && f.onLoad(c);
              }
            })
            .catch((c) => {
              const u = mo[e];
              if (void 0 === u) throw (this.manager.itemError(e), c);
              delete mo[e];
              for (let d = 0, h = u.length; d < h; d++) {
                const f = u[d];
                f.onError && f.onError(c);
              }
              this.manager.itemError(e);
            })
            .finally(() => {
              this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class ng extends po {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const s = this,
            o = ru.get(e);
          if (void 0 !== o)
            return (
              s.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), s.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = Yd("img");
          function l() {
            u(), ru.add(e, this), t && t(this), s.manager.itemEnd(e);
          }
          function c(d) {
            u(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
          }
          function u() {
            a.removeEventListener("load", l, !1),
              a.removeEventListener("error", c, !1);
          }
          return (
            a.addEventListener("load", l, !1),
            a.addEventListener("error", c, !1),
            "data:" !== e.slice(0, 5) &&
              void 0 !== this.crossOrigin &&
              (a.crossOrigin = this.crossOrigin),
            s.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class FO extends po {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          const s = new Ai(),
            o = new ng(this.manager);
          return (
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(
              e,
              function (a) {
                (s.image = a), (s.needsUpdate = !0), void 0 !== t && t(s);
              },
              i,
              r
            ),
            s
          );
        }
      }
      class ig extends Dn {
        constructor(e, t = 1) {
          super(),
            (this.isLight = !0),
            (this.type = "Light"),
            (this.color = new de(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e, t) {
          return (
            super.copy(e, t),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
          );
        }
      }
      const Lx = new Ae(),
        NO = new A(),
        kO = new A();
      class Fx {
        constructor(e) {
          (this.camera = e),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new $(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new Ae()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Wb()),
            (this._frameExtents = new $(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new Ft(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            i = this.matrix;
          NO.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(NO),
            kO.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(kO),
            t.updateMatrixWorld(),
            Lx.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Lx),
            i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            i.multiply(Lx);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            0 !== this.bias && (e.bias = this.bias),
            0 !== this.normalBias && (e.normalBias = this.normalBias),
            1 !== this.radius && (e.radius = this.radius),
            (512 !== this.mapSize.x || 512 !== this.mapSize.y) &&
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class KK extends Fx {
        constructor() {
          super(new Wn(50, 1, 0.5, 500)),
            (this.isSpotLightShadow = !0),
            (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            i = 2 * bc * e.angle * this.focus,
            r = this.mapSize.width / this.mapSize.height,
            s = e.distance || t.far;
          (i !== t.fov || r !== t.aspect || s !== t.far) &&
            ((t.fov = i),
            (t.aspect = r),
            (t.far = s),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      class Nx extends ig {
        constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
          super(e, t),
            (this.isSpotLight = !0),
            (this.type = "SpotLight"),
            this.position.copy(Dn.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new Dn()),
            (this.distance = i),
            (this.angle = r),
            (this.penumbra = s),
            (this.decay = o),
            (this.map = null),
            (this.shadow = new KK());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      const BO = new Ae(),
        yh = new A(),
        kx = new A();
      class $K extends Fx {
        constructor() {
          super(new Wn(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new $(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new Ft(2, 1, 1, 1),
              new Ft(0, 1, 1, 1),
              new Ft(3, 1, 1, 1),
              new Ft(1, 1, 1, 1),
              new Ft(3, 0, 1, 1),
              new Ft(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new A(1, 0, 0),
              new A(-1, 0, 0),
              new A(0, 0, 1),
              new A(0, 0, -1),
              new A(0, 1, 0),
              new A(0, -1, 0),
            ]),
            (this._cubeUps = [
              new A(0, 1, 0),
              new A(0, 1, 0),
              new A(0, 1, 0),
              new A(0, 1, 0),
              new A(0, 0, 1),
              new A(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const i = this.camera,
            r = this.matrix,
            s = e.distance || i.far;
          s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
            yh.setFromMatrixPosition(e.matrixWorld),
            i.position.copy(yh),
            kx.copy(i.position),
            kx.add(this._cubeDirections[t]),
            i.up.copy(this._cubeUps[t]),
            i.lookAt(kx),
            i.updateMatrixWorld(),
            r.makeTranslation(-yh.x, -yh.y, -yh.z),
            BO.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(BO);
        }
      }
      class rg extends ig {
        constructor(e, t, i = 0, r = 2) {
          super(e, t),
            (this.isPointLight = !0),
            (this.type = "PointLight"),
            (this.distance = i),
            (this.decay = r),
            (this.shadow = new $K());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      class QK extends Fx {
        constructor() {
          super(new Hc(-5, 5, 5, -5, 0.5, 500)),
            (this.isDirectionalLightShadow = !0);
        }
      }
      class su extends ig {
        constructor(e, t) {
          super(e, t),
            (this.isDirectionalLight = !0),
            (this.type = "DirectionalLight"),
            this.position.copy(Dn.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new Dn()),
            (this.shadow = new QK());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      class Bx extends ig {
        constructor(e, t) {
          super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
        }
      }
      class ou {
        static decodeText(e) {
          if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
          let t = "";
          for (let i = 0, r = e.length; i < r; i++)
            t += String.fromCharCode(e[i]);
          try {
            return decodeURIComponent(escape(t));
          } catch {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return -1 === t ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return "string" != typeof e || "" === e
            ? ""
            : (/^https?:\/\//i.test(t) &&
                /^\//.test(e) &&
                (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
                ? e
                : t + e);
        }
      }
      class s$ extends po {
        constructor(e) {
          super(e),
            (this.isImageBitmapLoader = !0),
            typeof createImageBitmap > "u" &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            typeof fetch > "u" &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, i, r) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const s = this,
            o = ru.get(e);
          if (void 0 !== o)
            return (
              s.manager.itemStart(e),
              setTimeout(function () {
                t && t(o), s.manager.itemEnd(e);
              }, 0),
              o
            );
          const a = {};
          (a.credentials =
            "anonymous" === this.crossOrigin ? "same-origin" : "include"),
            (a.headers = this.requestHeader),
            fetch(e, a)
              .then(function (l) {
                return l.blob();
              })
              .then(function (l) {
                return createImageBitmap(
                  l,
                  Object.assign(s.options, { colorSpaceConversion: "none" })
                );
              })
              .then(function (l) {
                ru.add(e, l), t && t(l), s.manager.itemEnd(e);
              })
              .catch(function (l) {
                r && r(l), s.manager.itemError(e), s.manager.itemEnd(e);
              }),
            s.manager.itemStart(e);
        }
      }
      class Vx {
        constructor(e = !0) {
          (this.autoStart = e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = WO()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = WO();
            (e = (t - this.oldTime) / 1e3),
              (this.oldTime = t),
              (this.elapsedTime += e);
          }
          return e;
        }
      }
      function WO() {
        return (typeof performance > "u" ? Date : performance).now();
      }
      class l$ {
        constructor(e, t, i) {
          let r, s, o;
          switch (((this.binding = e), (this.valueSize = i), t)) {
            case "quaternion":
              (r = this._slerp),
                (s = this._slerpAdditive),
                (o = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * i)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (r = this._select),
                (s = this._select),
                (o = this._setAdditiveIdentityOther),
                (this.buffer = new Array(5 * i));
              break;
            default:
              (r = this._lerp),
                (s = this._lerpAdditive),
                (o = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * i));
          }
          (this._mixBufferRegion = r),
            (this._mixBufferRegionAdditive = s),
            (this._setIdentity = o),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const i = this.buffer,
            r = this.valueSize,
            s = e * r + r;
          let o = this.cumulativeWeight;
          if (0 === o) {
            for (let a = 0; a !== r; ++a) i[s + a] = i[a];
            o = t;
          } else (o += t), this._mixBufferRegion(i, s, 0, t / o, r);
          this.cumulativeWeight = o;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            i = this.valueSize,
            r = i * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(t, r, 0, e, i),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            i = this.buffer,
            r = e * t + t,
            s = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
          (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            s < 1 && this._mixBufferRegion(i, r, t * this._origIndex, 1 - s, t),
            o > 0 &&
              this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
          for (let l = t, c = t + t; l !== c; ++l)
            if (i[l] !== i[l + t]) {
              a.setValue(i, r);
              break;
            }
        }
        saveOriginalState() {
          const t = this.buffer,
            i = this.valueSize,
            r = i * this._origIndex;
          this.binding.getValue(t, r);
          for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          this.binding.setValue(this.buffer, 3 * this.valueSize);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let i = e; i < t; i++) this.buffer[i] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let i = 0; i < this.valueSize; i++)
            this.buffer[t + i] = this.buffer[e + i];
        }
        _select(e, t, i, r, s) {
          if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
        }
        _slerp(e, t, i, r) {
          An.slerpFlat(e, t, e, t, e, i, r);
        }
        _slerpAdditive(e, t, i, r, s) {
          const o = this._workIndex * s;
          An.multiplyQuaternionsFlat(e, o, e, t, e, i),
            An.slerpFlat(e, t, e, t, e, o, r);
        }
        _lerp(e, t, i, r, s) {
          const o = 1 - r;
          for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[i + a] * r;
          }
        }
        _lerpAdditive(e, t, i, r, s) {
          for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * r;
          }
        }
      }
      const zx = "\\[\\]\\.:\\/",
        c$ = new RegExp("[" + zx + "]", "g"),
        Hx = "[^" + zx + "]",
        u$ = "[^" + zx.replace("\\.", "") + "]",
        m$ = new RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", Hx) +
            /(WCOD+)?/.source.replace("WCOD", u$) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Hx) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Hx) +
            "$"
        ),
        g$ = ["material", "materials", "bones", "map"];
      class _$ {
        constructor(e, t, i) {
          const r = i || Wt.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
        }
        getValue(e, t) {
          this.bind();
          const r = this._bindings[this._targetGroup.nCachedObjects_];
          void 0 !== r && r.getValue(e, t);
        }
        setValue(e, t) {
          const i = this._bindings;
          for (
            let r = this._targetGroup.nCachedObjects_, s = i.length;
            r !== s;
            ++r
          )
            i[r].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, i = e.length;
            t !== i;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, i = e.length;
            t !== i;
            ++t
          )
            e[t].unbind();
        }
      }
      let Wt = (() => {
        class n {
          constructor(t, i, r) {
            (this.path = i),
              (this.parsedPath = r || n.parseTrackName(i)),
              (this.node = n.findNode(t, this.parsedPath.nodeName)),
              (this.rootNode = t),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(t, i, r) {
            return t && t.isAnimationObjectGroup
              ? new n.Composite(t, i, r)
              : new n(t, i, r);
          }
          static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(c$, "");
          }
          static parseTrackName(t) {
            const i = m$.exec(t);
            if (null === i)
              throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const r = {
                nodeName: i[2],
                objectName: i[3],
                objectIndex: i[4],
                propertyName: i[5],
                propertyIndex: i[6],
              },
              s = r.nodeName && r.nodeName.lastIndexOf(".");
            if (void 0 !== s && -1 !== s) {
              const o = r.nodeName.substring(s + 1);
              -1 !== g$.indexOf(o) &&
                ((r.nodeName = r.nodeName.substring(0, s)), (r.objectName = o));
            }
            if (null === r.propertyName || 0 === r.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  t
              );
            return r;
          }
          static findNode(t, i) {
            if (
              void 0 === i ||
              "" === i ||
              "." === i ||
              -1 === i ||
              i === t.name ||
              i === t.uuid
            )
              return t;
            if (t.skeleton) {
              const r = t.skeleton.getBoneByName(i);
              if (void 0 !== r) return r;
            }
            if (t.children) {
              const r = function (o) {
                  for (let a = 0; a < o.length; a++) {
                    const l = o[a];
                    if (l.name === i || l.uuid === i) return l;
                    const c = r(l.children);
                    if (c) return c;
                  }
                  return null;
                },
                s = r(t.children);
              if (s) return s;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(t, i) {
            t[i] = this.targetObject[this.propertyName];
          }
          _getValue_array(t, i) {
            const r = this.resolvedProperty;
            for (let s = 0, o = r.length; s !== o; ++s) t[i++] = r[s];
          }
          _getValue_arrayElement(t, i) {
            t[i] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(t, i) {
            this.resolvedProperty.toArray(t, i);
          }
          _setValue_direct(t, i) {
            this.targetObject[this.propertyName] = t[i];
          }
          _setValue_direct_setNeedsUpdate(t, i) {
            (this.targetObject[this.propertyName] = t[i]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(t, i) {
            (this.targetObject[this.propertyName] = t[i]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(t, i) {
            const r = this.resolvedProperty;
            for (let s = 0, o = r.length; s !== o; ++s) r[s] = t[i++];
          }
          _setValue_array_setNeedsUpdate(t, i) {
            const r = this.resolvedProperty;
            for (let s = 0, o = r.length; s !== o; ++s) r[s] = t[i++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(t, i) {
            const r = this.resolvedProperty;
            for (let s = 0, o = r.length; s !== o; ++s) r[s] = t[i++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(t, i) {
            this.resolvedProperty[this.propertyIndex] = t[i];
          }
          _setValue_arrayElement_setNeedsUpdate(t, i) {
            (this.resolvedProperty[this.propertyIndex] = t[i]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, i) {
            (this.resolvedProperty[this.propertyIndex] = t[i]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(t, i) {
            this.resolvedProperty.fromArray(t, i);
          }
          _setValue_fromArray_setNeedsUpdate(t, i) {
            this.resolvedProperty.fromArray(t, i),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(t, i) {
            this.resolvedProperty.fromArray(t, i),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(t, i) {
            this.bind(), this.getValue(t, i);
          }
          _setValue_unbound(t, i) {
            this.bind(), this.setValue(t, i);
          }
          bind() {
            let t = this.node;
            const i = this.parsedPath,
              r = i.objectName,
              s = i.propertyName;
            let o = i.propertyIndex;
            if (
              (t ||
                ((t = n.findNode(this.rootNode, i.nodeName)), (this.node = t)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !t)
            )
              return void console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found."
              );
            if (r) {
              let u = i.objectIndex;
              switch (r) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (let d = 0; d < t.length; d++)
                    if (t[d].name === u) {
                      u = d;
                      break;
                    }
                  break;
                case "map":
                  if ("map" in t) {
                    t = t.map;
                    break;
                  }
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.map)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                      this
                    );
                  t = t.material.map;
                  break;
                default:
                  if (void 0 === t[r])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[r];
              }
              if (void 0 !== u) {
                if (void 0 === t[u])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[u];
              }
            }
            const a = t[s];
            if (void 0 === a)
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  i.nodeName +
                  "." +
                  s +
                  " but it wasn't found.",
                t
              );
            let l = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (l = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  (l = this.Versioning.MatrixWorldNeedsUpdate);
            let c = this.BindingType.Direct;
            if (void 0 !== o) {
              if ("morphTargetInfluences" === s) {
                if (!t.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                if (!t.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                void 0 !== t.morphTargetDictionary[o] &&
                  (o = t.morphTargetDictionary[o]);
              }
              (c = this.BindingType.ArrayElement),
                (this.resolvedProperty = a),
                (this.propertyIndex = o);
            } else
              void 0 !== a.fromArray && void 0 !== a.toArray
                ? ((c = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = a))
                : Array.isArray(a)
                ? ((c = this.BindingType.EntireArray),
                  (this.resolvedProperty = a))
                : (this.propertyName = s);
            (this.getValue = this.GetterByBindingType[c]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[c][l]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        }
        return (n.Composite = _$), n;
      })();
      (Wt.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      }),
        (Wt.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (Wt.prototype.GetterByBindingType = [
          Wt.prototype._getValue_direct,
          Wt.prototype._getValue_array,
          Wt.prototype._getValue_arrayElement,
          Wt.prototype._getValue_toArray,
        ]),
        (Wt.prototype.SetterByBindingTypeAndVersioning = [
          [
            Wt.prototype._setValue_direct,
            Wt.prototype._setValue_direct_setNeedsUpdate,
            Wt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            Wt.prototype._setValue_array,
            Wt.prototype._setValue_array_setNeedsUpdate,
            Wt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            Wt.prototype._setValue_arrayElement,
            Wt.prototype._setValue_arrayElement_setNeedsUpdate,
            Wt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            Wt.prototype._setValue_fromArray,
            Wt.prototype._setValue_fromArray_setNeedsUpdate,
            Wt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      class v$ {
        constructor(e, t, i = null, r = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = i),
            (this.blendMode = r);
          const s = t.tracks,
            o = s.length,
            a = new Array(o),
            l = { endingStart: vc, endingEnd: vc };
          for (let c = 0; c !== o; ++c) {
            const u = s[c].createInterpolant(null);
            (a[c] = u), (u.settings = l);
          }
          (this._interpolantSettings = l),
            (this._interpolants = a),
            (this._propertyBindings = new Array(o)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = 2201),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, i) {
          if ((e.fadeOut(t), this.fadeIn(t), i)) {
            const r = this._clip.duration,
              s = e._clip.duration,
              a = r / s;
            e.warp(1, s / r, t), this.warp(a, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, i) {
          return e.crossFadeFrom(this, t, i);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            null !== e &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, i) {
          const r = this._mixer,
            s = r.time,
            o = this.timeScale;
          let a = this._timeScaleInterpolant;
          null === a &&
            ((a = r._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const l = a.parameterPositions,
            c = a.sampleValues;
          return (
            (l[0] = s), (l[1] = s + i), (c[0] = e / o), (c[1] = t / o), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            null !== e &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, i, r) {
          if (!this.enabled) return void this._updateWeight(e);
          const s = this._startTime;
          if (null !== s) {
            const l = (e - s) * i;
            l < 0 || 0 === i
              ? (t = 0)
              : ((this._startTime = null), (t = i * l));
          }
          t *= this._updateTimeScale(e);
          const o = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const l = this._interpolants,
              c = this._propertyBindings;
            if (2501 === this.blendMode)
              for (let u = 0, d = l.length; u !== d; ++u)
                l[u].evaluate(o), c[u].accumulateAdditive(a);
            else
              for (let u = 0, d = l.length; u !== d; ++u)
                l[u].evaluate(o), c[u].accumulate(r, a);
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (null !== i) {
              const r = i.evaluate(e)[0];
              (t *= r),
                e > i.parameterPositions[1] &&
                  (this.stopFading(), 0 === r && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            null !== i &&
              ((t *= i.evaluate(e)[0]),
              e > i.parameterPositions[1] &&
                (this.stopWarping(),
                0 === t ? (this.paused = !0) : (this.timeScale = t)));
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            i = this.loop;
          let r = this.time + e,
            s = this._loopCount;
          const o = 2202 === i;
          if (0 === e) return -1 === s ? r : o && 1 == (1 & s) ? t - r : r;
          if (2200 === i) {
            -1 === s && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (r >= t) r = t;
              else {
                if (!(r < 0)) {
                  this.time = r;
                  break e;
                }
                r = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = r),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === s &&
                (e >= 0
                  ? ((s = 0), this._setEndings(!0, 0 === this.repetitions, o))
                  : this._setEndings(0 === this.repetitions, !0, o)),
              r >= t || r < 0)
            ) {
              const a = Math.floor(r / t);
              (r -= t * a), (s += Math.abs(a));
              const l = this.repetitions - s;
              if (l <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (r = e > 0 ? t : 0),
                  (this.time = r),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (1 === l) {
                  const c = e < 0;
                  this._setEndings(c, !c, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = s),
                  (this.time = r),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            } else this.time = r;
            if (o && 1 == (1 & s)) return t - r;
          }
          return r;
        }
        _setEndings(e, t, i) {
          const r = this._interpolantSettings;
          i
            ? ((r.endingStart = yc), (r.endingEnd = yc))
            : ((r.endingStart = e ? (this.zeroSlopeAtStart ? yc : vc) : 2402),
              (r.endingEnd = t ? (this.zeroSlopeAtEnd ? yc : vc) : 2402));
        }
        _scheduleFading(e, t, i) {
          const r = this._mixer,
            s = r.time;
          let o = this._weightInterpolant;
          null === o &&
            ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
          const a = o.parameterPositions,
            l = o.sampleValues;
          return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = i), this;
        }
      }
      const y$ = new Float32Array(1);
      class b$ extends No {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const i = e._localRoot || this._root,
            r = e._clip.tracks,
            s = r.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = i.uuid,
            c = this._bindingsByRootAndName;
          let u = c[l];
          void 0 === u && ((u = {}), (c[l] = u));
          for (let d = 0; d !== s; ++d) {
            const h = r[d],
              f = h.name;
            let p = u[f];
            if (void 0 !== p) ++p.referenceCount, (o[d] = p);
            else {
              if (((p = o[d]), void 0 !== p)) {
                null === p._cacheIndex &&
                  (++p.referenceCount, this._addInactiveBinding(p, l, f));
                continue;
              }
              (p = new l$(
                Wt.create(i, f, t && t._propertyBindings[d].binding.parsedPath),
                h.ValueTypeName,
                h.getValueSize()
              )),
                ++p.referenceCount,
                this._addInactiveBinding(p, l, f),
                (o[d] = p);
            }
            a[d].resultBuffer = p.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (null === e._cacheIndex) {
              const i = (e._localRoot || this._root).uuid,
                r = e._clip.uuid,
                s = this._actionsByClip[r];
              this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, r, i);
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
              const s = t[i];
              0 == s.useCount++ &&
                (this._lendBinding(s), s.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
              const s = t[i];
              0 == --s.useCount &&
                (s.restoreOriginalState(), this._takeBackBinding(s));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return null !== t && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, i) {
          const r = this._actions,
            s = this._actionsByClip;
          let o = s[t];
          if (void 0 === o)
            (o = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (s[t] = o);
          else {
            const a = o.knownActions;
            (e._byClipCacheIndex = a.length), a.push(e);
          }
          (e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            i = t[t.length - 1],
            r = e._cacheIndex;
          (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
          const s = e._clip.uuid,
            o = this._actionsByClip,
            a = o[s],
            l = a.knownActions,
            c = l[l.length - 1],
            u = e._byClipCacheIndex;
          (c._byClipCacheIndex = u),
            (l[u] = c),
            l.pop(),
            (e._byClipCacheIndex = null),
            delete a.actionByRoot[(e._localRoot || this._root).uuid],
            0 === l.length && delete o[s],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            0 == --s.referenceCount && this._removeInactiveBinding(s);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            i = e._cacheIndex,
            r = this._nActiveActions++,
            s = t[r];
          (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
        }
        _takeBackAction(e) {
          const t = this._actions,
            i = e._cacheIndex,
            r = --this._nActiveActions,
            s = t[r];
          (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
        }
        _addInactiveBinding(e, t, i) {
          const r = this._bindingsByRootAndName,
            s = this._bindings;
          let o = r[t];
          void 0 === o && ((o = {}), (r[t] = o)),
            (o[i] = e),
            (e._cacheIndex = s.length),
            s.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            i = e.binding,
            r = i.rootNode.uuid,
            s = i.path,
            o = this._bindingsByRootAndName,
            a = o[r],
            l = t[t.length - 1],
            c = e._cacheIndex;
          (l._cacheIndex = c),
            (t[c] = l),
            t.pop(),
            delete a[s],
            0 === Object.keys(a).length && delete o[r];
        }
        _lendBinding(e) {
          const t = this._bindings,
            i = e._cacheIndex,
            r = this._nActiveBindings++,
            s = t[r];
          (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            i = e._cacheIndex,
            r = --this._nActiveBindings,
            s = t[r];
          (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let i = e[t];
          return (
            void 0 === i &&
              ((i = new PO(new Float32Array(2), new Float32Array(2), 1, y$)),
              (i.__cacheIndex = t),
              (e[t] = i)),
            i
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            i = e.__cacheIndex,
            r = --this._nActiveControlInterpolants,
            s = t[r];
          (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
        }
        clipAction(e, t, i) {
          const r = t || this._root,
            s = r.uuid;
          let o = "string" == typeof e ? iu.findByName(r, e) : e;
          const a = null !== o ? o.uuid : e,
            l = this._actionsByClip[a];
          let c = null;
          if (
            (void 0 === i && (i = null !== o ? o.blendMode : 2500),
            void 0 !== l)
          ) {
            const d = l.actionByRoot[s];
            if (void 0 !== d && d.blendMode === i) return d;
            (c = l.knownActions[0]), null === o && (o = c._clip);
          }
          if (null === o) return null;
          const u = new v$(this, o, t, i);
          return this._bindAction(u, c), this._addInactiveAction(u, a, s), u;
        }
        existingAction(e, t) {
          const i = t || this._root,
            r = i.uuid,
            s = "string" == typeof e ? iu.findByName(i, e) : e,
            a = this._actionsByClip[s ? s.uuid : e];
          return (void 0 !== a && a.actionByRoot[r]) || null;
        }
        stopAllAction() {
          const e = this._actions;
          for (let i = this._nActiveActions - 1; i >= 0; --i) e[i].stop();
          return this;
        }
        update(e) {
          const t = this._actions,
            i = this._nActiveActions,
            r = (this.time += e *= this.timeScale),
            s = Math.sign(e),
            o = (this._accuIndex ^= 1);
          for (let c = 0; c !== i; ++c) t[c]._update(r, e, s, o);
          const a = this._bindings,
            l = this._nActiveBindings;
          for (let c = 0; c !== l; ++c) a[c].apply(o);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            i = e.uuid,
            r = this._actionsByClip,
            s = r[i];
          if (void 0 !== s) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
              const c = o[a];
              this._deactivateAction(c);
              const u = c._cacheIndex,
                d = t[t.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (d._cacheIndex = u),
                (t[u] = d),
                t.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete r[i];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            i = this._actionsByClip;
          for (const o in i) {
            const l = i[o].actionByRoot[t];
            void 0 !== l &&
              (this._deactivateAction(l), this._removeInactiveAction(l));
          }
          const s = this._bindingsByRootAndName[t];
          if (void 0 !== s)
            for (const o in s) {
              const a = s[o];
              a.restoreOriginalState(), this._removeInactiveBinding(a);
            }
        }
        uncacheAction(e, t) {
          const i = this.existingAction(e, t);
          null !== i &&
            (this._deactivateAction(i), this._removeInactiveAction(i));
        }
      }
      class ZO {
        constructor(e = 1, t = 0, i = 0) {
          return (this.radius = e), (this.phi = t), (this.theta = i), this;
        }
        set(e, t, i) {
          return (this.radius = e), (this.phi = t), (this.theta = i), this;
        }
        copy(e) {
          return (
            (this.radius = e.radius),
            (this.phi = e.phi),
            (this.theta = e.theta),
            this
          );
        }
        makeSafe() {
          return (
            (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
            this
          );
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, i) {
          return (
            (this.radius = Math.sqrt(e * e + t * t + i * i)),
            0 === this.radius
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(e, i)),
                (this.phi = Math.acos(bn(t / this.radius, -1, 1)))),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: "154" } })
        ),
        typeof window < "u" &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = "154"));
      const sL = { type: "change" },
        Xx = { type: "start" },
        oL = { type: "end" };
      class M$ extends No {
        constructor(e, t) {
          super(),
            (this.object = e),
            (this.domElement = t),
            (this.domElement.style.touchAction = "none"),
            (this.enabled = !0),
            (this.target = new A()),
            (this.minDistance = 0),
            (this.maxDistance = 1 / 0),
            (this.minZoom = 0),
            (this.maxZoom = 1 / 0),
            (this.minPolarAngle = 0),
            (this.maxPolarAngle = Math.PI),
            (this.minAzimuthAngle = -1 / 0),
            (this.maxAzimuthAngle = 1 / 0),
            (this.enableDamping = !1),
            (this.dampingFactor = 0.05),
            (this.enableZoom = !0),
            (this.zoomSpeed = 1),
            (this.enableRotate = !0),
            (this.rotateSpeed = 1),
            (this.enablePan = !0),
            (this.panSpeed = 1),
            (this.screenSpacePanning = !0),
            (this.keyPanSpeed = 7),
            (this.autoRotate = !1),
            (this.autoRotateSpeed = 2),
            (this.keys = {
              LEFT: "ArrowLeft",
              UP: "ArrowUp",
              RIGHT: "ArrowRight",
              BOTTOM: "ArrowDown",
            }),
            (this.mouseButtons = {
              LEFT: hc.ROTATE,
              MIDDLE: hc.DOLLY,
              RIGHT: hc.PAN,
            }),
            (this.touches = { ONE: fc.ROTATE, TWO: fc.DOLLY_PAN }),
            (this.target0 = this.target.clone()),
            (this.position0 = this.object.position.clone()),
            (this.zoom0 = this.object.zoom),
            (this._domElementKeyEvents = null),
            (this.getPolarAngle = function () {
              return a.phi;
            }),
            (this.getAzimuthalAngle = function () {
              return a.theta;
            }),
            (this.getDistance = function () {
              return this.object.position.distanceTo(this.target);
            }),
            (this.listenToKeyEvents = function (R) {
              R.addEventListener("keydown", et),
                (this._domElementKeyEvents = R);
            }),
            (this.stopListenToKeyEvents = function () {
              this._domElementKeyEvents.removeEventListener("keydown", et),
                (this._domElementKeyEvents = null);
            }),
            (this.saveState = function () {
              i.target0.copy(i.target),
                i.position0.copy(i.object.position),
                (i.zoom0 = i.object.zoom);
            }),
            (this.reset = function () {
              i.target.copy(i.target0),
                i.object.position.copy(i.position0),
                (i.object.zoom = i.zoom0),
                i.object.updateProjectionMatrix(),
                i.dispatchEvent(sL),
                i.update(),
                (s = r.NONE);
            }),
            (this.update = (function () {
              const R = new A(),
                ae = new An().setFromUnitVectors(e.up, new A(0, 1, 0)),
                ue = ae.clone().invert(),
                Y = new A(),
                ke = new An(),
                We = new A(),
                Ve = 2 * Math.PI;
              return function () {
                const Fe = i.object.position;
                R.copy(Fe).sub(i.target),
                  R.applyQuaternion(ae),
                  a.setFromVector3(R),
                  i.autoRotate &&
                    s === r.NONE &&
                    w(
                      (function S() {
                        return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
                      })()
                    ),
                  i.enableDamping
                    ? ((a.theta += l.theta * i.dampingFactor),
                      (a.phi += l.phi * i.dampingFactor))
                    : ((a.theta += l.theta), (a.phi += l.phi));
                let tt = i.minAzimuthAngle,
                  Dt = i.maxAzimuthAngle;
                return (
                  isFinite(tt) &&
                    isFinite(Dt) &&
                    (tt < -Math.PI ? (tt += Ve) : tt > Math.PI && (tt -= Ve),
                    Dt < -Math.PI ? (Dt += Ve) : Dt > Math.PI && (Dt -= Ve),
                    (a.theta =
                      tt <= Dt
                        ? Math.max(tt, Math.min(Dt, a.theta))
                        : a.theta > (tt + Dt) / 2
                        ? Math.max(tt, a.theta)
                        : Math.min(Dt, a.theta))),
                  (a.phi = Math.max(
                    i.minPolarAngle,
                    Math.min(i.maxPolarAngle, a.phi)
                  )),
                  a.makeSafe(),
                  (a.radius *= c),
                  (a.radius = Math.max(
                    i.minDistance,
                    Math.min(i.maxDistance, a.radius)
                  )),
                  !0 === i.enableDamping
                    ? i.target.addScaledVector(u, i.dampingFactor)
                    : i.target.add(u),
                  R.setFromSpherical(a),
                  R.applyQuaternion(ue),
                  Fe.copy(i.target).add(R),
                  i.object.lookAt(i.target),
                  !0 === i.enableDamping
                    ? ((l.theta *= 1 - i.dampingFactor),
                      (l.phi *= 1 - i.dampingFactor),
                      u.multiplyScalar(1 - i.dampingFactor))
                    : (l.set(0, 0, 0), u.set(0, 0, 0)),
                  (c = 1),
                  !!(
                    d ||
                    Y.distanceToSquared(i.object.position) > o ||
                    8 * (1 - ke.dot(i.object.quaternion)) > o ||
                    We.distanceToSquared(i.target) > 0
                  ) &&
                    (i.dispatchEvent(sL),
                    Y.copy(i.object.position),
                    ke.copy(i.object.quaternion),
                    We.copy(i.target),
                    (d = !1),
                    !0)
                );
              };
            })()),
            (this.dispose = function () {
              i.domElement.removeEventListener("contextmenu", I),
                i.domElement.removeEventListener("pointerdown", ie),
                i.domElement.removeEventListener("pointercancel", oe),
                i.domElement.removeEventListener("wheel", Oe),
                i.domElement.removeEventListener("pointermove", pe),
                i.domElement.removeEventListener("pointerup", oe),
                null !== i._domElementKeyEvents &&
                  (i._domElementKeyEvents.removeEventListener("keydown", et),
                  (i._domElementKeyEvents = null));
            });
          const i = this,
            r = {
              NONE: -1,
              ROTATE: 0,
              DOLLY: 1,
              PAN: 2,
              TOUCH_ROTATE: 3,
              TOUCH_PAN: 4,
              TOUCH_DOLLY_PAN: 5,
              TOUCH_DOLLY_ROTATE: 6,
            };
          let s = r.NONE;
          const o = 1e-6,
            a = new ZO(),
            l = new ZO();
          let c = 1;
          const u = new A();
          let d = !1;
          const h = new $(),
            f = new $(),
            p = new $(),
            _ = new $(),
            m = new $(),
            g = new $(),
            y = new $(),
            v = new $(),
            b = new $(),
            x = [],
            M = {};
          function C() {
            return Math.pow(0.95, i.zoomSpeed);
          }
          function w(R) {
            l.theta -= R;
          }
          function E(R) {
            l.phi -= R;
          }
          const V = (function () {
              const R = new A();
              return function (ue, Y) {
                R.setFromMatrixColumn(Y, 0), R.multiplyScalar(-ue), u.add(R);
              };
            })(),
            j = (function () {
              const R = new A();
              return function (ue, Y) {
                !0 === i.screenSpacePanning
                  ? R.setFromMatrixColumn(Y, 1)
                  : (R.setFromMatrixColumn(Y, 0),
                    R.crossVectors(i.object.up, R)),
                  R.multiplyScalar(ue),
                  u.add(R);
              };
            })(),
            F = (function () {
              const R = new A();
              return function (ue, Y) {
                const ke = i.domElement;
                if (i.object.isPerspectiveCamera) {
                  R.copy(i.object.position).sub(i.target);
                  let Ve = R.length();
                  (Ve *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
                    V((2 * ue * Ve) / ke.clientHeight, i.object.matrix),
                    j((2 * Y * Ve) / ke.clientHeight, i.object.matrix);
                } else
                  i.object.isOrthographicCamera
                    ? (V(
                        (ue * (i.object.right - i.object.left)) /
                          i.object.zoom /
                          ke.clientWidth,
                        i.object.matrix
                      ),
                      j(
                        (Y * (i.object.top - i.object.bottom)) /
                          i.object.zoom /
                          ke.clientHeight,
                        i.object.matrix
                      ))
                    : (console.warn(
                        "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                      ),
                      (i.enablePan = !1));
              };
            })();
          function k(R) {
            i.object.isPerspectiveCamera
              ? (c /= R)
              : i.object.isOrthographicCamera
              ? ((i.object.zoom = Math.max(
                  i.minZoom,
                  Math.min(i.maxZoom, i.object.zoom * R)
                )),
                i.object.updateProjectionMatrix(),
                (d = !0))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                ),
                (i.enableZoom = !1));
          }
          function z(R) {
            i.object.isPerspectiveCamera
              ? (c *= R)
              : i.object.isOrthographicCamera
              ? ((i.object.zoom = Math.max(
                  i.minZoom,
                  Math.min(i.maxZoom, i.object.zoom / R)
                )),
                i.object.updateProjectionMatrix(),
                (d = !0))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                ),
                (i.enableZoom = !1));
          }
          function O(R) {
            h.set(R.clientX, R.clientY);
          }
          function U(R) {
            _.set(R.clientX, R.clientY);
          }
          function te() {
            1 === x.length
              ? h.set(x[0].pageX, x[0].pageY)
              : h.set(
                  0.5 * (x[0].pageX + x[1].pageX),
                  0.5 * (x[0].pageY + x[1].pageY)
                );
          }
          function ce() {
            1 === x.length
              ? _.set(x[0].pageX, x[0].pageY)
              : _.set(
                  0.5 * (x[0].pageX + x[1].pageX),
                  0.5 * (x[0].pageY + x[1].pageY)
                );
          }
          function Ce() {
            const R = x[0].pageX - x[1].pageX,
              ae = x[0].pageY - x[1].pageY,
              ue = Math.sqrt(R * R + ae * ae);
            y.set(0, ue);
          }
          function Ze(R) {
            if (1 == x.length) f.set(R.pageX, R.pageY);
            else {
              const ue = he(R);
              f.set(0.5 * (R.pageX + ue.x), 0.5 * (R.pageY + ue.y));
            }
            p.subVectors(f, h).multiplyScalar(i.rotateSpeed);
            const ae = i.domElement;
            w((2 * Math.PI * p.x) / ae.clientHeight),
              E((2 * Math.PI * p.y) / ae.clientHeight),
              h.copy(f);
          }
          function dt(R) {
            if (1 === x.length) m.set(R.pageX, R.pageY);
            else {
              const ae = he(R);
              m.set(0.5 * (R.pageX + ae.x), 0.5 * (R.pageY + ae.y));
            }
            g.subVectors(m, _).multiplyScalar(i.panSpeed),
              F(g.x, g.y),
              _.copy(m);
          }
          function Ue(R) {
            const ae = he(R),
              ue = R.pageX - ae.x,
              Y = R.pageY - ae.y,
              ke = Math.sqrt(ue * ue + Y * Y);
            v.set(0, ke),
              b.set(0, Math.pow(v.y / y.y, i.zoomSpeed)),
              k(b.y),
              y.copy(v);
          }
          function ie(R) {
            !1 !== i.enabled &&
              (0 === x.length &&
                (i.domElement.setPointerCapture(R.pointerId),
                i.domElement.addEventListener("pointermove", pe),
                i.domElement.addEventListener("pointerup", oe)),
              (function T(R) {
                x.push(R);
              })(R),
              "touch" === R.pointerType
                ? (function Tt(R) {
                    switch ((fe(R), x.length)) {
                      case 1:
                        switch (i.touches.ONE) {
                          case fc.ROTATE:
                            if (!1 === i.enableRotate) return;
                            te(), (s = r.TOUCH_ROTATE);
                            break;
                          case fc.PAN:
                            if (!1 === i.enablePan) return;
                            ce(), (s = r.TOUCH_PAN);
                            break;
                          default:
                            s = r.NONE;
                        }
                        break;
                      case 2:
                        switch (i.touches.TWO) {
                          case fc.DOLLY_PAN:
                            if (!1 === i.enableZoom && !1 === i.enablePan)
                              return;
                            (function ve() {
                              i.enableZoom && Ce(), i.enablePan && ce();
                            })(),
                              (s = r.TOUCH_DOLLY_PAN);
                            break;
                          case fc.DOLLY_ROTATE:
                            if (!1 === i.enableZoom && !1 === i.enableRotate)
                              return;
                            (function xe() {
                              i.enableZoom && Ce(), i.enableRotate && te();
                            })(),
                              (s = r.TOUCH_DOLLY_ROTATE);
                            break;
                          default:
                            s = r.NONE;
                        }
                        break;
                      default:
                        s = r.NONE;
                    }
                    s !== r.NONE && i.dispatchEvent(Xx);
                  })(R)
                : (function ze(R) {
                    let ae;
                    switch (R.button) {
                      case 0:
                        ae = i.mouseButtons.LEFT;
                        break;
                      case 1:
                        ae = i.mouseButtons.MIDDLE;
                        break;
                      case 2:
                        ae = i.mouseButtons.RIGHT;
                        break;
                      default:
                        ae = -1;
                    }
                    switch (ae) {
                      case hc.DOLLY:
                        if (!1 === i.enableZoom) return;
                        (function L(R) {
                          y.set(R.clientX, R.clientY);
                        })(R),
                          (s = r.DOLLY);
                        break;
                      case hc.ROTATE:
                        if (R.ctrlKey || R.metaKey || R.shiftKey) {
                          if (!1 === i.enablePan) return;
                          U(R), (s = r.PAN);
                        } else {
                          if (!1 === i.enableRotate) return;
                          O(R), (s = r.ROTATE);
                        }
                        break;
                      case hc.PAN:
                        if (R.ctrlKey || R.metaKey || R.shiftKey) {
                          if (!1 === i.enableRotate) return;
                          O(R), (s = r.ROTATE);
                        } else {
                          if (!1 === i.enablePan) return;
                          U(R), (s = r.PAN);
                        }
                        break;
                      default:
                        s = r.NONE;
                    }
                    s !== r.NONE && i.dispatchEvent(Xx);
                  })(R));
          }
          function pe(R) {
            !1 !== i.enabled &&
              ("touch" === R.pointerType
                ? (function an(R) {
                    switch ((fe(R), s)) {
                      case r.TOUCH_ROTATE:
                        if (!1 === i.enableRotate) return;
                        Ze(R), i.update();
                        break;
                      case r.TOUCH_PAN:
                        if (!1 === i.enablePan) return;
                        dt(R), i.update();
                        break;
                      case r.TOUCH_DOLLY_PAN:
                        if (!1 === i.enableZoom && !1 === i.enablePan) return;
                        (function P(R) {
                          i.enableZoom && Ue(R), i.enablePan && dt(R);
                        })(R),
                          i.update();
                        break;
                      case r.TOUCH_DOLLY_ROTATE:
                        if (!1 === i.enableZoom && !1 === i.enableRotate)
                          return;
                        (function ge(R) {
                          i.enableZoom && Ue(R), i.enableRotate && Ze(R);
                        })(R),
                          i.update();
                        break;
                      default:
                        s = r.NONE;
                    }
                  })(R)
                : (function Pe(R) {
                    switch (s) {
                      case r.ROTATE:
                        if (!1 === i.enableRotate) return;
                        !(function W(R) {
                          f.set(R.clientX, R.clientY),
                            p.subVectors(f, h).multiplyScalar(i.rotateSpeed);
                          const ae = i.domElement;
                          w((2 * Math.PI * p.x) / ae.clientHeight),
                            E((2 * Math.PI * p.y) / ae.clientHeight),
                            h.copy(f),
                            i.update();
                        })(R);
                        break;
                      case r.DOLLY:
                        if (!1 === i.enableZoom) return;
                        !(function Z(R) {
                          v.set(R.clientX, R.clientY),
                            b.subVectors(v, y),
                            b.y > 0 ? k(C()) : b.y < 0 && z(C()),
                            y.copy(v),
                            i.update();
                        })(R);
                        break;
                      case r.PAN:
                        if (!1 === i.enablePan) return;
                        !(function B(R) {
                          m.set(R.clientX, R.clientY),
                            g.subVectors(m, _).multiplyScalar(i.panSpeed),
                            F(g.x, g.y),
                            _.copy(m),
                            i.update();
                        })(R);
                    }
                  })(R));
          }
          function oe(R) {
            (function Q(R) {
              delete M[R.pointerId];
              for (let ae = 0; ae < x.length; ae++)
                if (x[ae].pointerId == R.pointerId) return void x.splice(ae, 1);
            })(R),
              0 === x.length &&
                (i.domElement.releasePointerCapture(R.pointerId),
                i.domElement.removeEventListener("pointermove", pe),
                i.domElement.removeEventListener("pointerup", oe)),
              i.dispatchEvent(oL),
              (s = r.NONE);
          }
          function Oe(R) {
            !1 === i.enabled ||
              !1 === i.enableZoom ||
              s !== r.NONE ||
              (R.preventDefault(),
              i.dispatchEvent(Xx),
              (function q(R) {
                R.deltaY < 0 ? z(C()) : R.deltaY > 0 && k(C()), i.update();
              })(R),
              i.dispatchEvent(oL));
          }
          function et(R) {
            !1 === i.enabled ||
              !1 === i.enablePan ||
              (function le(R) {
                let ae = !1;
                switch (R.code) {
                  case i.keys.UP:
                    R.ctrlKey || R.metaKey || R.shiftKey
                      ? E(
                          (2 * Math.PI * i.rotateSpeed) /
                            i.domElement.clientHeight
                        )
                      : F(0, i.keyPanSpeed),
                      (ae = !0);
                    break;
                  case i.keys.BOTTOM:
                    R.ctrlKey || R.metaKey || R.shiftKey
                      ? E(
                          (-2 * Math.PI * i.rotateSpeed) /
                            i.domElement.clientHeight
                        )
                      : F(0, -i.keyPanSpeed),
                      (ae = !0);
                    break;
                  case i.keys.LEFT:
                    R.ctrlKey || R.metaKey || R.shiftKey
                      ? w(
                          (2 * Math.PI * i.rotateSpeed) /
                            i.domElement.clientHeight
                        )
                      : F(i.keyPanSpeed, 0),
                      (ae = !0);
                    break;
                  case i.keys.RIGHT:
                    R.ctrlKey || R.metaKey || R.shiftKey
                      ? w(
                          (-2 * Math.PI * i.rotateSpeed) /
                            i.domElement.clientHeight
                        )
                      : F(-i.keyPanSpeed, 0),
                      (ae = !0);
                }
                ae && (R.preventDefault(), i.update());
              })(R);
          }
          function I(R) {
            !1 !== i.enabled && R.preventDefault();
          }
          function fe(R) {
            let ae = M[R.pointerId];
            void 0 === ae && ((ae = new $()), (M[R.pointerId] = ae)),
              ae.set(R.pageX, R.pageY);
          }
          function he(R) {
            return M[(R.pointerId === x[0].pointerId ? x[1] : x[0]).pointerId];
          }
          i.domElement.addEventListener("contextmenu", I),
            i.domElement.addEventListener("pointerdown", ie),
            i.domElement.addEventListener("pointercancel", oe),
            i.domElement.addEventListener("wheel", Oe, { passive: !1 }),
            this.update();
        }
      }
      const aL = {
        name: "CopyShader",
        uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
        vertexShader:
          "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader:
          "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}",
      };
      class au {
        constructor() {
          (this.isPass = !0),
            (this.enabled = !0),
            (this.needsSwap = !0),
            (this.clear = !1),
            (this.renderToScreen = !1);
        }
        setSize() {}
        render() {
          console.error(
            "THREE.Pass: .render() must be implemented in derived pass."
          );
        }
        dispose() {}
      }
      const S$ = new Hc(-1, 1, 1, -1, 0, 1),
        qx = new ut();
      qx.setAttribute("position", new Ie([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
        qx.setAttribute("uv", new Ie([0, 2, 0, 0, 2, 0], 2));
      class Yx {
        constructor(e) {
          this._mesh = new Kn(qx, e);
        }
        dispose() {
          this._mesh.geometry.dispose();
        }
        render(e) {
          e.render(this._mesh, S$);
        }
        get material() {
          return this._mesh.material;
        }
        set material(e) {
          this._mesh.material = e;
        }
      }
      class E$ extends au {
        constructor(e, t) {
          super(),
            (this.textureID = void 0 !== t ? t : "tDiffuse"),
            e instanceof $n
              ? ((this.uniforms = e.uniforms), (this.material = e))
              : e &&
                ((this.uniforms = Uc.clone(e.uniforms)),
                (this.material = new $n({
                  name: void 0 !== e.name ? e.name : "unspecified",
                  defines: Object.assign({}, e.defines),
                  uniforms: this.uniforms,
                  vertexShader: e.vertexShader,
                  fragmentShader: e.fragmentShader,
                }))),
            (this.fsQuad = new Yx(this.material));
        }
        render(e, t, i) {
          this.uniforms[this.textureID] &&
            (this.uniforms[this.textureID].value = i.texture),
            (this.fsQuad.material = this.material),
            this.renderToScreen
              ? (e.setRenderTarget(null), this.fsQuad.render(e))
              : (e.setRenderTarget(t),
                this.clear &&
                  e.clear(
                    e.autoClearColor,
                    e.autoClearDepth,
                    e.autoClearStencil
                  ),
                this.fsQuad.render(e));
        }
        dispose() {
          this.material.dispose(), this.fsQuad.dispose();
        }
      }
      class lL extends au {
        constructor(e, t) {
          super(),
            (this.scene = e),
            (this.camera = t),
            (this.clear = !0),
            (this.needsSwap = !1),
            (this.inverse = !1);
        }
        render(e, t, i) {
          const r = e.getContext(),
            s = e.state;
          let o, a;
          s.buffers.color.setMask(!1),
            s.buffers.depth.setMask(!1),
            s.buffers.color.setLocked(!0),
            s.buffers.depth.setLocked(!0),
            this.inverse ? ((o = 0), (a = 1)) : ((o = 1), (a = 0)),
            s.buffers.stencil.setTest(!0),
            s.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE),
            s.buffers.stencil.setFunc(r.ALWAYS, o, 4294967295),
            s.buffers.stencil.setClear(a),
            s.buffers.stencil.setLocked(!0),
            e.setRenderTarget(i),
            this.clear && e.clear(),
            e.render(this.scene, this.camera),
            e.setRenderTarget(t),
            this.clear && e.clear(),
            e.render(this.scene, this.camera),
            s.buffers.color.setLocked(!1),
            s.buffers.depth.setLocked(!1),
            s.buffers.stencil.setLocked(!1),
            s.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295),
            s.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP),
            s.buffers.stencil.setLocked(!0);
        }
      }
      class C$ extends au {
        constructor() {
          super(), (this.needsSwap = !1);
        }
        render(e) {
          e.state.buffers.stencil.setLocked(!1),
            e.state.buffers.stencil.setTest(!1);
        }
      }
      class T$ {
        constructor(e, t) {
          if (
            ((this.renderer = e),
            (this._pixelRatio = e.getPixelRatio()),
            void 0 === t)
          ) {
            const i = e.getSize(new $());
            (this._width = i.width),
              (this._height = i.height),
              ((t = new li(
                this._width * this._pixelRatio,
                this._height * this._pixelRatio,
                { type: Hi }
              )).texture.name = "EffectComposer.rt1");
          } else (this._width = t.width), (this._height = t.height);
          (this.renderTarget1 = t),
            (this.renderTarget2 = t.clone()),
            (this.renderTarget2.texture.name = "EffectComposer.rt2"),
            (this.writeBuffer = this.renderTarget1),
            (this.readBuffer = this.renderTarget2),
            (this.renderToScreen = !0),
            (this.passes = []),
            (this.copyPass = new E$(aL)),
            (this.copyPass.material.blending = Zr),
            (this.clock = new Vx());
        }
        swapBuffers() {
          const e = this.readBuffer;
          (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
        }
        addPass(e) {
          this.passes.push(e),
            e.setSize(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio
            );
        }
        insertPass(e, t) {
          this.passes.splice(t, 0, e),
            e.setSize(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio
            );
        }
        removePass(e) {
          const t = this.passes.indexOf(e);
          -1 !== t && this.passes.splice(t, 1);
        }
        isLastEnabledPass(e) {
          for (let t = e + 1; t < this.passes.length; t++)
            if (this.passes[t].enabled) return !1;
          return !0;
        }
        render(e) {
          void 0 === e && (e = this.clock.getDelta());
          const t = this.renderer.getRenderTarget();
          let i = !1;
          for (let r = 0, s = this.passes.length; r < s; r++) {
            const o = this.passes[r];
            if (!1 !== o.enabled) {
              if (
                ((o.renderToScreen =
                  this.renderToScreen && this.isLastEnabledPass(r)),
                o.render(
                  this.renderer,
                  this.writeBuffer,
                  this.readBuffer,
                  e,
                  i
                ),
                o.needsSwap)
              ) {
                if (i) {
                  const a = this.renderer.getContext(),
                    l = this.renderer.state.buffers.stencil;
                  l.setFunc(a.NOTEQUAL, 1, 4294967295),
                    this.copyPass.render(
                      this.renderer,
                      this.writeBuffer,
                      this.readBuffer,
                      e
                    ),
                    l.setFunc(a.EQUAL, 1, 4294967295);
                }
                this.swapBuffers();
              }
              void 0 !== lL &&
                (o instanceof lL ? (i = !0) : o instanceof C$ && (i = !1));
            }
          }
          this.renderer.setRenderTarget(t);
        }
        reset(e) {
          if (void 0 === e) {
            const t = this.renderer.getSize(new $());
            (this._pixelRatio = this.renderer.getPixelRatio()),
              (this._width = t.width),
              (this._height = t.height),
              (e = this.renderTarget1.clone()).setSize(
                this._width * this._pixelRatio,
                this._height * this._pixelRatio
              );
          }
          this.renderTarget1.dispose(),
            this.renderTarget2.dispose(),
            (this.renderTarget1 = e),
            (this.renderTarget2 = e.clone()),
            (this.writeBuffer = this.renderTarget1),
            (this.readBuffer = this.renderTarget2);
        }
        setSize(e, t) {
          (this._width = e), (this._height = t);
          const i = this._width * this._pixelRatio,
            r = this._height * this._pixelRatio;
          this.renderTarget1.setSize(i, r), this.renderTarget2.setSize(i, r);
          for (let s = 0; s < this.passes.length; s++)
            this.passes[s].setSize(i, r);
        }
        setPixelRatio(e) {
          (this._pixelRatio = e), this.setSize(this._width, this._height);
        }
        dispose() {
          this.renderTarget1.dispose(),
            this.renderTarget2.dispose(),
            this.copyPass.dispose();
        }
      }
      class A$ extends au {
        constructor(e, t, i, r, s) {
          super(),
            (this.scene = e),
            (this.camera = t),
            (this.overrideMaterial = i),
            (this.clearColor = r),
            (this.clearAlpha = void 0 !== s ? s : 0),
            (this.clear = !0),
            (this.clearDepth = !1),
            (this.needsSwap = !1),
            (this._oldClearColor = new de());
        }
        render(e, t, i) {
          const r = e.autoClear;
          let s, o;
          (e.autoClear = !1),
            void 0 !== this.overrideMaterial &&
              ((o = this.scene.overrideMaterial),
              (this.scene.overrideMaterial = this.overrideMaterial)),
            this.clearColor &&
              (e.getClearColor(this._oldClearColor),
              (s = e.getClearAlpha()),
              e.setClearColor(this.clearColor, this.clearAlpha)),
            this.clearDepth && e.clearDepth(),
            e.setRenderTarget(this.renderToScreen ? null : i),
            this.clear &&
              e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            e.render(this.scene, this.camera),
            this.clearColor && e.setClearColor(this._oldClearColor, s),
            void 0 !== this.overrideMaterial &&
              (this.scene.overrideMaterial = o),
            (e.autoClear = r);
        }
      }
      class Wo extends au {
        constructor(e, t, i, r) {
          super(),
            (this.renderScene = t),
            (this.renderCamera = i),
            (this.selectedObjects = void 0 !== r ? r : []),
            (this.visibleEdgeColor = new de(1, 1, 1)),
            (this.hiddenEdgeColor = new de(0.1, 0.04, 0.02)),
            (this.edgeGlow = 0),
            (this.usePatternTexture = !1),
            (this.edgeThickness = 1),
            (this.edgeStrength = 3),
            (this.downSampleRatio = 2),
            (this.pulsePeriod = 0),
            (this._visibilityCache = new Map()),
            (this.resolution =
              void 0 !== e ? new $(e.x, e.y) : new $(256, 256));
          const s = Math.round(this.resolution.x / this.downSampleRatio),
            o = Math.round(this.resolution.y / this.downSampleRatio);
          (this.renderTargetMaskBuffer = new li(
            this.resolution.x,
            this.resolution.y
          )),
            (this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask"),
            (this.renderTargetMaskBuffer.texture.generateMipmaps = !1),
            (this.depthMaterial = new Kb()),
            (this.depthMaterial.side = Cr),
            (this.depthMaterial.depthPacking = XR),
            (this.depthMaterial.blending = Zr),
            (this.prepareMaskMaterial = this.getPrepareMaskMaterial()),
            (this.prepareMaskMaterial.side = Cr),
            (this.prepareMaskMaterial.fragmentShader = (function u(d, h) {
              return d.replace(
                /DEPTH_TO_VIEW_Z/g,
                (h.isPerspectiveCamera ? "perspective" : "orthographic") +
                  "DepthToViewZ"
              );
            })(this.prepareMaskMaterial.fragmentShader, this.renderCamera)),
            (this.renderTargetDepthBuffer = new li(
              this.resolution.x,
              this.resolution.y,
              { type: Hi }
            )),
            (this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth"),
            (this.renderTargetDepthBuffer.texture.generateMipmaps = !1),
            (this.renderTargetMaskDownSampleBuffer = new li(s, o, {
              type: Hi,
            })),
            (this.renderTargetMaskDownSampleBuffer.texture.name =
              "OutlinePass.depthDownSample"),
            (this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps =
              !1),
            (this.renderTargetBlurBuffer1 = new li(s, o, { type: Hi })),
            (this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1"),
            (this.renderTargetBlurBuffer1.texture.generateMipmaps = !1),
            (this.renderTargetBlurBuffer2 = new li(
              Math.round(s / 2),
              Math.round(o / 2),
              { type: Hi }
            )),
            (this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2"),
            (this.renderTargetBlurBuffer2.texture.generateMipmaps = !1),
            (this.edgeDetectionMaterial = this.getEdgeDetectionMaterial()),
            (this.renderTargetEdgeBuffer1 = new li(s, o, { type: Hi })),
            (this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1"),
            (this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1),
            (this.renderTargetEdgeBuffer2 = new li(
              Math.round(s / 2),
              Math.round(o / 2),
              { type: Hi }
            )),
            (this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2"),
            (this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1),
            (this.separableBlurMaterial1 = this.getSeperableBlurMaterial(4)),
            this.separableBlurMaterial1.uniforms.texSize.value.set(s, o),
            (this.separableBlurMaterial1.uniforms.kernelRadius.value = 1),
            (this.separableBlurMaterial2 = this.getSeperableBlurMaterial(4)),
            this.separableBlurMaterial2.uniforms.texSize.value.set(
              Math.round(s / 2),
              Math.round(o / 2)
            ),
            (this.separableBlurMaterial2.uniforms.kernelRadius.value = 4),
            (this.overlayMaterial = this.getOverlayMaterial());
          const c = aL;
          (this.copyUniforms = Uc.clone(c.uniforms)),
            (this.materialCopy = new $n({
              uniforms: this.copyUniforms,
              vertexShader: c.vertexShader,
              fragmentShader: c.fragmentShader,
              blending: Zr,
              depthTest: !1,
              depthWrite: !1,
            })),
            (this.enabled = !0),
            (this.needsSwap = !1),
            (this._oldClearColor = new de()),
            (this.oldClearAlpha = 1),
            (this.fsQuad = new Yx(null)),
            (this.tempPulseColor1 = new de()),
            (this.tempPulseColor2 = new de()),
            (this.textureMatrix = new Ae());
        }
        dispose() {
          this.renderTargetMaskBuffer.dispose(),
            this.renderTargetDepthBuffer.dispose(),
            this.renderTargetMaskDownSampleBuffer.dispose(),
            this.renderTargetBlurBuffer1.dispose(),
            this.renderTargetBlurBuffer2.dispose(),
            this.renderTargetEdgeBuffer1.dispose(),
            this.renderTargetEdgeBuffer2.dispose(),
            this.depthMaterial.dispose(),
            this.prepareMaskMaterial.dispose(),
            this.edgeDetectionMaterial.dispose(),
            this.separableBlurMaterial1.dispose(),
            this.separableBlurMaterial2.dispose(),
            this.overlayMaterial.dispose(),
            this.materialCopy.dispose(),
            this.fsQuad.dispose();
        }
        setSize(e, t) {
          this.renderTargetMaskBuffer.setSize(e, t),
            this.renderTargetDepthBuffer.setSize(e, t);
          let i = Math.round(e / this.downSampleRatio),
            r = Math.round(t / this.downSampleRatio);
          this.renderTargetMaskDownSampleBuffer.setSize(i, r),
            this.renderTargetBlurBuffer1.setSize(i, r),
            this.renderTargetEdgeBuffer1.setSize(i, r),
            this.separableBlurMaterial1.uniforms.texSize.value.set(i, r),
            (i = Math.round(i / 2)),
            (r = Math.round(r / 2)),
            this.renderTargetBlurBuffer2.setSize(i, r),
            this.renderTargetEdgeBuffer2.setSize(i, r),
            this.separableBlurMaterial2.uniforms.texSize.value.set(i, r);
        }
        changeVisibilityOfSelectedObjects(e) {
          const t = this._visibilityCache;
          function i(r) {
            r.isMesh &&
              (!0 === e
                ? (r.visible = t.get(r))
                : (t.set(r, r.visible), (r.visible = e)));
          }
          for (let r = 0; r < this.selectedObjects.length; r++)
            this.selectedObjects[r].traverse(i);
        }
        changeVisibilityOfNonSelectedObjects(e) {
          const t = this._visibilityCache,
            i = [];
          function r(o) {
            o.isMesh && i.push(o);
          }
          for (let o = 0; o < this.selectedObjects.length; o++)
            this.selectedObjects[o].traverse(r);
          this.renderScene.traverse(function s(o) {
            if (o.isMesh || o.isSprite) {
              let a = !1;
              for (let l = 0; l < i.length; l++)
                if (i[l].id === o.id) {
                  a = !0;
                  break;
                }
              if (!1 === a) {
                const l = o.visible;
                (!1 === e || !0 === t.get(o)) && (o.visible = e), t.set(o, l);
              }
            } else (o.isPoints || o.isLine) && (!0 === e ? (o.visible = t.get(o)) : (t.set(o, o.visible), (o.visible = e)));
          });
        }
        updateTextureMatrix() {
          this.textureMatrix.set(
            0.5,
            0,
            0,
            0.5,
            0,
            0.5,
            0,
            0.5,
            0,
            0,
            0.5,
            0.5,
            0,
            0,
            0,
            1
          ),
            this.textureMatrix.multiply(this.renderCamera.projectionMatrix),
            this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
        }
        render(e, t, i, r, s) {
          if (this.selectedObjects.length > 0) {
            e.getClearColor(this._oldClearColor),
              (this.oldClearAlpha = e.getClearAlpha());
            const o = e.autoClear;
            (e.autoClear = !1),
              s && e.state.buffers.stencil.setTest(!1),
              e.setClearColor(16777215, 1),
              this.changeVisibilityOfSelectedObjects(!1);
            const a = this.renderScene.background;
            if (
              ((this.renderScene.background = null),
              (this.renderScene.overrideMaterial = this.depthMaterial),
              e.setRenderTarget(this.renderTargetDepthBuffer),
              e.clear(),
              e.render(this.renderScene, this.renderCamera),
              this.changeVisibilityOfSelectedObjects(!0),
              this._visibilityCache.clear(),
              this.updateTextureMatrix(),
              this.changeVisibilityOfNonSelectedObjects(!1),
              (this.renderScene.overrideMaterial = this.prepareMaskMaterial),
              this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(
                this.renderCamera.near,
                this.renderCamera.far
              ),
              (this.prepareMaskMaterial.uniforms.depthTexture.value =
                this.renderTargetDepthBuffer.texture),
              (this.prepareMaskMaterial.uniforms.textureMatrix.value =
                this.textureMatrix),
              e.setRenderTarget(this.renderTargetMaskBuffer),
              e.clear(),
              e.render(this.renderScene, this.renderCamera),
              (this.renderScene.overrideMaterial = null),
              this.changeVisibilityOfNonSelectedObjects(!0),
              this._visibilityCache.clear(),
              (this.renderScene.background = a),
              (this.fsQuad.material = this.materialCopy),
              (this.copyUniforms.tDiffuse.value =
                this.renderTargetMaskBuffer.texture),
              e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),
              e.clear(),
              this.fsQuad.render(e),
              this.tempPulseColor1.copy(this.visibleEdgeColor),
              this.tempPulseColor2.copy(this.hiddenEdgeColor),
              this.pulsePeriod > 0)
            ) {
              const l =
                0.625 +
                (0.75 *
                  Math.cos((0.01 * performance.now()) / this.pulsePeriod)) /
                  2;
              this.tempPulseColor1.multiplyScalar(l),
                this.tempPulseColor2.multiplyScalar(l);
            }
            (this.fsQuad.material = this.edgeDetectionMaterial),
              (this.edgeDetectionMaterial.uniforms.maskTexture.value =
                this.renderTargetMaskDownSampleBuffer.texture),
              this.edgeDetectionMaterial.uniforms.texSize.value.set(
                this.renderTargetMaskDownSampleBuffer.width,
                this.renderTargetMaskDownSampleBuffer.height
              ),
              (this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value =
                this.tempPulseColor1),
              (this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value =
                this.tempPulseColor2),
              e.setRenderTarget(this.renderTargetEdgeBuffer1),
              e.clear(),
              this.fsQuad.render(e),
              (this.fsQuad.material = this.separableBlurMaterial1),
              (this.separableBlurMaterial1.uniforms.colorTexture.value =
                this.renderTargetEdgeBuffer1.texture),
              (this.separableBlurMaterial1.uniforms.direction.value =
                Wo.BlurDirectionX),
              (this.separableBlurMaterial1.uniforms.kernelRadius.value =
                this.edgeThickness),
              e.setRenderTarget(this.renderTargetBlurBuffer1),
              e.clear(),
              this.fsQuad.render(e),
              (this.separableBlurMaterial1.uniforms.colorTexture.value =
                this.renderTargetBlurBuffer1.texture),
              (this.separableBlurMaterial1.uniforms.direction.value =
                Wo.BlurDirectionY),
              e.setRenderTarget(this.renderTargetEdgeBuffer1),
              e.clear(),
              this.fsQuad.render(e),
              (this.fsQuad.material = this.separableBlurMaterial2),
              (this.separableBlurMaterial2.uniforms.colorTexture.value =
                this.renderTargetEdgeBuffer1.texture),
              (this.separableBlurMaterial2.uniforms.direction.value =
                Wo.BlurDirectionX),
              e.setRenderTarget(this.renderTargetBlurBuffer2),
              e.clear(),
              this.fsQuad.render(e),
              (this.separableBlurMaterial2.uniforms.colorTexture.value =
                this.renderTargetBlurBuffer2.texture),
              (this.separableBlurMaterial2.uniforms.direction.value =
                Wo.BlurDirectionY),
              e.setRenderTarget(this.renderTargetEdgeBuffer2),
              e.clear(),
              this.fsQuad.render(e),
              (this.fsQuad.material = this.overlayMaterial),
              (this.overlayMaterial.uniforms.maskTexture.value =
                this.renderTargetMaskBuffer.texture),
              (this.overlayMaterial.uniforms.edgeTexture1.value =
                this.renderTargetEdgeBuffer1.texture),
              (this.overlayMaterial.uniforms.edgeTexture2.value =
                this.renderTargetEdgeBuffer2.texture),
              (this.overlayMaterial.uniforms.patternTexture.value =
                this.patternTexture),
              (this.overlayMaterial.uniforms.edgeStrength.value =
                this.edgeStrength),
              (this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow),
              (this.overlayMaterial.uniforms.usePatternTexture.value =
                this.usePatternTexture),
              s && e.state.buffers.stencil.setTest(!0),
              e.setRenderTarget(i),
              this.fsQuad.render(e),
              e.setClearColor(this._oldClearColor, this.oldClearAlpha),
              (e.autoClear = o);
          }
          this.renderToScreen &&
            ((this.fsQuad.material = this.materialCopy),
            (this.copyUniforms.tDiffuse.value = i.texture),
            e.setRenderTarget(null),
            this.fsQuad.render(e));
        }
        getPrepareMaskMaterial() {
          return new $n({
            uniforms: {
              depthTexture: { value: null },
              cameraNearFar: { value: new $(0.5, 0.5) },
              textureMatrix: { value: null },
            },
            vertexShader:
              "#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\n\t\t\t\t\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t\t\t\t\t#ifdef USE_INSTANCING\n\n\t\t\t\t\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tworldPosition = modelMatrix * worldPosition;\n\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}",
            fragmentShader:
              "#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}",
          });
        }
        getEdgeDetectionMaterial() {
          return new $n({
            uniforms: {
              maskTexture: { value: null },
              texSize: { value: new $(0.5, 0.5) },
              visibleEdgeColor: { value: new A(1, 1, 1) },
              hiddenEdgeColor: { value: new A(1, 1, 1) },
            },
            vertexShader:
              "varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader:
              "varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}",
          });
        }
        getSeperableBlurMaterial(e) {
          return new $n({
            defines: { MAX_RADIUS: e },
            uniforms: {
              colorTexture: { value: null },
              texSize: { value: new $(0.5, 0.5) },
              direction: { value: new $(0.5, 0.5) },
              kernelRadius: { value: 1 },
            },
            vertexShader:
              "varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader:
              "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat sigma = kernelRadius/2.0;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, sigma);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = kernelRadius * float(i) / float(MAX_RADIUS);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, sigma);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}",
          });
        }
        getOverlayMaterial() {
          return new $n({
            uniforms: {
              maskTexture: { value: null },
              edgeTexture1: { value: null },
              edgeTexture2: { value: null },
              patternTexture: { value: null },
              edgeStrength: { value: 1 },
              edgeGlow: { value: 1 },
              usePatternTexture: { value: 0 },
            },
            vertexShader:
              "varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader:
              "varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",
            blending: ob,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0,
          });
        }
      }
      (Wo.BlurDirectionX = new $(1, 0)), (Wo.BlurDirectionY = new $(0, 1));
      const hg = {
          defines: { SMAA_THRESHOLD: "0.1" },
          uniforms: {
            tDiffuse: { value: null },
            resolution: { value: new $(1 / 1024, 1 / 512) },
          },
          vertexShader:
            "\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAAEdgeDetectionVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
          fragmentShader:
            "\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\n\t\tvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n\t\t\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\n\t\t\t// Calculate color deltas:\n\t\t\tvec4 delta;\n\t\t\tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\n\t\t\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n\t\t\tvec3 t = abs( C - Cleft );\n\t\t\tdelta.x = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n\t\t\tt = abs( C - Ctop );\n\t\t\tdelta.y = max( max( t.r, t.g ), t.b );\n\n\t\t\t// We do the usual threshold:\n\t\t\tvec2 edges = step( threshold, delta.xy );\n\n\t\t\t// Then discard if there is no edge:\n\t\t\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n\t\t\t\tdiscard;\n\n\t\t\t// Calculate right and bottom deltas:\n\t\t\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n\t\t\tt = abs( C - Cright );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n\t\t\tt = abs( C - Cbottom );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the maximum delta in the direct neighborhood:\n\t\t\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\n\t\t\t// Calculate left-left and top-top deltas:\n\t\t\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n\t\t\tt = abs( C - Cleftleft );\n\t\t\tdelta.z = max( max( t.r, t.g ), t.b );\n\n\t\t\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n\t\t\tt = abs( C - Ctoptop );\n\t\t\tdelta.w = max( max( t.r, t.g ), t.b );\n\n\t\t\t// Calculate the final maximum delta:\n\t\t\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\n\t\t\t// Local contrast adaptation in action:\n\t\t\tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\n\t\t\treturn vec4( edges, 0.0, 0.0 );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n\n\t\t}",
        },
        fg = {
          defines: {
            SMAA_MAX_SEARCH_STEPS: "8",
            SMAA_AREATEX_MAX_DISTANCE: "16",
            SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
            SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )",
          },
          uniforms: {
            tDiffuse: { value: null },
            tArea: { value: null },
            tSearch: { value: null },
            resolution: { value: new $(1 / 1024, 1 / 512) },
          },
          vertexShader:
            "\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 3 ];\n\t\tvarying vec2 vPixcoord;\n\n\t\tvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n\t\t\tvPixcoord = texcoord / resolution;\n\n\t\t\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components\n\n\t\t\t// And these for the searches, they indicate the ends of the loops:\n\t\t\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAABlendingWeightCalculationVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
          fragmentShader:
            "\n\n\t\t#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tArea;\n\t\tuniform sampler2D tSearch;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[3];\n\t\tvarying vec2 vPixcoord;\n\n\t\t#if __VERSION__ == 100\n\t\tvec2 round( vec2 x ) {\n\t\t\treturn sign( x ) * floor( abs( x ) + 0.5 );\n\t\t}\n\t\t#endif\n\n\t\tfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n\t\t\t// Not required if searchTex accesses are set to point:\n\t\t\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n\t\t\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n\t\t\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n\t\t\te.r = bias + e.r * scale;\n\t\t\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n\t\t}\n\n\t\tfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\t/**\n\t\t\t\t* @PSEUDO_GATHER4\n\t\t\t\t* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n\t\t\t\t* sample between edge, thus fetching four edges in a row.\n\t\t\t\t* Sampling with different offsets in each direction allows to disambiguate\n\t\t\t\t* which edges are active from the four fetched ones.\n\t\t\t\t*/\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\t// We correct the previous (-0.25, -0.125) offset we applied:\n\t\t\ttexcoord.x += 0.25 * resolution.x;\n\n\t\t\t// The searches are bias by 1, so adjust the coords accordingly:\n\t\t\ttexcoord.x += resolution.x;\n\n\t\t\t// Disambiguate the length added by the last step:\n\t\t\ttexcoord.x += 2.0 * resolution.x; // Undo last step\n\t\t\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 0.0, 1.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n\t\t\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.x -= 0.25 * resolution.x;\n\t\t\ttexcoord.x -= resolution.x;\n\t\t\ttexcoord.x -= 2.0 * resolution.x;\n\t\t\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\n\t\t\treturn texcoord.x;\n\t\t}\n\n\t\tfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\t\t\tvec2 e = vec2( 1.0, 0.0 );\n\n\t\t\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for\n\t\t\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\t\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign\n\t\t\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t\t\t}\n\n\t\t\ttexcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign\n\t\t\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign\n\n\t\t\treturn texcoord.y;\n\t\t}\n\n\t\tvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n\t\t\t// Rounding prevents precision errors of bilinear filtering:\n\t\t\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\n\t\t\t// We do a scale and bias for mapping to texel space:\n\t\t\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\n\t\t\t// Move to proper place, according to the subpixel offset:\n\t\t\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\n\t\t\treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n\t\t}\n\n\t\tvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n\t\t\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\n\t\t\tif ( e.g > 0.0 ) { // Edge at north\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the left:\n\t\t\t\tvec2 coords;\n\t\t\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n\t\t\t\tcoords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n\t\t\t\td.x = coords.x;\n\n\t\t\t\t// Now fetch the left crossing edges, two at a time using bilinear\n\t\t\t\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n\t\t\t\t// discern what value each edge has:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\n\t\t\t\t// Find the distance to the right:\n\t\t\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n\t\t\t\td.y = coords.x;\n\n\t\t\t\t// We want the distances to be in pixel units (doing this here allow to\n\t\t\t\t// better interleave arithmetic and memory accesses):\n\t\t\t\td = d / resolution.x - pixcoord.x;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the right crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\n\t\t\t\t// Ok, we know how this pattern looks like, now it is time for getting\n\t\t\t\t// the actual area:\n\t\t\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n\t\t\t}\n\n\t\t\tif ( e.r > 0.0 ) { // Edge at west\n\t\t\t\tvec2 d;\n\n\t\t\t\t// Find the distance to the top:\n\t\t\t\tvec2 coords;\n\n\t\t\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n\t\t\t\tcoords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;\n\t\t\t\td.x = coords.y;\n\n\t\t\t\t// Fetch the top crossing edges:\n\t\t\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\n\t\t\t\t// Find the distance to the bottom:\n\t\t\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n\t\t\t\td.y = coords.y;\n\n\t\t\t\t// We want the distances to be in pixel units:\n\t\t\t\td = d / resolution.y - pixcoord.y;\n\n\t\t\t\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t\t\t\t// quadratically:\n\t\t\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\n\t\t\t\t// Fetch the bottom crossing edges:\n\t\t\t\tcoords.y -= 1.0 * resolution.y; // WebGL port note: Added\n\t\t\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\n\t\t\t\t// Get the area for this direction:\n\t\t\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\t\t\t}\n\n\t\t\treturn weights;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n\n\t\t}",
        },
        Zx = {
          uniforms: {
            tDiffuse: { value: null },
            tColor: { value: null },
            resolution: { value: new $(1 / 1024, 1 / 512) },
          },
          vertexShader:
            "\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n\t\t\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component\n\t\t\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tSMAANeighborhoodBlendingVS( vUv );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
          fragmentShader:
            "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tColor;\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vOffset[ 2 ];\n\n\t\tvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n\t\t\t// Fetch the blending weights for current pixel:\n\t\t\tvec4 a;\n\t\t\ta.xz = texture2D( blendTex, texcoord ).xz;\n\t\t\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n\t\t\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\n\t\t\t// Is there any blending weight with a value greater than 0.0?\n\t\t\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n\t\t\t\treturn texture2D( colorTex, texcoord, 0.0 );\n\t\t\t} else {\n\t\t\t\t// Up to 4 lines can be crossing a pixel (one through each edge). We\n\t\t\t\t// favor blending by choosing the line with the maximum weight for each\n\t\t\t\t// direction:\n\t\t\t\tvec2 offset;\n\t\t\t\toffset.x = a.a > a.b ? a.a : -a.b; // left vs. right\n\t\t\t\toffset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs\n\n\t\t\t\t// Then we go in the direction that has the maximum weight:\n\t\t\t\tif ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical\n\t\t\t\t\toffset.y = 0.0;\n\t\t\t\t} else {\n\t\t\t\t\toffset.x = 0.0;\n\t\t\t\t}\n\n\t\t\t\t// Fetch the opposite color and lerp by hand:\n\t\t\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\ttexcoord += sign( offset ) * resolution;\n\t\t\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n\t\t\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\n\t\t\t\t// WebGL port note: Added gamma correction\n\t\t\t\tC.xyz = pow(C.xyz, vec3(2.2));\n\t\t\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n\t\t\t\tvec4 mixed = mix(C, Cop, s);\n\t\t\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\n\t\t\t\treturn mixed;\n\t\t\t}\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n\n\t\t}",
        };
      class D$ extends au {
        constructor(e, t) {
          super(),
            (this.edgesRT = new li(e, t, { depthBuffer: !1, type: Hi })),
            (this.edgesRT.texture.name = "SMAAPass.edges"),
            (this.weightsRT = new li(e, t, { depthBuffer: !1, type: Hi })),
            (this.weightsRT.texture.name = "SMAAPass.weights");
          const i = this,
            r = new Image();
          (r.src = this.getAreaTexture()),
            (r.onload = function () {
              i.areaTexture.needsUpdate = !0;
            }),
            (this.areaTexture = new Ai()),
            (this.areaTexture.name = "SMAAPass.area"),
            (this.areaTexture.image = r),
            (this.areaTexture.minFilter = fn),
            (this.areaTexture.generateMipmaps = !1),
            (this.areaTexture.flipY = !1);
          const s = new Image();
          (s.src = this.getSearchTexture()),
            (s.onload = function () {
              i.searchTexture.needsUpdate = !0;
            }),
            (this.searchTexture = new Ai()),
            (this.searchTexture.name = "SMAAPass.search"),
            (this.searchTexture.image = s),
            (this.searchTexture.magFilter = hn),
            (this.searchTexture.minFilter = hn),
            (this.searchTexture.generateMipmaps = !1),
            (this.searchTexture.flipY = !1),
            (this.uniformsEdges = Uc.clone(hg.uniforms)),
            this.uniformsEdges.resolution.value.set(1 / e, 1 / t),
            (this.materialEdges = new $n({
              defines: Object.assign({}, hg.defines),
              uniforms: this.uniformsEdges,
              vertexShader: hg.vertexShader,
              fragmentShader: hg.fragmentShader,
            })),
            (this.uniformsWeights = Uc.clone(fg.uniforms)),
            this.uniformsWeights.resolution.value.set(1 / e, 1 / t),
            (this.uniformsWeights.tDiffuse.value = this.edgesRT.texture),
            (this.uniformsWeights.tArea.value = this.areaTexture),
            (this.uniformsWeights.tSearch.value = this.searchTexture),
            (this.materialWeights = new $n({
              defines: Object.assign({}, fg.defines),
              uniforms: this.uniformsWeights,
              vertexShader: fg.vertexShader,
              fragmentShader: fg.fragmentShader,
            })),
            (this.uniformsBlend = Uc.clone(Zx.uniforms)),
            this.uniformsBlend.resolution.value.set(1 / e, 1 / t),
            (this.uniformsBlend.tDiffuse.value = this.weightsRT.texture),
            (this.materialBlend = new $n({
              uniforms: this.uniformsBlend,
              vertexShader: Zx.vertexShader,
              fragmentShader: Zx.fragmentShader,
            })),
            (this.needsSwap = !1),
            (this.fsQuad = new Yx(null));
        }
        render(e, t, i) {
          (this.uniformsEdges.tDiffuse.value = i.texture),
            (this.fsQuad.material = this.materialEdges),
            e.setRenderTarget(this.edgesRT),
            this.clear && e.clear(),
            this.fsQuad.render(e),
            (this.fsQuad.material = this.materialWeights),
            e.setRenderTarget(this.weightsRT),
            this.clear && e.clear(),
            this.fsQuad.render(e),
            (this.uniformsBlend.tColor.value = i.texture),
            (this.fsQuad.material = this.materialBlend),
            this.renderToScreen
              ? (e.setRenderTarget(null), this.fsQuad.render(e))
              : (e.setRenderTarget(t),
                this.clear && e.clear(),
                this.fsQuad.render(e));
        }
        setSize(e, t) {
          this.edgesRT.setSize(e, t),
            this.weightsRT.setSize(e, t),
            this.materialEdges.uniforms.resolution.value.set(1 / e, 1 / t),
            this.materialWeights.uniforms.resolution.value.set(1 / e, 1 / t),
            this.materialBlend.uniforms.resolution.value.set(1 / e, 1 / t);
        }
        getAreaTexture() {
          return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=";
        }
        getSearchTexture() {
          return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
        }
        dispose() {
          this.edgesRT.dispose(),
            this.weightsRT.dispose(),
            this.areaTexture.dispose(),
            this.searchTexture.dispose(),
            this.materialEdges.dispose(),
            this.materialWeights.dispose(),
            this.materialBlend.dispose(),
            this.fsQuad.dispose();
        }
      }
      const lu = new A(),
        cL = new Ae(),
        uL = new Ae(),
        dL = new A(),
        hL = new A();
      class I$ {
        constructor(e = {}) {
          const t = this;
          let i, r, s, o;
          const a = { objects: new WeakMap() },
            l =
              void 0 !== e.element ? e.element : document.createElement("div");
          function c(f, p, _) {
            if (f.isCSS2DObject) {
              lu.setFromMatrixPosition(f.matrixWorld), lu.applyMatrix4(uL);
              const m =
                !0 === f.visible &&
                lu.z >= -1 &&
                lu.z <= 1 &&
                !0 === f.layers.test(_.layers);
              if (
                ((f.element.style.display = !0 === m ? "" : "none"), !0 === m)
              ) {
                f.onBeforeRender(t, p, _);
                const y = f.element;
                (y.style.transform =
                  "translate(" +
                  -100 * f.center.x +
                  "%," +
                  -100 * f.center.y +
                  "%)translate(" +
                  (lu.x * s + s) +
                  "px," +
                  (-lu.y * o + o) +
                  "px)"),
                  y.parentNode !== l && l.appendChild(y),
                  f.onAfterRender(t, p, _);
              }
              const g = { distanceToCameraSquared: u(_, f) };
              a.objects.set(f, g);
            }
            for (let m = 0, g = f.children.length; m < g; m++)
              c(f.children[m], p, _);
          }
          function u(f, p) {
            return (
              dL.setFromMatrixPosition(f.matrixWorld),
              hL.setFromMatrixPosition(p.matrixWorld),
              dL.distanceToSquared(hL)
            );
          }
          (l.style.overflow = "hidden"),
            (this.domElement = l),
            (this.getSize = function () {
              return { width: i, height: r };
            }),
            (this.render = function (f, p) {
              !0 === f.matrixWorldAutoUpdate && f.updateMatrixWorld(),
                null === p.parent &&
                  !0 === p.matrixWorldAutoUpdate &&
                  p.updateMatrixWorld(),
                cL.copy(p.matrixWorldInverse),
                uL.multiplyMatrices(p.projectionMatrix, cL),
                c(f, f, p),
                (function h(f) {
                  const p = (function d(f) {
                      const p = [];
                      return (
                        f.traverse(function (_) {
                          _.isCSS2DObject && p.push(_);
                        }),
                        p
                      );
                    })(f).sort(function (m, g) {
                      return m.renderOrder !== g.renderOrder
                        ? g.renderOrder - m.renderOrder
                        : a.objects.get(m).distanceToCameraSquared -
                            a.objects.get(g).distanceToCameraSquared;
                    }),
                    _ = p.length;
                  for (let m = 0, g = p.length; m < g; m++)
                    p[m].element.style.zIndex = _ - m;
                })(f);
            }),
            (this.setSize = function (f, p) {
              (i = f),
                (r = p),
                (s = i / 2),
                (o = r / 2),
                (l.style.width = f + "px"),
                (l.style.height = p + "px");
            });
        }
      }
      const Kx = new WeakMap();
      class R$ extends po {
        constructor(e) {
          super(e),
            (this.decoderPath = ""),
            (this.decoderConfig = {}),
            (this.decoderBinary = null),
            (this.decoderPending = null),
            (this.workerLimit = 4),
            (this.workerPool = []),
            (this.workerNextTaskID = 1),
            (this.workerSourceURL = ""),
            (this.defaultAttributeIDs = {
              position: "POSITION",
              normal: "NORMAL",
              color: "COLOR",
              uv: "TEX_COORD",
            }),
            (this.defaultAttributeTypes = {
              position: "Float32Array",
              normal: "Float32Array",
              color: "Float32Array",
              uv: "Float32Array",
            });
        }
        setDecoderPath(e) {
          return (this.decoderPath = e), this;
        }
        setDecoderConfig(e) {
          return (this.decoderConfig = e), this;
        }
        setWorkerLimit(e) {
          return (this.workerLimit = e), this;
        }
        load(e, t, i, r) {
          const s = new cr(this.manager);
          s.setPath(this.path),
            s.setResponseType("arraybuffer"),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              e,
              (o) => {
                this.parse(o, t, r);
              },
              i,
              r
            );
        }
        parse(e, t, i) {
          this.decodeDracoFile(e, t, null, null, qe).catch(i);
        }
        decodeDracoFile(e, t, i, r, s = Kr) {
          return this.decodeGeometry(e, {
            attributeIDs: i || this.defaultAttributeIDs,
            attributeTypes: r || this.defaultAttributeTypes,
            useUniqueIDs: !!i,
            vertexColorSpace: s,
          }).then(t);
        }
        decodeGeometry(e, t) {
          const i = JSON.stringify(t);
          if (Kx.has(e)) {
            const l = Kx.get(e);
            if (l.key === i) return l.promise;
            if (0 === e.byteLength)
              throw new Error(
                "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
              );
          }
          let r;
          const s = this.workerNextTaskID++,
            a = this._getWorker(s, e.byteLength)
              .then(
                (l) => (
                  (r = l),
                  new Promise((c, u) => {
                    (r._callbacks[s] = { resolve: c, reject: u }),
                      r.postMessage(
                        { type: "decode", id: s, taskConfig: t, buffer: e },
                        [e]
                      );
                  })
                )
              )
              .then((l) => this._createGeometry(l.geometry));
          return (
            a
              .catch(() => !0)
              .then(() => {
                r && s && this._releaseTask(r, s);
              }),
            Kx.set(e, { key: i, promise: a }),
            a
          );
        }
        _createGeometry(e) {
          const t = new ut();
          e.index && t.setIndex(new on(e.index.array, 1));
          for (let i = 0; i < e.attributes.length; i++) {
            const r = e.attributes[i],
              s = r.name,
              o = r.array,
              l = new on(o, r.itemSize);
            "color" === s &&
              (this._assignVertexColorSpace(l, r.vertexColorSpace),
              (l.normalized = !(o instanceof Float32Array))),
              t.setAttribute(s, l);
          }
          return t;
        }
        _assignVertexColorSpace(e, t) {
          if (t !== qe) return;
          const i = new de();
          for (let r = 0, s = e.count; r < s; r++)
            i.fromBufferAttribute(e, r).convertSRGBToLinear(),
              e.setXYZ(r, i.r, i.g, i.b);
        }
        _loadLibrary(e, t) {
          const i = new cr(this.manager);
          return (
            i.setPath(this.decoderPath),
            i.setResponseType(t),
            i.setWithCredentials(this.withCredentials),
            new Promise((r, s) => {
              i.load(e, r, void 0, s);
            })
          );
        }
        preload() {
          return this._initDecoder(), this;
        }
        _initDecoder() {
          if (this.decoderPending) return this.decoderPending;
          const e =
              "object" != typeof WebAssembly ||
              "js" === this.decoderConfig.type,
            t = [];
          return (
            e
              ? t.push(this._loadLibrary("draco_decoder.js", "text"))
              : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
            (this.decoderPending = Promise.all(t).then((i) => {
              const r = i[0];
              e || (this.decoderConfig.wasmBinary = i[1]);
              const s = P$.toString(),
                o = [
                  "/* draco decoder */",
                  r,
                  "",
                  "/* worker */",
                  s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
                ].join("\n");
              this.workerSourceURL = URL.createObjectURL(new Blob([o]));
            })),
            this.decoderPending
          );
        }
        _getWorker(e, t) {
          return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
              const r = new Worker(this.workerSourceURL);
              (r._callbacks = {}),
                (r._taskCosts = {}),
                (r._taskLoad = 0),
                r.postMessage({
                  type: "init",
                  decoderConfig: this.decoderConfig,
                }),
                (r.onmessage = function (s) {
                  const o = s.data;
                  switch (o.type) {
                    case "decode":
                      r._callbacks[o.id].resolve(o);
                      break;
                    case "error":
                      r._callbacks[o.id].reject(o);
                      break;
                    default:
                      console.error(
                        'THREE.DRACOLoader: Unexpected message, "' +
                          o.type +
                          '"'
                      );
                  }
                }),
                this.workerPool.push(r);
            } else
              this.workerPool.sort(function (r, s) {
                return r._taskLoad > s._taskLoad ? -1 : 1;
              });
            const i = this.workerPool[this.workerPool.length - 1];
            return (i._taskCosts[e] = t), (i._taskLoad += t), i;
          });
        }
        _releaseTask(e, t) {
          (e._taskLoad -= e._taskCosts[t]),
            delete e._callbacks[t],
            delete e._taskCosts[t];
        }
        debug() {
          console.log(
            "Task load: ",
            this.workerPool.map((e) => e._taskLoad)
          );
        }
        dispose() {
          for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
          return (
            (this.workerPool.length = 0),
            "" !== this.workerSourceURL &&
              URL.revokeObjectURL(this.workerSourceURL),
            this
          );
        }
      }
      function P$() {
        let n, e;
        function r(o, a, l, c, u, d) {
          const h = d.num_components(),
            p = l.num_points() * h,
            _ = p * u.BYTES_PER_ELEMENT,
            m = (function s(o, a) {
              switch (a) {
                case Float32Array:
                  return o.DT_FLOAT32;
                case Int8Array:
                  return o.DT_INT8;
                case Int16Array:
                  return o.DT_INT16;
                case Int32Array:
                  return o.DT_INT32;
                case Uint8Array:
                  return o.DT_UINT8;
                case Uint16Array:
                  return o.DT_UINT16;
                case Uint32Array:
                  return o.DT_UINT32;
              }
            })(o, u),
            g = o._malloc(_);
          a.GetAttributeDataArrayForAllPoints(l, d, m, _, g);
          const y = new u(o.HEAPF32.buffer, g, p).slice();
          return o._free(g), { name: c, array: y, itemSize: h };
        }
        onmessage = function (o) {
          const a = o.data;
          switch (a.type) {
            case "init":
              (n = a.decoderConfig),
                (e = new Promise(function (u) {
                  (n.onModuleLoaded = function (d) {
                    u({ draco: d });
                  }),
                    DracoDecoderModule(n);
                }));
              break;
            case "decode":
              const l = a.buffer,
                c = a.taskConfig;
              e.then((u) => {
                const d = u.draco,
                  h = new d.Decoder();
                try {
                  const f = (function t(o, a, l, c) {
                      const u = c.attributeIDs,
                        d = c.attributeTypes;
                      let h, f;
                      const p = a.GetEncodedGeometryType(l);
                      if (p === o.TRIANGULAR_MESH)
                        (h = new o.Mesh()),
                          (f = a.DecodeArrayToMesh(l, l.byteLength, h));
                      else {
                        if (p !== o.POINT_CLOUD)
                          throw new Error(
                            "THREE.DRACOLoader: Unexpected geometry type."
                          );
                        (h = new o.PointCloud()),
                          (f = a.DecodeArrayToPointCloud(l, l.byteLength, h));
                      }
                      if (!f.ok() || 0 === h.ptr)
                        throw new Error(
                          "THREE.DRACOLoader: Decoding failed: " + f.error_msg()
                        );
                      const _ = { index: null, attributes: [] };
                      for (const m in u) {
                        const g = self[d[m]];
                        let y, v;
                        if (c.useUniqueIDs)
                          (v = u[m]), (y = a.GetAttributeByUniqueId(h, v));
                        else {
                          if (((v = a.GetAttributeId(h, o[u[m]])), -1 === v))
                            continue;
                          y = a.GetAttribute(h, v);
                        }
                        const b = r(o, a, h, m, g, y);
                        "color" === m &&
                          (b.vertexColorSpace = c.vertexColorSpace),
                          _.attributes.push(b);
                      }
                      return (
                        p === o.TRIANGULAR_MESH &&
                          (_.index = (function i(o, a, l) {
                            const u = 3 * l.num_faces(),
                              d = 4 * u,
                              h = o._malloc(d);
                            a.GetTrianglesUInt32Array(l, d, h);
                            const f = new Uint32Array(
                              o.HEAPF32.buffer,
                              h,
                              u
                            ).slice();
                            return o._free(h), { array: f, itemSize: 1 };
                          })(o, a, h)),
                        o.destroy(h),
                        _
                      );
                    })(d, h, new Int8Array(l), c),
                    p = f.attributes.map((_) => _.array.buffer);
                  f.index && p.push(f.index.array.buffer),
                    self.postMessage(
                      { type: "decode", id: a.id, geometry: f },
                      p
                    );
                } catch (f) {
                  console.error(f),
                    self.postMessage({
                      type: "error",
                      id: a.id,
                      error: f.message,
                    });
                } finally {
                  d.destroy(h);
                }
              });
          }
        };
      }
      function fL(n, e) {
        if (e === J9)
          return (
            console.warn(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
            ),
            n
          );
        if (e === vb || e === WR) {
          let t = n.getIndex();
          if (null === t) {
            const o = [],
              a = n.getAttribute("position");
            if (void 0 === a)
              return (
                console.error(
                  "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                ),
                n
              );
            for (let l = 0; l < a.count; l++) o.push(l);
            n.setIndex(o), (t = n.getIndex());
          }
          const i = t.count - 2,
            r = [];
          if (e === vb)
            for (let o = 1; o <= i; o++)
              r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1));
          else
            for (let o = 0; o < i; o++)
              o % 2 == 0
                ? (r.push(t.getX(o)),
                  r.push(t.getX(o + 1)),
                  r.push(t.getX(o + 2)))
                : (r.push(t.getX(o + 2)),
                  r.push(t.getX(o + 1)),
                  r.push(t.getX(o)));
          r.length / 3 !== i &&
            console.error(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
            );
          const s = n.clone();
          return s.setIndex(r), s.clearGroups(), s;
        }
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
            e
          ),
          n
        );
      }
      class L$ extends po {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (t) {
              return new U$(t);
            }),
            this.register(function (t) {
              return new q$(t);
            }),
            this.register(function (t) {
              return new Y$(t);
            }),
            this.register(function (t) {
              return new Z$(t);
            }),
            this.register(function (t) {
              return new z$(t);
            }),
            this.register(function (t) {
              return new H$(t);
            }),
            this.register(function (t) {
              return new G$(t);
            }),
            this.register(function (t) {
              return new W$(t);
            }),
            this.register(function (t) {
              return new B$(t);
            }),
            this.register(function (t) {
              return new j$(t);
            }),
            this.register(function (t) {
              return new V$(t);
            }),
            this.register(function (t) {
              return new X$(t);
            }),
            this.register(function (t) {
              return new N$(t);
            }),
            this.register(function (t) {
              return new K$(t);
            }),
            this.register(function (t) {
              return new $$(t);
            });
        }
        load(e, t, i, r) {
          const s = this;
          let o;
          (o =
            "" !== this.resourcePath
              ? this.resourcePath
              : "" !== this.path
              ? this.path
              : ou.extractUrlBase(e)),
            this.manager.itemStart(e);
          const a = function (c) {
              r ? r(c) : console.error(c),
                s.manager.itemError(e),
                s.manager.itemEnd(e);
            },
            l = new cr(this.manager);
          l.setPath(this.path),
            l.setResponseType("arraybuffer"),
            l.setRequestHeader(this.requestHeader),
            l.setWithCredentials(this.withCredentials),
            l.load(
              e,
              function (c) {
                try {
                  s.parse(
                    c,
                    o,
                    function (u) {
                      t(u), s.manager.itemEnd(e);
                    },
                    a
                  );
                } catch (u) {
                  a(u);
                }
              },
              i,
              a
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setDDSLoader() {
          throw new Error(
            'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
          );
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return (
            -1 === this.pluginCallbacks.indexOf(e) &&
              this.pluginCallbacks.push(e),
            this
          );
        }
        unregister(e) {
          return (
            -1 !== this.pluginCallbacks.indexOf(e) &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
            this
          );
        }
        parse(e, t, i, r) {
          let s;
          const o = {},
            a = {},
            l = new TextDecoder();
          if ("string" == typeof e) s = JSON.parse(e);
          else if (e instanceof ArrayBuffer)
            if (l.decode(new Uint8Array(e, 0, 4)) === pL) {
              try {
                o[It.KHR_BINARY_GLTF] = new Q$(e);
              } catch (d) {
                return void (r && r(d));
              }
              s = JSON.parse(o[It.KHR_BINARY_GLTF].content);
            } else s = JSON.parse(l.decode(e));
          else s = e;
          if (void 0 === s.asset || s.asset.version[0] < 2)
            return void (
              r &&
              r(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              )
            );
          const c = new dQ(s, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const d = this.pluginCallbacks[u](c);
            (a[d.name] = d), (o[d.name] = !0);
          }
          if (s.extensionsUsed)
            for (let u = 0; u < s.extensionsUsed.length; ++u) {
              const d = s.extensionsUsed[u],
                h = s.extensionsRequired || [];
              switch (d) {
                case It.KHR_MATERIALS_UNLIT:
                  o[d] = new k$();
                  break;
                case It.KHR_DRACO_MESH_COMPRESSION:
                  o[d] = new J$(s, this.dracoLoader);
                  break;
                case It.KHR_TEXTURE_TRANSFORM:
                  o[d] = new eQ();
                  break;
                case It.KHR_MESH_QUANTIZATION:
                  o[d] = new tQ();
                  break;
                default:
                  h.indexOf(d) >= 0 &&
                    void 0 === a[d] &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + d + '".'
                    );
              }
            }
          c.setExtensions(o), c.setPlugins(a), c.parse(i, r);
        }
        parseAsync(e, t) {
          const i = this;
          return new Promise(function (r, s) {
            i.parse(e, t, r, s);
          });
        }
      }
      function F$() {
        let n = {};
        return {
          get: function (e) {
            return n[e];
          },
          add: function (e, t) {
            n[e] = t;
          },
          remove: function (e) {
            delete n[e];
          },
          removeAll: function () {
            n = {};
          },
        };
      }
      const It = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
      };
      class N$ {
        constructor(e) {
          (this.parser = e),
            (this.name = It.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            s.extensions &&
              s.extensions[this.name] &&
              void 0 !== s.extensions[this.name].light &&
              e._addNodeRef(this.cache, s.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            i = "light:" + e;
          let r = t.cache.get(i);
          if (r) return r;
          const s = t.json,
            l = (((s.extensions && s.extensions[this.name]) || {}).lights ||
              [])[e];
          let c;
          const u = new de(16777215);
          void 0 !== l.color && u.fromArray(l.color);
          const d = void 0 !== l.range ? l.range : 0;
          switch (l.type) {
            case "directional":
              (c = new su(u)), c.target.position.set(0, 0, -1), c.add(c.target);
              break;
            case "point":
              (c = new rg(u)), (c.distance = d);
              break;
            case "spot":
              (c = new Nx(u)),
                (c.distance = d),
                (l.spot = l.spot || {}),
                (l.spot.innerConeAngle =
                  void 0 !== l.spot.innerConeAngle ? l.spot.innerConeAngle : 0),
                (l.spot.outerConeAngle =
                  void 0 !== l.spot.outerConeAngle
                    ? l.spot.outerConeAngle
                    : Math.PI / 4),
                (c.angle = l.spot.outerConeAngle),
                (c.penumbra =
                  1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
                c.target.position.set(0, 0, -1),
                c.add(c.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + l.type
              );
          }
          return (
            c.position.set(0, 0, 0),
            (c.decay = 2),
            Xo(c, l),
            void 0 !== l.intensity && (c.intensity = l.intensity),
            (c.name = t.createUniqueName(l.name || "light_" + e)),
            (r = Promise.resolve(c)),
            t.cache.add(i, r),
            r
          );
        }
        getDependency(e, t) {
          if ("light" === e) return this._loadLight(t);
        }
        createNodeAttachment(e) {
          const t = this,
            i = this.parser,
            s = i.json.nodes[e],
            a = ((s.extensions && s.extensions[this.name]) || {}).light;
          return void 0 === a
            ? null
            : this._loadLight(a).then(function (l) {
                return i._getNodeRef(t.cache, a, l);
              });
        }
      }
      class k$ {
        constructor() {
          this.name = It.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return Ar;
        }
        extendParams(e, t, i) {
          const r = [];
          (e.color = new de(1, 1, 1)), (e.opacity = 1);
          const s = t.pbrMetallicRoughness;
          if (s) {
            if (Array.isArray(s.baseColorFactor)) {
              const o = s.baseColorFactor;
              e.color.fromArray(o), (e.opacity = o[3]);
            }
            void 0 !== s.baseColorTexture &&
              r.push(i.assignTexture(e, "map", s.baseColorTexture, qe));
          }
          return Promise.all(r);
        }
      }
      class B$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_EMISSIVE_STRENGTH);
        }
        extendMaterialParams(e, t) {
          const r = this.parser.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = r.extensions[this.name].emissiveStrength;
          return void 0 !== s && (t.emissiveIntensity = s), Promise.resolve();
        }
      }
      class U$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return i.extensions && i.extensions[this.name] ? fo : null;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = r.extensions[this.name];
          if (
            (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor),
            void 0 !== o.clearcoatTexture &&
              s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
            void 0 !== o.clearcoatRoughnessFactor &&
              (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
            void 0 !== o.clearcoatRoughnessTexture &&
              s.push(
                i.assignTexture(
                  t,
                  "clearcoatRoughnessMap",
                  o.clearcoatRoughnessTexture
                )
              ),
            void 0 !== o.clearcoatNormalTexture &&
              (s.push(
                i.assignTexture(
                  t,
                  "clearcoatNormalMap",
                  o.clearcoatNormalTexture
                )
              ),
              void 0 !== o.clearcoatNormalTexture.scale))
          ) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new $(a, a);
          }
          return Promise.all(s);
        }
      }
      class V$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_IRIDESCENCE);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return i.extensions && i.extensions[this.name] ? fo : null;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = r.extensions[this.name];
          return (
            void 0 !== o.iridescenceFactor &&
              (t.iridescence = o.iridescenceFactor),
            void 0 !== o.iridescenceTexture &&
              s.push(
                i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)
              ),
            void 0 !== o.iridescenceIor &&
              (t.iridescenceIOR = o.iridescenceIor),
            void 0 === t.iridescenceThicknessRange &&
              (t.iridescenceThicknessRange = [100, 400]),
            void 0 !== o.iridescenceThicknessMinimum &&
              (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
            void 0 !== o.iridescenceThicknessMaximum &&
              (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
            void 0 !== o.iridescenceThicknessTexture &&
              s.push(
                i.assignTexture(
                  t,
                  "iridescenceThicknessMap",
                  o.iridescenceThicknessTexture
                )
              ),
            Promise.all(s)
          );
        }
      }
      class z$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_SHEEN);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return i.extensions && i.extensions[this.name] ? fo : null;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [];
          (t.sheenColor = new de(0, 0, 0)),
            (t.sheenRoughness = 0),
            (t.sheen = 1);
          const o = r.extensions[this.name];
          return (
            void 0 !== o.sheenColorFactor &&
              t.sheenColor.fromArray(o.sheenColorFactor),
            void 0 !== o.sheenRoughnessFactor &&
              (t.sheenRoughness = o.sheenRoughnessFactor),
            void 0 !== o.sheenColorTexture &&
              s.push(
                i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, qe)
              ),
            void 0 !== o.sheenRoughnessTexture &&
              s.push(
                i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
              ),
            Promise.all(s)
          );
        }
      }
      class H$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return i.extensions && i.extensions[this.name] ? fo : null;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = r.extensions[this.name];
          return (
            void 0 !== o.transmissionFactor &&
              (t.transmission = o.transmissionFactor),
            void 0 !== o.transmissionTexture &&
              s.push(
                i.assignTexture(t, "transmissionMap", o.transmissionTexture)
              ),
            Promise.all(s)
          );
        }
      }
      class G$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_VOLUME);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return i.extensions && i.extensions[this.name] ? fo : null;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = r.extensions[this.name];
          (t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0),
            void 0 !== o.thicknessTexture &&
              s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
            (t.attenuationDistance = o.attenuationDistance || 1 / 0);
          const a = o.attenuationColor || [1, 1, 1];
          return (
            (t.attenuationColor = new de(a[0], a[1], a[2])), Promise.all(s)
          );
        }
      }
      class W$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_IOR);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return i.extensions && i.extensions[this.name] ? fo : null;
        }
        extendMaterialParams(e, t) {
          const r = this.parser.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = r.extensions[this.name];
          return (t.ior = void 0 !== s.ior ? s.ior : 1.5), Promise.resolve();
        }
      }
      class j$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_SPECULAR);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return i.extensions && i.extensions[this.name] ? fo : null;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = r.extensions[this.name];
          (t.specularIntensity =
            void 0 !== o.specularFactor ? o.specularFactor : 1),
            void 0 !== o.specularTexture &&
              s.push(
                i.assignTexture(t, "specularIntensityMap", o.specularTexture)
              );
          const a = o.specularColorFactor || [1, 1, 1];
          return (
            (t.specularColor = new de(a[0], a[1], a[2])),
            void 0 !== o.specularColorTexture &&
              s.push(
                i.assignTexture(
                  t,
                  "specularColorMap",
                  o.specularColorTexture,
                  qe
                )
              ),
            Promise.all(s)
          );
        }
      }
      class X$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_MATERIALS_ANISOTROPY);
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return i.extensions && i.extensions[this.name] ? fo : null;
        }
        extendMaterialParams(e, t) {
          const i = this.parser,
            r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            o = r.extensions[this.name];
          return (
            void 0 !== o.anisotropyStrength &&
              (t.anisotropy = o.anisotropyStrength),
            void 0 !== o.anisotropyRotation &&
              (t.anisotropyRotation = o.anisotropyRotation),
            void 0 !== o.anisotropyTexture &&
              s.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
            Promise.all(s)
          );
        }
      }
      class q$ {
        constructor(e) {
          (this.parser = e), (this.name = It.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            i = t.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[this.name]) return null;
          const s = r.extensions[this.name],
            o = t.options.ktx2Loader;
          if (!o) {
            if (
              i.extensionsRequired &&
              i.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return t.loadTextureImage(e, s.source, o);
        }
      }
      class Y$ {
        constructor(e) {
          (this.parser = e),
            (this.name = It.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            i = this.parser,
            r = i.json,
            s = r.textures[e];
          if (!s.extensions || !s.extensions[t]) return null;
          const o = s.extensions[t],
            a = r.images[o.source];
          let l = i.textureLoader;
          if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            null !== c && (l = c);
          }
          return this.detectSupport().then(function (c) {
            if (c) return i.loadTextureImage(e, o.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return i.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(1 === t.height);
                    });
              })),
            this.isSupported
          );
        }
      }
      class Z$ {
        constructor(e) {
          (this.parser = e),
            (this.name = It.EXT_TEXTURE_AVIF),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            i = this.parser,
            r = i.json,
            s = r.textures[e];
          if (!s.extensions || !s.extensions[t]) return null;
          const o = s.extensions[t],
            a = r.images[o.source];
          let l = i.textureLoader;
          if (a.uri) {
            const c = i.options.manager.getHandler(a.uri);
            null !== c && (l = c);
          }
          return this.detectSupport().then(function (c) {
            if (c) return i.loadTextureImage(e, o.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: AVIF required by asset but unsupported."
              );
            return i.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
                  (t.onload = t.onerror =
                    function () {
                      e(1 === t.height);
                    });
              })),
            this.isSupported
          );
        }
      }
      class K$ {
        constructor(e) {
          (this.name = It.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            i = t.bufferViews[e];
          if (i.extensions && i.extensions[this.name]) {
            const r = i.extensions[this.name],
              s = this.parser.getDependency("buffer", r.buffer),
              o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
              if (
                t.extensionsRequired &&
                t.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return s.then(function (a) {
              const u = r.count,
                d = r.byteStride,
                h = new Uint8Array(a, r.byteOffset || 0, r.byteLength || 0);
              return o.decodeGltfBufferAsync
                ? o
                    .decodeGltfBufferAsync(u, d, h, r.mode, r.filter)
                    .then(function (f) {
                      return f.buffer;
                    })
                : o.ready.then(function () {
                    const f = new ArrayBuffer(u * d);
                    return (
                      o.decodeGltfBuffer(
                        new Uint8Array(f),
                        u,
                        d,
                        h,
                        r.mode,
                        r.filter
                      ),
                      f
                    );
                  });
            });
          }
          return null;
        }
      }
      class $$ {
        constructor(e) {
          (this.name = It.EXT_MESH_GPU_INSTANCING), (this.parser = e);
        }
        createNodeMesh(e) {
          const t = this.parser.json,
            i = t.nodes[e];
          if (!i.extensions || !i.extensions[this.name] || void 0 === i.mesh)
            return null;
          const r = t.meshes[i.mesh];
          for (const c of r.primitives)
            if (
              c.mode !== Rr.TRIANGLES &&
              c.mode !== Rr.TRIANGLE_STRIP &&
              c.mode !== Rr.TRIANGLE_FAN &&
              void 0 !== c.mode
            )
              return null;
          const o = i.extensions[this.name].attributes,
            a = [],
            l = {};
          for (const c in o)
            a.push(
              this.parser
                .getDependency("accessor", o[c])
                .then((u) => ((l[c] = u), l[c]))
            );
          return a.length < 1
            ? null
            : (a.push(this.parser.createNodeMesh(e)),
              Promise.all(a).then((c) => {
                const u = c.pop(),
                  d = u.isGroup ? u.children : [u],
                  h = c[0].count,
                  f = [];
                for (const p of d) {
                  const _ = new Ae(),
                    m = new A(),
                    g = new An(),
                    y = new A(1, 1, 1),
                    v = new aO(p.geometry, p.material, h);
                  for (let b = 0; b < h; b++)
                    l.TRANSLATION && m.fromBufferAttribute(l.TRANSLATION, b),
                      l.ROTATION && g.fromBufferAttribute(l.ROTATION, b),
                      l.SCALE && y.fromBufferAttribute(l.SCALE, b),
                      v.setMatrixAt(b, _.compose(m, g, y));
                  for (const b in l)
                    "TRANSLATION" !== b &&
                      "ROTATION" !== b &&
                      "SCALE" !== b &&
                      p.geometry.setAttribute(b, l[b]);
                  Dn.prototype.copy.call(v, p),
                    this.parser.assignFinalMaterial(v),
                    f.push(v);
                }
                return u.isGroup ? (u.clear(), u.add(...f), u) : f[0];
              }));
        }
      }
      const pL = "glTF";
      class Q$ {
        constructor(e) {
          (this.name = It.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const t = new DataView(e, 0, 12),
            i = new TextDecoder();
          if (
            ((this.header = {
              magic: i.decode(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== pL)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const r = this.header.length - 12,
            s = new DataView(e, 12);
          let o = 0;
          for (; o < r; ) {
            const a = s.getUint32(o, !0);
            o += 4;
            const l = s.getUint32(o, !0);
            if (((o += 4), 1313821514 === l)) {
              const c = new Uint8Array(e, 12 + o, a);
              this.content = i.decode(c);
            } else if (5130562 === l) {
              const c = 12 + o;
              this.body = e.slice(c, c + a);
            }
            o += a;
          }
          if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class J$ {
        constructor(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = It.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const i = this.json,
            r = this.dracoLoader,
            s = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
          for (const u in o) {
            const d = ew[u] || u.toLowerCase();
            a[d] = o[u];
          }
          for (const u in e.attributes) {
            const d = ew[u] || u.toLowerCase();
            if (void 0 !== o[u]) {
              const h = i.accessors[e.attributes[u]];
              (c[d] = cu[h.componentType].name), (l[d] = !0 === h.normalized);
            }
          }
          return t.getDependency("bufferView", s).then(function (u) {
            return new Promise(function (d) {
              r.decodeDracoFile(
                u,
                function (h) {
                  for (const f in h.attributes) {
                    const _ = l[f];
                    void 0 !== _ && (h.attributes[f].normalized = _);
                  }
                  d(h);
                },
                a,
                c
              );
            });
          });
        }
      }
      class eQ {
        constructor() {
          this.name = It.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (
            ((void 0 === t.texCoord || t.texCoord === e.channel) &&
              void 0 === t.offset &&
              void 0 === t.rotation &&
              void 0 === t.scale) ||
              ((e = e.clone()),
              void 0 !== t.texCoord && (e.channel = t.texCoord),
              void 0 !== t.offset && e.offset.fromArray(t.offset),
              void 0 !== t.rotation && (e.rotation = t.rotation),
              void 0 !== t.scale && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0)),
            e
          );
        }
      }
      class tQ {
        constructor() {
          this.name = It.KHR_MESH_QUANTIZATION;
        }
      }
      class gL extends vh {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            i = this.sampleValues,
            r = this.valueSize,
            s = e * r * 3 + r;
          for (let o = 0; o !== r; o++) t[o] = i[s + o];
          return t;
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = 2 * a,
            c = 3 * a,
            u = r - t,
            d = (i - t) / u,
            h = d * d,
            f = h * d,
            p = e * c,
            _ = p - c,
            m = -2 * f + 3 * h,
            g = f - h,
            y = 1 - m,
            v = g - h + d;
          for (let b = 0; b !== a; b++)
            s[b] =
              y * o[_ + b + a] +
              v * (o[_ + b + l] * u) +
              m * o[p + b + a] +
              g * (o[p + b] * u);
          return s;
        }
      }
      const nQ = new An();
      class iQ extends gL {
        interpolate_(e, t, i, r) {
          const s = super.interpolate_(e, t, i, r);
          return nQ.fromArray(s).normalize().toArray(s), s;
        }
      }
      const Rr = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
        cu = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        _L = { 9728: hn, 9729: fn, 9984: om, 9985: cb, 9986: jd, 9987: eo },
        vL = { 33071: Yn, 33648: Wd, 10497: Js },
        Jx = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        ew = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        jo = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        rQ = { CUBICSPLINE: void 0, LINEAR: _c, STEP: Xd };
      function Za(n, e, t) {
        for (const i in t.extensions)
          void 0 === n[i] &&
            ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
            (e.userData.gltfExtensions[i] = t.extensions[i]));
      }
      function Xo(n, e) {
        void 0 !== e.extras &&
          ("object" == typeof e.extras
            ? Object.assign(n.userData, e.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
              ));
      }
      function aQ(n, e) {
        if ((n.updateMorphTargets(), void 0 !== e.weights))
          for (let t = 0, i = e.weights.length; t < i; t++)
            n.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let i = 0, r = t.length; i < r; i++)
              n.morphTargetDictionary[t[i]] = i;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function lQ(n) {
        let e;
        const t = n.extensions && n.extensions[It.KHR_DRACO_MESH_COMPRESSION];
        if (
          ((e = t
            ? "draco:" + t.bufferView + ":" + t.indices + ":" + nw(t.attributes)
            : n.indices + ":" + nw(n.attributes) + ":" + n.mode),
          void 0 !== n.targets)
        )
          for (let i = 0, r = n.targets.length; i < r; i++)
            e += ":" + nw(n.targets[i]);
        return e;
      }
      function nw(n) {
        let e = "";
        const t = Object.keys(n).sort();
        for (let i = 0, r = t.length; i < r; i++)
          e += t[i] + ":" + n[t[i]] + ";";
        return e;
      }
      function iw(n) {
        switch (n) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      const uQ = new Ae();
      class dQ {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new F$()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.nodeCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.sourceCache = {}),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {});
          let i = !1,
            r = !1,
            s = -1;
          typeof navigator < "u" &&
            ((i =
              !0 ===
              /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
            (r = navigator.userAgent.indexOf("Firefox") > -1),
            (s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
            (this.textureLoader =
              typeof createImageBitmap > "u" || i || (r && s < 98)
                ? new FO(this.options.manager)
                : new s$(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new cr(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const i = this,
            r = this.json,
            s = this.extensions;
          this.cache.removeAll(),
            (this.nodeCache = {}),
            this._invokeAll(function (o) {
              return o._markDefs && o._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (o) {
                return o.beforeRoot && o.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  i.getDependencies("scene"),
                  i.getDependencies("animation"),
                  i.getDependencies("camera"),
                ]);
              })
              .then(function (o) {
                const a = {
                  scene: o[0][r.scene || 0],
                  scenes: o[0],
                  animations: o[1],
                  cameras: o[2],
                  asset: r.asset,
                  parser: i,
                  userData: {},
                };
                Za(s, a, r),
                  Xo(a, r),
                  Promise.all(
                    i._invokeAll(function (l) {
                      return l.afterRoot && l.afterRoot(a);
                    })
                  ).then(function () {
                    e(a);
                  });
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            i = this.json.meshes || [];
          for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
          }
          for (let r = 0, s = e.length; r < s; r++) {
            const o = e[r];
            void 0 !== o.mesh &&
              (this._addNodeRef(this.meshCache, o.mesh),
              void 0 !== o.skin && (i[o.mesh].isSkinnedMesh = !0)),
              void 0 !== o.camera &&
                this._addNodeRef(this.cameraCache, o.camera);
          }
        }
        _addNodeRef(e, t) {
          void 0 !== t &&
            (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, i) {
          if (e.refs[t] <= 1) return i;
          const r = i.clone(),
            s = (o, a) => {
              const l = this.associations.get(o);
              null != l && this.associations.set(a, l);
              for (const [c, u] of o.children.entries()) s(u, a.children[c]);
            };
          return s(i, r), (r.name += "_instance_" + e.uses[t]++), r;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            if (r) return r;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const i = [];
          for (let r = 0; r < t.length; r++) {
            const s = e(t[r]);
            s && i.push(s);
          }
          return i;
        }
        getDependency(e, t) {
          const i = e + ":" + t;
          let r = this.cache.get(i);
          if (!r) {
            switch (e) {
              case "scene":
                r = this.loadScene(t);
                break;
              case "node":
                r = this._invokeOne(function (s) {
                  return s.loadNode && s.loadNode(t);
                });
                break;
              case "mesh":
                r = this._invokeOne(function (s) {
                  return s.loadMesh && s.loadMesh(t);
                });
                break;
              case "accessor":
                r = this.loadAccessor(t);
                break;
              case "bufferView":
                r = this._invokeOne(function (s) {
                  return s.loadBufferView && s.loadBufferView(t);
                });
                break;
              case "buffer":
                r = this.loadBuffer(t);
                break;
              case "material":
                r = this._invokeOne(function (s) {
                  return s.loadMaterial && s.loadMaterial(t);
                });
                break;
              case "texture":
                r = this._invokeOne(function (s) {
                  return s.loadTexture && s.loadTexture(t);
                });
                break;
              case "skin":
                r = this.loadSkin(t);
                break;
              case "animation":
                r = this._invokeOne(function (s) {
                  return s.loadAnimation && s.loadAnimation(t);
                });
                break;
              case "camera":
                r = this.loadCamera(t);
                break;
              default:
                if (
                  ((r = this._invokeOne(function (s) {
                    return (
                      s != this && s.getDependency && s.getDependency(e, t)
                    );
                  })),
                  !r)
                )
                  throw new Error("Unknown type: " + e);
            }
            this.cache.add(i, r);
          }
          return r;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const i = this;
            (t = Promise.all(
              (this.json[e + ("mesh" === e ? "es" : "s")] || []).map(function (
                s,
                o
              ) {
                return i.getDependency(e, o);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            i = this.fileLoader;
          if (t.type && "arraybuffer" !== t.type)
            throw new Error(
              "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
            );
          if (void 0 === t.uri && 0 === e)
            return Promise.resolve(this.extensions[It.KHR_BINARY_GLTF].body);
          const r = this.options;
          return new Promise(function (s, o) {
            i.load(ou.resolveURL(t.uri, r.path), s, void 0, function () {
              o(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (i) {
            const s = t.byteOffset || 0;
            return i.slice(s, s + (t.byteLength || 0));
          });
        }
        loadAccessor(e) {
          const t = this,
            i = this.json,
            r = this.json.accessors[e];
          if (void 0 === r.bufferView && void 0 === r.sparse) {
            const o = Jx[r.type],
              l = !0 === r.normalized,
              c = new (0, cu[r.componentType])(r.count * o);
            return Promise.resolve(new on(c, o, l));
          }
          const s = [];
          return (
            s.push(
              void 0 !== r.bufferView
                ? this.getDependency("bufferView", r.bufferView)
                : null
            ),
            void 0 !== r.sparse &&
              (s.push(
                this.getDependency("bufferView", r.sparse.indices.bufferView)
              ),
              s.push(
                this.getDependency("bufferView", r.sparse.values.bufferView)
              )),
            Promise.all(s).then(function (o) {
              const a = o[0],
                l = Jx[r.type],
                c = cu[r.componentType],
                u = c.BYTES_PER_ELEMENT,
                h = r.byteOffset || 0,
                f =
                  void 0 !== r.bufferView
                    ? i.bufferViews[r.bufferView].byteStride
                    : void 0,
                p = !0 === r.normalized;
              let _, m;
              if (f && f !== u * l) {
                const g = Math.floor(h / f),
                  y =
                    "InterleavedBuffer:" +
                    r.bufferView +
                    ":" +
                    r.componentType +
                    ":" +
                    g +
                    ":" +
                    r.count;
                let v = t.cache.get(y);
                v ||
                  ((_ = new c(a, g * f, (r.count * f) / u)),
                  (v = new ex(_, f / u)),
                  t.cache.add(y, v)),
                  (m = new Ua(v, l, (h % f) / u, p));
              } else (_ = null === a ? new c(r.count * l) : new c(a, h, r.count * l)), (m = new on(_, l, p));
              if (void 0 !== r.sparse) {
                const b = r.sparse.values.byteOffset || 0,
                  x = new (0, cu[r.sparse.indices.componentType])(
                    o[1],
                    r.sparse.indices.byteOffset || 0,
                    r.sparse.count * Jx.SCALAR
                  ),
                  M = new c(o[2], b, r.sparse.count * l);
                null !== a &&
                  (m = new on(m.array.slice(), m.itemSize, m.normalized));
                for (let S = 0, C = x.length; S < C; S++) {
                  const w = x[S];
                  if (
                    (m.setX(w, M[S * l]),
                    l >= 2 && m.setY(w, M[S * l + 1]),
                    l >= 3 && m.setZ(w, M[S * l + 2]),
                    l >= 4 && m.setW(w, M[S * l + 3]),
                    l >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
              }
              return m;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            s = t.textures[e].source,
            o = t.images[s];
          let a = this.textureLoader;
          if (o.uri) {
            const l = this.options.manager.getHandler(o.uri);
            null !== l && (a = l);
          }
          return this.loadTextureImage(e, s, a);
        }
        loadTextureImage(e, t, i) {
          const r = this,
            s = this.json,
            o = s.textures[e],
            a = s.images[t],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
          if (this.textureCache[l]) return this.textureCache[l];
          const c = this.loadImageSource(t, i)
            .then(function (u) {
              (u.flipY = !1),
                (u.name = o.name || a.name || ""),
                "" === u.name &&
                  "string" == typeof a.uri &&
                  !1 === a.uri.startsWith("data:image/") &&
                  (u.name = a.uri);
              const h = (s.samplers || {})[o.sampler] || {};
              return (
                (u.magFilter = _L[h.magFilter] || fn),
                (u.minFilter = _L[h.minFilter] || eo),
                (u.wrapS = vL[h.wrapS] || Js),
                (u.wrapT = vL[h.wrapT] || Js),
                r.associations.set(u, { textures: e }),
                u
              );
            })
            .catch(function () {
              return null;
            });
          return (this.textureCache[l] = c), c;
        }
        loadImageSource(e, t) {
          const r = this.json,
            s = this.options;
          if (void 0 !== this.sourceCache[e])
            return this.sourceCache[e].then((d) => d.clone());
          const o = r.images[e],
            a = self.URL || self.webkitURL;
          let l = o.uri || "",
            c = !1;
          if (void 0 !== o.bufferView)
            l = this.getDependency("bufferView", o.bufferView).then(function (
              d
            ) {
              c = !0;
              const h = new Blob([d], { type: o.mimeType });
              return (l = a.createObjectURL(h)), l;
            });
          else if (void 0 === o.uri)
            throw new Error(
              "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
            );
          const u = Promise.resolve(l)
            .then(function (d) {
              return new Promise(function (h, f) {
                let p = h;
                !0 === t.isImageBitmapLoader &&
                  (p = function (_) {
                    const m = new Ai(_);
                    (m.needsUpdate = !0), h(m);
                  }),
                  t.load(ou.resolveURL(d, s.path), p, void 0, f);
              });
            })
            .then(function (d) {
              return (
                !0 === c && a.revokeObjectURL(l),
                (d.userData.mimeType =
                  o.mimeType ||
                  (function cQ(n) {
                    return n.search(/\.jpe?g($|\?)/i) > 0 ||
                      0 === n.search(/^data\:image\/jpeg/)
                      ? "image/jpeg"
                      : n.search(/\.webp($|\?)/i) > 0 ||
                        0 === n.search(/^data\:image\/webp/)
                      ? "image/webp"
                      : "image/png";
                  })(o.uri)),
                d
              );
            })
            .catch(function (d) {
              throw (
                (console.error("THREE.GLTFLoader: Couldn't load texture", l), d)
              );
            });
          return (this.sourceCache[e] = u), u;
        }
        assignTexture(e, t, i, r) {
          const s = this;
          return this.getDependency("texture", i.index).then(function (o) {
            if (!o) return null;
            if (
              (void 0 !== i.texCoord &&
                i.texCoord > 0 &&
                ((o = o.clone()).channel = i.texCoord),
              s.extensions[It.KHR_TEXTURE_TRANSFORM])
            ) {
              const a =
                void 0 !== i.extensions
                  ? i.extensions[It.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (a) {
                const l = s.associations.get(o);
                (o = s.extensions[It.KHR_TEXTURE_TRANSFORM].extendTexture(
                  o,
                  a
                )),
                  s.associations.set(o, l);
              }
            }
            return void 0 !== r && (o.colorSpace = r), (e[t] = o), o;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let i = e.material;
          const r = void 0 === t.attributes.tangent,
            s = void 0 !== t.attributes.color,
            o = void 0 === t.attributes.normal;
          if (e.isPoints) {
            const a = "PointsMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l ||
              ((l = new ax()),
              ar.prototype.copy.call(l, i),
              l.color.copy(i.color),
              (l.map = i.map),
              (l.sizeAttenuation = !1),
              this.cache.add(a, l)),
              (i = l);
          } else if (e.isLine) {
            const a = "LineBasicMaterial:" + i.uuid;
            let l = this.cache.get(a);
            l ||
              ((l = new Ri()),
              ar.prototype.copy.call(l, i),
              l.color.copy(i.color),
              (l.map = i.map),
              this.cache.add(a, l)),
              (i = l);
          }
          if (r || s || o) {
            let a = "ClonedMaterial:" + i.uuid + ":";
            r && (a += "derivative-tangents:"),
              s && (a += "vertex-colors:"),
              o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l ||
              ((l = i.clone()),
              s && (l.vertexColors = !0),
              o && (l.flatShading = !0),
              r &&
                (l.normalScale && (l.normalScale.y *= -1),
                l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
              this.cache.add(a, l),
              this.associations.set(l, this.associations.get(i))),
              (i = l);
          }
          e.material = i;
        }
        getMaterialType() {
          return eg;
        }
        loadMaterial(e) {
          const t = this,
            r = this.extensions,
            s = this.json.materials[e];
          let o;
          const a = {},
            c = [];
          if ((s.extensions || {})[It.KHR_MATERIALS_UNLIT]) {
            const d = r[It.KHR_MATERIALS_UNLIT];
            (o = d.getMaterialType()), c.push(d.extendParams(a, s, t));
          } else {
            const d = s.pbrMetallicRoughness || {};
            if (
              ((a.color = new de(1, 1, 1)),
              (a.opacity = 1),
              Array.isArray(d.baseColorFactor))
            ) {
              const h = d.baseColorFactor;
              a.color.fromArray(h), (a.opacity = h[3]);
            }
            void 0 !== d.baseColorTexture &&
              c.push(t.assignTexture(a, "map", d.baseColorTexture, qe)),
              (a.metalness =
                void 0 !== d.metallicFactor ? d.metallicFactor : 1),
              (a.roughness =
                void 0 !== d.roughnessFactor ? d.roughnessFactor : 1),
              void 0 !== d.metallicRoughnessTexture &&
                (c.push(
                  t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)
                ),
                c.push(
                  t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture)
                )),
              (o = this._invokeOne(function (h) {
                return h.getMaterialType && h.getMaterialType(e);
              })),
              c.push(
                Promise.all(
                  this._invokeAll(function (h) {
                    return (
                      h.extendMaterialParams && h.extendMaterialParams(e, a)
                    );
                  })
                )
              );
          }
          !0 === s.doubleSided && (a.side = Cr);
          const u = s.alphaMode || "OPAQUE";
          if (
            ("BLEND" === u
              ? ((a.transparent = !0), (a.depthWrite = !1))
              : ((a.transparent = !1),
                "MASK" === u &&
                  (a.alphaTest =
                    void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
            void 0 !== s.normalTexture &&
              o !== Ar &&
              (c.push(t.assignTexture(a, "normalMap", s.normalTexture)),
              (a.normalScale = new $(1, 1)),
              void 0 !== s.normalTexture.scale))
          ) {
            const d = s.normalTexture.scale;
            a.normalScale.set(d, d);
          }
          return (
            void 0 !== s.occlusionTexture &&
              o !== Ar &&
              (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
              void 0 !== s.occlusionTexture.strength &&
                (a.aoMapIntensity = s.occlusionTexture.strength)),
            void 0 !== s.emissiveFactor &&
              o !== Ar &&
              (a.emissive = new de().fromArray(s.emissiveFactor)),
            void 0 !== s.emissiveTexture &&
              o !== Ar &&
              c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, qe)),
            Promise.all(c).then(function () {
              const d = new o(a);
              return (
                s.name && (d.name = s.name),
                Xo(d, s),
                t.associations.set(d, { materials: e }),
                s.extensions && Za(r, d, s),
                d
              );
            })
          );
        }
        createUniqueName(e) {
          const t = Wt.sanitizeNodeName(e || "");
          return t in this.nodeNamesUsed
            ? t + "_" + ++this.nodeNamesUsed[t]
            : ((this.nodeNamesUsed[t] = 0), t);
        }
        loadGeometries(e) {
          const t = this,
            i = this.extensions,
            r = this.primitiveCache;
          function s(a) {
            return i[It.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(a, t)
              .then(function (l) {
                return yL(l, a, t);
              });
          }
          const o = [];
          for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
              u = lQ(c),
              d = r[u];
            if (d) o.push(d.promise);
            else {
              let h;
              (h =
                c.extensions && c.extensions[It.KHR_DRACO_MESH_COMPRESSION]
                  ? s(c)
                  : yL(new ut(), c, t)),
                (r[u] = { primitive: c, promise: h }),
                o.push(h);
            }
          }
          return Promise.all(o);
        }
        loadMesh(e) {
          const t = this,
            r = this.extensions,
            s = this.json.meshes[e],
            o = s.primitives,
            a = [];
          for (let l = 0, c = o.length; l < c; l++) {
            const u =
              void 0 === o[l].material
                ? (void 0 === (n = this.cache).DefaultMaterial &&
                    (n.DefaultMaterial = new eg({
                      color: 16777215,
                      emissive: 0,
                      metalness: 1,
                      roughness: 1,
                      transparent: !1,
                      depthTest: !0,
                      side: $s,
                    })),
                  n.DefaultMaterial)
                : this.getDependency("material", o[l].material);
            a.push(u);
          }
          var n;
          return (
            a.push(t.loadGeometries(o)),
            Promise.all(a).then(function (l) {
              const c = l.slice(0, l.length - 1),
                u = l[l.length - 1],
                d = [];
              for (let f = 0, p = u.length; f < p; f++) {
                const _ = u[f],
                  m = o[f];
                let g;
                const y = c[f];
                if (
                  m.mode === Rr.TRIANGLES ||
                  m.mode === Rr.TRIANGLE_STRIP ||
                  m.mode === Rr.TRIANGLE_FAN ||
                  void 0 === m.mode
                )
                  (g = !0 === s.isSkinnedMesh ? new rx(_, y) : new Kn(_, y)),
                    !0 === g.isSkinnedMesh && g.normalizeSkinWeights(),
                    m.mode === Rr.TRIANGLE_STRIP
                      ? (g.geometry = fL(g.geometry, WR))
                      : m.mode === Rr.TRIANGLE_FAN &&
                        (g.geometry = fL(g.geometry, vb));
                else if (m.mode === Rr.LINES) g = new ox(_, y);
                else if (m.mode === Rr.LINE_STRIP) g = new zo(_, y);
                else if (m.mode === Rr.LINE_LOOP) g = new fO(_, y);
                else {
                  if (m.mode !== Rr.POINTS)
                    throw new Error(
                      "THREE.GLTFLoader: Primitive mode unsupported: " + m.mode
                    );
                  g = new mO(_, y);
                }
                Object.keys(g.geometry.morphAttributes).length > 0 && aQ(g, s),
                  (g.name = t.createUniqueName(s.name || "mesh_" + e)),
                  Xo(g, s),
                  m.extensions && Za(r, g, m),
                  t.assignFinalMaterial(g),
                  d.push(g);
              }
              for (let f = 0, p = d.length; f < p; f++)
                t.associations.set(d[f], { meshes: e, primitives: f });
              if (1 === d.length) return s.extensions && Za(r, d[0], s), d[0];
              const h = new Es();
              s.extensions && Za(r, h, s), t.associations.set(h, { meshes: e });
              for (let f = 0, p = d.length; f < p; f++) h.add(d[f]);
              return h;
            })
          );
        }
        loadCamera(e) {
          let t;
          const i = this.json.cameras[e],
            r = i[i.type];
          if (r)
            return (
              "perspective" === i.type
                ? (t = new Wn(
                    $r.radToDeg(r.yfov),
                    r.aspectRatio || 1,
                    r.znear || 1,
                    r.zfar || 2e6
                  ))
                : "orthographic" === i.type &&
                  (t = new Hc(
                    -r.xmag,
                    r.xmag,
                    r.ymag,
                    -r.ymag,
                    r.znear,
                    r.zfar
                  )),
              i.name && (t.name = this.createUniqueName(i.name)),
              Xo(t, i),
              Promise.resolve(t)
            );
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            i = [];
          for (let r = 0, s = t.joints.length; r < s; r++)
            i.push(this._loadNodeShallow(t.joints[r]));
          return (
            i.push(
              void 0 !== t.inverseBindMatrices
                ? this.getDependency("accessor", t.inverseBindMatrices)
                : null
            ),
            Promise.all(i).then(function (r) {
              const s = r.pop(),
                o = r,
                a = [],
                l = [];
              for (let c = 0, u = o.length; c < u; c++) {
                const d = o[c];
                if (d) {
                  a.push(d);
                  const h = new Ae();
                  null !== s && h.fromArray(s.array, 16 * c), l.push(h);
                } else
                  console.warn(
                    'THREE.GLTFLoader: Joint "%s" could not be found.',
                    t.joints[c]
                  );
              }
              return new lh(a, l);
            })
          );
        }
        loadAnimation(e) {
          const i = this,
            r = this.json.animations[e],
            s = r.name ? r.name : "animation_" + e,
            o = [],
            a = [],
            l = [],
            c = [],
            u = [];
          for (let d = 0, h = r.channels.length; d < h; d++) {
            const f = r.channels[d],
              p = r.samplers[f.sampler],
              _ = f.target,
              g = void 0 !== r.parameters ? r.parameters[p.input] : p.input,
              y = void 0 !== r.parameters ? r.parameters[p.output] : p.output;
            void 0 !== _.node &&
              (o.push(this.getDependency("node", _.node)),
              a.push(this.getDependency("accessor", g)),
              l.push(this.getDependency("accessor", y)),
              c.push(p),
              u.push(_));
          }
          return Promise.all([
            Promise.all(o),
            Promise.all(a),
            Promise.all(l),
            Promise.all(c),
            Promise.all(u),
          ]).then(function (d) {
            const h = d[0],
              f = d[1],
              p = d[2],
              _ = d[3],
              m = d[4],
              g = [];
            for (let y = 0, v = h.length; y < v; y++) {
              const b = h[y],
                x = f[y],
                M = p[y],
                S = _[y],
                C = m[y];
              if (void 0 === b) continue;
              b.updateMatrix && (b.updateMatrix(), (b.matrixAutoUpdate = !0));
              const w = i._createAnimationTracks(b, x, M, S, C);
              if (w) for (let E = 0; E < w.length; E++) g.push(w[E]);
            }
            return new iu(s, void 0, g);
          });
        }
        createNodeMesh(e) {
          const i = this,
            r = this.json.nodes[e];
          return void 0 === r.mesh
            ? null
            : i.getDependency("mesh", r.mesh).then(function (s) {
                const o = i._getNodeRef(i.meshCache, r.mesh, s);
                return (
                  void 0 !== r.weights &&
                    o.traverse(function (a) {
                      if (a.isMesh)
                        for (let l = 0, c = r.weights.length; l < c; l++)
                          a.morphTargetInfluences[l] = r.weights[l];
                    }),
                  o
                );
              });
        }
        loadNode(e) {
          const i = this,
            r = this.json.nodes[e],
            s = i._loadNodeShallow(e),
            o = [],
            a = r.children || [];
          for (let c = 0, u = a.length; c < u; c++)
            o.push(i.getDependency("node", a[c]));
          const l =
            void 0 === r.skin
              ? Promise.resolve(null)
              : i.getDependency("skin", r.skin);
          return Promise.all([s, Promise.all(o), l]).then(function (c) {
            const u = c[0],
              d = c[1],
              h = c[2];
            null !== h &&
              u.traverse(function (f) {
                f.isSkinnedMesh && f.bind(h, uQ);
              });
            for (let f = 0, p = d.length; f < p; f++) u.add(d[f]);
            return u;
          });
        }
        _loadNodeShallow(e) {
          const i = this.extensions,
            r = this;
          if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
          const s = this.json.nodes[e],
            o = s.name ? r.createUniqueName(s.name) : "",
            a = [],
            l = r._invokeOne(function (c) {
              return c.createNodeMesh && c.createNodeMesh(e);
            });
          return (
            l && a.push(l),
            void 0 !== s.camera &&
              a.push(
                r.getDependency("camera", s.camera).then(function (c) {
                  return r._getNodeRef(r.cameraCache, s.camera, c);
                })
              ),
            r
              ._invokeAll(function (c) {
                return c.createNodeAttachment && c.createNodeAttachment(e);
              })
              .forEach(function (c) {
                a.push(c);
              }),
            (this.nodeCache[e] = Promise.all(a).then(function (c) {
              let u;
              if (
                ((u =
                  !0 === s.isBone
                    ? new oh()
                    : c.length > 1
                    ? new Es()
                    : 1 === c.length
                    ? c[0]
                    : new Dn()),
                u !== c[0])
              )
                for (let d = 0, h = c.length; d < h; d++) u.add(c[d]);
              if (
                (s.name && ((u.userData.name = s.name), (u.name = o)),
                Xo(u, s),
                s.extensions && Za(i, u, s),
                void 0 !== s.matrix)
              ) {
                const d = new Ae();
                d.fromArray(s.matrix), u.applyMatrix4(d);
              } else void 0 !== s.translation && u.position.fromArray(s.translation), void 0 !== s.rotation && u.quaternion.fromArray(s.rotation), void 0 !== s.scale && u.scale.fromArray(s.scale);
              return (
                r.associations.has(u) || r.associations.set(u, {}),
                (r.associations.get(u).nodes = e),
                u
              );
            })),
            this.nodeCache[e]
          );
        }
        loadScene(e) {
          const t = this.extensions,
            i = this.json.scenes[e],
            r = this,
            s = new Es();
          i.name && (s.name = r.createUniqueName(i.name)),
            Xo(s, i),
            i.extensions && Za(t, s, i);
          const o = i.nodes || [],
            a = [];
          for (let l = 0, c = o.length; l < c; l++)
            a.push(r.getDependency("node", o[l]));
          return Promise.all(a).then(function (l) {
            for (let u = 0, d = l.length; u < d; u++) s.add(l[u]);
            return (
              (r.associations = ((u) => {
                const d = new Map();
                for (const [h, f] of r.associations)
                  (h instanceof ar || h instanceof Ai) && d.set(h, f);
                return (
                  u.traverse((h) => {
                    const f = r.associations.get(h);
                    null != f && d.set(h, f);
                  }),
                  d
                );
              })(s)),
              s
            );
          });
        }
        _createAnimationTracks(e, t, i, r, s) {
          const o = [],
            a = e.name ? e.name : e.uuid,
            l = [];
          let c;
          switch (
            (jo[s.path] === jo.weights
              ? e.traverse(function (h) {
                  h.morphTargetInfluences && l.push(h.name ? h.name : h.uuid);
                })
              : l.push(a),
            jo[s.path])
          ) {
            case jo.weights:
              c = Ga;
              break;
            case jo.rotation:
              c = Ho;
              break;
            default:
              switch (i.itemSize) {
                case 1:
                  c = Ga;
                  break;
                case 2:
                case 3:
                  c = nu;
              }
          }
          const u = void 0 !== r.interpolation ? rQ[r.interpolation] : _c,
            d = this._getArrayFromAccessor(i);
          for (let h = 0, f = l.length; h < f; h++) {
            const p = new c(l[h] + "." + jo[s.path], t.array, d, u);
            "CUBICSPLINE" === u && this._createCubicSplineTrackInterpolant(p),
              o.push(p);
          }
          return o;
        }
        _getArrayFromAccessor(e) {
          let t = e.array;
          if (e.normalized) {
            const i = iw(t.constructor),
              r = new Float32Array(t.length);
            for (let s = 0, o = t.length; s < o; s++) r[s] = t[s] * i;
            t = r;
          }
          return t;
        }
        _createCubicSplineTrackInterpolant(e) {
          (e.createInterpolant = function (i) {
            return new (this instanceof Ho ? iQ : gL)(
              this.times,
              this.values,
              this.getValueSize() / 3,
              i
            );
          }),
            (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0);
        }
      }
      function yL(n, e, t) {
        const i = e.attributes,
          r = [];
        function s(o, a) {
          return t.getDependency("accessor", o).then(function (l) {
            n.setAttribute(a, l);
          });
        }
        for (const o in i) {
          const a = ew[o] || o.toLowerCase();
          a in n.attributes || r.push(s(i[o], a));
        }
        if (void 0 !== e.indices && !n.index) {
          const o = t.getDependency("accessor", e.indices).then(function (a) {
            n.setIndex(a);
          });
          r.push(o);
        }
        return (
          Xo(n, e),
          (function hQ(n, e, t) {
            const i = e.attributes,
              r = new Ms();
            if (void 0 === i.POSITION) return;
            {
              const a = t.json.accessors[i.POSITION],
                l = a.min,
                c = a.max;
              if (void 0 === l || void 0 === c)
                return void console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
              if (
                (r.set(new A(l[0], l[1], l[2]), new A(c[0], c[1], c[2])),
                a.normalized)
              ) {
                const u = iw(cu[a.componentType]);
                r.min.multiplyScalar(u), r.max.multiplyScalar(u);
              }
            }
            const s = e.targets;
            if (void 0 !== s) {
              const a = new A(),
                l = new A();
              for (let c = 0, u = s.length; c < u; c++) {
                const d = s[c];
                if (void 0 !== d.POSITION) {
                  const h = t.json.accessors[d.POSITION],
                    f = h.min,
                    p = h.max;
                  if (void 0 !== f && void 0 !== p) {
                    if (
                      (l.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))),
                      l.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))),
                      l.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))),
                      h.normalized)
                    ) {
                      const _ = iw(cu[h.componentType]);
                      l.multiplyScalar(_);
                    }
                    a.max(l);
                  } else
                    console.warn(
                      "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                    );
                }
              }
              r.expandByVector(a);
            }
            n.boundingBox = r;
            const o = new Jr();
            r.getCenter(o.center),
              (o.radius = r.min.distanceTo(r.max) / 2),
              (n.boundingSphere = o);
          })(n, e, t),
          Promise.all(r).then(function () {
            return void 0 !== e.targets
              ? (function oQ(n, e, t) {
                  let i = !1,
                    r = !1,
                    s = !1;
                  for (let c = 0, u = e.length; c < u; c++) {
                    const d = e[c];
                    if (
                      (void 0 !== d.POSITION && (i = !0),
                      void 0 !== d.NORMAL && (r = !0),
                      void 0 !== d.COLOR_0 && (s = !0),
                      i && r && s)
                    )
                      break;
                  }
                  if (!i && !r && !s) return Promise.resolve(n);
                  const o = [],
                    a = [],
                    l = [];
                  for (let c = 0, u = e.length; c < u; c++) {
                    const d = e[c];
                    if (i) {
                      const h =
                        void 0 !== d.POSITION
                          ? t.getDependency("accessor", d.POSITION)
                          : n.attributes.position;
                      o.push(h);
                    }
                    if (r) {
                      const h =
                        void 0 !== d.NORMAL
                          ? t.getDependency("accessor", d.NORMAL)
                          : n.attributes.normal;
                      a.push(h);
                    }
                    if (s) {
                      const h =
                        void 0 !== d.COLOR_0
                          ? t.getDependency("accessor", d.COLOR_0)
                          : n.attributes.color;
                      l.push(h);
                    }
                  }
                  return Promise.all([
                    Promise.all(o),
                    Promise.all(a),
                    Promise.all(l),
                  ]).then(function (c) {
                    const d = c[1],
                      h = c[2];
                    return (
                      i && (n.morphAttributes.position = c[0]),
                      r && (n.morphAttributes.normal = d),
                      s && (n.morphAttributes.color = h),
                      (n.morphTargetsRelative = !0),
                      n
                    );
                  });
                })(n, e.targets, t)
              : n;
          })
        );
      }
      var rw = function (n) {
        return URL.createObjectURL(new Blob([n], { type: "text/javascript" }));
      };
      try {
        URL.revokeObjectURL(rw(""));
      } catch {
        rw = function (e) {
          return "data:application/javascript;charset=UTF-8," + encodeURI(e);
        };
      }
      var Yt = Uint8Array,
        Qn = Uint16Array,
        qo = Uint32Array,
        uu = new Yt([
          0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
          4, 5, 5, 5, 5, 0, 0, 0, 0,
        ]),
        du = new Yt([
          0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
          10, 11, 11, 12, 12, 13, 13, 0, 0,
        ]),
        xh = new Yt([
          16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
        ]),
        wL = function (n, e) {
          for (var t = new Qn(31), i = 0; i < 31; ++i)
            t[i] = e += 1 << n[i - 1];
          var r = new qo(t[30]);
          for (i = 1; i < 30; ++i)
            for (var s = t[i]; s < t[i + 1]; ++s) r[s] = ((s - t[i]) << 5) | i;
          return [t, r];
        },
        ML = wL(uu, 2),
        sw = ML[0],
        pg = ML[1];
      (sw[28] = 258), (pg[258] = 28);
      for (
        var EL = wL(du, 0)[0], wh = new Qn(32768), sn = 0;
        sn < 32768;
        ++sn
      ) {
        var Yo = ((43690 & sn) >>> 1) | ((21845 & sn) << 1);
        wh[sn] =
          (((65280 &
            (Yo =
              ((61680 & (Yo = ((52428 & Yo) >>> 2) | ((13107 & Yo) << 2))) >>>
                4) |
              ((3855 & Yo) << 4))) >>>
            8) |
            ((255 & Yo) << 8)) >>>
          1;
      }
      var Ts = function (n, e, t) {
          for (var i = n.length, r = 0, s = new Qn(e); r < i; ++r)
            ++s[n[r] - 1];
          var a,
            o = new Qn(e);
          for (r = 0; r < e; ++r) o[r] = (o[r - 1] + s[r - 1]) << 1;
          if (t) {
            a = new Qn(1 << e);
            var l = 15 - e;
            for (r = 0; r < i; ++r)
              if (n[r])
                for (
                  var c = (r << 4) | n[r],
                    u = e - n[r],
                    d = o[n[r] - 1]++ << u,
                    h = d | ((1 << u) - 1);
                  d <= h;
                  ++d
                )
                  a[wh[d] >>> l] = c;
          } else
            for (a = new Qn(i), r = 0; r < i; ++r)
              n[r] && (a[r] = wh[o[n[r] - 1]++] >>> (15 - n[r]));
          return a;
        },
        Zo = new Yt(288);
      for (sn = 0; sn < 144; ++sn) Zo[sn] = 8;
      for (sn = 144; sn < 256; ++sn) Zo[sn] = 9;
      for (sn = 256; sn < 280; ++sn) Zo[sn] = 7;
      for (sn = 280; sn < 288; ++sn) Zo[sn] = 8;
      var Mh = new Yt(32);
      for (sn = 0; sn < 32; ++sn) Mh[sn] = 5;
      var TL = Ts(Zo, 9, 1),
        DL = Ts(Mh, 5, 1),
        mg = function (n) {
          for (var e = n[0], t = 1; t < n.length; ++t) n[t] > e && (e = n[t]);
          return e;
        },
        Pr = function (n, e, t) {
          var i = (e / 8) | 0;
          return ((n[i] | (n[i + 1] << 8)) >> (7 & e)) & t;
        },
        gg = function (n, e) {
          var t = (e / 8) | 0;
          return (n[t] | (n[t + 1] << 8) | (n[t + 2] << 16)) >> (7 & e);
        },
        Sh = function (n) {
          return ((n / 8) | 0) + (7 & n && 1);
        },
        _g = function (n, e, t) {
          var i = n.length;
          if (!i || (t && !t.l && i < 5)) return e || new Yt(0);
          var r = !e || t,
            s = !t || t.i;
          t || (t = {}), e || (e = new Yt(3 * i));
          var o = function (Ce) {
              var ve = e.length;
              if (Ce > ve) {
                var xe = new Yt(Math.max(2 * ve, Ce));
                xe.set(e), (e = xe);
              }
            },
            a = t.f || 0,
            l = t.p || 0,
            c = t.b || 0,
            u = t.l,
            d = t.d,
            h = t.m,
            f = t.n,
            p = 8 * i;
          do {
            if (!u) {
              t.f = a = Pr(n, l, 1);
              var _ = Pr(n, l + 1, 3);
              if (((l += 3), !_)) {
                var g = n[(m = Sh(l) + 4) - 4] | (n[m - 3] << 8),
                  y = m + g;
                if (y > i) {
                  if (s) throw "unexpected EOF";
                  break;
                }
                r && o(c + g),
                  e.set(n.subarray(m, y), c),
                  (t.b = c += g),
                  (t.p = l = 8 * y);
                continue;
              }
              if (1 == _) (u = TL), (d = DL), (h = 9), (f = 5);
              else {
                if (2 != _) throw "invalid block type";
                var v = Pr(n, l, 31) + 257,
                  b = Pr(n, l + 10, 15) + 4,
                  x = v + Pr(n, l + 5, 31) + 1;
                l += 14;
                for (var M = new Yt(x), S = new Yt(19), C = 0; C < b; ++C)
                  S[xh[C]] = Pr(n, l + 3 * C, 7);
                l += 3 * b;
                var w = mg(S),
                  E = (1 << w) - 1,
                  V = Ts(S, w, 1);
                for (C = 0; C < x; ) {
                  var m,
                    j = V[Pr(n, l, E)];
                  if (((l += 15 & j), (m = j >>> 4) < 16)) M[C++] = m;
                  else {
                    var F = 0,
                      k = 0;
                    for (
                      16 == m
                        ? ((k = 3 + Pr(n, l, 3)), (l += 2), (F = M[C - 1]))
                        : 17 == m
                        ? ((k = 3 + Pr(n, l, 7)), (l += 3))
                        : 18 == m && ((k = 11 + Pr(n, l, 127)), (l += 7));
                      k--;

                    )
                      M[C++] = F;
                  }
                }
                var z = M.subarray(0, v),
                  O = M.subarray(v);
                (h = mg(z)), (f = mg(O)), (u = Ts(z, h, 1)), (d = Ts(O, f, 1));
              }
              if (l > p) {
                if (s) throw "unexpected EOF";
                break;
              }
            }
            r && o(c + 131072);
            for (var L = (1 << h) - 1, U = (1 << f) - 1, W = l; ; W = l) {
              var Z = (F = u[gg(n, l) & L]) >>> 4;
              if ((l += 15 & F) > p) {
                if (s) throw "unexpected EOF";
                break;
              }
              if (!F) throw "invalid length/literal";
              if (Z < 256) e[c++] = Z;
              else {
                if (256 == Z) {
                  (W = l), (u = null);
                  break;
                }
                var B = Z - 254;
                Z > 264 &&
                  ((B = Pr(n, l, (1 << (q = uu[(C = Z - 257)])) - 1) + sw[C]),
                  (l += q));
                var le = d[gg(n, l) & U],
                  te = le >>> 4;
                if (!le) throw "invalid distance";
                if (((l += 15 & le), (O = EL[te]), te > 3)) {
                  var q = du[te];
                  (O += gg(n, l) & ((1 << q) - 1)), (l += q);
                }
                if (l > p) {
                  if (s) throw "unexpected EOF";
                  break;
                }
                r && o(c + 131072);
                for (var ce = c + B; c < ce; c += 4)
                  (e[c] = e[c - O]),
                    (e[c + 1] = e[c + 1 - O]),
                    (e[c + 2] = e[c + 2 - O]),
                    (e[c + 3] = e[c + 3 - O]);
                c = ce;
              }
            }
            (t.l = u),
              (t.p = W),
              (t.b = c),
              u && ((a = 1), (t.m = h), (t.d = d), (t.n = f));
          } while (!a);
          return c == e.length
            ? e
            : (function (n, e, t) {
                (null == e || e < 0) && (e = 0),
                  (null == t || t > n.length) && (t = n.length);
                var i = new (n instanceof Qn ? Qn : n instanceof qo ? qo : Yt)(
                  t - e
                );
                return i.set(n.subarray(e, t)), i;
              })(e, 0, c);
        },
        bg = new Yt(0),
        zL = function (n) {
          if (8 != (15 & n[0]) || n[0] >>> 4 > 7 || ((n[0] << 8) | n[1]) % 31)
            throw "invalid zlib data";
          if (32 & n[1])
            throw "invalid zlib data: preset dictionaries not supported";
        };
      var mw = typeof TextDecoder < "u" && new TextDecoder();
      try {
        mw.decode(bg, { stream: !0 });
      } catch {}
      function Dg(n, e, t) {
        const i = t.length - n - 1;
        if (e >= t[i]) return i - 1;
        if (e <= t[n]) return n;
        let r = n,
          s = i,
          o = Math.floor((r + s) / 2);
        for (; e < t[o] || e >= t[o + 1]; )
          e < t[o] ? (s = o) : (r = o), (o = Math.floor((r + s) / 2));
        return o;
      }
      function DQ(n, e) {
        let t = 1;
        for (let r = 2; r <= n; ++r) t *= r;
        let i = 1;
        for (let r = 2; r <= e; ++r) i *= r;
        for (let r = 2; r <= n - e; ++r) i *= r;
        return t / i;
      }
      class PQ extends is {
        constructor(e, t, i, r, s) {
          super(),
            (this.degree = e),
            (this.knots = t),
            (this.controlPoints = []),
            (this.startKnot = r || 0),
            (this.endKnot = s || this.knots.length - 1);
          for (let o = 0; o < i.length; ++o) {
            const a = i[o];
            this.controlPoints[o] = new Ft(a.x, a.y, a.z, a.w);
          }
        }
        getPoint(e, t = new A()) {
          const i = t,
            s = (function CQ(n, e, t, i) {
              const r = Dg(n, i, e),
                s = (function gw(n, e, t, i) {
                  const r = [],
                    s = [],
                    o = [];
                  r[0] = 1;
                  for (let a = 1; a <= t; ++a) {
                    (s[a] = e - i[n + 1 - a]), (o[a] = i[n + a] - e);
                    let l = 0;
                    for (let c = 0; c < a; ++c) {
                      const u = o[c + 1],
                        d = s[a - c],
                        h = r[c] / (u + d);
                      (r[c] = l + u * h), (l = d * h);
                    }
                    r[a] = l;
                  }
                  return r;
                })(r, i, n, e),
                o = new Ft(0, 0, 0, 0);
              for (let a = 0; a <= n; ++a) {
                const l = t[r - n + a],
                  c = s[a],
                  u = l.w * c;
                (o.x += l.x * u),
                  (o.y += l.y * u),
                  (o.z += l.z * u),
                  (o.w += l.w * c);
              }
              return o;
            })(
              this.degree,
              this.knots,
              this.controlPoints,
              this.knots[this.startKnot] +
                e * (this.knots[this.endKnot] - this.knots[this.startKnot])
            );
          return 1 !== s.w && s.divideScalar(s.w), i.set(s.x, s.y, s.z);
        }
        getTangent(e, t = new A()) {
          const i = t,
            s = (function RQ(n, e, t, i, r) {
              const s = (function AQ(n, e, t, i, r) {
                const s = r < n ? r : n,
                  o = [],
                  a = Dg(n, i, e),
                  l = (function TQ(n, e, t, i, r) {
                    const s = [];
                    for (let d = 0; d <= t; ++d) s[d] = 0;
                    const o = [];
                    for (let d = 0; d <= i; ++d) o[d] = s.slice(0);
                    const a = [];
                    for (let d = 0; d <= t; ++d) a[d] = s.slice(0);
                    a[0][0] = 1;
                    const l = s.slice(0),
                      c = s.slice(0);
                    for (let d = 1; d <= t; ++d) {
                      (l[d] = e - r[n + 1 - d]), (c[d] = r[n + d] - e);
                      let h = 0;
                      for (let f = 0; f < d; ++f) {
                        const p = c[f + 1],
                          _ = l[d - f];
                        a[d][f] = p + _;
                        const m = a[f][d - 1] / a[d][f];
                        (a[f][d] = h + p * m), (h = _ * m);
                      }
                      a[d][d] = h;
                    }
                    for (let d = 0; d <= t; ++d) o[0][d] = a[d][t];
                    for (let d = 0; d <= t; ++d) {
                      let h = 0,
                        f = 1;
                      const p = [];
                      for (let _ = 0; _ <= t; ++_) p[_] = s.slice(0);
                      p[0][0] = 1;
                      for (let _ = 1; _ <= i; ++_) {
                        let m = 0;
                        const g = d - _,
                          y = t - _;
                        d >= _ &&
                          ((p[f][0] = p[h][0] / a[y + 1][g]),
                          (m = p[f][0] * a[g][y]));
                        const b = d - 1 <= y ? _ - 1 : t - d;
                        for (let M = g >= -1 ? 1 : -g; M <= b; ++M)
                          (p[f][M] = (p[h][M] - p[h][M - 1]) / a[y + 1][g + M]),
                            (m += p[f][M] * a[g + M][y]);
                        d <= y &&
                          ((p[f][_] = -p[h][_ - 1] / a[y + 1][d]),
                          (m += p[f][_] * a[d][y])),
                          (o[_][d] = m);
                        const x = h;
                        (h = f), (f = x);
                      }
                    }
                    let u = t;
                    for (let d = 1; d <= i; ++d) {
                      for (let h = 0; h <= t; ++h) o[d][h] *= u;
                      u *= t - d;
                    }
                    return o;
                  })(a, i, n, s, e),
                  c = [];
                for (let u = 0; u < t.length; ++u) {
                  const d = t[u].clone(),
                    h = d.w;
                  (d.x *= h), (d.y *= h), (d.z *= h), (c[u] = d);
                }
                for (let u = 0; u <= s; ++u) {
                  const d = c[a - n].clone().multiplyScalar(l[u][0]);
                  for (let h = 1; h <= n; ++h)
                    d.add(c[a - n + h].clone().multiplyScalar(l[u][h]));
                  o[u] = d;
                }
                for (let u = s + 1; u <= r + 1; ++u) o[u] = new Ft(0, 0, 0);
                return o;
              })(n, e, t, i, r);
              return (function IQ(n) {
                const e = n.length,
                  t = [],
                  i = [];
                for (let s = 0; s < e; ++s) {
                  const o = n[s];
                  (t[s] = new A(o.x, o.y, o.z)), (i[s] = o.w);
                }
                const r = [];
                for (let s = 0; s < e; ++s) {
                  const o = t[s].clone();
                  for (let a = 1; a <= s; ++a)
                    o.sub(r[s - a].clone().multiplyScalar(DQ(s, a) * i[a]));
                  r[s] = o.divideScalar(i[0]);
                }
                return r;
              })(s);
            })(
              this.degree,
              this.knots,
              this.controlPoints,
              this.knots[0] +
                e * (this.knots[this.knots.length - 1] - this.knots[0]),
              1
            );
          return i.copy(s[1]).normalize(), i;
        }
      }
      let Ct, Rn, Wi;
      class OQ extends po {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          const s = this,
            o = "" === s.path ? ou.extractUrlBase(e) : s.path,
            a = new cr(this.manager);
          a.setPath(s.path),
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(s.requestHeader),
            a.setWithCredentials(s.withCredentials),
            a.load(
              e,
              function (l) {
                try {
                  t(s.parse(l, o));
                } catch (c) {
                  r ? r(c) : console.error(c), s.manager.itemError(e);
                }
              },
              i,
              r
            );
        }
        parse(e, t) {
          if (
            (function UQ(n) {
              const e = "Kaydara FBX Binary  \0";
              return n.byteLength >= e.length && e === eF(n, 0, e.length);
            })(e)
          )
            Ct = new BQ().parse(e);
          else {
            const r = eF(e);
            if (
              !(function VQ(n) {
                const e = [
                  "K",
                  "a",
                  "y",
                  "d",
                  "a",
                  "r",
                  "a",
                  "\\",
                  "F",
                  "B",
                  "X",
                  "\\",
                  "B",
                  "i",
                  "n",
                  "a",
                  "r",
                  "y",
                  "\\",
                  "\\",
                ];
                let t = 0;
                function i(r) {
                  const s = n[r - 1];
                  return (n = n.slice(t + r)), t++, s;
                }
                for (let r = 0; r < e.length; ++r) if (i(1) === e[r]) return !1;
                return !0;
              })(r)
            )
              throw new Error("THREE.FBXLoader: Unknown format.");
            if ($L(r) < 7e3)
              throw new Error(
                "THREE.FBXLoader: FBX version not supported, FileVersion: " +
                  $L(r)
              );
            Ct = new kQ().parse(r);
          }
          const i = new FO(this.manager)
            .setPath(this.resourcePath || t)
            .setCrossOrigin(this.crossOrigin);
          return new LQ(i, this.manager).parse(Ct);
        }
      }
      class LQ {
        constructor(e, t) {
          (this.textureLoader = e), (this.manager = t);
        }
        parse() {
          Rn = this.parseConnections();
          const e = this.parseImages(),
            t = this.parseTextures(e),
            i = this.parseMaterials(t),
            r = this.parseDeformers(),
            s = new FQ().parse(r);
          return this.parseScene(r, s, i), Wi;
        }
        parseConnections() {
          const e = new Map();
          return (
            "Connections" in Ct &&
              Ct.Connections.connections.forEach(function (i) {
                const r = i[0],
                  s = i[1],
                  o = i[2];
                e.has(r) || e.set(r, { parents: [], children: [] });
                const a = { ID: s, relationship: o };
                e.get(r).parents.push(a),
                  e.has(s) || e.set(s, { parents: [], children: [] });
                const l = { ID: r, relationship: o };
                e.get(s).children.push(l);
              }),
            e
          );
        }
        parseImages() {
          const e = {},
            t = {};
          if ("Video" in Ct.Objects) {
            const i = Ct.Objects.Video;
            for (const r in i) {
              const s = i[r];
              if (
                ((e[parseInt(r)] = s.RelativeFilename || s.Filename),
                "Content" in s &&
                  ((s.Content instanceof ArrayBuffer &&
                    s.Content.byteLength > 0) ||
                    ("string" == typeof s.Content && "" !== s.Content)))
              ) {
                const c = this.parseImage(i[r]);
                t[s.RelativeFilename || s.Filename] = c;
              }
            }
          }
          for (const i in e) {
            const r = e[i];
            e[i] = void 0 !== t[r] ? t[r] : e[i].split("\\").pop();
          }
          return e;
        }
        parseImage(e) {
          const t = e.Content,
            i = e.RelativeFilename || e.Filename,
            r = i.slice(i.lastIndexOf(".") + 1).toLowerCase();
          let s;
          switch (r) {
            case "bmp":
              s = "image/bmp";
              break;
            case "jpg":
            case "jpeg":
              s = "image/jpeg";
              break;
            case "png":
              s = "image/png";
              break;
            case "tif":
              s = "image/tiff";
              break;
            case "tga":
              null === this.manager.getHandler(".tga") &&
                console.warn("FBXLoader: TGA loader not found, skipping ", i),
                (s = "image/tga");
              break;
            default:
              return void console.warn(
                'FBXLoader: Image type "' + r + '" is not supported.'
              );
          }
          if ("string" == typeof t) return "data:" + s + ";base64," + t;
          {
            const o = new Uint8Array(t);
            return window.URL.createObjectURL(new Blob([o], { type: s }));
          }
        }
        parseTextures(e) {
          const t = new Map();
          if ("Texture" in Ct.Objects) {
            const i = Ct.Objects.Texture;
            for (const r in i) {
              const s = this.parseTexture(i[r], e);
              t.set(parseInt(r), s);
            }
          }
          return t;
        }
        parseTexture(e, t) {
          const i = this.loadTexture(e, t);
          (i.ID = e.id), (i.name = e.attrName);
          const r = e.WrapModeU,
            s = e.WrapModeV,
            a = void 0 !== s ? s.value : 0;
          if (
            ((i.wrapS = 0 === (void 0 !== r ? r.value : 0) ? Js : Yn),
            (i.wrapT = 0 === a ? Js : Yn),
            "Scaling" in e)
          ) {
            const l = e.Scaling.value;
            (i.repeat.x = l[0]), (i.repeat.y = l[1]);
          }
          if ("Translation" in e) {
            const l = e.Translation.value;
            (i.offset.x = l[0]), (i.offset.y = l[1]);
          }
          return i;
        }
        loadTexture(e, t) {
          let i;
          const r = this.textureLoader.path,
            s = Rn.get(e.id).children;
          let o;
          void 0 !== s &&
            s.length > 0 &&
            void 0 !== t[s[0].ID] &&
            ((i = t[s[0].ID]),
            (0 === i.indexOf("blob:") || 0 === i.indexOf("data:")) &&
              this.textureLoader.setPath(void 0));
          const a = e.FileName.slice(-3).toLowerCase();
          if ("tga" === a) {
            const l = this.manager.getHandler(".tga");
            null === l
              ? (console.warn(
                  "FBXLoader: TGA loader not found, creating placeholder texture for",
                  e.RelativeFilename
                ),
                (o = new Ai()))
              : (l.setPath(this.textureLoader.path), (o = l.load(i)));
          } else
            "psd" === a
              ? (console.warn(
                  "FBXLoader: PSD textures are not supported, creating placeholder texture for",
                  e.RelativeFilename
                ),
                (o = new Ai()))
              : (o = this.textureLoader.load(i));
          return this.textureLoader.setPath(r), o;
        }
        parseMaterials(e) {
          const t = new Map();
          if ("Material" in Ct.Objects) {
            const i = Ct.Objects.Material;
            for (const r in i) {
              const s = this.parseMaterial(i[r], e);
              null !== s && t.set(parseInt(r), s);
            }
          }
          return t;
        }
        parseMaterial(e, t) {
          const i = e.id,
            r = e.attrName;
          let s = e.ShadingModel;
          if (("object" == typeof s && (s = s.value), !Rn.has(i))) return null;
          const o = this.parseParameters(e, t, i);
          let a;
          switch (s.toLowerCase()) {
            case "phong":
              a = new tg();
              break;
            case "lambert":
              a = new IO();
              break;
            default:
              console.warn(
                'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',
                s
              ),
                (a = new tg());
          }
          return a.setValues(o), (a.name = r), a;
        }
        parseParameters(e, t, i) {
          const r = {};
          e.BumpFactor && (r.bumpScale = e.BumpFactor.value),
            e.Diffuse
              ? (r.color = new de()
                  .fromArray(e.Diffuse.value)
                  .convertSRGBToLinear())
              : e.DiffuseColor &&
                ("Color" === e.DiffuseColor.type ||
                  "ColorRGB" === e.DiffuseColor.type) &&
                (r.color = new de()
                  .fromArray(e.DiffuseColor.value)
                  .convertSRGBToLinear()),
            e.DisplacementFactor &&
              (r.displacementScale = e.DisplacementFactor.value),
            e.Emissive
              ? (r.emissive = new de()
                  .fromArray(e.Emissive.value)
                  .convertSRGBToLinear())
              : e.EmissiveColor &&
                ("Color" === e.EmissiveColor.type ||
                  "ColorRGB" === e.EmissiveColor.type) &&
                (r.emissive = new de()
                  .fromArray(e.EmissiveColor.value)
                  .convertSRGBToLinear()),
            e.EmissiveFactor &&
              (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
            e.Opacity && (r.opacity = parseFloat(e.Opacity.value)),
            r.opacity < 1 && (r.transparent = !0),
            e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value),
            e.Shininess && (r.shininess = e.Shininess.value),
            e.Specular
              ? (r.specular = new de()
                  .fromArray(e.Specular.value)
                  .convertSRGBToLinear())
              : e.SpecularColor &&
                "Color" === e.SpecularColor.type &&
                (r.specular = new de()
                  .fromArray(e.SpecularColor.value)
                  .convertSRGBToLinear());
          const s = this;
          return (
            Rn.get(i).children.forEach(function (o) {
              const a = o.relationship;
              switch (a) {
                case "Bump":
                  r.bumpMap = s.getTexture(t, o.ID);
                  break;
                case "Maya|TEX_ao_map":
                  r.aoMap = s.getTexture(t, o.ID);
                  break;
                case "DiffuseColor":
                case "Maya|TEX_color_map":
                  (r.map = s.getTexture(t, o.ID)),
                    void 0 !== r.map && (r.map.colorSpace = qe);
                  break;
                case "DisplacementColor":
                  r.displacementMap = s.getTexture(t, o.ID);
                  break;
                case "EmissiveColor":
                  (r.emissiveMap = s.getTexture(t, o.ID)),
                    void 0 !== r.emissiveMap && (r.emissiveMap.colorSpace = qe);
                  break;
                case "NormalMap":
                case "Maya|TEX_normal_map":
                  r.normalMap = s.getTexture(t, o.ID);
                  break;
                case "ReflectionColor":
                  (r.envMap = s.getTexture(t, o.ID)),
                    void 0 !== r.envMap &&
                      ((r.envMap.mapping = Hd), (r.envMap.colorSpace = qe));
                  break;
                case "SpecularColor":
                  (r.specularMap = s.getTexture(t, o.ID)),
                    void 0 !== r.specularMap && (r.specularMap.colorSpace = qe);
                  break;
                case "TransparentColor":
                case "TransparencyFactor":
                  (r.alphaMap = s.getTexture(t, o.ID)), (r.transparent = !0);
                  break;
                default:
                  console.warn(
                    "THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",
                    a
                  );
              }
            }),
            r
          );
        }
        getTexture(e, t) {
          return (
            "LayeredTexture" in Ct.Objects &&
              t in Ct.Objects.LayeredTexture &&
              (console.warn(
                "THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."
              ),
              (t = Rn.get(t).children[0].ID)),
            e.get(t)
          );
        }
        parseDeformers() {
          const e = {},
            t = {};
          if ("Deformer" in Ct.Objects) {
            const i = Ct.Objects.Deformer;
            for (const r in i) {
              const s = i[r],
                o = Rn.get(parseInt(r));
              if ("Skin" === s.attrType) {
                const a = this.parseSkeleton(o, i);
                (a.ID = r),
                  o.parents.length > 1 &&
                    console.warn(
                      "THREE.FBXLoader: skeleton attached to more than one geometry is not supported."
                    ),
                  (a.geometryID = o.parents[0].ID),
                  (e[r] = a);
              } else if ("BlendShape" === s.attrType) {
                const a = { id: r };
                (a.rawTargets = this.parseMorphTargets(o, i)),
                  (a.id = r),
                  o.parents.length > 1 &&
                    console.warn(
                      "THREE.FBXLoader: morph target attached to more than one geometry is not supported."
                    ),
                  (t[r] = a);
              }
            }
          }
          return { skeletons: e, morphTargets: t };
        }
        parseSkeleton(e, t) {
          const i = [];
          return (
            e.children.forEach(function (r) {
              const s = t[r.ID];
              if ("Cluster" !== s.attrType) return;
              const o = {
                ID: r.ID,
                indices: [],
                weights: [],
                transformLink: new Ae().fromArray(s.TransformLink.a),
              };
              "Indexes" in s &&
                ((o.indices = s.Indexes.a), (o.weights = s.Weights.a)),
                i.push(o);
            }),
            { rawBones: i, bones: [] }
          );
        }
        parseMorphTargets(e, t) {
          const i = [];
          for (let r = 0; r < e.children.length; r++) {
            const s = e.children[r],
              o = t[s.ID],
              a = {
                name: o.attrName,
                initialWeight: o.DeformPercent,
                id: o.id,
                fullWeights: o.FullWeights.a,
              };
            if ("BlendShapeChannel" !== o.attrType) return;
            (a.geoID = Rn.get(parseInt(s.ID)).children.filter(function (l) {
              return void 0 === l.relationship;
            })[0].ID),
              i.push(a);
          }
          return i;
        }
        parseScene(e, t, i) {
          Wi = new Es();
          const r = this.parseModels(e.skeletons, t, i),
            s = Ct.Objects.Model,
            o = this;
          r.forEach(function (l) {
            o.setLookAtProperties(l, s[l.ID]),
              Rn.get(l.ID).parents.forEach(function (d) {
                const h = r.get(d.ID);
                void 0 !== h && h.add(l);
              }),
              null === l.parent && Wi.add(l);
          }),
            this.bindSkeleton(e.skeletons, t, r),
            this.createAmbientLight(),
            Wi.traverse(function (l) {
              if (l.userData.transformData) {
                l.parent &&
                  ((l.userData.transformData.parentMatrix = l.parent.matrix),
                  (l.userData.transformData.parentMatrixWorld =
                    l.parent.matrixWorld));
                const c = QL(l.userData.transformData);
                l.applyMatrix4(c), l.updateWorldMatrix();
              }
            });
          const a = new NQ().parse();
          1 === Wi.children.length &&
            Wi.children[0].isGroup &&
            ((Wi.children[0].animations = a), (Wi = Wi.children[0])),
            (Wi.animations = a);
        }
        parseModels(e, t, i) {
          const r = new Map(),
            s = Ct.Objects.Model;
          for (const o in s) {
            const a = parseInt(o),
              l = s[o],
              c = Rn.get(a);
            let u = this.buildSkeleton(c, e, a, l.attrName);
            if (!u) {
              switch (l.attrType) {
                case "Camera":
                  u = this.createCamera(c);
                  break;
                case "Light":
                  u = this.createLight(c);
                  break;
                case "Mesh":
                  u = this.createMesh(c, t, i);
                  break;
                case "NurbsCurve":
                  u = this.createCurve(c, t);
                  break;
                case "LimbNode":
                case "Root":
                  u = new oh();
                  break;
                default:
                  u = new Es();
              }
              (u.name = l.attrName ? Wt.sanitizeNodeName(l.attrName) : ""),
                (u.ID = a);
            }
            this.getTransformData(u, l), r.set(a, u);
          }
          return r;
        }
        buildSkeleton(e, t, i, r) {
          let s = null;
          return (
            e.parents.forEach(function (o) {
              for (const a in t) {
                const l = t[a];
                l.rawBones.forEach(function (c, u) {
                  if (c.ID === o.ID) {
                    const d = s;
                    (s = new oh()),
                      s.matrixWorld.copy(c.transformLink),
                      (s.name = r ? Wt.sanitizeNodeName(r) : ""),
                      (s.ID = i),
                      (l.bones[u] = s),
                      null !== d && s.add(d);
                  }
                });
              }
            }),
            s
          );
        }
        createCamera(e) {
          let t, i;
          if (
            (e.children.forEach(function (r) {
              const s = Ct.Objects.NodeAttribute[r.ID];
              void 0 !== s && (i = s);
            }),
            void 0 === i)
          )
            t = new Dn();
          else {
            let r = 0;
            void 0 !== i.CameraProjectionType &&
              1 === i.CameraProjectionType.value &&
              (r = 1);
            let s = 1;
            void 0 !== i.NearPlane && (s = i.NearPlane.value / 1e3);
            let o = 1e3;
            void 0 !== i.FarPlane && (o = i.FarPlane.value / 1e3);
            let a = window.innerWidth,
              l = window.innerHeight;
            void 0 !== i.AspectWidth &&
              void 0 !== i.AspectHeight &&
              ((a = i.AspectWidth.value), (l = i.AspectHeight.value));
            const c = a / l;
            let u = 45;
            void 0 !== i.FieldOfView && (u = i.FieldOfView.value);
            const d = i.FocalLength ? i.FocalLength.value : null;
            switch (r) {
              case 0:
                (t = new Wn(u, c, s, o)), null !== d && t.setFocalLength(d);
                break;
              case 1:
                t = new Hc(-a / 2, a / 2, l / 2, -l / 2, s, o);
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown camera type " + r + "."),
                  (t = new Dn());
            }
          }
          return t;
        }
        createLight(e) {
          let t, i;
          if (
            (e.children.forEach(function (r) {
              const s = Ct.Objects.NodeAttribute[r.ID];
              void 0 !== s && (i = s);
            }),
            void 0 === i)
          )
            t = new Dn();
          else {
            let r;
            r = void 0 === i.LightType ? 0 : i.LightType.value;
            let s = 16777215;
            void 0 !== i.Color &&
              (s = new de().fromArray(i.Color.value).convertSRGBToLinear());
            let o = void 0 === i.Intensity ? 1 : i.Intensity.value / 100;
            void 0 !== i.CastLightOnObject &&
              0 === i.CastLightOnObject.value &&
              (o = 0);
            let a = 0;
            void 0 !== i.FarAttenuationEnd &&
              (a =
                void 0 !== i.EnableFarAttenuation &&
                0 === i.EnableFarAttenuation.value
                  ? 0
                  : i.FarAttenuationEnd.value);
            const l = 1;
            switch (r) {
              case 0:
                t = new rg(s, o, a, l);
                break;
              case 1:
                t = new su(s, o);
                break;
              case 2:
                let c = Math.PI / 3;
                void 0 !== i.InnerAngle &&
                  (c = $r.degToRad(i.InnerAngle.value));
                let u = 0;
                void 0 !== i.OuterAngle &&
                  ((u = $r.degToRad(i.OuterAngle.value)), (u = Math.max(u, 1))),
                  (t = new Nx(s, o, a, c, u, l));
                break;
              default:
                console.warn(
                  "THREE.FBXLoader: Unknown light type " +
                    i.LightType.value +
                    ", defaulting to a PointLight."
                ),
                  (t = new rg(s, o));
            }
            void 0 !== i.CastShadows &&
              1 === i.CastShadows.value &&
              (t.castShadow = !0);
          }
          return t;
        }
        createMesh(e, t, i) {
          let r,
            s = null,
            o = null;
          const a = [];
          return (
            e.children.forEach(function (l) {
              t.has(l.ID) && (s = t.get(l.ID)),
                i.has(l.ID) && a.push(i.get(l.ID));
            }),
            a.length > 1
              ? (o = a)
              : a.length > 0
              ? (o = a[0])
              : ((o = new tg({
                  name: po.DEFAULT_MATERIAL_NAME,
                  color: 13421772,
                })),
                a.push(o)),
            "color" in s.attributes &&
              a.forEach(function (l) {
                l.vertexColors = !0;
              }),
            s.FBX_Deformer
              ? ((r = new rx(s, o)), r.normalizeSkinWeights())
              : (r = new Kn(s, o)),
            r
          );
        }
        createCurve(e, t) {
          const i = e.children.reduce(function (s, o) {
              return t.has(o.ID) && (s = t.get(o.ID)), s;
            }, null),
            r = new Ri({
              name: po.DEFAULT_MATERIAL_NAME,
              color: 3342591,
              linewidth: 1,
            });
          return new zo(i, r);
        }
        getTransformData(e, t) {
          const i = {};
          "InheritType" in t && (i.inheritType = parseInt(t.InheritType.value)),
            (i.eulerOrder =
              "RotationOrder" in t ? JL(t.RotationOrder.value) : "ZYX"),
            "Lcl_Translation" in t && (i.translation = t.Lcl_Translation.value),
            "PreRotation" in t && (i.preRotation = t.PreRotation.value),
            "Lcl_Rotation" in t && (i.rotation = t.Lcl_Rotation.value),
            "PostRotation" in t && (i.postRotation = t.PostRotation.value),
            "Lcl_Scaling" in t && (i.scale = t.Lcl_Scaling.value),
            "ScalingOffset" in t && (i.scalingOffset = t.ScalingOffset.value),
            "ScalingPivot" in t && (i.scalingPivot = t.ScalingPivot.value),
            "RotationOffset" in t &&
              (i.rotationOffset = t.RotationOffset.value),
            "RotationPivot" in t && (i.rotationPivot = t.RotationPivot.value),
            (e.userData.transformData = i);
        }
        setLookAtProperties(e, t) {
          "LookAtProperty" in t &&
            Rn.get(e.ID).children.forEach(function (r) {
              if ("LookAtProperty" === r.relationship) {
                const s = Ct.Objects.Model[r.ID];
                if ("Lcl_Translation" in s) {
                  const o = s.Lcl_Translation.value;
                  void 0 !== e.target
                    ? (e.target.position.fromArray(o), Wi.add(e.target))
                    : e.lookAt(new A().fromArray(o));
                }
              }
            });
        }
        bindSkeleton(e, t, i) {
          const r = this.parsePoseNodes();
          for (const s in e) {
            const o = e[s];
            Rn.get(parseInt(o.ID)).parents.forEach(function (l) {
              t.has(l.ID) &&
                Rn.get(l.ID).parents.forEach(function (d) {
                  i.has(d.ID) && i.get(d.ID).bind(new lh(o.bones), r[d.ID]);
                });
            });
          }
        }
        parsePoseNodes() {
          const e = {};
          if ("Pose" in Ct.Objects) {
            const t = Ct.Objects.Pose;
            for (const i in t)
              if ("BindPose" === t[i].attrType && t[i].NbPoseNodes > 0) {
                const r = t[i].PoseNode;
                Array.isArray(r)
                  ? r.forEach(function (s) {
                      e[s.Node] = new Ae().fromArray(s.Matrix.a);
                    })
                  : (e[r.Node] = new Ae().fromArray(r.Matrix.a));
              }
          }
          return e;
        }
        createAmbientLight() {
          if ("GlobalSettings" in Ct && "AmbientColor" in Ct.GlobalSettings) {
            const e = Ct.GlobalSettings.AmbientColor.value,
              t = e[0],
              i = e[1],
              r = e[2];
            if (0 !== t || 0 !== i || 0 !== r) {
              const s = new de(t, i, r).convertSRGBToLinear();
              Wi.add(new Bx(s, 1));
            }
          }
        }
      }
      class FQ {
        constructor() {
          this.negativeMaterialIndices = !1;
        }
        parse(e) {
          const t = new Map();
          if ("Geometry" in Ct.Objects) {
            const i = Ct.Objects.Geometry;
            for (const r in i) {
              const s = Rn.get(parseInt(r)),
                o = this.parseGeometry(s, i[r], e);
              t.set(parseInt(r), o);
            }
          }
          return (
            !0 === this.negativeMaterialIndices &&
              console.warn(
                "THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."
              ),
            t
          );
        }
        parseGeometry(e, t, i) {
          switch (t.attrType) {
            case "Mesh":
              return this.parseMeshGeometry(e, t, i);
            case "NurbsCurve":
              return this.parseNurbsGeometry(t);
          }
        }
        parseMeshGeometry(e, t, i) {
          const r = i.skeletons,
            s = [],
            o = e.parents.map(function (d) {
              return Ct.Objects.Model[d.ID];
            });
          if (0 === o.length) return;
          const a = e.children.reduce(function (d, h) {
            return void 0 !== r[h.ID] && (d = r[h.ID]), d;
          }, null);
          e.children.forEach(function (d) {
            void 0 !== i.morphTargets[d.ID] && s.push(i.morphTargets[d.ID]);
          });
          const l = o[0],
            c = {};
          "RotationOrder" in l && (c.eulerOrder = JL(l.RotationOrder.value)),
            "InheritType" in l &&
              (c.inheritType = parseInt(l.InheritType.value)),
            "GeometricTranslation" in l &&
              (c.translation = l.GeometricTranslation.value),
            "GeometricRotation" in l &&
              (c.rotation = l.GeometricRotation.value),
            "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
          const u = QL(c);
          return this.genGeometry(t, a, s, u);
        }
        genGeometry(e, t, i, r) {
          const s = new ut();
          e.attrName && (s.name = e.attrName);
          const o = this.parseGeoNode(e, t),
            a = this.genBuffers(o),
            l = new Ie(a.vertex, 3);
          if (
            (l.applyMatrix4(r),
            s.setAttribute("position", l),
            a.colors.length > 0 && s.setAttribute("color", new Ie(a.colors, 3)),
            t &&
              (s.setAttribute("skinIndex", new Ub(a.weightsIndices, 4)),
              s.setAttribute("skinWeight", new Ie(a.vertexWeights, 4)),
              (s.FBX_Deformer = t)),
            a.normal.length > 0)
          ) {
            const c = new vt().getNormalMatrix(r),
              u = new Ie(a.normal, 3);
            u.applyNormalMatrix(c), s.setAttribute("normal", u);
          }
          if (
            (a.uvs.forEach(function (c, u) {
              s.setAttribute(0 === u ? "uv" : `uv${u}`, new Ie(a.uvs[u], 2));
            }),
            o.material && "AllSame" !== o.material.mappingType)
          ) {
            let c = a.materialIndex[0],
              u = 0;
            if (
              (a.materialIndex.forEach(function (d, h) {
                d !== c && (s.addGroup(u, h - u, c), (c = d), (u = h));
              }),
              s.groups.length > 0)
            ) {
              const d = s.groups[s.groups.length - 1],
                h = d.start + d.count;
              h !== a.materialIndex.length &&
                s.addGroup(h, a.materialIndex.length - h, c);
            }
            0 === s.groups.length &&
              s.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
          }
          return this.addMorphTargets(s, e, i, r), s;
        }
        parseGeoNode(e, t) {
          const i = {};
          if (
            ((i.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : []),
            (i.vertexIndices =
              void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : []),
            e.LayerElementColor &&
              (i.color = this.parseVertexColors(e.LayerElementColor[0])),
            e.LayerElementMaterial &&
              (i.material = this.parseMaterialIndices(
                e.LayerElementMaterial[0]
              )),
            e.LayerElementNormal &&
              (i.normal = this.parseNormals(e.LayerElementNormal[0])),
            e.LayerElementUV)
          ) {
            i.uv = [];
            let r = 0;
            for (; e.LayerElementUV[r]; )
              e.LayerElementUV[r].UV &&
                i.uv.push(this.parseUVs(e.LayerElementUV[r])),
                r++;
          }
          return (
            (i.weightTable = {}),
            null !== t &&
              ((i.skeleton = t),
              t.rawBones.forEach(function (r, s) {
                r.indices.forEach(function (o, a) {
                  void 0 === i.weightTable[o] && (i.weightTable[o] = []),
                    i.weightTable[o].push({ id: s, weight: r.weights[a] });
                });
              })),
            i
          );
        }
        genBuffers(e) {
          const t = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: [],
          };
          let i = 0,
            r = 0,
            s = !1,
            o = [],
            a = [],
            l = [],
            c = [],
            u = [],
            d = [];
          const h = this;
          return (
            e.vertexIndices.forEach(function (f, p) {
              let _,
                m = !1;
              f < 0 && ((f ^= -1), (m = !0));
              let g = [],
                y = [];
              if ((o.push(3 * f, 3 * f + 1, 3 * f + 2), e.color)) {
                const v = Ig(p, i, f, e.color);
                l.push(v[0], v[1], v[2]);
              }
              if (e.skeleton) {
                if (
                  (void 0 !== e.weightTable[f] &&
                    e.weightTable[f].forEach(function (v) {
                      y.push(v.weight), g.push(v.id);
                    }),
                  y.length > 4)
                ) {
                  s ||
                    (console.warn(
                      "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
                    ),
                    (s = !0));
                  const v = [0, 0, 0, 0],
                    b = [0, 0, 0, 0];
                  y.forEach(function (x, M) {
                    let S = x,
                      C = g[M];
                    b.forEach(function (w, E, V) {
                      if (S > w) {
                        (V[E] = S), (S = w);
                        const j = v[E];
                        (v[E] = C), (C = j);
                      }
                    });
                  }),
                    (g = v),
                    (y = b);
                }
                for (; y.length < 4; ) y.push(0), g.push(0);
                for (let v = 0; v < 4; ++v) u.push(y[v]), d.push(g[v]);
              }
              if (e.normal) {
                const v = Ig(p, i, f, e.normal);
                a.push(v[0], v[1], v[2]);
              }
              e.material &&
                "AllSame" !== e.material.mappingType &&
                ((_ = Ig(p, i, f, e.material)[0]),
                _ < 0 && ((h.negativeMaterialIndices = !0), (_ = 0))),
                e.uv &&
                  e.uv.forEach(function (v, b) {
                    const x = Ig(p, i, f, v);
                    void 0 === c[b] && (c[b] = []),
                      c[b].push(x[0]),
                      c[b].push(x[1]);
                  }),
                r++,
                m &&
                  (r > 4 &&
                    console.warn(
                      "THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."
                    ),
                  h.genFace(t, e, o, _, a, l, c, u, d, r),
                  i++,
                  (r = 0),
                  (o = []),
                  (a = []),
                  (l = []),
                  (c = []),
                  (u = []),
                  (d = []));
            }),
            t
          );
        }
        genFace(e, t, i, r, s, o, a, l, c, u) {
          for (let d = 2; d < u; d++)
            e.vertex.push(t.vertexPositions[i[0]]),
              e.vertex.push(t.vertexPositions[i[1]]),
              e.vertex.push(t.vertexPositions[i[2]]),
              e.vertex.push(t.vertexPositions[i[3 * (d - 1)]]),
              e.vertex.push(t.vertexPositions[i[3 * (d - 1) + 1]]),
              e.vertex.push(t.vertexPositions[i[3 * (d - 1) + 2]]),
              e.vertex.push(t.vertexPositions[i[3 * d]]),
              e.vertex.push(t.vertexPositions[i[3 * d + 1]]),
              e.vertex.push(t.vertexPositions[i[3 * d + 2]]),
              t.skeleton &&
                (e.vertexWeights.push(l[0]),
                e.vertexWeights.push(l[1]),
                e.vertexWeights.push(l[2]),
                e.vertexWeights.push(l[3]),
                e.vertexWeights.push(l[4 * (d - 1)]),
                e.vertexWeights.push(l[4 * (d - 1) + 1]),
                e.vertexWeights.push(l[4 * (d - 1) + 2]),
                e.vertexWeights.push(l[4 * (d - 1) + 3]),
                e.vertexWeights.push(l[4 * d]),
                e.vertexWeights.push(l[4 * d + 1]),
                e.vertexWeights.push(l[4 * d + 2]),
                e.vertexWeights.push(l[4 * d + 3]),
                e.weightsIndices.push(c[0]),
                e.weightsIndices.push(c[1]),
                e.weightsIndices.push(c[2]),
                e.weightsIndices.push(c[3]),
                e.weightsIndices.push(c[4 * (d - 1)]),
                e.weightsIndices.push(c[4 * (d - 1) + 1]),
                e.weightsIndices.push(c[4 * (d - 1) + 2]),
                e.weightsIndices.push(c[4 * (d - 1) + 3]),
                e.weightsIndices.push(c[4 * d]),
                e.weightsIndices.push(c[4 * d + 1]),
                e.weightsIndices.push(c[4 * d + 2]),
                e.weightsIndices.push(c[4 * d + 3])),
              t.color &&
                (e.colors.push(o[0]),
                e.colors.push(o[1]),
                e.colors.push(o[2]),
                e.colors.push(o[3 * (d - 1)]),
                e.colors.push(o[3 * (d - 1) + 1]),
                e.colors.push(o[3 * (d - 1) + 2]),
                e.colors.push(o[3 * d]),
                e.colors.push(o[3 * d + 1]),
                e.colors.push(o[3 * d + 2])),
              t.material &&
                "AllSame" !== t.material.mappingType &&
                (e.materialIndex.push(r),
                e.materialIndex.push(r),
                e.materialIndex.push(r)),
              t.normal &&
                (e.normal.push(s[0]),
                e.normal.push(s[1]),
                e.normal.push(s[2]),
                e.normal.push(s[3 * (d - 1)]),
                e.normal.push(s[3 * (d - 1) + 1]),
                e.normal.push(s[3 * (d - 1) + 2]),
                e.normal.push(s[3 * d]),
                e.normal.push(s[3 * d + 1]),
                e.normal.push(s[3 * d + 2])),
              t.uv &&
                t.uv.forEach(function (h, f) {
                  void 0 === e.uvs[f] && (e.uvs[f] = []),
                    e.uvs[f].push(a[f][0]),
                    e.uvs[f].push(a[f][1]),
                    e.uvs[f].push(a[f][2 * (d - 1)]),
                    e.uvs[f].push(a[f][2 * (d - 1) + 1]),
                    e.uvs[f].push(a[f][2 * d]),
                    e.uvs[f].push(a[f][2 * d + 1]);
                });
        }
        addMorphTargets(e, t, i, r) {
          if (0 === i.length) return;
          (e.morphTargetsRelative = !0), (e.morphAttributes.position = []);
          const s = this;
          i.forEach(function (o) {
            o.rawTargets.forEach(function (a) {
              const l = Ct.Objects.Geometry[a.geoID];
              void 0 !== l && s.genMorphGeometry(e, t, l, r, a.name);
            });
          });
        }
        genMorphGeometry(e, t, i, r, s) {
          const o =
              void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
            a = void 0 !== i.Vertices ? i.Vertices.a : [],
            l = void 0 !== i.Indexes ? i.Indexes.a : [],
            u = new Float32Array(3 * e.attributes.position.count);
          for (let p = 0; p < l.length; p++) {
            const _ = 3 * l[p];
            (u[_] = a[3 * p]),
              (u[_ + 1] = a[3 * p + 1]),
              (u[_ + 2] = a[3 * p + 2]);
          }
          const h = this.genBuffers({ vertexIndices: o, vertexPositions: u }),
            f = new Ie(h.vertex, 3);
          (f.name = s || i.attrName),
            f.applyMatrix4(r),
            e.morphAttributes.position.push(f);
        }
        parseNormals(e) {
          const i = e.ReferenceInformationType;
          let s = [];
          return (
            "IndexToDirect" === i &&
              ("NormalIndex" in e
                ? (s = e.NormalIndex.a)
                : "NormalsIndex" in e && (s = e.NormalsIndex.a)),
            {
              dataSize: 3,
              buffer: e.Normals.a,
              indices: s,
              mappingType: e.MappingInformationType,
              referenceType: i,
            }
          );
        }
        parseUVs(e) {
          const i = e.ReferenceInformationType;
          let s = [];
          return (
            "IndexToDirect" === i && (s = e.UVIndex.a),
            {
              dataSize: 2,
              buffer: e.UV.a,
              indices: s,
              mappingType: e.MappingInformationType,
              referenceType: i,
            }
          );
        }
        parseVertexColors(e) {
          const t = e.MappingInformationType,
            i = e.ReferenceInformationType,
            r = e.Colors.a;
          let s = [];
          "IndexToDirect" === i && (s = e.ColorIndex.a);
          for (let o = 0, a = new de(); o < r.length; o += 4)
            a.fromArray(r, o).convertSRGBToLinear().toArray(r, o);
          return {
            dataSize: 4,
            buffer: r,
            indices: s,
            mappingType: t,
            referenceType: i,
          };
        }
        parseMaterialIndices(e) {
          const t = e.MappingInformationType,
            i = e.ReferenceInformationType;
          if ("NoMappingInformation" === t)
            return {
              dataSize: 1,
              buffer: [0],
              indices: [0],
              mappingType: "AllSame",
              referenceType: i,
            };
          const r = e.Materials.a,
            s = [];
          for (let o = 0; o < r.length; ++o) s.push(o);
          return {
            dataSize: 1,
            buffer: r,
            indices: s,
            mappingType: t,
            referenceType: i,
          };
        }
        parseNurbsGeometry(e) {
          const t = parseInt(e.Order);
          if (isNaN(t))
            return (
              console.error(
                "THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",
                e.Order,
                e.id
              ),
              new ut()
            );
          const i = t - 1,
            r = e.KnotVector.a,
            s = [],
            o = e.Points.a;
          for (let d = 0, h = o.length; d < h; d += 4)
            s.push(new Ft().fromArray(o, d));
          let a, l;
          if ("Closed" === e.Form) s.push(s[0]);
          else if ("Periodic" === e.Form) {
            (a = i), (l = r.length - 1 - a);
            for (let d = 0; d < i; ++d) s.push(s[d]);
          }
          const u = new PQ(i, r, s, a, l).getPoints(12 * s.length);
          return new ut().setFromPoints(u);
        }
      }
      class NQ {
        parse() {
          const e = [],
            t = this.parseClips();
          if (void 0 !== t)
            for (const i in t) {
              const s = this.addClip(t[i]);
              e.push(s);
            }
          return e;
        }
        parseClips() {
          if (void 0 === Ct.Objects.AnimationCurve) return;
          const e = this.parseAnimationCurveNodes();
          this.parseAnimationCurves(e);
          const t = this.parseAnimationLayers(e);
          return this.parseAnimStacks(t);
        }
        parseAnimationCurveNodes() {
          const e = Ct.Objects.AnimationCurveNode,
            t = new Map();
          for (const i in e) {
            const r = e[i];
            if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
              const s = { id: r.id, attr: r.attrName, curves: {} };
              t.set(s.id, s);
            }
          }
          return t;
        }
        parseAnimationCurves(e) {
          const t = Ct.Objects.AnimationCurve;
          for (const i in t) {
            const r = {
                id: t[i].id,
                times: t[i].KeyTime.a.map(zQ),
                values: t[i].KeyValueFloat.a,
              },
              s = Rn.get(r.id);
            if (void 0 !== s) {
              const o = s.parents[0].ID,
                a = s.parents[0].relationship;
              a.match(/X/)
                ? (e.get(o).curves.x = r)
                : a.match(/Y/)
                ? (e.get(o).curves.y = r)
                : a.match(/Z/)
                ? (e.get(o).curves.z = r)
                : a.match(/DeformPercent/) &&
                  e.has(o) &&
                  (e.get(o).curves.morph = r);
            }
          }
        }
        parseAnimationLayers(e) {
          const t = Ct.Objects.AnimationLayer,
            i = new Map();
          for (const r in t) {
            const s = [],
              o = Rn.get(parseInt(r));
            void 0 !== o &&
              (o.children.forEach(function (l, c) {
                if (e.has(l.ID)) {
                  const u = e.get(l.ID);
                  if (
                    void 0 !== u.curves.x ||
                    void 0 !== u.curves.y ||
                    void 0 !== u.curves.z
                  ) {
                    if (void 0 === s[c]) {
                      const d = Rn.get(l.ID).parents.filter(function (h) {
                        return void 0 !== h.relationship;
                      })[0].ID;
                      if (void 0 !== d) {
                        const h = Ct.Objects.Model[d.toString()];
                        if (void 0 === h)
                          return void console.warn(
                            "THREE.FBXLoader: Encountered a unused curve.",
                            l
                          );
                        const f = {
                          modelName: h.attrName
                            ? Wt.sanitizeNodeName(h.attrName)
                            : "",
                          ID: h.id,
                          initialPosition: [0, 0, 0],
                          initialRotation: [0, 0, 0],
                          initialScale: [1, 1, 1],
                        };
                        Wi.traverse(function (p) {
                          p.ID === h.id &&
                            ((f.transform = p.matrix),
                            p.userData.transformData &&
                              (f.eulerOrder =
                                p.userData.transformData.eulerOrder));
                        }),
                          f.transform || (f.transform = new Ae()),
                          "PreRotation" in h &&
                            (f.preRotation = h.PreRotation.value),
                          "PostRotation" in h &&
                            (f.postRotation = h.PostRotation.value),
                          (s[c] = f);
                      }
                    }
                    s[c] && (s[c][u.attr] = u);
                  } else if (void 0 !== u.curves.morph) {
                    if (void 0 === s[c]) {
                      const d = Rn.get(l.ID).parents.filter(function (g) {
                          return void 0 !== g.relationship;
                        })[0].ID,
                        h = Rn.get(d).parents[0].ID,
                        f = Rn.get(h).parents[0].ID,
                        p = Rn.get(f).parents[0].ID,
                        _ = Ct.Objects.Model[p],
                        m = {
                          modelName: _.attrName
                            ? Wt.sanitizeNodeName(_.attrName)
                            : "",
                          morphName: Ct.Objects.Deformer[d].attrName,
                        };
                      s[c] = m;
                    }
                    s[c][u.attr] = u;
                  }
                }
              }),
              i.set(parseInt(r), s));
          }
          return i;
        }
        parseAnimStacks(e) {
          const t = Ct.Objects.AnimationStack,
            i = {};
          for (const r in t) {
            const s = Rn.get(parseInt(r)).children;
            s.length > 1 &&
              console.warn(
                "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
              );
            const o = e.get(s[0].ID);
            i[r] = { name: t[r].attrName, layer: o };
          }
          return i;
        }
        addClip(e) {
          let t = [];
          const i = this;
          return (
            e.layer.forEach(function (r) {
              t = t.concat(i.generateTracks(r));
            }),
            new iu(e.name, -1, t)
          );
        }
        generateTracks(e) {
          const t = [];
          let i = new A(),
            r = new An(),
            s = new A();
          if (
            (e.transform && e.transform.decompose(i, r, s),
            (i = i.toArray()),
            (r = new oo().setFromQuaternion(r, e.eulerOrder).toArray()),
            (s = s.toArray()),
            void 0 !== e.T && Object.keys(e.T.curves).length > 0)
          ) {
            const o = this.generateVectorTrack(
              e.modelName,
              e.T.curves,
              i,
              "position"
            );
            void 0 !== o && t.push(o);
          }
          if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
            const o = this.generateRotationTrack(
              e.modelName,
              e.R.curves,
              r,
              e.preRotation,
              e.postRotation,
              e.eulerOrder
            );
            void 0 !== o && t.push(o);
          }
          if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
            const o = this.generateVectorTrack(
              e.modelName,
              e.S.curves,
              s,
              "scale"
            );
            void 0 !== o && t.push(o);
          }
          if (void 0 !== e.DeformPercent) {
            const o = this.generateMorphTrack(e);
            void 0 !== o && t.push(o);
          }
          return t;
        }
        generateVectorTrack(e, t, i, r) {
          const s = this.getTimesForAllAxes(t),
            o = this.getKeyframeTrackValues(s, t, i);
          return new nu(e + "." + r, s, o);
        }
        generateRotationTrack(e, t, i, r, s, o) {
          void 0 !== t.x &&
            (this.interpolateRotations(t.x),
            (t.x.values = t.x.values.map($r.degToRad))),
            void 0 !== t.y &&
              (this.interpolateRotations(t.y),
              (t.y.values = t.y.values.map($r.degToRad))),
            void 0 !== t.z &&
              (this.interpolateRotations(t.z),
              (t.z.values = t.z.values.map($r.degToRad)));
          const a = this.getTimesForAllAxes(t),
            l = this.getKeyframeTrackValues(a, t, i);
          void 0 !== r &&
            ((r = r.map($r.degToRad)).push(o),
            (r = new oo().fromArray(r)),
            (r = new An().setFromEuler(r))),
            void 0 !== s &&
              ((s = s.map($r.degToRad)).push(o),
              (s = new oo().fromArray(s)),
              (s = new An().setFromEuler(s).invert()));
          const c = new An(),
            u = new oo(),
            d = [];
          for (let h = 0; h < l.length; h += 3)
            u.set(l[h], l[h + 1], l[h + 2], o),
              c.setFromEuler(u),
              void 0 !== r && c.premultiply(r),
              void 0 !== s && c.multiply(s),
              c.toArray(d, (h / 3) * 4);
          return new Ho(e + ".quaternion", a, d);
        }
        generateMorphTrack(e) {
          const t = e.DeformPercent.curves.morph,
            i = t.values.map(function (s) {
              return s / 100;
            }),
            r = Wi.getObjectByName(e.modelName).morphTargetDictionary[
              e.morphName
            ];
          return new Ga(
            e.modelName + ".morphTargetInfluences[" + r + "]",
            t.times,
            i
          );
        }
        getTimesForAllAxes(e) {
          let t = [];
          if (
            (void 0 !== e.x && (t = t.concat(e.x.times)),
            void 0 !== e.y && (t = t.concat(e.y.times)),
            void 0 !== e.z && (t = t.concat(e.z.times)),
            (t = t.sort(function (i, r) {
              return i - r;
            })),
            t.length > 1)
          ) {
            let i = 1,
              r = t[0];
            for (let s = 1; s < t.length; s++) {
              const o = t[s];
              o !== r && ((t[i] = o), (r = o), i++);
            }
            t = t.slice(0, i);
          }
          return t;
        }
        getKeyframeTrackValues(e, t, i) {
          const r = i,
            s = [];
          let o = -1,
            a = -1,
            l = -1;
          return (
            e.forEach(function (c) {
              if (
                (t.x && (o = t.x.times.indexOf(c)),
                t.y && (a = t.y.times.indexOf(c)),
                t.z && (l = t.z.times.indexOf(c)),
                -1 !== o)
              ) {
                const u = t.x.values[o];
                s.push(u), (r[0] = u);
              } else s.push(r[0]);
              if (-1 !== a) {
                const u = t.y.values[a];
                s.push(u), (r[1] = u);
              } else s.push(r[1]);
              if (-1 !== l) {
                const u = t.z.values[l];
                s.push(u), (r[2] = u);
              } else s.push(r[2]);
            }),
            s
          );
        }
        interpolateRotations(e) {
          for (let t = 1; t < e.values.length; t++) {
            const i = e.values[t - 1],
              r = e.values[t] - i,
              s = Math.abs(r);
            if (s >= 180) {
              const o = s / 180,
                a = r / o;
              let l = i + a;
              const c = e.times[t - 1],
                d = (e.times[t] - c) / o;
              let h = c + d;
              const f = [],
                p = [];
              for (; h < e.times[t]; ) f.push(h), (h += d), p.push(l), (l += a);
              (e.times = tF(e.times, t, f)), (e.values = tF(e.values, t, p));
            }
          }
        }
      }
      class kQ {
        getPrevNode() {
          return this.nodeStack[this.currentIndent - 2];
        }
        getCurrentNode() {
          return this.nodeStack[this.currentIndent - 1];
        }
        getCurrentProp() {
          return this.currentProp;
        }
        pushStack(e) {
          this.nodeStack.push(e), (this.currentIndent += 1);
        }
        popStack() {
          this.nodeStack.pop(), (this.currentIndent -= 1);
        }
        setCurrentProp(e, t) {
          (this.currentProp = e), (this.currentPropName = t);
        }
        parse(e) {
          (this.currentIndent = 0),
            (this.allNodes = new KL()),
            (this.nodeStack = []),
            (this.currentProp = []),
            (this.currentPropName = "");
          const t = this,
            i = e.split(/[\r\n]+/);
          return (
            i.forEach(function (r, s) {
              const o = r.match(/^[\s\t]*;/),
                a = r.match(/^[\s\t]*$/);
              if (o || a) return;
              const l = r.match(
                  "^\\t{" + t.currentIndent + "}(\\w+):(.*){",
                  ""
                ),
                c = r.match(
                  "^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"
                ),
                u = r.match("^\\t{" + (t.currentIndent - 1) + "}}");
              l
                ? t.parseNodeBegin(r, l)
                : c
                ? t.parseNodeProperty(r, c, i[++s])
                : u
                ? t.popStack()
                : r.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(r);
            }),
            this.allNodes
          );
        }
        parseNodeBegin(e, t) {
          const i = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
            r = t[2].split(",").map(function (l) {
              return l.trim().replace(/^"/, "").replace(/"$/, "");
            }),
            s = { name: i },
            o = this.parseNodeAttr(r),
            a = this.getCurrentNode();
          0 === this.currentIndent
            ? this.allNodes.add(i, s)
            : i in a
            ? ("PoseNode" === i
                ? a.PoseNode.push(s)
                : void 0 !== a[i].id && ((a[i] = {}), (a[i][a[i].id] = a[i])),
              "" !== o.id && (a[i][o.id] = s))
            : "number" == typeof o.id
            ? ((a[i] = {}), (a[i][o.id] = s))
            : "Properties70" !== i && (a[i] = "PoseNode" === i ? [s] : s),
            "number" == typeof o.id && (s.id = o.id),
            "" !== o.name && (s.attrName = o.name),
            "" !== o.type && (s.attrType = o.type),
            this.pushStack(s);
        }
        parseNodeAttr(e) {
          let t = e[0];
          "" !== e[0] && ((t = parseInt(e[0])), isNaN(t) && (t = e[0]));
          let i = "",
            r = "";
          return (
            e.length > 1 && ((i = e[1].replace(/^(\w+)::/, "")), (r = e[2])),
            { id: t, name: i, type: r }
          );
        }
        parseNodeProperty(e, t, i) {
          let r = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
            s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
          "Content" === r &&
            "," === s &&
            (s = i.replace(/"/g, "").replace(/,$/, "").trim());
          const o = this.getCurrentNode();
          if ("Properties70" !== o.name) {
            if ("C" === r) {
              const l = s.split(",").slice(1),
                c = parseInt(l[0]),
                u = parseInt(l[1]);
              let d = s.split(",").slice(3);
              (d = d.map(function (h) {
                return h.trim().replace(/^"/, "");
              })),
                (r = "connections"),
                (s = [c, u]),
                (function GQ(n, e) {
                  for (let t = 0, i = n.length, r = e.length; t < r; t++, i++)
                    n[i] = e[t];
                })(s, d),
                void 0 === o[r] && (o[r] = []);
            }
            "Node" === r && (o.id = s),
              r in o && Array.isArray(o[r])
                ? o[r].push(s)
                : "a" !== r
                ? (o[r] = s)
                : (o.a = s),
              this.setCurrentProp(o, r),
              "a" === r && "," !== s.slice(-1) && (o.a = vw(s));
          } else this.parseNodeSpecialProperty(e, r, s);
        }
        parseNodePropertyContinued(e) {
          const t = this.getCurrentNode();
          (t.a += e), "," !== e.slice(-1) && (t.a = vw(t.a));
        }
        parseNodeSpecialProperty(e, t, i) {
          const r = i.split('",').map(function (u) {
              return u.trim().replace(/^\"/, "").replace(/\s/, "_");
            }),
            s = r[0],
            o = r[1],
            a = r[2],
            l = r[3];
          let c = r[4];
          switch (o) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
              c = parseFloat(c);
              break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
              c = vw(c);
          }
          (this.getPrevNode()[s] = { type: o, type2: a, flag: l, value: c }),
            this.setCurrentProp(this.getPrevNode(), s);
        }
      }
      class BQ {
        parse(e) {
          const t = new ZL(e);
          t.skip(23);
          const i = t.getUint32();
          if (i < 6400)
            throw new Error(
              "THREE.FBXLoader: FBX version not supported, FileVersion: " + i
            );
          const r = new KL();
          for (; !this.endOfContent(t); ) {
            const s = this.parseNode(t, i);
            null !== s && r.add(s.name, s);
          }
          return r;
        }
        endOfContent(e) {
          return e.size() % 16 == 0
            ? ((e.getOffset() + 160 + 16) & -16) >= e.size()
            : e.getOffset() + 160 + 16 >= e.size();
        }
        parseNode(e, t) {
          const i = {},
            r = t >= 7500 ? e.getUint64() : e.getUint32(),
            s = t >= 7500 ? e.getUint64() : e.getUint32();
          t >= 7500 ? e.getUint64() : e.getUint32();
          const o = e.getUint8(),
            a = e.getString(o);
          if (0 === r) return null;
          const l = [];
          for (let h = 0; h < s; h++) l.push(this.parseProperty(e));
          const c = l.length > 0 ? l[0] : "",
            u = l.length > 1 ? l[1] : "",
            d = l.length > 2 ? l[2] : "";
          for (
            i.singleProperty = 1 === s && e.getOffset() === r;
            r > e.getOffset();

          ) {
            const h = this.parseNode(e, t);
            null !== h && this.parseSubNode(a, i, h);
          }
          return (
            (i.propertyList = l),
            "number" == typeof c && (i.id = c),
            "" !== u && (i.attrName = u),
            "" !== d && (i.attrType = d),
            "" !== a && (i.name = a),
            i
          );
        }
        parseSubNode(e, t, i) {
          if (!0 === i.singleProperty) {
            const r = i.propertyList[0];
            Array.isArray(r) ? ((t[i.name] = i), (i.a = r)) : (t[i.name] = r);
          } else if ("Connections" === e && "C" === i.name) {
            const r = [];
            i.propertyList.forEach(function (s, o) {
              0 !== o && r.push(s);
            }),
              void 0 === t.connections && (t.connections = []),
              t.connections.push(r);
          } else if ("Properties70" === i.name)
            Object.keys(i).forEach(function (s) {
              t[s] = i[s];
            });
          else if ("Properties70" === e && "P" === i.name) {
            let r = i.propertyList[0],
              s = i.propertyList[1];
            const o = i.propertyList[2],
              a = i.propertyList[3];
            let l;
            0 === r.indexOf("Lcl ") && (r = r.replace("Lcl ", "Lcl_")),
              0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")),
              (l =
                "Color" === s ||
                "ColorRGB" === s ||
                "Vector" === s ||
                "Vector3D" === s ||
                0 === s.indexOf("Lcl_")
                  ? [i.propertyList[4], i.propertyList[5], i.propertyList[6]]
                  : i.propertyList[4]),
              (t[r] = { type: s, type2: o, flag: a, value: l });
          } else
            void 0 === t[i.name]
              ? "number" == typeof i.id
                ? ((t[i.name] = {}), (t[i.name][i.id] = i))
                : (t[i.name] = i)
              : "PoseNode" === i.name
              ? (Array.isArray(t[i.name]) || (t[i.name] = [t[i.name]]),
                t[i.name].push(i))
              : void 0 === t[i.name][i.id] && (t[i.name][i.id] = i);
        }
        parseProperty(e) {
          const t = e.getString(1);
          let i;
          switch (t) {
            case "C":
              return e.getBoolean();
            case "D":
              return e.getFloat64();
            case "F":
              return e.getFloat32();
            case "I":
              return e.getInt32();
            case "L":
              return e.getInt64();
            case "R":
              return (i = e.getUint32()), e.getArrayBuffer(i);
            case "S":
              return (i = e.getUint32()), e.getString(i);
            case "Y":
              return e.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
              const r = e.getUint32(),
                s = e.getUint32(),
                o = e.getUint32();
              if (0 === s)
                switch (t) {
                  case "b":
                  case "c":
                    return e.getBooleanArray(r);
                  case "d":
                    return e.getFloat64Array(r);
                  case "f":
                    return e.getFloat32Array(r);
                  case "i":
                    return e.getInt32Array(r);
                  case "l":
                    return e.getInt64Array(r);
                }
              const a = (function Cg(n, e) {
                  return _g((zL(n), n.subarray(2, -4)), e);
                })(new Uint8Array(e.getArrayBuffer(o))),
                l = new ZL(a.buffer);
              switch (t) {
                case "b":
                case "c":
                  return l.getBooleanArray(r);
                case "d":
                  return l.getFloat64Array(r);
                case "f":
                  return l.getFloat32Array(r);
                case "i":
                  return l.getInt32Array(r);
                case "l":
                  return l.getInt64Array(r);
              }
              break;
            default:
              throw new Error("THREE.FBXLoader: Unknown property type " + t);
          }
        }
      }
      class ZL {
        constructor(e, t) {
          (this.dv = new DataView(e)),
            (this.offset = 0),
            (this.littleEndian = void 0 === t || t),
            (this._textDecoder = new TextDecoder());
        }
        getOffset() {
          return this.offset;
        }
        size() {
          return this.dv.buffer.byteLength;
        }
        skip(e) {
          this.offset += e;
        }
        getBoolean() {
          return 1 == (1 & this.getUint8());
        }
        getBooleanArray(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getBoolean());
          return t;
        }
        getUint8() {
          const e = this.dv.getUint8(this.offset);
          return (this.offset += 1), e;
        }
        getInt16() {
          const e = this.dv.getInt16(this.offset, this.littleEndian);
          return (this.offset += 2), e;
        }
        getInt32() {
          const e = this.dv.getInt32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getInt32Array(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getInt32());
          return t;
        }
        getUint32() {
          const e = this.dv.getUint32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getInt64() {
          let e, t;
          return (
            this.littleEndian
              ? ((e = this.getUint32()), (t = this.getUint32()))
              : ((t = this.getUint32()), (e = this.getUint32())),
            2147483648 & t
              ? ((t = 4294967295 & ~t),
                (e = 4294967295 & ~e),
                4294967295 === e && (t = (t + 1) & 4294967295),
                (e = (e + 1) & 4294967295),
                -(4294967296 * t + e))
              : 4294967296 * t + e
          );
        }
        getInt64Array(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getInt64());
          return t;
        }
        getUint64() {
          let e, t;
          return (
            this.littleEndian
              ? ((e = this.getUint32()), (t = this.getUint32()))
              : ((t = this.getUint32()), (e = this.getUint32())),
            4294967296 * t + e
          );
        }
        getFloat32() {
          const e = this.dv.getFloat32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getFloat32Array(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getFloat32());
          return t;
        }
        getFloat64() {
          const e = this.dv.getFloat64(this.offset, this.littleEndian);
          return (this.offset += 8), e;
        }
        getFloat64Array(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getFloat64());
          return t;
        }
        getArrayBuffer(e) {
          const t = this.dv.buffer.slice(this.offset, this.offset + e);
          return (this.offset += e), t;
        }
        getString(e) {
          const t = this.offset;
          let i = new Uint8Array(this.dv.buffer, t, e);
          this.skip(e);
          const r = i.indexOf(0);
          return (
            r >= 0 && (i = new Uint8Array(this.dv.buffer, t, r)),
            this._textDecoder.decode(i)
          );
        }
      }
      class KL {
        add(e, t) {
          this[e] = t;
        }
      }
      function $L(n) {
        const t = n.match(/FBXVersion: (\d+)/);
        if (t) return parseInt(t[1]);
        throw new Error(
          "THREE.FBXLoader: Cannot find the version number for the file given."
        );
      }
      function zQ(n) {
        return n / 46186158e3;
      }
      const HQ = [];
      function Ig(n, e, t, i) {
        let r;
        switch (i.mappingType) {
          case "ByPolygonVertex":
            r = n;
            break;
          case "ByPolygon":
            r = e;
            break;
          case "ByVertice":
            r = t;
            break;
          case "AllSame":
            r = i.indices[0];
            break;
          default:
            console.warn(
              "THREE.FBXLoader: unknown attribute mapping type " + i.mappingType
            );
        }
        "IndexToDirect" === i.referenceType && (r = i.indices[r]);
        const s = r * i.dataSize;
        return (function WQ(n, e, t, i) {
          for (let r = t, s = 0; r < i; r++, s++) n[s] = e[r];
          return n;
        })(HQ, i.buffer, s, s + i.dataSize);
      }
      const _w = new oo(),
        mu = new A();
      function QL(n) {
        const e = new Ae(),
          t = new Ae(),
          i = new Ae(),
          r = new Ae(),
          s = new Ae(),
          o = new Ae(),
          a = new Ae(),
          l = new Ae(),
          c = new Ae(),
          u = new Ae(),
          d = new Ae(),
          h = new Ae(),
          f = n.inheritType ? n.inheritType : 0;
        if (
          (n.translation && e.setPosition(mu.fromArray(n.translation)),
          n.preRotation)
        ) {
          const E = n.preRotation.map($r.degToRad);
          E.push(n.eulerOrder || oo.DEFAULT_ORDER),
            t.makeRotationFromEuler(_w.fromArray(E));
        }
        if (n.rotation) {
          const E = n.rotation.map($r.degToRad);
          E.push(n.eulerOrder || oo.DEFAULT_ORDER),
            i.makeRotationFromEuler(_w.fromArray(E));
        }
        if (n.postRotation) {
          const E = n.postRotation.map($r.degToRad);
          E.push(n.eulerOrder || oo.DEFAULT_ORDER),
            r.makeRotationFromEuler(_w.fromArray(E)),
            r.invert();
        }
        n.scale && s.scale(mu.fromArray(n.scale)),
          n.scalingOffset && a.setPosition(mu.fromArray(n.scalingOffset)),
          n.scalingPivot && o.setPosition(mu.fromArray(n.scalingPivot)),
          n.rotationOffset && l.setPosition(mu.fromArray(n.rotationOffset)),
          n.rotationPivot && c.setPosition(mu.fromArray(n.rotationPivot)),
          n.parentMatrixWorld &&
            (d.copy(n.parentMatrix), u.copy(n.parentMatrixWorld));
        const p = t.clone().multiply(i).multiply(r),
          _ = new Ae();
        _.extractRotation(u);
        const m = new Ae();
        m.copyPosition(u);
        const g = m.clone().invert().multiply(u),
          y = _.clone().invert().multiply(g),
          v = s,
          b = new Ae();
        if (0 === f) b.copy(_).multiply(p).multiply(y).multiply(v);
        else if (1 === f) b.copy(_).multiply(y).multiply(p).multiply(v);
        else {
          const V = new Ae()
              .scale(new A().setFromMatrixScale(d))
              .clone()
              .invert(),
            j = y.clone().multiply(V);
          b.copy(_).multiply(p).multiply(j).multiply(v);
        }
        const x = c.clone().invert(),
          M = o.clone().invert();
        let S = e
          .clone()
          .multiply(l)
          .multiply(c)
          .multiply(t)
          .multiply(i)
          .multiply(r)
          .multiply(x)
          .multiply(a)
          .multiply(o)
          .multiply(s)
          .multiply(M);
        const C = new Ae().copyPosition(S),
          w = u.clone().multiply(C);
        return (
          h.copyPosition(w),
          (S = h.clone().multiply(b)),
          S.premultiply(u.invert()),
          S
        );
      }
      function JL(n) {
        const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
        return 6 === (n = n || 0)
          ? (console.warn(
              "THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."
            ),
            e[0])
          : e[n];
      }
      function vw(n) {
        return n.split(",").map(function (t) {
          return parseFloat(t);
        });
      }
      function eF(n, e, t) {
        return (
          void 0 === e && (e = 0),
          void 0 === t && (t = n.byteLength),
          new TextDecoder().decode(new Uint8Array(n, e, t))
        );
      }
      function tF(n, e, t) {
        return n.slice(0, e).concat(t).concat(n.slice(e));
      }
      class jQ {
        constructor(e) {
          (this.mixers = []),
            (this.actions = []),
            (this.clock = new Vx()),
            (this.domElement = document.querySelector(e)),
            (this.width = this.domElement.clientWidth),
            (this.height = this.domElement.clientHeight),
            this.init();
        }
        init() {
          this.initScene(),
            this.initCamera(),
            this.initRenderer(),
            this.initEffect(),
            this.render();
        }
        initScene() {
          this.scene = new qP();
        }
        initCamera() {
          (this.camera = new Wn(75, this.width / this.height, 0.01, 1e3)),
            this.camera.position.set(0, 0, 10),
            (this.camera.aspect = window.innerWidth / window.innerHeight),
            this.camera.updateProjectionMatrix();
        }
        initRenderer() {
          (this.renderer = new XP({ antialias: !0, alpha: !0 })),
            this.renderer.setSize(this.width, this.height),
            (this.renderer.shadowMap.enabled = !0),
            (this.renderer.outputEncoding = Fo),
            (this.renderer.physicallyCorrectLights = !0),
            (this.renderer.toneMapping = dR),
            (this.renderer.toneMappingExposure = 1),
            this.domElement.appendChild(this.renderer.domElement),
            (this.labelRenderer = new I$()),
            this.labelRenderer.setSize(window.innerWidth, window.innerHeight),
            this.domElement.appendChild(this.labelRenderer.domElement),
            (this.labelRenderer.domElement.style.position = "absolute"),
            (this.labelRenderer.domElement.style.top = "0px"),
            (this.labelRenderer.domElement.style.left = "0px"),
            (this.labelRenderer.domElement.style.zIndex = "10"),
            (this.labelRenderer.domElement.style.pointerEvents = "none");
        }
        initControls() {
          (this.control = new M$(this.camera, this.renderer.domElement)),
            (this.control.minPolarAngle = 0),
            (this.control.maxPolarAngle = (4 * Math.PI) / 9);
        }
        initEffect() {
          this.effectComposer = new T$(this.renderer);
          const e = new A$(this.scene, this.camera);
          this.effectComposer.addPass(e);
          const t = new D$(
            this.domElement.innerWidth,
            this.domElement.innerHeight
          );
          this.effectComposer.addPass(t),
            (this.outlinePass = new Wo(
              new $(window.innerWidth, window.innerHeight),
              this.scene,
              this.camera
            )),
            this.effectComposer.addPass(this.outlinePass),
            (this.outlinePass.edgeStrength = 6),
            (this.outlinePass.edgeGlow = 1),
            (this.outlinePass.edgeThickness = 2),
            (this.outlinePass.pulsePeriod = 3),
            (this.outlinePass.visibleEdgeColor = new de(16724787)),
            (this.outlinePass.hiddenEdgeColor = new de(16777215));
        }
        render() {
          let e = this.clock.getDelta();
          for (let t = 0; t < this.mixers.length; t++)
            this.mixers[t].update(0.2 * e);
          this.effectComposer.render(),
            this.labelRenderer.render(this.scene, this.camera),
            requestAnimationFrame(this.render.bind(this));
        }
        gltfLoad(e) {
          const t = new L$(),
            i = new R$();
          return (
            i.setDecoderPath("assets/draco/"),
            i.setDecoderConfig({ type: "js" }),
            i.preload(),
            t.setDRACOLoader(i),
            new Promise((r, s) => {
              t.load(e, (o) => {
                r(o);
              });
            })
          );
        }
        fbxLoad(e) {
          const t = new OQ();
          return new Promise((i, r) => {
            t.load(e, (s) => {
              i(s);
            });
          });
        }
        setLight() {
          (this.ambientLight = new Bx(16777215, 2)),
            this.scene.add(this.ambientLight);
          const e = new su(16777215, 2);
          e.position.set(0, 10, 10);
          const t = new su(16777215, 2);
          t.position.set(0, 10, -10);
          const i = new su(16777215, 2);
          i.position.set(10, 10, 10),
            (e.castShadow = !0),
            (t.castShadow = !0),
            (i.castShadow = !0),
            (e.shadow.mapSize.width = 10240),
            (e.shadow.mapSize.height = 10240),
            (t.shadow.mapSize.width = 10240),
            (t.shadow.mapSize.height = 10240),
            (i.shadow.mapSize.width = 10240),
            (i.shadow.mapSize.height = 10240),
            this.scene.add(e, t, i);
        }
      }
      let yw,
        nF = (n = 21) =>
          crypto
            .getRandomValues(new Uint8Array(n))
            .reduce(
              (e, t) =>
                e +
                ((t &= 63) < 36
                  ? t.toString(36)
                  : t < 62
                  ? (t - 26).toString(36).toUpperCase()
                  : t > 62
                  ? "-"
                  : "_"),
              ""
            ),
        gu = (() => {
          class n {
            constructor() {
              (this.todoList = []),
                (this.editId = ""),
                (this.editTid = ""),
                (this.toggleGroup = new kt()),
                (this.pinnedId = ""),
                (this.isInitSubject = new kt()),
                (this.init = !1);
            }
            getList() {
              var t = this;
              return ai(function* () {
                let i = yield window.databaseApi.getList();
                return (
                  (i = i.filter(
                    (r) =>
                      !r.isDelete &&
                      ((r.list = r.list.filter((s) => !s.isDelete)), !0)
                  )),
                  (t.todoList = i),
                  t.init || t.isInitSubject.next(!0),
                  i
                );
              })();
            }
            saveList() {
              window.databaseApi.saveList(JSON.stringify(this.todoList));
            }
            getTitle(t) {
              return this.todoList.find((i) => i.id === t)?.title;
            }
            toggleDone(t, i, r) {
              let s = this.getTodo(t, i);
              s && ((s.done = r), (s.isEdit = !1), (s.doneDate = Date.now()));
            }
            toggleEdit(t, i, r = !0) {
              if (this.editId && this.editTid) {
                let s = this.getTodo(this.editId, this.editTid);
                s && (s.isEdit = !1);
              }
              if (r) {
                let s = this.getTodo(t, i);
                s && (s.isEdit = !0), (this.editId = t), (this.editTid = i);
              } else (this.editId = ""), (this.editTid = "");
            }
            toEdit(t, i, r) {
              let s = this.getTodo(t, i);
              s &&
                ((s.content = r),
                (s.isEdit = !1),
                (this.editId = ""),
                (this.editTid = ""));
            }
            toDeleteTodo(t, i) {
              let r = this.todoList.find((s) => s.id === t);
              if (r) {
                let s = r.list.find((o) => o.tid == i);
                s && (s.isDelete = !0);
              }
            }
            getTodo(t, i) {
              let r = this.todoList.find((s) => s.id === t);
              return r ? r.list.find((o) => o.tid === i) : null;
            }
            addNullTodo(t) {
              let i = this.todoList.find((r) => r.id === t);
              i &&
                i.list.push({
                  tid: "\u65b0\u589e",
                  content: "",
                  done: !1,
                  isEdit: !0,
                  isDelete: !1,
                  createDate: Date.now(),
                });
            }
            addTodo(t, i, r = !1, s, o) {
              let a = this.todoList.find((l) => l.id === t);
              if (a) {
                let l = {
                  tid: s || "t_" + nF(6),
                  content: i,
                  done: r,
                  isEdit: !1,
                  isDelete: !1,
                  createDate: Date.now(),
                };
                o && (l.type = o), a.list.push(l);
              }
            }
            addNullGroup() {
              this.todoList.push({
                id: "newGroupId",
                title: "",
                list: [],
                isDelete: !1,
              });
            }
            addGroup(t) {
              this.todoList.push({
                id: "g_" + nF(5),
                title: t,
                list: [],
                isDelete: !1,
              });
            }
            editGroup(t, i) {
              let r = this.todoList.find((s) => s.id === t);
              r && (r.title = i);
            }
            deleteGroup(t) {
              if ("newGroupId" === t) {
                let r = this.todoList.findIndex((s) => s.id === t);
                return void (r > -1 && this.todoList.splice(r, 1));
              }
              let i = this.todoList.find((r) => r.id === t);
              i && (i.isDelete = !0);
            }
            toSort(t) {
              let i = this.todoList.find((r) => r.id === t);
              if (i) {
                let r = i.sort ? i.sort : "time",
                  s = ["time", "asc", "desc"],
                  o = s.findIndex((a) => a === r);
                if (
                  (o > -1 && (r = o + 1 === s.length ? s[0] : s[o + 1]),
                  (i.sort = r),
                  "time" === r)
                )
                  i.list.sort((a, l) => a.createDate - l.createDate);
                else if ("asc" === r)
                  i.list.sort((a, l) =>
                    this.customSort(a.content, l.content, "asc")
                  );
                else if ("desc" === r) {
                  i.list.sort((c, u) =>
                    this.customSort(c.content, u.content, "desc")
                  );
                  const a = i.list.filter((c) => /^#\d+\s/.test(c.content)),
                    l = i.list.filter((c) => !/^#\d+\s/.test(c.content));
                  i.list = [...a, ...l];
                }
              }
            }
            customSort(t, i, r) {
              const s = t.match(/^#\d+\s/),
                o = i.match(/^#\d+\s/);
              if (s && o) {
                const a = Number(t.match(/\d+/)?.[0]),
                  l = Number(i.match(/\d+/)?.[0]);
                if (a === l) {
                  const c = t.replace(/^#\d+\s/, ""),
                    u = i.replace(/^#\d+\s/, "");
                  return c.localeCompare(u, "zh-CN", { sensitivity: "accent" });
                }
                return "asc" === r ? a - l : l - a;
              }
              return s
                ? "asc" === r
                  ? -1
                  : 1
                : o
                ? "asc" === r
                  ? 1
                  : -1
                : "asc" === r
                ? t.localeCompare(i, "zh-CN", { sensitivity: "accent" })
                : i.localeCompare(t, "zh-CN", { sensitivity: "accent" });
            }
            toggleType(t, i, r) {
              let s = this.getTodo(t, i);
              s && ((s.type = r), this.saveList());
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        YQ = (() => {
          class n {
            constructor(t) {
              (this.todoService = t),
                (this.actions = {}),
                (this.activeAction = {}),
                (this.prevAction = {});
            }
            ngOnInit() {
              var t = this;
              return ai(function* () {
                t.threes = new jQ(".pet");
                let i = yield t.threes.gltfLoad("./assets/robot.glb");
                console.log("gltf", i),
                  i.scene.scale.set(3, 3, 3),
                  i.scene.position.set(0, -6, -1),
                  t.threes.scene.add(i.scene),
                  (t.mixer = new b$(i.scene.children[0]));
                for (let r = 0; r < i.animations.length; r++) {
                  let s = i.animations[r].name;
                  (t.actions[s] = t.mixer.clipAction(i.animations[r])),
                    (t.actions[s].loop = "sit" === s ? 2201 : 2200);
                }
                t.threes.setLight(),
                  t.fadeToAction("dance"),
                  requestAnimationFrame(() => t.update()),
                  window.api.animation((r) => {
                    t.fadeToAction(r);
                  });
              })();
            }
            fadeToAction(t, i = 5) {
              this.prevAction && (this.prevAction = this.activeAction),
                (this.activeAction = this.actions[t]),
                this.prevAction.fadeOut &&
                  this.prevAction != this.activeAction &&
                  this.prevAction.fadeOut(0.2),
                this.activeAction
                  .reset()
                  .setEffectiveTimeScale(i)
                  .setEffectiveWeight(2)
                  .fadeIn(0.2)
                  .play(),
                this.mixer.addEventListener("finished", (r) => {
                  (this.prevAction = this.activeAction),
                    (this.activeAction = this.actions.sit),
                    this.prevAction.fadeOut(0.2),
                    this.activeAction
                      .reset()
                      .setEffectiveTimeScale(i)
                      .setEffectiveWeight(2)
                      .fadeIn(0.2)
                      .play();
                });
            }
            update() {
              let t = this.threes.clock.getDelta();
              this.mixer && this.mixer.update(t),
                requestAnimationFrame(() => this.update());
            }
            openTodo() {
              window.api.showTodo();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(G(gu));
            }),
            (n.ɵcmp = Xi({
              type: n,
              selectors: [["app-pet"]],
              decls: 2,
              vars: 0,
              consts: [
                [1, "pet", 3, "dblclick"],
                [1, "center"],
              ],
              template: function (t, i) {
                1 & t &&
                  (Se(0, "div", 0),
                  Le("dblclick", function () {
                    return i.openTodo();
                  }),
                  Gt(1, "div", 1),
                  Re());
              },
              styles: [
                ".pet[_ngcontent-%COMP%]{width:100vw;height:100vh;overflow:hidden;position:relative}.pet[_ngcontent-%COMP%]   .center[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:50%;height:50px;-webkit-app-region:drag;z-index:10}",
              ],
            })),
            n
          );
        })();
      try {
        yw = typeof Intl < "u" && Intl.v8BreakIterator;
      } catch {
        yw = !1;
      }
      let Ah,
        Rg,
        Ka,
        bw,
        ss = (() => {
          class n {
            constructor(t) {
              (this._platformId = t),
                (this.isBrowser = this._platformId
                  ? (function R8(n) {
                      return n === f1;
                    })(this._platformId)
                  : "object" == typeof document && !!document),
                (this.EDGE =
                  this.isBrowser && /(edge)/i.test(navigator.userAgent)),
                (this.TRIDENT =
                  this.isBrowser &&
                  /(msie|trident)/i.test(navigator.userAgent)),
                (this.BLINK =
                  this.isBrowser &&
                  !(!window.chrome && !yw) &&
                  typeof CSS < "u" &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.WEBKIT =
                  this.isBrowser &&
                  /AppleWebKit/i.test(navigator.userAgent) &&
                  !this.BLINK &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.IOS =
                  this.isBrowser &&
                  /iPad|iPhone|iPod/.test(navigator.userAgent) &&
                  !("MSStream" in window)),
                (this.FIREFOX =
                  this.isBrowser &&
                  /(firefox|minefield)/i.test(navigator.userAgent)),
                (this.ANDROID =
                  this.isBrowser &&
                  /android/i.test(navigator.userAgent) &&
                  !this.TRIDENT),
                (this.SAFARI =
                  this.isBrowser &&
                  /safari/i.test(navigator.userAgent) &&
                  this.WEBKIT);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Vy));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      function Dh(n) {
        return (function ZQ() {
          if (null == Ah && typeof window < "u")
            try {
              window.addEventListener(
                "test",
                null,
                Object.defineProperty({}, "passive", { get: () => (Ah = !0) })
              );
            } finally {
              Ah = Ah || !1;
            }
          return Ah;
        })()
          ? n
          : !!n.capture;
      }
      function rF() {
        if (null == Ka) {
          if (
            "object" != typeof document ||
            !document ||
            "function" != typeof Element ||
            !Element
          )
            return (Ka = !1), Ka;
          if ("scrollBehavior" in document.documentElement.style) Ka = !0;
          else {
            const n = Element.prototype.scrollTo;
            Ka = !!n && !/\{\s*\[native code\]\s*\}/.test(n.toString());
          }
        }
        return Ka;
      }
      function Ih() {
        if ("object" != typeof document || !document) return 0;
        if (null == Rg) {
          const n = document.createElement("div"),
            e = n.style;
          (n.dir = "rtl"),
            (e.width = "1px"),
            (e.overflow = "auto"),
            (e.visibility = "hidden"),
            (e.pointerEvents = "none"),
            (e.position = "absolute");
          const t = document.createElement("div"),
            i = t.style;
          (i.width = "2px"),
            (i.height = "1px"),
            n.appendChild(t),
            document.body.appendChild(n),
            (Rg = 0),
            0 === n.scrollLeft &&
              ((n.scrollLeft = 1), (Rg = 0 === n.scrollLeft ? 1 : 2)),
            n.remove();
        }
        return Rg;
      }
      function Qo(n) {
        return n.composedPath ? n.composedPath()[0] : n.target;
      }
      function xw() {
        return (
          (typeof __karma__ < "u" && !!__karma__) ||
          (typeof jasmine < "u" && !!jasmine) ||
          (typeof jest < "u" && !!jest) ||
          (typeof Mocha < "u" && !!Mocha)
        );
      }
      function aF(n, ...e) {
        return e.length
          ? e.some((t) => n[t])
          : n.altKey || n.shiftKey || n.ctrlKey || n.metaKey;
      }
      class mJ extends Sn {
        constructor(e, t) {
          super();
        }
        schedule(e, t = 0) {
          return this;
        }
      }
      const Pg = {
        setInterval(n, e, ...t) {
          const { delegate: i } = Pg;
          return i?.setInterval
            ? i.setInterval(n, e, ...t)
            : setInterval(n, e, ...t);
        },
        clearInterval(n) {
          const { delegate: e } = Pg;
          return (e?.clearInterval || clearInterval)(n);
        },
        delegate: void 0,
      };
      class Sw extends mJ {
        constructor(e, t) {
          super(e, t),
            (this.scheduler = e),
            (this.work = t),
            (this.pending = !1);
        }
        schedule(e, t = 0) {
          var i;
          if (this.closed) return this;
          this.state = e;
          const r = this.id,
            s = this.scheduler;
          return (
            null != r && (this.id = this.recycleAsyncId(s, r, t)),
            (this.pending = !0),
            (this.delay = t),
            (this.id =
              null !== (i = this.id) && void 0 !== i
                ? i
                : this.requestAsyncId(s, this.id, t)),
            this
          );
        }
        requestAsyncId(e, t, i = 0) {
          return Pg.setInterval(e.flush.bind(e, this), i);
        }
        recycleAsyncId(e, t, i = 0) {
          if (null != i && this.delay === i && !1 === this.pending) return t;
          null != t && Pg.clearInterval(t);
        }
        execute(e, t) {
          if (this.closed) return new Error("executing a cancelled action");
          this.pending = !1;
          const i = this._execute(e, t);
          if (i) return i;
          !1 === this.pending &&
            null != this.id &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }
        _execute(e, t) {
          let r,
            i = !1;
          try {
            this.work(e);
          } catch (s) {
            (i = !0),
              (r = s || new Error("Scheduled action threw falsy error"));
          }
          if (i) return this.unsubscribe(), r;
        }
        unsubscribe() {
          if (!this.closed) {
            const { id: e, scheduler: t } = this,
              { actions: i } = t;
            (this.work = this.state = this.scheduler = null),
              (this.pending = !1),
              ol(i, this),
              null != e && (this.id = this.recycleAsyncId(t, e, null)),
              (this.delay = null),
              super.unsubscribe();
          }
        }
      }
      const lF = { now: () => (lF.delegate || Date).now(), delegate: void 0 };
      class Rh {
        constructor(e, t = Rh.now) {
          (this.schedulerActionCtor = e), (this.now = t);
        }
        schedule(e, t = 0, i) {
          return new this.schedulerActionCtor(this, e).schedule(i, t);
        }
      }
      Rh.now = lF.now;
      class Ew extends Rh {
        constructor(e, t = Rh.now) {
          super(e, t), (this.actions = []), (this._active = !1);
        }
        flush(e) {
          const { actions: t } = this;
          if (this._active) return void t.push(e);
          let i;
          this._active = !0;
          do {
            if ((i = e.execute(e.state, e.delay))) break;
          } while ((e = t.shift()));
          if (((this._active = !1), i)) {
            for (; (e = t.shift()); ) e.unsubscribe();
            throw i;
          }
        }
      }
      const Og = new Ew(Sw),
        gJ = Og;
      function cF(n, e = Og) {
        return ln((t, i) => {
          let r = null,
            s = null,
            o = null;
          const a = () => {
            if (r) {
              r.unsubscribe(), (r = null);
              const c = s;
              (s = null), i.next(c);
            }
          };
          function l() {
            const c = o + n,
              u = e.now();
            if (u < c) return (r = this.schedule(void 0, c - u)), void i.add(r);
            a();
          }
          t.subscribe(
            en(
              i,
              (c) => {
                (s = c), (o = e.now()), r || ((r = e.schedule(l, n)), i.add(r));
              },
              () => {
                a(), i.complete();
              },
              void 0,
              () => {
                s = r = null;
              }
            )
          );
        });
      }
      function uF(n) {
        return _i((e, t) => n <= t);
      }
      function vJ(n, e) {
        return n === e;
      }
      function Jo(n) {
        return ln((e, t) => {
          di(n).subscribe(en(t, () => t.complete(), ef)),
            !t.closed && e.subscribe(t);
        });
      }
      function $a(n) {
        return null != n && "false" != `${n}`;
      }
      function Lg(n) {
        return Array.isArray(n) ? n : [n];
      }
      function kn(n) {
        return null == n ? "" : "string" == typeof n ? n : `${n}px`;
      }
      function vu(n) {
        return n instanceof rn ? n.nativeElement : n;
      }
      const dF = new Set();
      let yu,
        xJ = (() => {
          class n {
            constructor(t) {
              (this._platform = t),
                (this._matchMedia =
                  this._platform.isBrowser && window.matchMedia
                    ? window.matchMedia.bind(window)
                    : MJ);
            }
            matchMedia(t) {
              return (
                (this._platform.WEBKIT || this._platform.BLINK) &&
                  (function wJ(n) {
                    if (!dF.has(n))
                      try {
                        yu ||
                          ((yu = document.createElement("style")),
                          yu.setAttribute("type", "text/css"),
                          document.head.appendChild(yu)),
                          yu.sheet &&
                            (yu.sheet.insertRule(`@media ${n} {body{ }}`, 0),
                            dF.add(n));
                      } catch (e) {
                        console.error(e);
                      }
                  })(t),
                this._matchMedia(t)
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(ss));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      function MJ(n) {
        return {
          matches: "all" === n || "" === n,
          media: n,
          addListener: () => {},
          removeListener: () => {},
        };
      }
      let SJ = (() => {
        class n {
          constructor(t, i) {
            (this._mediaMatcher = t),
              (this._zone = i),
              (this._queries = new Map()),
              (this._destroySubject = new kt());
          }
          ngOnDestroy() {
            this._destroySubject.next(), this._destroySubject.complete();
          }
          isMatched(t) {
            return hF(Lg(t)).some((r) => this._registerQuery(r).mql.matches);
          }
          observe(t) {
            let s = T0(hF(Lg(t)).map((o) => this._registerQuery(o).observable));
            return (
              (s = Ed(s.pipe(er(1)), s.pipe(uF(1), cF(0)))),
              s.pipe(
                xt((o) => {
                  const a = { matches: !1, breakpoints: {} };
                  return (
                    o.forEach(({ matches: l, query: c }) => {
                      (a.matches = a.matches || l), (a.breakpoints[c] = l);
                    }),
                    a
                  );
                })
              )
            );
          }
          _registerQuery(t) {
            if (this._queries.has(t)) return this._queries.get(t);
            const i = this._mediaMatcher.matchMedia(t),
              s = {
                observable: new Kt((o) => {
                  const a = (l) => this._zone.run(() => o.next(l));
                  return (
                    i.addListener(a),
                    () => {
                      i.removeListener(a);
                    }
                  );
                }).pipe(
                  tc(i),
                  xt(({ matches: o }) => ({ query: t, matches: o })),
                  Jo(this._destroySubject)
                ),
                mql: i,
              };
            return this._queries.set(t, s), s;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(xJ), re(wt));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function hF(n) {
        return n
          .map((e) => e.split(","))
          .reduce((e, t) => e.concat(t))
          .map((e) => e.trim());
      }
      class TJ {
        constructor(e) {
          (this._items = e),
            (this._activeItemIndex = -1),
            (this._activeItem = null),
            (this._wrap = !1),
            (this._letterKeyStream = new kt()),
            (this._typeaheadSubscription = Sn.EMPTY),
            (this._vertical = !0),
            (this._allowedModifierKeys = []),
            (this._homeAndEnd = !1),
            (this._pageUpAndDown = { enabled: !1, delta: 10 }),
            (this._skipPredicateFn = (t) => t.disabled),
            (this._pressedLetters = []),
            (this.tabOut = new kt()),
            (this.change = new kt()),
            e instanceof Yl &&
              (this._itemChangesSubscription = e.changes.subscribe((t) => {
                if (this._activeItem) {
                  const r = t.toArray().indexOf(this._activeItem);
                  r > -1 &&
                    r !== this._activeItemIndex &&
                    (this._activeItemIndex = r);
                }
              }));
        }
        skipPredicate(e) {
          return (this._skipPredicateFn = e), this;
        }
        withWrap(e = !0) {
          return (this._wrap = e), this;
        }
        withVerticalOrientation(e = !0) {
          return (this._vertical = e), this;
        }
        withHorizontalOrientation(e) {
          return (this._horizontal = e), this;
        }
        withAllowedModifierKeys(e) {
          return (this._allowedModifierKeys = e), this;
        }
        withTypeAhead(e = 200) {
          return (
            this._typeaheadSubscription.unsubscribe(),
            (this._typeaheadSubscription = this._letterKeyStream
              .pipe(
                si((t) => this._pressedLetters.push(t)),
                cF(e),
                _i(() => this._pressedLetters.length > 0),
                xt(() => this._pressedLetters.join(""))
              )
              .subscribe((t) => {
                const i = this._getItemsArray();
                for (let r = 1; r < i.length + 1; r++) {
                  const s = (this._activeItemIndex + r) % i.length,
                    o = i[s];
                  if (
                    !this._skipPredicateFn(o) &&
                    0 === o.getLabel().toUpperCase().trim().indexOf(t)
                  ) {
                    this.setActiveItem(s);
                    break;
                  }
                }
                this._pressedLetters = [];
              })),
            this
          );
        }
        cancelTypeahead() {
          return (this._pressedLetters = []), this;
        }
        withHomeAndEnd(e = !0) {
          return (this._homeAndEnd = e), this;
        }
        withPageUpDown(e = !0, t = 10) {
          return (this._pageUpAndDown = { enabled: e, delta: t }), this;
        }
        setActiveItem(e) {
          const t = this._activeItem;
          this.updateActiveItem(e),
            this._activeItem !== t && this.change.next(this._activeItemIndex);
        }
        onKeydown(e) {
          const t = e.keyCode,
            r = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(
              (s) => !e[s] || this._allowedModifierKeys.indexOf(s) > -1
            );
          switch (t) {
            case 9:
              return void this.tabOut.next();
            case 40:
              if (this._vertical && r) {
                this.setNextItemActive();
                break;
              }
              return;
            case 38:
              if (this._vertical && r) {
                this.setPreviousItemActive();
                break;
              }
              return;
            case 39:
              if (this._horizontal && r) {
                "rtl" === this._horizontal
                  ? this.setPreviousItemActive()
                  : this.setNextItemActive();
                break;
              }
              return;
            case 37:
              if (this._horizontal && r) {
                "rtl" === this._horizontal
                  ? this.setNextItemActive()
                  : this.setPreviousItemActive();
                break;
              }
              return;
            case 36:
              if (this._homeAndEnd && r) {
                this.setFirstItemActive();
                break;
              }
              return;
            case 35:
              if (this._homeAndEnd && r) {
                this.setLastItemActive();
                break;
              }
              return;
            case 33:
              if (this._pageUpAndDown.enabled && r) {
                const s = this._activeItemIndex - this._pageUpAndDown.delta;
                this._setActiveItemByIndex(s > 0 ? s : 0, 1);
                break;
              }
              return;
            case 34:
              if (this._pageUpAndDown.enabled && r) {
                const s = this._activeItemIndex + this._pageUpAndDown.delta,
                  o = this._getItemsArray().length;
                this._setActiveItemByIndex(s < o ? s : o - 1, -1);
                break;
              }
              return;
            default:
              return void (
                (r || aF(e, "shiftKey")) &&
                (e.key && 1 === e.key.length
                  ? this._letterKeyStream.next(e.key.toLocaleUpperCase())
                  : ((t >= 65 && t <= 90) || (t >= 48 && t <= 57)) &&
                    this._letterKeyStream.next(String.fromCharCode(t)))
              );
          }
          (this._pressedLetters = []), e.preventDefault();
        }
        get activeItemIndex() {
          return this._activeItemIndex;
        }
        get activeItem() {
          return this._activeItem;
        }
        isTyping() {
          return this._pressedLetters.length > 0;
        }
        setFirstItemActive() {
          this._setActiveItemByIndex(0, 1);
        }
        setLastItemActive() {
          this._setActiveItemByIndex(this._items.length - 1, -1);
        }
        setNextItemActive() {
          this._activeItemIndex < 0
            ? this.setFirstItemActive()
            : this._setActiveItemByDelta(1);
        }
        setPreviousItemActive() {
          this._activeItemIndex < 0 && this._wrap
            ? this.setLastItemActive()
            : this._setActiveItemByDelta(-1);
        }
        updateActiveItem(e) {
          const t = this._getItemsArray(),
            i = "number" == typeof e ? e : t.indexOf(e);
          (this._activeItem = t[i] ?? null), (this._activeItemIndex = i);
        }
        destroy() {
          this._typeaheadSubscription.unsubscribe(),
            this._itemChangesSubscription?.unsubscribe(),
            this._letterKeyStream.complete(),
            this.tabOut.complete(),
            this.change.complete(),
            (this._pressedLetters = []);
        }
        _setActiveItemByDelta(e) {
          this._wrap
            ? this._setActiveInWrapMode(e)
            : this._setActiveInDefaultMode(e);
        }
        _setActiveInWrapMode(e) {
          const t = this._getItemsArray();
          for (let i = 1; i <= t.length; i++) {
            const r = (this._activeItemIndex + e * i + t.length) % t.length;
            if (!this._skipPredicateFn(t[r])) return void this.setActiveItem(r);
          }
        }
        _setActiveInDefaultMode(e) {
          this._setActiveItemByIndex(this._activeItemIndex + e, e);
        }
        _setActiveItemByIndex(e, t) {
          const i = this._getItemsArray();
          if (i[e]) {
            for (; this._skipPredicateFn(i[e]); ) if (!i[(e += t)]) return;
            this.setActiveItem(e);
          }
        }
        _getItemsArray() {
          return this._items instanceof Yl
            ? this._items.toArray()
            : this._items;
        }
      }
      class AJ extends TJ {
        constructor() {
          super(...arguments), (this._origin = "program");
        }
        setFocusOrigin(e) {
          return (this._origin = e), this;
        }
        setActiveItem(e) {
          super.setActiveItem(e),
            this.activeItem && this.activeItem.focus(this._origin);
        }
      }
      function Cw(n) {
        return 0 === n.buttons || (0 === n.offsetX && 0 === n.offsetY);
      }
      function Tw(n) {
        const e =
          (n.touches && n.touches[0]) ||
          (n.changedTouches && n.changedTouches[0]);
        return !(
          !e ||
          -1 !== e.identifier ||
          (null != e.radiusX && 1 !== e.radiusX) ||
          (null != e.radiusY && 1 !== e.radiusY)
        );
      }
      const LJ = new ye("cdk-input-modality-detector-options"),
        FJ = { ignoreKeys: [18, 17, 224, 91, 16] },
        bu = Dh({ passive: !0, capture: !0 });
      let NJ = (() => {
        class n {
          get mostRecentModality() {
            return this._modality.value;
          }
          constructor(t, i, r, s) {
            (this._platform = t),
              (this._mostRecentTarget = null),
              (this._modality = new Mr(null)),
              (this._lastTouchMs = 0),
              (this._onKeydown = (o) => {
                this._options?.ignoreKeys?.some((a) => a === o.keyCode) ||
                  (this._modality.next("keyboard"),
                  (this._mostRecentTarget = Qo(o)));
              }),
              (this._onMousedown = (o) => {
                Date.now() - this._lastTouchMs < 650 ||
                  (this._modality.next(Cw(o) ? "keyboard" : "mouse"),
                  (this._mostRecentTarget = Qo(o)));
              }),
              (this._onTouchstart = (o) => {
                Tw(o)
                  ? this._modality.next("keyboard")
                  : ((this._lastTouchMs = Date.now()),
                    this._modality.next("touch"),
                    (this._mostRecentTarget = Qo(o)));
              }),
              (this._options = { ...FJ, ...s }),
              (this.modalityDetected = this._modality.pipe(uF(1))),
              (this.modalityChanged = this.modalityDetected.pipe(
                (function _J(n, e = bo) {
                  return (
                    (n = n ?? vJ),
                    ln((t, i) => {
                      let r,
                        s = !0;
                      t.subscribe(
                        en(i, (o) => {
                          const a = e(o);
                          (s || !n(r, a)) && ((s = !1), (r = a), i.next(o));
                        })
                      );
                    })
                  );
                })()
              )),
              t.isBrowser &&
                i.runOutsideAngular(() => {
                  r.addEventListener("keydown", this._onKeydown, bu),
                    r.addEventListener("mousedown", this._onMousedown, bu),
                    r.addEventListener("touchstart", this._onTouchstart, bu);
                });
          }
          ngOnDestroy() {
            this._modality.complete(),
              this._platform.isBrowser &&
                (document.removeEventListener("keydown", this._onKeydown, bu),
                document.removeEventListener(
                  "mousedown",
                  this._onMousedown,
                  bu
                ),
                document.removeEventListener(
                  "touchstart",
                  this._onTouchstart,
                  bu
                ));
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(ss), re(wt), re(Lt), re(LJ, 8));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const BJ = new ye("cdk-focus-monitor-default-options"),
        Fg = Dh({ passive: !0, capture: !0 });
      let Aw = (() => {
        class n {
          constructor(t, i, r, s, o) {
            (this._ngZone = t),
              (this._platform = i),
              (this._inputModalityDetector = r),
              (this._origin = null),
              (this._windowFocused = !1),
              (this._originFromTouchInteraction = !1),
              (this._elementInfo = new Map()),
              (this._monitoredElementCount = 0),
              (this._rootNodeFocusListenerCount = new Map()),
              (this._windowFocusListener = () => {
                (this._windowFocused = !0),
                  (this._windowFocusTimeoutId = window.setTimeout(
                    () => (this._windowFocused = !1)
                  ));
              }),
              (this._stopInputModalityDetector = new kt()),
              (this._rootNodeFocusAndBlurListener = (a) => {
                for (let c = Qo(a); c; c = c.parentElement)
                  "focus" === a.type ? this._onFocus(a, c) : this._onBlur(a, c);
              }),
              (this._document = s),
              (this._detectionMode = o?.detectionMode || 0);
          }
          monitor(t, i = !1) {
            const r = vu(t);
            if (!this._platform.isBrowser || 1 !== r.nodeType) return Ge(null);
            const s =
                (function $Q(n) {
                  if (
                    (function KQ() {
                      if (null == bw) {
                        const n = typeof document < "u" ? document.head : null;
                        bw = !(!n || (!n.createShadowRoot && !n.attachShadow));
                      }
                      return bw;
                    })()
                  ) {
                    const e = n.getRootNode ? n.getRootNode() : null;
                    if (
                      typeof ShadowRoot < "u" &&
                      ShadowRoot &&
                      e instanceof ShadowRoot
                    )
                      return e;
                  }
                  return null;
                })(r) || this._getDocument(),
              o = this._elementInfo.get(r);
            if (o) return i && (o.checkChildren = !0), o.subject;
            const a = { checkChildren: i, subject: new kt(), rootNode: s };
            return (
              this._elementInfo.set(r, a),
              this._registerGlobalListeners(a),
              a.subject
            );
          }
          stopMonitoring(t) {
            const i = vu(t),
              r = this._elementInfo.get(i);
            r &&
              (r.subject.complete(),
              this._setClasses(i),
              this._elementInfo.delete(i),
              this._removeGlobalListeners(r));
          }
          focusVia(t, i, r) {
            const s = vu(t);
            s === this._getDocument().activeElement
              ? this._getClosestElementsInfo(s).forEach(([a, l]) =>
                  this._originChanged(a, i, l)
                )
              : (this._setOrigin(i),
                "function" == typeof s.focus && s.focus(r));
          }
          ngOnDestroy() {
            this._elementInfo.forEach((t, i) => this.stopMonitoring(i));
          }
          _getDocument() {
            return this._document || document;
          }
          _getWindow() {
            return this._getDocument().defaultView || window;
          }
          _getFocusOrigin(t) {
            return this._origin
              ? this._originFromTouchInteraction
                ? this._shouldBeAttributedToTouch(t)
                  ? "touch"
                  : "program"
                : this._origin
              : this._windowFocused && this._lastFocusOrigin
              ? this._lastFocusOrigin
              : t && this._isLastInteractionFromInputLabel(t)
              ? "mouse"
              : "program";
          }
          _shouldBeAttributedToTouch(t) {
            return (
              1 === this._detectionMode ||
              !!t?.contains(this._inputModalityDetector._mostRecentTarget)
            );
          }
          _setClasses(t, i) {
            t.classList.toggle("cdk-focused", !!i),
              t.classList.toggle("cdk-touch-focused", "touch" === i),
              t.classList.toggle("cdk-keyboard-focused", "keyboard" === i),
              t.classList.toggle("cdk-mouse-focused", "mouse" === i),
              t.classList.toggle("cdk-program-focused", "program" === i);
          }
          _setOrigin(t, i = !1) {
            this._ngZone.runOutsideAngular(() => {
              (this._origin = t),
                (this._originFromTouchInteraction = "touch" === t && i),
                0 === this._detectionMode &&
                  (clearTimeout(this._originTimeoutId),
                  (this._originTimeoutId = setTimeout(
                    () => (this._origin = null),
                    this._originFromTouchInteraction ? 650 : 1
                  )));
            });
          }
          _onFocus(t, i) {
            const r = this._elementInfo.get(i),
              s = Qo(t);
            !r ||
              (!r.checkChildren && i !== s) ||
              this._originChanged(i, this._getFocusOrigin(s), r);
          }
          _onBlur(t, i) {
            const r = this._elementInfo.get(i);
            !r ||
              (r.checkChildren &&
                t.relatedTarget instanceof Node &&
                i.contains(t.relatedTarget)) ||
              (this._setClasses(i), this._emitOrigin(r, null));
          }
          _emitOrigin(t, i) {
            t.subject.observers.length &&
              this._ngZone.run(() => t.subject.next(i));
          }
          _registerGlobalListeners(t) {
            if (!this._platform.isBrowser) return;
            const i = t.rootNode,
              r = this._rootNodeFocusListenerCount.get(i) || 0;
            r ||
              this._ngZone.runOutsideAngular(() => {
                i.addEventListener(
                  "focus",
                  this._rootNodeFocusAndBlurListener,
                  Fg
                ),
                  i.addEventListener(
                    "blur",
                    this._rootNodeFocusAndBlurListener,
                    Fg
                  );
              }),
              this._rootNodeFocusListenerCount.set(i, r + 1),
              1 == ++this._monitoredElementCount &&
                (this._ngZone.runOutsideAngular(() => {
                  this._getWindow().addEventListener(
                    "focus",
                    this._windowFocusListener
                  );
                }),
                this._inputModalityDetector.modalityDetected
                  .pipe(Jo(this._stopInputModalityDetector))
                  .subscribe((s) => {
                    this._setOrigin(s, !0);
                  }));
          }
          _removeGlobalListeners(t) {
            const i = t.rootNode;
            if (this._rootNodeFocusListenerCount.has(i)) {
              const r = this._rootNodeFocusListenerCount.get(i);
              r > 1
                ? this._rootNodeFocusListenerCount.set(i, r - 1)
                : (i.removeEventListener(
                    "focus",
                    this._rootNodeFocusAndBlurListener,
                    Fg
                  ),
                  i.removeEventListener(
                    "blur",
                    this._rootNodeFocusAndBlurListener,
                    Fg
                  ),
                  this._rootNodeFocusListenerCount.delete(i));
            }
            --this._monitoredElementCount ||
              (this._getWindow().removeEventListener(
                "focus",
                this._windowFocusListener
              ),
              this._stopInputModalityDetector.next(),
              clearTimeout(this._windowFocusTimeoutId),
              clearTimeout(this._originTimeoutId));
          }
          _originChanged(t, i, r) {
            this._setClasses(t, i),
              this._emitOrigin(r, i),
              (this._lastFocusOrigin = i);
          }
          _getClosestElementsInfo(t) {
            const i = [];
            return (
              this._elementInfo.forEach((r, s) => {
                (s === t || (r.checkChildren && s.contains(t))) &&
                  i.push([s, r]);
              }),
              i
            );
          }
          _isLastInteractionFromInputLabel(t) {
            const { _mostRecentTarget: i, mostRecentModality: r } =
              this._inputModalityDetector;
            if (
              "mouse" !== r ||
              !i ||
              i === t ||
              ("INPUT" !== t.nodeName && "TEXTAREA" !== t.nodeName) ||
              t.disabled
            )
              return !1;
            const s = t.labels;
            if (s)
              for (let o = 0; o < s.length; o++)
                if (s[o].contains(i)) return !0;
            return !1;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(wt), re(ss), re(NJ), re(Lt, 8), re(BJ, 8));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const _F = "cdk-high-contrast-black-on-white",
        vF = "cdk-high-contrast-white-on-black",
        Dw = "cdk-high-contrast-active";
      let Iw,
        UJ = (() => {
          class n {
            constructor(t, i) {
              (this._platform = t),
                (this._document = i),
                (this._breakpointSubscription = ft(SJ)
                  .observe("(forced-colors: active)")
                  .subscribe(() => {
                    this._hasCheckedHighContrastMode &&
                      ((this._hasCheckedHighContrastMode = !1),
                      this._applyBodyHighContrastModeCssClasses());
                  }));
            }
            getHighContrastMode() {
              if (!this._platform.isBrowser) return 0;
              const t = this._document.createElement("div");
              (t.style.backgroundColor = "rgb(1,2,3)"),
                (t.style.position = "absolute"),
                this._document.body.appendChild(t);
              const i = this._document.defaultView || window,
                r = i && i.getComputedStyle ? i.getComputedStyle(t) : null,
                s = ((r && r.backgroundColor) || "").replace(/ /g, "");
              switch ((t.remove(), s)) {
                case "rgb(0,0,0)":
                case "rgb(45,50,54)":
                case "rgb(32,32,32)":
                  return 2;
                case "rgb(255,255,255)":
                case "rgb(255,250,239)":
                  return 1;
              }
              return 0;
            }
            ngOnDestroy() {
              this._breakpointSubscription.unsubscribe();
            }
            _applyBodyHighContrastModeCssClasses() {
              if (
                !this._hasCheckedHighContrastMode &&
                this._platform.isBrowser &&
                this._document.body
              ) {
                const t = this._document.body.classList;
                t.remove(Dw, _F, vF), (this._hasCheckedHighContrastMode = !0);
                const i = this.getHighContrastMode();
                1 === i ? t.add(Dw, _F) : 2 === i && t.add(Dw, vF);
              }
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(ss), re(Lt));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        VJ = 1;
      const Ng = {};
      function yF(n) {
        return n in Ng && (delete Ng[n], !0);
      }
      const zJ = {
          setImmediate(n) {
            const e = VJ++;
            return (
              (Ng[e] = !0),
              Iw || (Iw = Promise.resolve()),
              Iw.then(() => yF(e) && n()),
              e
            );
          },
          clearImmediate(n) {
            yF(n);
          },
        },
        { setImmediate: HJ, clearImmediate: GJ } = zJ,
        kg = {
          setImmediate(...n) {
            const { delegate: e } = kg;
            return (e?.setImmediate || HJ)(...n);
          },
          clearImmediate(n) {
            const { delegate: e } = kg;
            return (e?.clearImmediate || GJ)(n);
          },
          delegate: void 0,
        },
        Rw = new (class jJ extends Ew {
          flush(e) {
            this._active = !0;
            const t = this._scheduled;
            this._scheduled = void 0;
            const { actions: i } = this;
            let r;
            e = e || i.shift();
            do {
              if ((r = e.execute(e.state, e.delay))) break;
            } while ((e = i[0]) && e.id === t && i.shift());
            if (((this._active = !1), r)) {
              for (; (e = i[0]) && e.id === t && i.shift(); ) e.unsubscribe();
              throw r;
            }
          }
        })(
          class WJ extends Sw {
            constructor(e, t) {
              super(e, t), (this.scheduler = e), (this.work = t);
            }
            requestAsyncId(e, t, i = 0) {
              return null !== i && i > 0
                ? super.requestAsyncId(e, t, i)
                : (e.actions.push(this),
                  e._scheduled ||
                    (e._scheduled = kg.setImmediate(e.flush.bind(e, void 0))));
            }
            recycleAsyncId(e, t, i = 0) {
              var r;
              if (null != i ? i > 0 : this.delay > 0)
                return super.recycleAsyncId(e, t, i);
              const { actions: s } = e;
              null != t &&
                (null === (r = s[s.length - 1]) || void 0 === r
                  ? void 0
                  : r.id) !== t &&
                (kg.clearImmediate(t),
                e._scheduled === t && (e._scheduled = void 0));
            }
          }
        );
      function bF(n, e) {
        return e
          ? (t) =>
              Ed(
                e.pipe(
                  er(1),
                  (function XJ() {
                    return ln((n, e) => {
                      n.subscribe(en(e, ef));
                    });
                  })()
                ),
                t.pipe(bF(n))
              )
          : Un((t, i) => di(n(t, i)).pipe(er(1), K1(t)));
      }
      function xF(n = 0, e, t = gJ) {
        let i = -1;
        return (
          null != e && (lS(e) ? (t = e) : (i = e)),
          new Kt((r) => {
            let s = (function qJ(n) {
              return n instanceof Date && !isNaN(n);
            })(n)
              ? +n - t.now()
              : n;
            s < 0 && (s = 0);
            let o = 0;
            return t.schedule(function () {
              r.closed ||
                (r.next(o++), 0 <= i ? this.schedule(void 0, i) : r.complete());
            }, s);
          })
        );
      }
      function wF(n, e = Og) {
        const t = xF(n, e);
        return bF(() => t);
      }
      const YJ = new ye("cdk-dir-doc", {
          providedIn: "root",
          factory: function ZJ() {
            return ft(Lt);
          },
        }),
        KJ =
          /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
      let Ph = (() => {
          class n {
            constructor(t) {
              (this.value = "ltr"),
                (this.change = new Ut()),
                t &&
                  (this.value = (function $J(n) {
                    const e = n?.toLowerCase() || "";
                    return "auto" === e &&
                      typeof navigator < "u" &&
                      navigator?.language
                      ? KJ.test(navigator.language)
                        ? "rtl"
                        : "ltr"
                      : "rtl" === e
                      ? "rtl"
                      : "ltr";
                  })(
                    (t.body ? t.body.dir : null) ||
                      (t.documentElement ? t.documentElement.dir : null) ||
                      "ltr"
                  ));
            }
            ngOnDestroy() {
              this.change.complete();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(YJ, 8));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        Oh = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({})),
            n
          );
        })();
      const JJ = new ye("mat-sanity-checks", {
        providedIn: "root",
        factory: function QJ() {
          return !0;
        },
      });
      let Ds = (() => {
        class n {
          constructor(t, i, r) {
            (this._sanityChecks = i),
              (this._document = r),
              (this._hasDoneGlobalChecks = !1),
              t._applyBodyHighContrastModeCssClasses(),
              this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0);
          }
          _checkIsEnabled(t) {
            return (
              !xw() &&
              ("boolean" == typeof this._sanityChecks
                ? this._sanityChecks
                : !!this._sanityChecks[t])
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(UJ), re(JJ, 8), re(Lt));
          }),
          (n.ɵmod = _n({ type: n })),
          (n.ɵinj = cn({ imports: [Oh, Oh] })),
          n
        );
      })();
      function EF(n) {
        return class extends n {
          get disabled() {
            return this._disabled;
          }
          set disabled(e) {
            this._disabled = $a(e);
          }
          constructor(...e) {
            super(...e), (this._disabled = !1);
          }
        };
      }
      function eee(n, e) {
        return class extends n {
          get color() {
            return this._color;
          }
          set color(t) {
            const i = t || this.defaultColor;
            i !== this._color &&
              (this._color &&
                this._elementRef.nativeElement.classList.remove(
                  `mat-${this._color}`
                ),
              i && this._elementRef.nativeElement.classList.add(`mat-${i}`),
              (this._color = i));
          }
          constructor(...t) {
            super(...t), (this.defaultColor = e), (this.color = e);
          }
        };
      }
      function CF(n) {
        return class extends n {
          get disableRipple() {
            return this._disableRipple;
          }
          set disableRipple(e) {
            this._disableRipple = $a(e);
          }
          constructor(...e) {
            super(...e), (this._disableRipple = !1);
          }
        };
      }
      function tee(n, e = 0) {
        return class extends n {
          get tabIndex() {
            return this.disabled ? -1 : this._tabIndex;
          }
          set tabIndex(t) {
            this._tabIndex =
              null != t
                ? (function yJ(n, e = 0) {
                    return (function bJ(n) {
                      return !isNaN(parseFloat(n)) && !isNaN(Number(n));
                    })(n)
                      ? Number(n)
                      : e;
                  })(t)
                : this.defaultTabIndex;
          }
          constructor(...t) {
            super(...t), (this._tabIndex = e), (this.defaultTabIndex = e);
          }
        };
      }
      class iee {
        constructor(e, t, i, r = !1) {
          (this._renderer = e),
            (this.element = t),
            (this.config = i),
            (this._animationForciblyDisabledThroughCss = r),
            (this.state = 3);
        }
        fadeOut() {
          this._renderer.fadeOutRipple(this);
        }
      }
      const TF = Dh({ passive: !0, capture: !0 });
      class ree {
        constructor() {
          (this._events = new Map()),
            (this._delegateEventHandler = (e) => {
              const t = Qo(e);
              t &&
                this._events.get(e.type)?.forEach((i, r) => {
                  (r === t || r.contains(t)) &&
                    i.forEach((s) => s.handleEvent(e));
                });
            });
        }
        addHandler(e, t, i, r) {
          const s = this._events.get(t);
          if (s) {
            const o = s.get(i);
            o ? o.add(r) : s.set(i, new Set([r]));
          } else
            this._events.set(t, new Map([[i, new Set([r])]])),
              e.runOutsideAngular(() => {
                document.addEventListener(t, this._delegateEventHandler, TF);
              });
        }
        removeHandler(e, t, i) {
          const r = this._events.get(e);
          if (!r) return;
          const s = r.get(t);
          s &&
            (s.delete(i),
            0 === s.size && r.delete(t),
            0 === r.size &&
              (this._events.delete(e),
              document.removeEventListener(e, this._delegateEventHandler, TF)));
        }
      }
      const AF = { enterDuration: 225, exitDuration: 150 },
        DF = Dh({ passive: !0, capture: !0 }),
        IF = ["mousedown", "touchstart"],
        RF = ["mouseup", "mouseleave", "touchend", "touchcancel"];
      class Fh {
        constructor(e, t, i, r) {
          (this._target = e),
            (this._ngZone = t),
            (this._platform = r),
            (this._isPointerDown = !1),
            (this._activeRipples = new Map()),
            (this._pointerUpEventsRegistered = !1),
            r.isBrowser && (this._containerElement = vu(i));
        }
        fadeInRipple(e, t, i = {}) {
          const r = (this._containerRect =
              this._containerRect ||
              this._containerElement.getBoundingClientRect()),
            s = { ...AF, ...i.animation };
          i.centered &&
            ((e = r.left + r.width / 2), (t = r.top + r.height / 2));
          const o =
              i.radius ||
              (function oee(n, e, t) {
                const i = Math.max(Math.abs(n - t.left), Math.abs(n - t.right)),
                  r = Math.max(Math.abs(e - t.top), Math.abs(e - t.bottom));
                return Math.sqrt(i * i + r * r);
              })(e, t, r),
            a = e - r.left,
            l = t - r.top,
            c = s.enterDuration,
            u = document.createElement("div");
          u.classList.add("mat-ripple-element"),
            (u.style.left = a - o + "px"),
            (u.style.top = l - o + "px"),
            (u.style.height = 2 * o + "px"),
            (u.style.width = 2 * o + "px"),
            null != i.color && (u.style.backgroundColor = i.color),
            (u.style.transitionDuration = `${c}ms`),
            this._containerElement.appendChild(u);
          const d = window.getComputedStyle(u),
            f = d.transitionDuration,
            p =
              "none" === d.transitionProperty ||
              "0s" === f ||
              "0s, 0s" === f ||
              (0 === r.width && 0 === r.height),
            _ = new iee(this, u, i, p);
          (u.style.transform = "scale3d(1, 1, 1)"),
            (_.state = 0),
            i.persistent || (this._mostRecentTransientRipple = _);
          let m = null;
          return (
            !p &&
              (c || s.exitDuration) &&
              this._ngZone.runOutsideAngular(() => {
                const g = () => this._finishRippleTransition(_),
                  y = () => this._destroyRipple(_);
                u.addEventListener("transitionend", g),
                  u.addEventListener("transitioncancel", y),
                  (m = { onTransitionEnd: g, onTransitionCancel: y });
              }),
            this._activeRipples.set(_, m),
            (p || !c) && this._finishRippleTransition(_),
            _
          );
        }
        fadeOutRipple(e) {
          if (2 === e.state || 3 === e.state) return;
          const t = e.element,
            i = { ...AF, ...e.config.animation };
          (t.style.transitionDuration = `${i.exitDuration}ms`),
            (t.style.opacity = "0"),
            (e.state = 2),
            (e._animationForciblyDisabledThroughCss || !i.exitDuration) &&
              this._finishRippleTransition(e);
        }
        fadeOutAll() {
          this._getActiveRipples().forEach((e) => e.fadeOut());
        }
        fadeOutAllNonPersistent() {
          this._getActiveRipples().forEach((e) => {
            e.config.persistent || e.fadeOut();
          });
        }
        setupTriggerEvents(e) {
          const t = vu(e);
          !this._platform.isBrowser ||
            !t ||
            t === this._triggerElement ||
            (this._removeTriggerEvents(),
            (this._triggerElement = t),
            IF.forEach((i) => {
              Fh._eventManager.addHandler(this._ngZone, i, t, this);
            }));
        }
        handleEvent(e) {
          "mousedown" === e.type
            ? this._onMousedown(e)
            : "touchstart" === e.type
            ? this._onTouchStart(e)
            : this._onPointerUp(),
            this._pointerUpEventsRegistered ||
              (this._ngZone.runOutsideAngular(() => {
                RF.forEach((t) => {
                  this._triggerElement.addEventListener(t, this, DF);
                });
              }),
              (this._pointerUpEventsRegistered = !0));
        }
        _finishRippleTransition(e) {
          0 === e.state
            ? this._startFadeOutTransition(e)
            : 2 === e.state && this._destroyRipple(e);
        }
        _startFadeOutTransition(e) {
          const t = e === this._mostRecentTransientRipple,
            { persistent: i } = e.config;
          (e.state = 1), !i && (!t || !this._isPointerDown) && e.fadeOut();
        }
        _destroyRipple(e) {
          const t = this._activeRipples.get(e) ?? null;
          this._activeRipples.delete(e),
            this._activeRipples.size || (this._containerRect = null),
            e === this._mostRecentTransientRipple &&
              (this._mostRecentTransientRipple = null),
            (e.state = 3),
            null !== t &&
              (e.element.removeEventListener(
                "transitionend",
                t.onTransitionEnd
              ),
              e.element.removeEventListener(
                "transitioncancel",
                t.onTransitionCancel
              )),
            e.element.remove();
        }
        _onMousedown(e) {
          const t = Cw(e),
            i =
              this._lastTouchStartEvent &&
              Date.now() < this._lastTouchStartEvent + 800;
          !this._target.rippleDisabled &&
            !t &&
            !i &&
            ((this._isPointerDown = !0),
            this.fadeInRipple(e.clientX, e.clientY, this._target.rippleConfig));
        }
        _onTouchStart(e) {
          if (!this._target.rippleDisabled && !Tw(e)) {
            (this._lastTouchStartEvent = Date.now()),
              (this._isPointerDown = !0);
            const t = e.changedTouches;
            for (let i = 0; i < t.length; i++)
              this.fadeInRipple(
                t[i].clientX,
                t[i].clientY,
                this._target.rippleConfig
              );
          }
        }
        _onPointerUp() {
          this._isPointerDown &&
            ((this._isPointerDown = !1),
            this._getActiveRipples().forEach((e) => {
              !e.config.persistent &&
                (1 === e.state ||
                  (e.config.terminateOnPointerUp && 0 === e.state)) &&
                e.fadeOut();
            }));
        }
        _getActiveRipples() {
          return Array.from(this._activeRipples.keys());
        }
        _removeTriggerEvents() {
          const e = this._triggerElement;
          e &&
            (IF.forEach((t) => Fh._eventManager.removeHandler(t, e, this)),
            this._pointerUpEventsRegistered &&
              RF.forEach((t) => e.removeEventListener(t, this, DF)));
        }
      }
      Fh._eventManager = new ree();
      const aee = new ye("mat-ripple-global-options");
      let PF = (() => {
          class n {
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              t && this.fadeOutAllNonPersistent(),
                (this._disabled = t),
                this._setupTriggerEventsIfEnabled();
            }
            get trigger() {
              return this._trigger || this._elementRef.nativeElement;
            }
            set trigger(t) {
              (this._trigger = t), this._setupTriggerEventsIfEnabled();
            }
            constructor(t, i, r, s, o) {
              (this._elementRef = t),
                (this._animationMode = o),
                (this.radius = 0),
                (this._disabled = !1),
                (this._isInitialized = !1),
                (this._globalOptions = s || {}),
                (this._rippleRenderer = new Fh(this, i, t, r));
            }
            ngOnInit() {
              (this._isInitialized = !0), this._setupTriggerEventsIfEnabled();
            }
            ngOnDestroy() {
              this._rippleRenderer._removeTriggerEvents();
            }
            fadeOutAll() {
              this._rippleRenderer.fadeOutAll();
            }
            fadeOutAllNonPersistent() {
              this._rippleRenderer.fadeOutAllNonPersistent();
            }
            get rippleConfig() {
              return {
                centered: this.centered,
                radius: this.radius,
                color: this.color,
                animation: {
                  ...this._globalOptions.animation,
                  ...("NoopAnimations" === this._animationMode
                    ? { enterDuration: 0, exitDuration: 0 }
                    : {}),
                  ...this.animation,
                },
                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,
              };
            }
            get rippleDisabled() {
              return this.disabled || !!this._globalOptions.disabled;
            }
            _setupTriggerEventsIfEnabled() {
              !this.disabled &&
                this._isInitialized &&
                this._rippleRenderer.setupTriggerEvents(this.trigger);
            }
            launch(t, i = 0, r) {
              return "number" == typeof t
                ? this._rippleRenderer.fadeInRipple(t, i, {
                    ...this.rippleConfig,
                    ...r,
                  })
                : this._rippleRenderer.fadeInRipple(0, 0, {
                    ...this.rippleConfig,
                    ...t,
                  });
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(G(rn), G(wt), G(ss), G(aee, 8), G(_d, 8));
            }),
            (n.ɵdir = He({
              type: n,
              selectors: [
                ["", "mat-ripple", ""],
                ["", "matRipple", ""],
              ],
              hostAttrs: [1, "mat-ripple"],
              hostVars: 2,
              hostBindings: function (t, i) {
                2 & t && gs("mat-ripple-unbounded", i.unbounded);
              },
              inputs: {
                color: ["matRippleColor", "color"],
                unbounded: ["matRippleUnbounded", "unbounded"],
                centered: ["matRippleCentered", "centered"],
                radius: ["matRippleRadius", "radius"],
                animation: ["matRippleAnimation", "animation"],
                disabled: ["matRippleDisabled", "disabled"],
                trigger: ["matRippleTrigger", "trigger"],
              },
              exportAs: ["matRipple"],
            })),
            n
          );
        })(),
        Pw = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ imports: [Ds, Ds] })),
            n
          );
        })();
      class Ow {
        attach(e) {
          return (this._attachedHost = e), e.attach(this);
        }
        detach() {
          let e = this._attachedHost;
          null != e && ((this._attachedHost = null), e.detach());
        }
        get isAttached() {
          return null != this._attachedHost;
        }
        setAttachedHost(e) {
          this._attachedHost = e;
        }
      }
      class lee extends Ow {
        constructor(e, t, i, r, s) {
          super(),
            (this.component = e),
            (this.viewContainerRef = t),
            (this.injector = i),
            (this.componentFactoryResolver = r),
            (this.projectableNodes = s);
        }
      }
      class OF extends Ow {
        constructor(e, t, i, r) {
          super(),
            (this.templateRef = e),
            (this.viewContainerRef = t),
            (this.context = i),
            (this.injector = r);
        }
        get origin() {
          return this.templateRef.elementRef;
        }
        attach(e, t = this.context) {
          return (this.context = t), super.attach(e);
        }
        detach() {
          return (this.context = void 0), super.detach();
        }
      }
      class cee extends Ow {
        constructor(e) {
          super(), (this.element = e instanceof rn ? e.nativeElement : e);
        }
      }
      class uee {
        constructor() {
          (this._isDisposed = !1), (this.attachDomPortal = null);
        }
        hasAttached() {
          return !!this._attachedPortal;
        }
        attach(e) {
          return e instanceof lee
            ? ((this._attachedPortal = e), this.attachComponentPortal(e))
            : e instanceof OF
            ? ((this._attachedPortal = e), this.attachTemplatePortal(e))
            : this.attachDomPortal && e instanceof cee
            ? ((this._attachedPortal = e), this.attachDomPortal(e))
            : void 0;
        }
        detach() {
          this._attachedPortal &&
            (this._attachedPortal.setAttachedHost(null),
            (this._attachedPortal = null)),
            this._invokeDisposeFn();
        }
        dispose() {
          this.hasAttached() && this.detach(),
            this._invokeDisposeFn(),
            (this._isDisposed = !0);
        }
        setDisposeFn(e) {
          this._disposeFn = e;
        }
        _invokeDisposeFn() {
          this._disposeFn && (this._disposeFn(), (this._disposeFn = null));
        }
      }
      class dee extends uee {
        constructor(e, t, i, r, s) {
          super(),
            (this.outletElement = e),
            (this._componentFactoryResolver = t),
            (this._appRef = i),
            (this._defaultInjector = r),
            (this.attachDomPortal = (o) => {
              const a = o.element,
                l = this._document.createComment("dom-portal");
              a.parentNode.insertBefore(l, a),
                this.outletElement.appendChild(a),
                (this._attachedPortal = o),
                super.setDisposeFn(() => {
                  l.parentNode && l.parentNode.replaceChild(a, l);
                });
            }),
            (this._document = s);
        }
        attachComponentPortal(e) {
          const i = (
            e.componentFactoryResolver || this._componentFactoryResolver
          ).resolveComponentFactory(e.component);
          let r;
          return (
            e.viewContainerRef
              ? ((r = e.viewContainerRef.createComponent(
                  i,
                  e.viewContainerRef.length,
                  e.injector || e.viewContainerRef.injector,
                  e.projectableNodes || void 0
                )),
                this.setDisposeFn(() => r.destroy()))
              : ((r = i.create(e.injector || this._defaultInjector || Qi.NULL)),
                this._appRef.attachView(r.hostView),
                this.setDisposeFn(() => {
                  this._appRef.viewCount > 0 &&
                    this._appRef.detachView(r.hostView),
                    r.destroy();
                })),
            this.outletElement.appendChild(this._getComponentRootNode(r)),
            (this._attachedPortal = e),
            r
          );
        }
        attachTemplatePortal(e) {
          let t = e.viewContainerRef,
            i = t.createEmbeddedView(e.templateRef, e.context, {
              injector: e.injector,
            });
          return (
            i.rootNodes.forEach((r) => this.outletElement.appendChild(r)),
            i.detectChanges(),
            this.setDisposeFn(() => {
              let r = t.indexOf(i);
              -1 !== r && t.remove(r);
            }),
            (this._attachedPortal = e),
            i
          );
        }
        dispose() {
          super.dispose(), this.outletElement.remove();
        }
        _getComponentRootNode(e) {
          return e.hostView.rootNodes[0];
        }
      }
      let hee = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = _n({ type: n })),
          (n.ɵinj = cn({})),
          n
        );
      })();
      class LF {}
      class fee {}
      const go = "*";
      function Lw(n, e) {
        return { type: 7, name: n, definitions: e, options: {} };
      }
      function Nh(n, e = null) {
        return { type: 4, styles: e, timings: n };
      }
      function FF(n, e = null) {
        return { type: 2, steps: n, options: e };
      }
      function _o(n) {
        return { type: 6, styles: n, offset: null };
      }
      function Bg(n, e, t) {
        return { type: 0, name: n, styles: e, options: t };
      }
      function kh(n, e, t = null) {
        return { type: 1, expr: n, animation: e, options: t };
      }
      function NF(n) {
        Promise.resolve().then(n);
      }
      class Bh {
        constructor(e = 0, t = 0) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this._started = !1),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._position = 0),
            (this.parentPlayer = null),
            (this.totalTime = e + t);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        init() {}
        play() {
          this.hasStarted() || (this._onStart(), this.triggerMicrotask()),
            (this._started = !0);
        }
        triggerMicrotask() {
          NF(() => this._onFinish());
        }
        _onStart() {
          this._onStartFns.forEach((e) => e()), (this._onStartFns = []);
        }
        pause() {}
        restart() {}
        finish() {
          this._onFinish();
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.hasStarted() || this._onStart(),
            this.finish(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          (this._started = !1),
            (this._finished = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        setPosition(e) {
          this._position = this.totalTime ? e * this.totalTime : 1;
        }
        getPosition() {
          return this.totalTime ? this._position / this.totalTime : 1;
        }
        triggerCallback(e) {
          const t = "start" == e ? this._onStartFns : this._onDoneFns;
          t.forEach((i) => i()), (t.length = 0);
        }
      }
      class kF {
        constructor(e) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._onDestroyFns = []),
            (this.parentPlayer = null),
            (this.totalTime = 0),
            (this.players = e);
          let t = 0,
            i = 0,
            r = 0;
          const s = this.players.length;
          0 == s
            ? NF(() => this._onFinish())
            : this.players.forEach((o) => {
                o.onDone(() => {
                  ++t == s && this._onFinish();
                }),
                  o.onDestroy(() => {
                    ++i == s && this._onDestroy();
                  }),
                  o.onStart(() => {
                    ++r == s && this._onStart();
                  });
              }),
            (this.totalTime = this.players.reduce(
              (o, a) => Math.max(o, a.totalTime),
              0
            ));
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this.players.forEach((e) => e.init());
        }
        onStart(e) {
          this._onStartFns.push(e);
        }
        _onStart() {
          this.hasStarted() ||
            ((this._started = !0),
            this._onStartFns.forEach((e) => e()),
            (this._onStartFns = []));
        }
        onDone(e) {
          this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this.parentPlayer || this.init(),
            this._onStart(),
            this.players.forEach((e) => e.play());
        }
        pause() {
          this.players.forEach((e) => e.pause());
        }
        restart() {
          this.players.forEach((e) => e.restart());
        }
        finish() {
          this._onFinish(), this.players.forEach((e) => e.finish());
        }
        destroy() {
          this._onDestroy();
        }
        _onDestroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._onFinish(),
            this.players.forEach((e) => e.destroy()),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          this.players.forEach((e) => e.reset()),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1);
        }
        setPosition(e) {
          const t = e * this.totalTime;
          this.players.forEach((i) => {
            const r = i.totalTime ? Math.min(1, t / i.totalTime) : 1;
            i.setPosition(r);
          });
        }
        getPosition() {
          const e = this.players.reduce(
            (t, i) => (null === t || i.totalTime > t.totalTime ? i : t),
            null
          );
          return null != e ? e.getPosition() : 0;
        }
        beforeDestroy() {
          this.players.forEach((e) => {
            e.beforeDestroy && e.beforeDestroy();
          });
        }
        triggerCallback(e) {
          const t = "start" == e ? this._onStartFns : this._onDoneFns;
          t.forEach((i) => i()), (t.length = 0);
        }
      }
      const Fw = "!",
        pee = ["addListener", "removeListener"],
        mee = ["addEventListener", "removeEventListener"],
        gee = ["on", "off"];
      function Ug(n, e, t, i) {
        if ((Ot(t) && ((i = t), (t = void 0)), i))
          return Ug(n, e, t).pipe(C0(i));
        const [r, s] = (function yee(n) {
          return Ot(n.addEventListener) && Ot(n.removeEventListener);
        })(n)
          ? mee.map((o) => (a) => n[o](e, a, t))
          : (function _ee(n) {
              return Ot(n.addListener) && Ot(n.removeListener);
            })(n)
          ? pee.map(BF(n, e))
          : (function vee(n) {
              return Ot(n.on) && Ot(n.off);
            })(n)
          ? gee.map(BF(n, e))
          : [];
        if (!r && E_(n)) return Un((o) => Ug(o, e, t))(di(n));
        if (!r) throw new TypeError("Invalid event target");
        return new Kt((o) => {
          const a = (...l) => o.next(1 < l.length ? l : l[0]);
          return r(a), () => s(a);
        });
      }
      function BF(n, e) {
        return (t) => (i) => n[t](e, i);
      }
      const Uh = {
          schedule(n) {
            let e = requestAnimationFrame,
              t = cancelAnimationFrame;
            const { delegate: i } = Uh;
            i && ((e = i.requestAnimationFrame), (t = i.cancelAnimationFrame));
            const r = e((s) => {
              (t = void 0), n(s);
            });
            return new Sn(() => t?.(r));
          },
          requestAnimationFrame(...n) {
            const { delegate: e } = Uh;
            return (e?.requestAnimationFrame || requestAnimationFrame)(...n);
          },
          cancelAnimationFrame(...n) {
            const { delegate: e } = Uh;
            return (e?.cancelAnimationFrame || cancelAnimationFrame)(...n);
          },
          delegate: void 0,
        },
        wee = new (class xee extends Ew {
          flush(e) {
            this._active = !0;
            const t = this._scheduled;
            this._scheduled = void 0;
            const { actions: i } = this;
            let r;
            e = e || i.shift();
            do {
              if ((r = e.execute(e.state, e.delay))) break;
            } while ((e = i[0]) && e.id === t && i.shift());
            if (((this._active = !1), r)) {
              for (; (e = i[0]) && e.id === t && i.shift(); ) e.unsubscribe();
              throw r;
            }
          }
        })(
          class bee extends Sw {
            constructor(e, t) {
              super(e, t), (this.scheduler = e), (this.work = t);
            }
            requestAsyncId(e, t, i = 0) {
              return null !== i && i > 0
                ? super.requestAsyncId(e, t, i)
                : (e.actions.push(this),
                  e._scheduled ||
                    (e._scheduled = Uh.requestAnimationFrame(() =>
                      e.flush(void 0)
                    )));
            }
            recycleAsyncId(e, t, i = 0) {
              var r;
              if (null != i ? i > 0 : this.delay > 0)
                return super.recycleAsyncId(e, t, i);
              const { actions: s } = e;
              null != t &&
                (null === (r = s[s.length - 1]) || void 0 === r
                  ? void 0
                  : r.id) !== t &&
                (Uh.cancelAnimationFrame(t), (e._scheduled = void 0));
            }
          }
        );
      function Nw(n, e = Og) {
        return (function Mee(n) {
          return ln((e, t) => {
            let i = !1,
              r = null,
              s = null,
              o = !1;
            const a = () => {
                if ((s?.unsubscribe(), (s = null), i)) {
                  i = !1;
                  const c = r;
                  (r = null), t.next(c);
                }
                o && t.complete();
              },
              l = () => {
                (s = null), o && t.complete();
              };
            e.subscribe(
              en(
                t,
                (c) => {
                  (i = !0), (r = c), s || di(n(c)).subscribe((s = en(t, a, l)));
                },
                () => {
                  (o = !0), (!i || !s || s.closed) && t.complete();
                }
              )
            );
          });
        })(() => xF(n, e));
      }
      const See = ["contentWrapper"],
        Eee = ["*"],
        Cee = new ye("VIRTUAL_SCROLL_STRATEGY");
      let Vg = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngZone = t),
                (this._platform = i),
                (this._scrolled = new kt()),
                (this._globalSubscription = null),
                (this._scrolledCount = 0),
                (this.scrollContainers = new Map()),
                (this._document = r);
            }
            register(t) {
              this.scrollContainers.has(t) ||
                this.scrollContainers.set(
                  t,
                  t.elementScrolled().subscribe(() => this._scrolled.next(t))
                );
            }
            deregister(t) {
              const i = this.scrollContainers.get(t);
              i && (i.unsubscribe(), this.scrollContainers.delete(t));
            }
            scrolled(t = 20) {
              return this._platform.isBrowser
                ? new Kt((i) => {
                    this._globalSubscription || this._addGlobalListener();
                    const r =
                      t > 0
                        ? this._scrolled.pipe(Nw(t)).subscribe(i)
                        : this._scrolled.subscribe(i);
                    return (
                      this._scrolledCount++,
                      () => {
                        r.unsubscribe(),
                          this._scrolledCount--,
                          this._scrolledCount || this._removeGlobalListener();
                      }
                    );
                  })
                : Ge();
            }
            ngOnDestroy() {
              this._removeGlobalListener(),
                this.scrollContainers.forEach((t, i) => this.deregister(i)),
                this._scrolled.complete();
            }
            ancestorScrolled(t, i) {
              const r = this.getAncestorScrollContainers(t);
              return this.scrolled(i).pipe(_i((s) => !s || r.indexOf(s) > -1));
            }
            getAncestorScrollContainers(t) {
              const i = [];
              return (
                this.scrollContainers.forEach((r, s) => {
                  this._scrollableContainsElement(s, t) && i.push(s);
                }),
                i
              );
            }
            _getWindow() {
              return this._document.defaultView || window;
            }
            _scrollableContainsElement(t, i) {
              let r = vu(i),
                s = t.getElementRef().nativeElement;
              do {
                if (r == s) return !0;
              } while ((r = r.parentElement));
              return !1;
            }
            _addGlobalListener() {
              this._globalSubscription = this._ngZone.runOutsideAngular(() =>
                Ug(this._getWindow().document, "scroll").subscribe(() =>
                  this._scrolled.next()
                )
              );
            }
            _removeGlobalListener() {
              this._globalSubscription &&
                (this._globalSubscription.unsubscribe(),
                (this._globalSubscription = null));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(wt), re(ss), re(Lt, 8));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        UF = (() => {
          class n {
            constructor(t, i, r, s) {
              (this.elementRef = t),
                (this.scrollDispatcher = i),
                (this.ngZone = r),
                (this.dir = s),
                (this._destroyed = new kt()),
                (this._elementScrolled = new Kt((o) =>
                  this.ngZone.runOutsideAngular(() =>
                    Ug(this.elementRef.nativeElement, "scroll")
                      .pipe(Jo(this._destroyed))
                      .subscribe(o)
                  )
                ));
            }
            ngOnInit() {
              this.scrollDispatcher.register(this);
            }
            ngOnDestroy() {
              this.scrollDispatcher.deregister(this),
                this._destroyed.next(),
                this._destroyed.complete();
            }
            elementScrolled() {
              return this._elementScrolled;
            }
            getElementRef() {
              return this.elementRef;
            }
            scrollTo(t) {
              const i = this.elementRef.nativeElement,
                r = this.dir && "rtl" == this.dir.value;
              null == t.left && (t.left = r ? t.end : t.start),
                null == t.right && (t.right = r ? t.start : t.end),
                null != t.bottom &&
                  (t.top = i.scrollHeight - i.clientHeight - t.bottom),
                r && 0 != Ih()
                  ? (null != t.left &&
                      (t.right = i.scrollWidth - i.clientWidth - t.left),
                    2 == Ih()
                      ? (t.left = t.right)
                      : 1 == Ih() && (t.left = t.right ? -t.right : t.right))
                  : null != t.right &&
                    (t.left = i.scrollWidth - i.clientWidth - t.right),
                this._applyScrollToOptions(t);
            }
            _applyScrollToOptions(t) {
              const i = this.elementRef.nativeElement;
              rF()
                ? i.scrollTo(t)
                : (null != t.top && (i.scrollTop = t.top),
                  null != t.left && (i.scrollLeft = t.left));
            }
            measureScrollOffset(t) {
              const i = "left",
                r = "right",
                s = this.elementRef.nativeElement;
              if ("top" == t) return s.scrollTop;
              if ("bottom" == t)
                return s.scrollHeight - s.clientHeight - s.scrollTop;
              const o = this.dir && "rtl" == this.dir.value;
              return (
                "start" == t ? (t = o ? r : i) : "end" == t && (t = o ? i : r),
                o && 2 == Ih()
                  ? t == i
                    ? s.scrollWidth - s.clientWidth - s.scrollLeft
                    : s.scrollLeft
                  : o && 1 == Ih()
                  ? t == i
                    ? s.scrollLeft + s.scrollWidth - s.clientWidth
                    : -s.scrollLeft
                  : t == i
                  ? s.scrollLeft
                  : s.scrollWidth - s.clientWidth - s.scrollLeft
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(G(rn), G(Vg), G(wt), G(Ph, 8));
            }),
            (n.ɵdir = He({
              type: n,
              selectors: [
                ["", "cdk-scrollable", ""],
                ["", "cdkScrollable", ""],
              ],
              standalone: !0,
            })),
            n
          );
        })(),
        kw = (() => {
          class n {
            constructor(t, i, r) {
              (this._platform = t),
                (this._change = new kt()),
                (this._changeListener = (s) => {
                  this._change.next(s);
                }),
                (this._document = r),
                i.runOutsideAngular(() => {
                  if (t.isBrowser) {
                    const s = this._getWindow();
                    s.addEventListener("resize", this._changeListener),
                      s.addEventListener(
                        "orientationchange",
                        this._changeListener
                      );
                  }
                  this.change().subscribe(() => (this._viewportSize = null));
                });
            }
            ngOnDestroy() {
              if (this._platform.isBrowser) {
                const t = this._getWindow();
                t.removeEventListener("resize", this._changeListener),
                  t.removeEventListener(
                    "orientationchange",
                    this._changeListener
                  );
              }
              this._change.complete();
            }
            getViewportSize() {
              this._viewportSize || this._updateViewportSize();
              const t = {
                width: this._viewportSize.width,
                height: this._viewportSize.height,
              };
              return this._platform.isBrowser || (this._viewportSize = null), t;
            }
            getViewportRect() {
              const t = this.getViewportScrollPosition(),
                { width: i, height: r } = this.getViewportSize();
              return {
                top: t.top,
                left: t.left,
                bottom: t.top + r,
                right: t.left + i,
                height: r,
                width: i,
              };
            }
            getViewportScrollPosition() {
              if (!this._platform.isBrowser) return { top: 0, left: 0 };
              const t = this._document,
                i = this._getWindow(),
                r = t.documentElement,
                s = r.getBoundingClientRect();
              return {
                top:
                  -s.top || t.body.scrollTop || i.scrollY || r.scrollTop || 0,
                left:
                  -s.left ||
                  t.body.scrollLeft ||
                  i.scrollX ||
                  r.scrollLeft ||
                  0,
              };
            }
            change(t = 20) {
              return t > 0 ? this._change.pipe(Nw(t)) : this._change;
            }
            _getWindow() {
              return this._document.defaultView || window;
            }
            _updateViewportSize() {
              const t = this._getWindow();
              this._viewportSize = this._platform.isBrowser
                ? { width: t.innerWidth, height: t.innerHeight }
                : { width: 0, height: 0 };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(ss), re(wt), re(Lt, 8));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      const VF = new ye("VIRTUAL_SCROLLABLE");
      let Dee = (() => {
        class n extends UF {
          constructor(t, i, r, s) {
            super(t, i, r, s);
          }
          measureViewportSize(t) {
            const i = this.elementRef.nativeElement;
            return "horizontal" === t ? i.clientWidth : i.clientHeight;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(rn), G(Vg), G(wt), G(Ph, 8));
          }),
          (n.ɵdir = He({ type: n, features: [St] })),
          n
        );
      })();
      const Ree = typeof requestAnimationFrame < "u" ? wee : Rw;
      let Pee = (() => {
          class n extends Dee {
            get orientation() {
              return this._orientation;
            }
            set orientation(t) {
              this._orientation !== t &&
                ((this._orientation = t), this._calculateSpacerSize());
            }
            get appendOnly() {
              return this._appendOnly;
            }
            set appendOnly(t) {
              this._appendOnly = $a(t);
            }
            constructor(t, i, r, s, o, a, l, c) {
              super(t, a, r, o),
                (this.elementRef = t),
                (this._changeDetectorRef = i),
                (this._scrollStrategy = s),
                (this.scrollable = c),
                (this._platform = ft(ss)),
                (this._detachedSubject = new kt()),
                (this._renderedRangeSubject = new kt()),
                (this._orientation = "vertical"),
                (this._appendOnly = !1),
                (this.scrolledIndexChange = new Kt((u) =>
                  this._scrollStrategy.scrolledIndexChange.subscribe((d) =>
                    Promise.resolve().then(() =>
                      this.ngZone.run(() => u.next(d))
                    )
                  )
                )),
                (this.renderedRangeStream = this._renderedRangeSubject),
                (this._totalContentSize = 0),
                (this._totalContentWidth = ""),
                (this._totalContentHeight = ""),
                (this._renderedRange = { start: 0, end: 0 }),
                (this._dataLength = 0),
                (this._viewportSize = 0),
                (this._renderedContentOffset = 0),
                (this._renderedContentOffsetNeedsRewrite = !1),
                (this._isChangeDetectionPending = !1),
                (this._runAfterChangeDetection = []),
                (this._viewportChanges = Sn.EMPTY),
                (this._viewportChanges = l.change().subscribe(() => {
                  this.checkViewportSize();
                })),
                this.scrollable ||
                  (this.elementRef.nativeElement.classList.add(
                    "cdk-virtual-scrollable"
                  ),
                  (this.scrollable = this));
            }
            ngOnInit() {
              this._platform.isBrowser &&
                (this.scrollable === this && super.ngOnInit(),
                this.ngZone.runOutsideAngular(() =>
                  Promise.resolve().then(() => {
                    this._measureViewportSize(),
                      this._scrollStrategy.attach(this),
                      this.scrollable
                        .elementScrolled()
                        .pipe(tc(null), Nw(0, Ree))
                        .subscribe(() =>
                          this._scrollStrategy.onContentScrolled()
                        ),
                      this._markChangeDetectionNeeded();
                  })
                ));
            }
            ngOnDestroy() {
              this.detach(),
                this._scrollStrategy.detach(),
                this._renderedRangeSubject.complete(),
                this._detachedSubject.complete(),
                this._viewportChanges.unsubscribe(),
                super.ngOnDestroy();
            }
            attach(t) {
              this.ngZone.runOutsideAngular(() => {
                (this._forOf = t),
                  this._forOf.dataStream
                    .pipe(Jo(this._detachedSubject))
                    .subscribe((i) => {
                      const r = i.length;
                      r !== this._dataLength &&
                        ((this._dataLength = r),
                        this._scrollStrategy.onDataLengthChanged()),
                        this._doChangeDetection();
                    });
              });
            }
            detach() {
              (this._forOf = null), this._detachedSubject.next();
            }
            getDataLength() {
              return this._dataLength;
            }
            getViewportSize() {
              return this._viewportSize;
            }
            getRenderedRange() {
              return this._renderedRange;
            }
            measureBoundingClientRectWithScrollOffset(t) {
              return this.getElementRef().nativeElement.getBoundingClientRect()[
                t
              ];
            }
            setTotalContentSize(t) {
              this._totalContentSize !== t &&
                ((this._totalContentSize = t),
                this._calculateSpacerSize(),
                this._markChangeDetectionNeeded());
            }
            setRenderedRange(t) {
              (function Iee(n, e) {
                return n.start == e.start && n.end == e.end;
              })(this._renderedRange, t) ||
                (this.appendOnly &&
                  (t = {
                    start: 0,
                    end: Math.max(this._renderedRange.end, t.end),
                  }),
                this._renderedRangeSubject.next((this._renderedRange = t)),
                this._markChangeDetectionNeeded(() =>
                  this._scrollStrategy.onContentRendered()
                ));
            }
            getOffsetToRenderedContentStart() {
              return this._renderedContentOffsetNeedsRewrite
                ? null
                : this._renderedContentOffset;
            }
            setRenderedContentOffset(t, i = "to-start") {
              t = this.appendOnly && "to-start" === i ? 0 : t;
              const s = "horizontal" == this.orientation,
                o = s ? "X" : "Y";
              let l = `translate${o}(${Number(
                (s && this.dir && "rtl" == this.dir.value ? -1 : 1) * t
              )}px)`;
              (this._renderedContentOffset = t),
                "to-end" === i &&
                  ((l += ` translate${o}(-100%)`),
                  (this._renderedContentOffsetNeedsRewrite = !0)),
                this._renderedContentTransform != l &&
                  ((this._renderedContentTransform = l),
                  this._markChangeDetectionNeeded(() => {
                    this._renderedContentOffsetNeedsRewrite
                      ? ((this._renderedContentOffset -=
                          this.measureRenderedContentSize()),
                        (this._renderedContentOffsetNeedsRewrite = !1),
                        this.setRenderedContentOffset(
                          this._renderedContentOffset
                        ))
                      : this._scrollStrategy.onRenderedOffsetChanged();
                  }));
            }
            scrollToOffset(t, i = "auto") {
              const r = { behavior: i };
              "horizontal" === this.orientation ? (r.start = t) : (r.top = t),
                this.scrollable.scrollTo(r);
            }
            scrollToIndex(t, i = "auto") {
              this._scrollStrategy.scrollToIndex(t, i);
            }
            measureScrollOffset(t) {
              let i;
              return (
                (i =
                  this.scrollable == this
                    ? (r) => super.measureScrollOffset(r)
                    : (r) => this.scrollable.measureScrollOffset(r)),
                Math.max(
                  0,
                  i(
                    t ?? ("horizontal" === this.orientation ? "start" : "top")
                  ) - this.measureViewportOffset()
                )
              );
            }
            measureViewportOffset(t) {
              let i;
              const r = "left",
                s = "right",
                o = "rtl" == this.dir?.value;
              i =
                "start" == t
                  ? o
                    ? s
                    : r
                  : "end" == t
                  ? o
                    ? r
                    : s
                  : t || ("horizontal" === this.orientation ? "left" : "top");
              const a =
                this.scrollable.measureBoundingClientRectWithScrollOffset(i);
              return (
                this.elementRef.nativeElement.getBoundingClientRect()[i] - a
              );
            }
            measureRenderedContentSize() {
              const t = this._contentWrapper.nativeElement;
              return "horizontal" === this.orientation
                ? t.offsetWidth
                : t.offsetHeight;
            }
            measureRangeSize(t) {
              return this._forOf
                ? this._forOf.measureRangeSize(t, this.orientation)
                : 0;
            }
            checkViewportSize() {
              this._measureViewportSize(),
                this._scrollStrategy.onDataLengthChanged();
            }
            _measureViewportSize() {
              this._viewportSize = this.scrollable.measureViewportSize(
                this.orientation
              );
            }
            _markChangeDetectionNeeded(t) {
              t && this._runAfterChangeDetection.push(t),
                this._isChangeDetectionPending ||
                  ((this._isChangeDetectionPending = !0),
                  this.ngZone.runOutsideAngular(() =>
                    Promise.resolve().then(() => {
                      this._doChangeDetection();
                    })
                  ));
            }
            _doChangeDetection() {
              (this._isChangeDetectionPending = !1),
                (this._contentWrapper.nativeElement.style.transform =
                  this._renderedContentTransform),
                this.ngZone.run(() => this._changeDetectorRef.markForCheck());
              const t = this._runAfterChangeDetection;
              this._runAfterChangeDetection = [];
              for (const i of t) i();
            }
            _calculateSpacerSize() {
              (this._totalContentHeight =
                "horizontal" === this.orientation
                  ? ""
                  : `${this._totalContentSize}px`),
                (this._totalContentWidth =
                  "horizontal" === this.orientation
                    ? `${this._totalContentSize}px`
                    : "");
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                G(rn),
                G(Ui),
                G(wt),
                G(Cee, 8),
                G(Ph, 8),
                G(Vg),
                G(kw),
                G(VF, 8)
              );
            }),
            (n.ɵcmp = Xi({
              type: n,
              selectors: [["cdk-virtual-scroll-viewport"]],
              viewQuery: function (t, i) {
                if ((1 & t && jr(See, 7), 2 & t)) {
                  let r;
                  Ei((r = Ci())) && (i._contentWrapper = r.first);
                }
              },
              hostAttrs: [1, "cdk-virtual-scroll-viewport"],
              hostVars: 4,
              hostBindings: function (t, i) {
                2 & t &&
                  gs(
                    "cdk-virtual-scroll-orientation-horizontal",
                    "horizontal" === i.orientation
                  )(
                    "cdk-virtual-scroll-orientation-vertical",
                    "horizontal" !== i.orientation
                  );
              },
              inputs: { orientation: "orientation", appendOnly: "appendOnly" },
              outputs: { scrolledIndexChange: "scrolledIndexChange" },
              standalone: !0,
              features: [
                qt([
                  {
                    provide: UF,
                    useFactory: (e, t) => e || t,
                    deps: [[new Ml(), new Rf(VF)], n],
                  },
                ]),
                St,
                Sy,
              ],
              ngContentSelectors: Eee,
              decls: 4,
              vars: 4,
              consts: [
                [1, "cdk-virtual-scroll-content-wrapper"],
                ["contentWrapper", ""],
                [1, "cdk-virtual-scroll-spacer"],
              ],
              template: function (t, i) {
                1 & t &&
                  (rd(), Se(0, "div", 0, 1), Gl(2), Re(), Gt(3, "div", 2)),
                  2 & t &&
                    (je(3),
                    tp("width", i._totalContentWidth)(
                      "height",
                      i._totalContentHeight
                    ));
              },
              styles: [
                "cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}",
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        Vh = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({})),
            n
          );
        })(),
        zF = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ imports: [Oh, Vh, Pee, Oh, Vh] })),
            n
          );
        })();
      const HF = rF();
      class Oee {
        constructor(e, t) {
          (this._viewportRuler = e),
            (this._previousHTMLStyles = { top: "", left: "" }),
            (this._isEnabled = !1),
            (this._document = t);
        }
        attach() {}
        enable() {
          if (this._canBeEnabled()) {
            const e = this._document.documentElement;
            (this._previousScrollPosition =
              this._viewportRuler.getViewportScrollPosition()),
              (this._previousHTMLStyles.left = e.style.left || ""),
              (this._previousHTMLStyles.top = e.style.top || ""),
              (e.style.left = kn(-this._previousScrollPosition.left)),
              (e.style.top = kn(-this._previousScrollPosition.top)),
              e.classList.add("cdk-global-scrollblock"),
              (this._isEnabled = !0);
          }
        }
        disable() {
          if (this._isEnabled) {
            const e = this._document.documentElement,
              i = e.style,
              r = this._document.body.style,
              s = i.scrollBehavior || "",
              o = r.scrollBehavior || "";
            (this._isEnabled = !1),
              (i.left = this._previousHTMLStyles.left),
              (i.top = this._previousHTMLStyles.top),
              e.classList.remove("cdk-global-scrollblock"),
              HF && (i.scrollBehavior = r.scrollBehavior = "auto"),
              window.scroll(
                this._previousScrollPosition.left,
                this._previousScrollPosition.top
              ),
              HF && ((i.scrollBehavior = s), (r.scrollBehavior = o));
          }
        }
        _canBeEnabled() {
          if (
            this._document.documentElement.classList.contains(
              "cdk-global-scrollblock"
            ) ||
            this._isEnabled
          )
            return !1;
          const t = this._document.body,
            i = this._viewportRuler.getViewportSize();
          return t.scrollHeight > i.height || t.scrollWidth > i.width;
        }
      }
      class Lee {
        constructor(e, t, i, r) {
          (this._scrollDispatcher = e),
            (this._ngZone = t),
            (this._viewportRuler = i),
            (this._config = r),
            (this._scrollSubscription = null),
            (this._detach = () => {
              this.disable(),
                this._overlayRef.hasAttached() &&
                  this._ngZone.run(() => this._overlayRef.detach());
            });
        }
        attach(e) {
          this._overlayRef = e;
        }
        enable() {
          if (this._scrollSubscription) return;
          const e = this._scrollDispatcher
            .scrolled(0)
            .pipe(
              _i(
                (t) =>
                  !t ||
                  !this._overlayRef.overlayElement.contains(
                    t.getElementRef().nativeElement
                  )
              )
            );
          this._config && this._config.threshold && this._config.threshold > 1
            ? ((this._initialScrollPosition =
                this._viewportRuler.getViewportScrollPosition().top),
              (this._scrollSubscription = e.subscribe(() => {
                const t = this._viewportRuler.getViewportScrollPosition().top;
                Math.abs(t - this._initialScrollPosition) >
                this._config.threshold
                  ? this._detach()
                  : this._overlayRef.updatePosition();
              })))
            : (this._scrollSubscription = e.subscribe(this._detach));
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null));
        }
        detach() {
          this.disable(), (this._overlayRef = null);
        }
      }
      class GF {
        enable() {}
        disable() {}
        attach() {}
      }
      function Bw(n, e) {
        return e.some(
          (t) =>
            n.bottom < t.top ||
            n.top > t.bottom ||
            n.right < t.left ||
            n.left > t.right
        );
      }
      function WF(n, e) {
        return e.some(
          (t) =>
            n.top < t.top ||
            n.bottom > t.bottom ||
            n.left < t.left ||
            n.right > t.right
        );
      }
      class Fee {
        constructor(e, t, i, r) {
          (this._scrollDispatcher = e),
            (this._viewportRuler = t),
            (this._ngZone = i),
            (this._config = r),
            (this._scrollSubscription = null);
        }
        attach(e) {
          this._overlayRef = e;
        }
        enable() {
          this._scrollSubscription ||
            (this._scrollSubscription = this._scrollDispatcher
              .scrolled(this._config ? this._config.scrollThrottle : 0)
              .subscribe(() => {
                if (
                  (this._overlayRef.updatePosition(),
                  this._config && this._config.autoClose)
                ) {
                  const t =
                      this._overlayRef.overlayElement.getBoundingClientRect(),
                    { width: i, height: r } =
                      this._viewportRuler.getViewportSize();
                  Bw(t, [
                    {
                      width: i,
                      height: r,
                      bottom: r,
                      right: i,
                      top: 0,
                      left: 0,
                    },
                  ]) &&
                    (this.disable(),
                    this._ngZone.run(() => this._overlayRef.detach()));
                }
              }));
        }
        disable() {
          this._scrollSubscription &&
            (this._scrollSubscription.unsubscribe(),
            (this._scrollSubscription = null));
        }
        detach() {
          this.disable(), (this._overlayRef = null);
        }
      }
      let Nee = (() => {
        class n {
          constructor(t, i, r, s) {
            (this._scrollDispatcher = t),
              (this._viewportRuler = i),
              (this._ngZone = r),
              (this.noop = () => new GF()),
              (this.close = (o) =>
                new Lee(
                  this._scrollDispatcher,
                  this._ngZone,
                  this._viewportRuler,
                  o
                )),
              (this.block = () => new Oee(this._viewportRuler, this._document)),
              (this.reposition = (o) =>
                new Fee(
                  this._scrollDispatcher,
                  this._viewportRuler,
                  this._ngZone,
                  o
                )),
              (this._document = s);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re(Vg), re(kw), re(wt), re(Lt));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      class jF {
        constructor(e) {
          if (
            ((this.scrollStrategy = new GF()),
            (this.panelClass = ""),
            (this.hasBackdrop = !1),
            (this.backdropClass = "cdk-overlay-dark-backdrop"),
            (this.disposeOnNavigation = !1),
            e)
          ) {
            const t = Object.keys(e);
            for (const i of t) void 0 !== e[i] && (this[i] = e[i]);
          }
        }
      }
      class kee {
        constructor(e, t) {
          (this.connectionPair = e), (this.scrollableViewProperties = t);
        }
      }
      let XF = (() => {
          class n {
            constructor(t) {
              (this._attachedOverlays = []), (this._document = t);
            }
            ngOnDestroy() {
              this.detach();
            }
            add(t) {
              this.remove(t), this._attachedOverlays.push(t);
            }
            remove(t) {
              const i = this._attachedOverlays.indexOf(t);
              i > -1 && this._attachedOverlays.splice(i, 1),
                0 === this._attachedOverlays.length && this.detach();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Lt));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        Bee = (() => {
          class n extends XF {
            constructor(t, i) {
              super(t),
                (this._ngZone = i),
                (this._keydownListener = (r) => {
                  const s = this._attachedOverlays;
                  for (let o = s.length - 1; o > -1; o--)
                    if (s[o]._keydownEvents.observers.length > 0) {
                      const a = s[o]._keydownEvents;
                      this._ngZone
                        ? this._ngZone.run(() => a.next(r))
                        : a.next(r);
                      break;
                    }
                });
            }
            add(t) {
              super.add(t),
                this._isAttached ||
                  (this._ngZone
                    ? this._ngZone.runOutsideAngular(() =>
                        this._document.body.addEventListener(
                          "keydown",
                          this._keydownListener
                        )
                      )
                    : this._document.body.addEventListener(
                        "keydown",
                        this._keydownListener
                      ),
                  (this._isAttached = !0));
            }
            detach() {
              this._isAttached &&
                (this._document.body.removeEventListener(
                  "keydown",
                  this._keydownListener
                ),
                (this._isAttached = !1));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Lt), re(wt, 8));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        Uee = (() => {
          class n extends XF {
            constructor(t, i, r) {
              super(t),
                (this._platform = i),
                (this._ngZone = r),
                (this._cursorStyleIsSet = !1),
                (this._pointerDownListener = (s) => {
                  this._pointerDownEventTarget = Qo(s);
                }),
                (this._clickListener = (s) => {
                  const o = Qo(s),
                    a =
                      "click" === s.type && this._pointerDownEventTarget
                        ? this._pointerDownEventTarget
                        : o;
                  this._pointerDownEventTarget = null;
                  const l = this._attachedOverlays.slice();
                  for (let c = l.length - 1; c > -1; c--) {
                    const u = l[c];
                    if (
                      u._outsidePointerEvents.observers.length < 1 ||
                      !u.hasAttached()
                    )
                      continue;
                    if (
                      u.overlayElement.contains(o) ||
                      u.overlayElement.contains(a)
                    )
                      break;
                    const d = u._outsidePointerEvents;
                    this._ngZone
                      ? this._ngZone.run(() => d.next(s))
                      : d.next(s);
                  }
                });
            }
            add(t) {
              if ((super.add(t), !this._isAttached)) {
                const i = this._document.body;
                this._ngZone
                  ? this._ngZone.runOutsideAngular(() =>
                      this._addEventListeners(i)
                    )
                  : this._addEventListeners(i),
                  this._platform.IOS &&
                    !this._cursorStyleIsSet &&
                    ((this._cursorOriginalValue = i.style.cursor),
                    (i.style.cursor = "pointer"),
                    (this._cursorStyleIsSet = !0)),
                  (this._isAttached = !0);
              }
            }
            detach() {
              if (this._isAttached) {
                const t = this._document.body;
                t.removeEventListener(
                  "pointerdown",
                  this._pointerDownListener,
                  !0
                ),
                  t.removeEventListener("click", this._clickListener, !0),
                  t.removeEventListener("auxclick", this._clickListener, !0),
                  t.removeEventListener("contextmenu", this._clickListener, !0),
                  this._platform.IOS &&
                    this._cursorStyleIsSet &&
                    ((t.style.cursor = this._cursorOriginalValue),
                    (this._cursorStyleIsSet = !1)),
                  (this._isAttached = !1);
              }
            }
            _addEventListeners(t) {
              t.addEventListener("pointerdown", this._pointerDownListener, !0),
                t.addEventListener("click", this._clickListener, !0),
                t.addEventListener("auxclick", this._clickListener, !0),
                t.addEventListener("contextmenu", this._clickListener, !0);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Lt), re(ss), re(wt, 8));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        qF = (() => {
          class n {
            constructor(t, i) {
              (this._platform = i), (this._document = t);
            }
            ngOnDestroy() {
              this._containerElement?.remove();
            }
            getContainerElement() {
              return (
                this._containerElement || this._createContainer(),
                this._containerElement
              );
            }
            _createContainer() {
              const t = "cdk-overlay-container";
              if (this._platform.isBrowser || xw()) {
                const r = this._document.querySelectorAll(
                  `.${t}[platform="server"], .${t}[platform="test"]`
                );
                for (let s = 0; s < r.length; s++) r[s].remove();
              }
              const i = this._document.createElement("div");
              i.classList.add(t),
                xw()
                  ? i.setAttribute("platform", "test")
                  : this._platform.isBrowser ||
                    i.setAttribute("platform", "server"),
                this._document.body.appendChild(i),
                (this._containerElement = i);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(Lt), re(ss));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      class Vee {
        constructor(e, t, i, r, s, o, a, l, c, u = !1) {
          (this._portalOutlet = e),
            (this._host = t),
            (this._pane = i),
            (this._config = r),
            (this._ngZone = s),
            (this._keyboardDispatcher = o),
            (this._document = a),
            (this._location = l),
            (this._outsideClickDispatcher = c),
            (this._animationsDisabled = u),
            (this._backdropElement = null),
            (this._backdropClick = new kt()),
            (this._attachments = new kt()),
            (this._detachments = new kt()),
            (this._locationChanges = Sn.EMPTY),
            (this._backdropClickHandler = (d) => this._backdropClick.next(d)),
            (this._backdropTransitionendHandler = (d) => {
              this._disposeBackdrop(d.target);
            }),
            (this._keydownEvents = new kt()),
            (this._outsidePointerEvents = new kt()),
            r.scrollStrategy &&
              ((this._scrollStrategy = r.scrollStrategy),
              this._scrollStrategy.attach(this)),
            (this._positionStrategy = r.positionStrategy);
        }
        get overlayElement() {
          return this._pane;
        }
        get backdropElement() {
          return this._backdropElement;
        }
        get hostElement() {
          return this._host;
        }
        attach(e) {
          !this._host.parentElement &&
            this._previousHostParent &&
            this._previousHostParent.appendChild(this._host);
          const t = this._portalOutlet.attach(e);
          return (
            this._positionStrategy && this._positionStrategy.attach(this),
            this._updateStackingOrder(),
            this._updateElementSize(),
            this._updateElementDirection(),
            this._scrollStrategy && this._scrollStrategy.enable(),
            this._ngZone.onStable.pipe(er(1)).subscribe(() => {
              this.hasAttached() && this.updatePosition();
            }),
            this._togglePointerEvents(!0),
            this._config.hasBackdrop && this._attachBackdrop(),
            this._config.panelClass &&
              this._toggleClasses(this._pane, this._config.panelClass, !0),
            this._attachments.next(),
            this._keyboardDispatcher.add(this),
            this._config.disposeOnNavigation &&
              (this._locationChanges = this._location.subscribe(() =>
                this.dispose()
              )),
            this._outsideClickDispatcher.add(this),
            "function" == typeof t?.onDestroy &&
              t.onDestroy(() => {
                this.hasAttached() &&
                  this._ngZone.runOutsideAngular(() =>
                    Promise.resolve().then(() => this.detach())
                  );
              }),
            t
          );
        }
        detach() {
          if (!this.hasAttached()) return;
          this.detachBackdrop(),
            this._togglePointerEvents(!1),
            this._positionStrategy &&
              this._positionStrategy.detach &&
              this._positionStrategy.detach(),
            this._scrollStrategy && this._scrollStrategy.disable();
          const e = this._portalOutlet.detach();
          return (
            this._detachments.next(),
            this._keyboardDispatcher.remove(this),
            this._detachContentWhenStable(),
            this._locationChanges.unsubscribe(),
            this._outsideClickDispatcher.remove(this),
            e
          );
        }
        dispose() {
          const e = this.hasAttached();
          this._positionStrategy && this._positionStrategy.dispose(),
            this._disposeScrollStrategy(),
            this._disposeBackdrop(this._backdropElement),
            this._locationChanges.unsubscribe(),
            this._keyboardDispatcher.remove(this),
            this._portalOutlet.dispose(),
            this._attachments.complete(),
            this._backdropClick.complete(),
            this._keydownEvents.complete(),
            this._outsidePointerEvents.complete(),
            this._outsideClickDispatcher.remove(this),
            this._host?.remove(),
            (this._previousHostParent = this._pane = this._host = null),
            e && this._detachments.next(),
            this._detachments.complete();
        }
        hasAttached() {
          return this._portalOutlet.hasAttached();
        }
        backdropClick() {
          return this._backdropClick;
        }
        attachments() {
          return this._attachments;
        }
        detachments() {
          return this._detachments;
        }
        keydownEvents() {
          return this._keydownEvents;
        }
        outsidePointerEvents() {
          return this._outsidePointerEvents;
        }
        getConfig() {
          return this._config;
        }
        updatePosition() {
          this._positionStrategy && this._positionStrategy.apply();
        }
        updatePositionStrategy(e) {
          e !== this._positionStrategy &&
            (this._positionStrategy && this._positionStrategy.dispose(),
            (this._positionStrategy = e),
            this.hasAttached() && (e.attach(this), this.updatePosition()));
        }
        updateSize(e) {
          (this._config = { ...this._config, ...e }), this._updateElementSize();
        }
        setDirection(e) {
          (this._config = { ...this._config, direction: e }),
            this._updateElementDirection();
        }
        addPanelClass(e) {
          this._pane && this._toggleClasses(this._pane, e, !0);
        }
        removePanelClass(e) {
          this._pane && this._toggleClasses(this._pane, e, !1);
        }
        getDirection() {
          const e = this._config.direction;
          return e ? ("string" == typeof e ? e : e.value) : "ltr";
        }
        updateScrollStrategy(e) {
          e !== this._scrollStrategy &&
            (this._disposeScrollStrategy(),
            (this._scrollStrategy = e),
            this.hasAttached() && (e.attach(this), e.enable()));
        }
        _updateElementDirection() {
          this._host.setAttribute("dir", this.getDirection());
        }
        _updateElementSize() {
          if (!this._pane) return;
          const e = this._pane.style;
          (e.width = kn(this._config.width)),
            (e.height = kn(this._config.height)),
            (e.minWidth = kn(this._config.minWidth)),
            (e.minHeight = kn(this._config.minHeight)),
            (e.maxWidth = kn(this._config.maxWidth)),
            (e.maxHeight = kn(this._config.maxHeight));
        }
        _togglePointerEvents(e) {
          this._pane.style.pointerEvents = e ? "" : "none";
        }
        _attachBackdrop() {
          const e = "cdk-overlay-backdrop-showing";
          (this._backdropElement = this._document.createElement("div")),
            this._backdropElement.classList.add("cdk-overlay-backdrop"),
            this._animationsDisabled &&
              this._backdropElement.classList.add(
                "cdk-overlay-backdrop-noop-animation"
              ),
            this._config.backdropClass &&
              this._toggleClasses(
                this._backdropElement,
                this._config.backdropClass,
                !0
              ),
            this._host.parentElement.insertBefore(
              this._backdropElement,
              this._host
            ),
            this._backdropElement.addEventListener(
              "click",
              this._backdropClickHandler
            ),
            !this._animationsDisabled && typeof requestAnimationFrame < "u"
              ? this._ngZone.runOutsideAngular(() => {
                  requestAnimationFrame(() => {
                    this._backdropElement &&
                      this._backdropElement.classList.add(e);
                  });
                })
              : this._backdropElement.classList.add(e);
        }
        _updateStackingOrder() {
          this._host.nextSibling &&
            this._host.parentNode.appendChild(this._host);
        }
        detachBackdrop() {
          const e = this._backdropElement;
          if (e) {
            if (this._animationsDisabled) return void this._disposeBackdrop(e);
            e.classList.remove("cdk-overlay-backdrop-showing"),
              this._ngZone.runOutsideAngular(() => {
                e.addEventListener(
                  "transitionend",
                  this._backdropTransitionendHandler
                );
              }),
              (e.style.pointerEvents = "none"),
              (this._backdropTimeout = this._ngZone.runOutsideAngular(() =>
                setTimeout(() => {
                  this._disposeBackdrop(e);
                }, 500)
              ));
          }
        }
        _toggleClasses(e, t, i) {
          const r = Lg(t || []).filter((s) => !!s);
          r.length && (i ? e.classList.add(...r) : e.classList.remove(...r));
        }
        _detachContentWhenStable() {
          this._ngZone.runOutsideAngular(() => {
            const e = this._ngZone.onStable
              .pipe(Jo(Tu(this._attachments, this._detachments)))
              .subscribe(() => {
                (!this._pane ||
                  !this._host ||
                  0 === this._pane.children.length) &&
                  (this._pane &&
                    this._config.panelClass &&
                    this._toggleClasses(
                      this._pane,
                      this._config.panelClass,
                      !1
                    ),
                  this._host &&
                    this._host.parentElement &&
                    ((this._previousHostParent = this._host.parentElement),
                    this._host.remove()),
                  e.unsubscribe());
              });
          });
        }
        _disposeScrollStrategy() {
          const e = this._scrollStrategy;
          e && (e.disable(), e.detach && e.detach());
        }
        _disposeBackdrop(e) {
          e &&
            (e.removeEventListener("click", this._backdropClickHandler),
            e.removeEventListener(
              "transitionend",
              this._backdropTransitionendHandler
            ),
            e.remove(),
            this._backdropElement === e && (this._backdropElement = null)),
            this._backdropTimeout &&
              (clearTimeout(this._backdropTimeout),
              (this._backdropTimeout = void 0));
        }
      }
      const YF = "cdk-overlay-connected-position-bounding-box",
        zee = /([A-Za-z%]+)$/;
      class Hee {
        get positions() {
          return this._preferredPositions;
        }
        constructor(e, t, i, r, s) {
          (this._viewportRuler = t),
            (this._document = i),
            (this._platform = r),
            (this._overlayContainer = s),
            (this._lastBoundingBoxSize = { width: 0, height: 0 }),
            (this._isPushed = !1),
            (this._canPush = !0),
            (this._growAfterOpen = !1),
            (this._hasFlexibleDimensions = !0),
            (this._positionLocked = !1),
            (this._viewportMargin = 0),
            (this._scrollables = []),
            (this._preferredPositions = []),
            (this._positionChanges = new kt()),
            (this._resizeSubscription = Sn.EMPTY),
            (this._offsetX = 0),
            (this._offsetY = 0),
            (this._appliedPanelClasses = []),
            (this.positionChanges = this._positionChanges),
            this.setOrigin(e);
        }
        attach(e) {
          this._validatePositions(),
            e.hostElement.classList.add(YF),
            (this._overlayRef = e),
            (this._boundingBox = e.hostElement),
            (this._pane = e.overlayElement),
            (this._isDisposed = !1),
            (this._isInitialRender = !0),
            (this._lastPosition = null),
            this._resizeSubscription.unsubscribe(),
            (this._resizeSubscription = this._viewportRuler
              .change()
              .subscribe(() => {
                (this._isInitialRender = !0), this.apply();
              }));
        }
        apply() {
          if (this._isDisposed || !this._platform.isBrowser) return;
          if (
            !this._isInitialRender &&
            this._positionLocked &&
            this._lastPosition
          )
            return void this.reapplyLastPosition();
          this._clearPanelClasses(),
            this._resetOverlayElementStyles(),
            this._resetBoundingBoxStyles(),
            (this._viewportRect = this._getNarrowedViewportRect()),
            (this._originRect = this._getOriginRect()),
            (this._overlayRect = this._pane.getBoundingClientRect()),
            (this._containerRect = this._overlayContainer
              .getContainerElement()
              .getBoundingClientRect());
          const e = this._originRect,
            t = this._overlayRect,
            i = this._viewportRect,
            r = this._containerRect,
            s = [];
          let o;
          for (let a of this._preferredPositions) {
            let l = this._getOriginPoint(e, r, a),
              c = this._getOverlayPoint(l, t, a),
              u = this._getOverlayFit(c, t, i, a);
            if (u.isCompletelyWithinViewport)
              return (this._isPushed = !1), void this._applyPosition(a, l);
            this._canFitWithFlexibleDimensions(u, c, i)
              ? s.push({
                  position: a,
                  origin: l,
                  overlayRect: t,
                  boundingBoxRect: this._calculateBoundingBoxRect(l, a),
                })
              : (!o || o.overlayFit.visibleArea < u.visibleArea) &&
                (o = {
                  overlayFit: u,
                  overlayPoint: c,
                  originPoint: l,
                  position: a,
                  overlayRect: t,
                });
          }
          if (s.length) {
            let a = null,
              l = -1;
            for (const c of s) {
              const u =
                c.boundingBoxRect.width *
                c.boundingBoxRect.height *
                (c.position.weight || 1);
              u > l && ((l = u), (a = c));
            }
            return (
              (this._isPushed = !1),
              void this._applyPosition(a.position, a.origin)
            );
          }
          if (this._canPush)
            return (
              (this._isPushed = !0),
              void this._applyPosition(o.position, o.originPoint)
            );
          this._applyPosition(o.position, o.originPoint);
        }
        detach() {
          this._clearPanelClasses(),
            (this._lastPosition = null),
            (this._previousPushAmount = null),
            this._resizeSubscription.unsubscribe();
        }
        dispose() {
          this._isDisposed ||
            (this._boundingBox &&
              Qa(this._boundingBox.style, {
                top: "",
                left: "",
                right: "",
                bottom: "",
                height: "",
                width: "",
                alignItems: "",
                justifyContent: "",
              }),
            this._pane && this._resetOverlayElementStyles(),
            this._overlayRef &&
              this._overlayRef.hostElement.classList.remove(YF),
            this.detach(),
            this._positionChanges.complete(),
            (this._overlayRef = this._boundingBox = null),
            (this._isDisposed = !0));
        }
        reapplyLastPosition() {
          if (this._isDisposed || !this._platform.isBrowser) return;
          const e = this._lastPosition;
          if (e) {
            (this._originRect = this._getOriginRect()),
              (this._overlayRect = this._pane.getBoundingClientRect()),
              (this._viewportRect = this._getNarrowedViewportRect()),
              (this._containerRect = this._overlayContainer
                .getContainerElement()
                .getBoundingClientRect());
            const t = this._getOriginPoint(
              this._originRect,
              this._containerRect,
              e
            );
            this._applyPosition(e, t);
          } else this.apply();
        }
        withScrollableContainers(e) {
          return (this._scrollables = e), this;
        }
        withPositions(e) {
          return (
            (this._preferredPositions = e),
            -1 === e.indexOf(this._lastPosition) && (this._lastPosition = null),
            this._validatePositions(),
            this
          );
        }
        withViewportMargin(e) {
          return (this._viewportMargin = e), this;
        }
        withFlexibleDimensions(e = !0) {
          return (this._hasFlexibleDimensions = e), this;
        }
        withGrowAfterOpen(e = !0) {
          return (this._growAfterOpen = e), this;
        }
        withPush(e = !0) {
          return (this._canPush = e), this;
        }
        withLockedPosition(e = !0) {
          return (this._positionLocked = e), this;
        }
        setOrigin(e) {
          return (this._origin = e), this;
        }
        withDefaultOffsetX(e) {
          return (this._offsetX = e), this;
        }
        withDefaultOffsetY(e) {
          return (this._offsetY = e), this;
        }
        withTransformOriginOn(e) {
          return (this._transformOriginSelector = e), this;
        }
        _getOriginPoint(e, t, i) {
          let r, s;
          if ("center" == i.originX) r = e.left + e.width / 2;
          else {
            const o = this._isRtl() ? e.right : e.left,
              a = this._isRtl() ? e.left : e.right;
            r = "start" == i.originX ? o : a;
          }
          return (
            t.left < 0 && (r -= t.left),
            (s =
              "center" == i.originY
                ? e.top + e.height / 2
                : "top" == i.originY
                ? e.top
                : e.bottom),
            t.top < 0 && (s -= t.top),
            { x: r, y: s }
          );
        }
        _getOverlayPoint(e, t, i) {
          let r, s;
          return (
            (r =
              "center" == i.overlayX
                ? -t.width / 2
                : "start" === i.overlayX
                ? this._isRtl()
                  ? -t.width
                  : 0
                : this._isRtl()
                ? 0
                : -t.width),
            (s =
              "center" == i.overlayY
                ? -t.height / 2
                : "top" == i.overlayY
                ? 0
                : -t.height),
            { x: e.x + r, y: e.y + s }
          );
        }
        _getOverlayFit(e, t, i, r) {
          const s = KF(t);
          let { x: o, y: a } = e,
            l = this._getOffset(r, "x"),
            c = this._getOffset(r, "y");
          l && (o += l), c && (a += c);
          let h = 0 - a,
            f = a + s.height - i.height,
            p = this._subtractOverflows(s.width, 0 - o, o + s.width - i.width),
            _ = this._subtractOverflows(s.height, h, f),
            m = p * _;
          return {
            visibleArea: m,
            isCompletelyWithinViewport: s.width * s.height === m,
            fitsInViewportVertically: _ === s.height,
            fitsInViewportHorizontally: p == s.width,
          };
        }
        _canFitWithFlexibleDimensions(e, t, i) {
          if (this._hasFlexibleDimensions) {
            const r = i.bottom - t.y,
              s = i.right - t.x,
              o = ZF(this._overlayRef.getConfig().minHeight),
              a = ZF(this._overlayRef.getConfig().minWidth);
            return (
              (e.fitsInViewportVertically || (null != o && o <= r)) &&
              (e.fitsInViewportHorizontally || (null != a && a <= s))
            );
          }
          return !1;
        }
        _pushOverlayOnScreen(e, t, i) {
          if (this._previousPushAmount && this._positionLocked)
            return {
              x: e.x + this._previousPushAmount.x,
              y: e.y + this._previousPushAmount.y,
            };
          const r = KF(t),
            s = this._viewportRect,
            o = Math.max(e.x + r.width - s.width, 0),
            a = Math.max(e.y + r.height - s.height, 0),
            l = Math.max(s.top - i.top - e.y, 0),
            c = Math.max(s.left - i.left - e.x, 0);
          let u = 0,
            d = 0;
          return (
            (u =
              r.width <= s.width
                ? c || -o
                : e.x < this._viewportMargin
                ? s.left - i.left - e.x
                : 0),
            (d =
              r.height <= s.height
                ? l || -a
                : e.y < this._viewportMargin
                ? s.top - i.top - e.y
                : 0),
            (this._previousPushAmount = { x: u, y: d }),
            { x: e.x + u, y: e.y + d }
          );
        }
        _applyPosition(e, t) {
          if (
            (this._setTransformOrigin(e),
            this._setOverlayElementStyles(t, e),
            this._setBoundingBoxStyles(t, e),
            e.panelClass && this._addPanelClasses(e.panelClass),
            (this._lastPosition = e),
            this._positionChanges.observers.length)
          ) {
            const i = this._getScrollVisibility(),
              r = new kee(e, i);
            this._positionChanges.next(r);
          }
          this._isInitialRender = !1;
        }
        _setTransformOrigin(e) {
          if (!this._transformOriginSelector) return;
          const t = this._boundingBox.querySelectorAll(
            this._transformOriginSelector
          );
          let i,
            r = e.overlayY;
          i =
            "center" === e.overlayX
              ? "center"
              : this._isRtl()
              ? "start" === e.overlayX
                ? "right"
                : "left"
              : "start" === e.overlayX
              ? "left"
              : "right";
          for (let s = 0; s < t.length; s++)
            t[s].style.transformOrigin = `${i} ${r}`;
        }
        _calculateBoundingBoxRect(e, t) {
          const i = this._viewportRect,
            r = this._isRtl();
          let s, o, a, u, d, h;
          if ("top" === t.overlayY)
            (o = e.y), (s = i.height - o + this._viewportMargin);
          else if ("bottom" === t.overlayY)
            (a = i.height - e.y + 2 * this._viewportMargin),
              (s = i.height - a + this._viewportMargin);
          else {
            const f = Math.min(i.bottom - e.y + i.top, e.y),
              p = this._lastBoundingBoxSize.height;
            (s = 2 * f),
              (o = e.y - f),
              s > p &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (o = e.y - p / 2);
          }
          if (("end" === t.overlayX && !r) || ("start" === t.overlayX && r))
            (h = i.width - e.x + this._viewportMargin),
              (u = e.x - this._viewportMargin);
          else if (
            ("start" === t.overlayX && !r) ||
            ("end" === t.overlayX && r)
          )
            (d = e.x), (u = i.right - e.x);
          else {
            const f = Math.min(i.right - e.x + i.left, e.x),
              p = this._lastBoundingBoxSize.width;
            (u = 2 * f),
              (d = e.x - f),
              u > p &&
                !this._isInitialRender &&
                !this._growAfterOpen &&
                (d = e.x - p / 2);
          }
          return { top: o, left: d, bottom: a, right: h, width: u, height: s };
        }
        _setBoundingBoxStyles(e, t) {
          const i = this._calculateBoundingBoxRect(e, t);
          !this._isInitialRender &&
            !this._growAfterOpen &&
            ((i.height = Math.min(i.height, this._lastBoundingBoxSize.height)),
            (i.width = Math.min(i.width, this._lastBoundingBoxSize.width)));
          const r = {};
          if (this._hasExactPosition())
            (r.top = r.left = "0"),
              (r.bottom = r.right = r.maxHeight = r.maxWidth = ""),
              (r.width = r.height = "100%");
          else {
            const s = this._overlayRef.getConfig().maxHeight,
              o = this._overlayRef.getConfig().maxWidth;
            (r.height = kn(i.height)),
              (r.top = kn(i.top)),
              (r.bottom = kn(i.bottom)),
              (r.width = kn(i.width)),
              (r.left = kn(i.left)),
              (r.right = kn(i.right)),
              (r.alignItems =
                "center" === t.overlayX
                  ? "center"
                  : "end" === t.overlayX
                  ? "flex-end"
                  : "flex-start"),
              (r.justifyContent =
                "center" === t.overlayY
                  ? "center"
                  : "bottom" === t.overlayY
                  ? "flex-end"
                  : "flex-start"),
              s && (r.maxHeight = kn(s)),
              o && (r.maxWidth = kn(o));
          }
          (this._lastBoundingBoxSize = i), Qa(this._boundingBox.style, r);
        }
        _resetBoundingBoxStyles() {
          Qa(this._boundingBox.style, {
            top: "0",
            left: "0",
            right: "0",
            bottom: "0",
            height: "",
            width: "",
            alignItems: "",
            justifyContent: "",
          });
        }
        _resetOverlayElementStyles() {
          Qa(this._pane.style, {
            top: "",
            left: "",
            bottom: "",
            right: "",
            position: "",
            transform: "",
          });
        }
        _setOverlayElementStyles(e, t) {
          const i = {},
            r = this._hasExactPosition(),
            s = this._hasFlexibleDimensions,
            o = this._overlayRef.getConfig();
          if (r) {
            const u = this._viewportRuler.getViewportScrollPosition();
            Qa(i, this._getExactOverlayY(t, e, u)),
              Qa(i, this._getExactOverlayX(t, e, u));
          } else i.position = "static";
          let a = "",
            l = this._getOffset(t, "x"),
            c = this._getOffset(t, "y");
          l && (a += `translateX(${l}px) `),
            c && (a += `translateY(${c}px)`),
            (i.transform = a.trim()),
            o.maxHeight &&
              (r ? (i.maxHeight = kn(o.maxHeight)) : s && (i.maxHeight = "")),
            o.maxWidth &&
              (r ? (i.maxWidth = kn(o.maxWidth)) : s && (i.maxWidth = "")),
            Qa(this._pane.style, i);
        }
        _getExactOverlayY(e, t, i) {
          let r = { top: "", bottom: "" },
            s = this._getOverlayPoint(t, this._overlayRect, e);
          return (
            this._isPushed &&
              (s = this._pushOverlayOnScreen(s, this._overlayRect, i)),
            "bottom" === e.overlayY
              ? (r.bottom =
                  this._document.documentElement.clientHeight -
                  (s.y + this._overlayRect.height) +
                  "px")
              : (r.top = kn(s.y)),
            r
          );
        }
        _getExactOverlayX(e, t, i) {
          let o,
            r = { left: "", right: "" },
            s = this._getOverlayPoint(t, this._overlayRect, e);
          return (
            this._isPushed &&
              (s = this._pushOverlayOnScreen(s, this._overlayRect, i)),
            (o = this._isRtl()
              ? "end" === e.overlayX
                ? "left"
                : "right"
              : "end" === e.overlayX
              ? "right"
              : "left"),
            "right" === o
              ? (r.right =
                  this._document.documentElement.clientWidth -
                  (s.x + this._overlayRect.width) +
                  "px")
              : (r.left = kn(s.x)),
            r
          );
        }
        _getScrollVisibility() {
          const e = this._getOriginRect(),
            t = this._pane.getBoundingClientRect(),
            i = this._scrollables.map((r) =>
              r.getElementRef().nativeElement.getBoundingClientRect()
            );
          return {
            isOriginClipped: WF(e, i),
            isOriginOutsideView: Bw(e, i),
            isOverlayClipped: WF(t, i),
            isOverlayOutsideView: Bw(t, i),
          };
        }
        _subtractOverflows(e, ...t) {
          return t.reduce((i, r) => i - Math.max(r, 0), e);
        }
        _getNarrowedViewportRect() {
          const e = this._document.documentElement.clientWidth,
            t = this._document.documentElement.clientHeight,
            i = this._viewportRuler.getViewportScrollPosition();
          return {
            top: i.top + this._viewportMargin,
            left: i.left + this._viewportMargin,
            right: i.left + e - this._viewportMargin,
            bottom: i.top + t - this._viewportMargin,
            width: e - 2 * this._viewportMargin,
            height: t - 2 * this._viewportMargin,
          };
        }
        _isRtl() {
          return "rtl" === this._overlayRef.getDirection();
        }
        _hasExactPosition() {
          return !this._hasFlexibleDimensions || this._isPushed;
        }
        _getOffset(e, t) {
          return "x" === t
            ? null == e.offsetX
              ? this._offsetX
              : e.offsetX
            : null == e.offsetY
            ? this._offsetY
            : e.offsetY;
        }
        _validatePositions() {}
        _addPanelClasses(e) {
          this._pane &&
            Lg(e).forEach((t) => {
              "" !== t &&
                -1 === this._appliedPanelClasses.indexOf(t) &&
                (this._appliedPanelClasses.push(t),
                this._pane.classList.add(t));
            });
        }
        _clearPanelClasses() {
          this._pane &&
            (this._appliedPanelClasses.forEach((e) => {
              this._pane.classList.remove(e);
            }),
            (this._appliedPanelClasses = []));
        }
        _getOriginRect() {
          const e = this._origin;
          if (e instanceof rn) return e.nativeElement.getBoundingClientRect();
          if (e instanceof Element) return e.getBoundingClientRect();
          const t = e.width || 0,
            i = e.height || 0;
          return {
            top: e.y,
            bottom: e.y + i,
            left: e.x,
            right: e.x + t,
            height: i,
            width: t,
          };
        }
      }
      function Qa(n, e) {
        for (let t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
        return n;
      }
      function ZF(n) {
        if ("number" != typeof n && null != n) {
          const [e, t] = n.split(zee);
          return t && "px" !== t ? null : parseFloat(e);
        }
        return n || null;
      }
      function KF(n) {
        return {
          top: Math.floor(n.top),
          right: Math.floor(n.right),
          bottom: Math.floor(n.bottom),
          left: Math.floor(n.left),
          width: Math.floor(n.width),
          height: Math.floor(n.height),
        };
      }
      const $F = "cdk-global-overlay-wrapper";
      class Gee {
        constructor() {
          (this._cssPosition = "static"),
            (this._topOffset = ""),
            (this._bottomOffset = ""),
            (this._alignItems = ""),
            (this._xPosition = ""),
            (this._xOffset = ""),
            (this._width = ""),
            (this._height = ""),
            (this._isDisposed = !1);
        }
        attach(e) {
          const t = e.getConfig();
          (this._overlayRef = e),
            this._width && !t.width && e.updateSize({ width: this._width }),
            this._height && !t.height && e.updateSize({ height: this._height }),
            e.hostElement.classList.add($F),
            (this._isDisposed = !1);
        }
        top(e = "") {
          return (
            (this._bottomOffset = ""),
            (this._topOffset = e),
            (this._alignItems = "flex-start"),
            this
          );
        }
        left(e = "") {
          return (this._xOffset = e), (this._xPosition = "left"), this;
        }
        bottom(e = "") {
          return (
            (this._topOffset = ""),
            (this._bottomOffset = e),
            (this._alignItems = "flex-end"),
            this
          );
        }
        right(e = "") {
          return (this._xOffset = e), (this._xPosition = "right"), this;
        }
        start(e = "") {
          return (this._xOffset = e), (this._xPosition = "start"), this;
        }
        end(e = "") {
          return (this._xOffset = e), (this._xPosition = "end"), this;
        }
        width(e = "") {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ width: e })
              : (this._width = e),
            this
          );
        }
        height(e = "") {
          return (
            this._overlayRef
              ? this._overlayRef.updateSize({ height: e })
              : (this._height = e),
            this
          );
        }
        centerHorizontally(e = "") {
          return this.left(e), (this._xPosition = "center"), this;
        }
        centerVertically(e = "") {
          return this.top(e), (this._alignItems = "center"), this;
        }
        apply() {
          if (!this._overlayRef || !this._overlayRef.hasAttached()) return;
          const e = this._overlayRef.overlayElement.style,
            t = this._overlayRef.hostElement.style,
            i = this._overlayRef.getConfig(),
            { width: r, height: s, maxWidth: o, maxHeight: a } = i,
            l = !(
              ("100%" !== r && "100vw" !== r) ||
              (o && "100%" !== o && "100vw" !== o)
            ),
            c = !(
              ("100%" !== s && "100vh" !== s) ||
              (a && "100%" !== a && "100vh" !== a)
            ),
            u = this._xPosition,
            d = this._xOffset,
            h = "rtl" === this._overlayRef.getConfig().direction;
          let f = "",
            p = "",
            _ = "";
          l
            ? (_ = "flex-start")
            : "center" === u
            ? ((_ = "center"), h ? (p = d) : (f = d))
            : h
            ? "left" === u || "end" === u
              ? ((_ = "flex-end"), (f = d))
              : ("right" === u || "start" === u) &&
                ((_ = "flex-start"), (p = d))
            : "left" === u || "start" === u
            ? ((_ = "flex-start"), (f = d))
            : ("right" === u || "end" === u) && ((_ = "flex-end"), (p = d)),
            (e.position = this._cssPosition),
            (e.marginLeft = l ? "0" : f),
            (e.marginTop = c ? "0" : this._topOffset),
            (e.marginBottom = this._bottomOffset),
            (e.marginRight = l ? "0" : p),
            (t.justifyContent = _),
            (t.alignItems = c ? "flex-start" : this._alignItems);
        }
        dispose() {
          if (this._isDisposed || !this._overlayRef) return;
          const e = this._overlayRef.overlayElement.style,
            t = this._overlayRef.hostElement,
            i = t.style;
          t.classList.remove($F),
            (i.justifyContent =
              i.alignItems =
              e.marginTop =
              e.marginBottom =
              e.marginLeft =
              e.marginRight =
              e.position =
                ""),
            (this._overlayRef = null),
            (this._isDisposed = !0);
        }
      }
      let Wee = (() => {
          class n {
            constructor(t, i, r, s) {
              (this._viewportRuler = t),
                (this._document = i),
                (this._platform = r),
                (this._overlayContainer = s);
            }
            global() {
              return new Gee();
            }
            flexibleConnectedTo(t) {
              return new Hee(
                t,
                this._viewportRuler,
                this._document,
                this._platform,
                this._overlayContainer
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(re(kw), re(Lt), re(ss), re(qF));
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        jee = 0,
        zg = (() => {
          class n {
            constructor(t, i, r, s, o, a, l, c, u, d, h, f) {
              (this.scrollStrategies = t),
                (this._overlayContainer = i),
                (this._componentFactoryResolver = r),
                (this._positionBuilder = s),
                (this._keyboardDispatcher = o),
                (this._injector = a),
                (this._ngZone = l),
                (this._document = c),
                (this._directionality = u),
                (this._location = d),
                (this._outsideClickDispatcher = h),
                (this._animationsModuleType = f);
            }
            create(t) {
              const i = this._createHostElement(),
                r = this._createPaneElement(i),
                s = this._createPortalOutlet(r),
                o = new jF(t);
              return (
                (o.direction = o.direction || this._directionality.value),
                new Vee(
                  s,
                  i,
                  r,
                  o,
                  this._ngZone,
                  this._keyboardDispatcher,
                  this._document,
                  this._location,
                  this._outsideClickDispatcher,
                  "NoopAnimations" === this._animationsModuleType
                )
              );
            }
            position() {
              return this._positionBuilder;
            }
            _createPaneElement(t) {
              const i = this._document.createElement("div");
              return (
                (i.id = "cdk-overlay-" + jee++),
                i.classList.add("cdk-overlay-pane"),
                t.appendChild(i),
                i
              );
            }
            _createHostElement() {
              const t = this._document.createElement("div");
              return (
                this._overlayContainer.getContainerElement().appendChild(t), t
              );
            }
            _createPortalOutlet(t) {
              return (
                this._appRef || (this._appRef = this._injector.get($l)),
                new dee(
                  t,
                  this._componentFactoryResolver,
                  this._appRef,
                  this._injector,
                  this._document
                )
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                re(Nee),
                re(qF),
                re(Al),
                re(Wee),
                re(Bee),
                re(Qi),
                re(wt),
                re(Lt),
                re(Ph),
                re(yp),
                re(Uee),
                re(_d, 8)
              );
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      const Yee = {
        provide: new ye("cdk-connected-overlay-scroll-strategy"),
        deps: [zg],
        useFactory: function qee(n) {
          return () => n.scrollStrategies.reposition();
        },
      };
      let Zee = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = _n({ type: n })),
          (n.ɵinj = cn({ providers: [zg, Yee], imports: [Oh, hee, zF, zF] })),
          n
        );
      })();
      const Kee = ["mat-menu-item", ""];
      function $ee(n, e) {
        1 & n && (K_(), Se(0, "svg", 3), Gt(1, "polygon", 4), Re());
      }
      const Qee = [[["mat-icon"], ["", "matMenuItemIcon", ""]], "*"],
        Jee = ["mat-icon, [matMenuItemIcon]", "*"];
      function ete(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 0),
            Le("keydown", function (r) {
              return at(t), lt(me()._handleKeydown(r));
            })("click", function () {
              return at(t), lt(me().closed.emit("click"));
            })("@transformMenu.start", function (r) {
              return at(t), lt(me()._onAnimationStart(r));
            })("@transformMenu.done", function (r) {
              return at(t), lt(me()._onAnimationDone(r));
            }),
            Se(1, "div", 1),
            Gl(2),
            Re()();
        }
        if (2 & n) {
          const t = me();
          Xe("id", t.panelId)("ngClass", t._classList)(
            "@transformMenu",
            t._panelAnimationState
          ),
            ii("aria-label", t.ariaLabel || null)(
              "aria-labelledby",
              t.ariaLabelledby || null
            )("aria-describedby", t.ariaDescribedby || null);
        }
      }
      const tte = ["*"],
        Uw = new ye("MAT_MENU_PANEL"),
        nte = CF(EF(class {}));
      let xu = (() => {
        class n extends nte {
          constructor(t, i, r, s, o) {
            super(),
              (this._elementRef = t),
              (this._document = i),
              (this._focusMonitor = r),
              (this._parentMenu = s),
              (this._changeDetectorRef = o),
              (this.role = "menuitem"),
              (this._hovered = new kt()),
              (this._focused = new kt()),
              (this._highlighted = !1),
              (this._triggersSubmenu = !1),
              s?.addItem?.(this);
          }
          focus(t, i) {
            this._focusMonitor && t
              ? this._focusMonitor.focusVia(this._getHostElement(), t, i)
              : this._getHostElement().focus(i),
              this._focused.next(this);
          }
          ngAfterViewInit() {
            this._focusMonitor &&
              this._focusMonitor.monitor(this._elementRef, !1);
          }
          ngOnDestroy() {
            this._focusMonitor &&
              this._focusMonitor.stopMonitoring(this._elementRef),
              this._parentMenu &&
                this._parentMenu.removeItem &&
                this._parentMenu.removeItem(this),
              this._hovered.complete(),
              this._focused.complete();
          }
          _getTabIndex() {
            return this.disabled ? "-1" : "0";
          }
          _getHostElement() {
            return this._elementRef.nativeElement;
          }
          _checkDisabled(t) {
            this.disabled && (t.preventDefault(), t.stopPropagation());
          }
          _handleMouseEnter() {
            this._hovered.next(this);
          }
          getLabel() {
            const t = this._elementRef.nativeElement.cloneNode(!0),
              i = t.querySelectorAll("mat-icon, .material-icons");
            for (let r = 0; r < i.length; r++) i[r].remove();
            return t.textContent?.trim() || "";
          }
          _setHighlighted(t) {
            (this._highlighted = t), this._changeDetectorRef?.markForCheck();
          }
          _setTriggersSubmenu(t) {
            (this._triggersSubmenu = t),
              this._changeDetectorRef?.markForCheck();
          }
          _hasFocus() {
            return (
              this._document &&
              this._document.activeElement === this._getHostElement()
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(rn), G(Lt), G(Aw), G(Uw, 8), G(Ui));
          }),
          (n.ɵcmp = Xi({
            type: n,
            selectors: [["", "mat-menu-item", ""]],
            hostAttrs: [
              1,
              "mat-mdc-menu-item",
              "mat-mdc-focus-indicator",
              "mdc-list-item",
            ],
            hostVars: 8,
            hostBindings: function (t, i) {
              1 & t &&
                Le("click", function (s) {
                  return i._checkDisabled(s);
                })("mouseenter", function () {
                  return i._handleMouseEnter();
                }),
                2 & t &&
                  (ii("role", i.role)("tabindex", i._getTabIndex())(
                    "aria-disabled",
                    i.disabled
                  )("disabled", i.disabled || null),
                  gs("mat-mdc-menu-item-highlighted", i._highlighted)(
                    "mat-mdc-menu-item-submenu-trigger",
                    i._triggersSubmenu
                  ));
            },
            inputs: {
              disabled: "disabled",
              disableRipple: "disableRipple",
              role: "role",
            },
            exportAs: ["matMenuItem"],
            features: [St],
            attrs: Kee,
            ngContentSelectors: Jee,
            decls: 5,
            vars: 3,
            consts: [
              [1, "mdc-list-item__primary-text"],
              [
                "matRipple",
                "",
                1,
                "mat-mdc-menu-ripple",
                3,
                "matRippleDisabled",
                "matRippleTrigger",
              ],
              [
                "class",
                "mat-mdc-menu-submenu-icon",
                "viewBox",
                "0 0 5 10",
                "focusable",
                "false",
                4,
                "ngIf",
              ],
              [
                "viewBox",
                "0 0 5 10",
                "focusable",
                "false",
                1,
                "mat-mdc-menu-submenu-icon",
              ],
              ["points", "0,0 5,5 0,10"],
            ],
            template: function (t, i) {
              1 & t &&
                (rd(Qee),
                Gl(0),
                Se(1, "span", 0),
                Gl(2, 1),
                Re(),
                Gt(3, "div", 1),
                jt(4, $ee, 2, 0, "svg", 2)),
                2 & t &&
                  (je(3),
                  Xe("matRippleDisabled", i.disableRipple || i.disabled)(
                    "matRippleTrigger",
                    i._getHostElement()
                  ),
                  je(1),
                  Xe("ngIf", i._triggersSubmenu));
            },
            dependencies: [ec, PF],
            encapsulation: 2,
            changeDetection: 0,
          })),
          n
        );
      })();
      const ite = new ye("MatMenuContent"),
        Hg = {
          transformMenu: Lw("transformMenu", [
            Bg("void", _o({ opacity: 0, transform: "scale(0.8)" })),
            kh(
              "void => enter",
              Nh(
                "120ms cubic-bezier(0, 0, 0.2, 1)",
                _o({ opacity: 1, transform: "scale(1)" })
              )
            ),
            kh("* => void", Nh("100ms 25ms linear", _o({ opacity: 0 }))),
          ]),
          fadeInItems: Lw("fadeInItems", [
            Bg("showing", _o({ opacity: 1 })),
            kh("void => *", [
              _o({ opacity: 0 }),
              Nh("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)"),
            ]),
          ]),
        };
      let rte = 0;
      const QF = new ye("mat-menu-default-options", {
        providedIn: "root",
        factory: function ste() {
          return {
            overlapTrigger: !1,
            xPosition: "after",
            yPosition: "below",
            backdropClass: "cdk-overlay-transparent-backdrop",
          };
        },
      });
      let zh = (() => {
          class n {
            get xPosition() {
              return this._xPosition;
            }
            set xPosition(t) {
              (this._xPosition = t), this.setPositionClasses();
            }
            get yPosition() {
              return this._yPosition;
            }
            set yPosition(t) {
              (this._yPosition = t), this.setPositionClasses();
            }
            get overlapTrigger() {
              return this._overlapTrigger;
            }
            set overlapTrigger(t) {
              this._overlapTrigger = $a(t);
            }
            get hasBackdrop() {
              return this._hasBackdrop;
            }
            set hasBackdrop(t) {
              this._hasBackdrop = $a(t);
            }
            set panelClass(t) {
              const i = this._previousPanelClass;
              i &&
                i.length &&
                i.split(" ").forEach((r) => {
                  this._classList[r] = !1;
                }),
                (this._previousPanelClass = t),
                t &&
                  t.length &&
                  (t.split(" ").forEach((r) => {
                    this._classList[r] = !0;
                  }),
                  (this._elementRef.nativeElement.className = ""));
            }
            get classList() {
              return this.panelClass;
            }
            set classList(t) {
              this.panelClass = t;
            }
            constructor(t, i, r, s) {
              (this._elementRef = t),
                (this._ngZone = i),
                (this._defaultOptions = r),
                (this._changeDetectorRef = s),
                (this._xPosition = this._defaultOptions.xPosition),
                (this._yPosition = this._defaultOptions.yPosition),
                (this._directDescendantItems = new Yl()),
                (this._classList = {}),
                (this._panelAnimationState = "void"),
                (this._animationDone = new kt()),
                (this.overlayPanelClass =
                  this._defaultOptions.overlayPanelClass || ""),
                (this.backdropClass = this._defaultOptions.backdropClass),
                (this._overlapTrigger = this._defaultOptions.overlapTrigger),
                (this._hasBackdrop = this._defaultOptions.hasBackdrop),
                (this.closed = new Ut()),
                (this.close = this.closed),
                (this.panelId = "mat-menu-panel-" + rte++);
            }
            ngOnInit() {
              this.setPositionClasses();
            }
            ngAfterContentInit() {
              this._updateDirectDescendants(),
                (this._keyManager = new AJ(this._directDescendantItems)
                  .withWrap()
                  .withTypeAhead()
                  .withHomeAndEnd()),
                this._keyManager.tabOut.subscribe(() =>
                  this.closed.emit("tab")
                ),
                this._directDescendantItems.changes
                  .pipe(
                    tc(this._directDescendantItems),
                    Sr((t) => Tu(...t.map((i) => i._focused)))
                  )
                  .subscribe((t) => this._keyManager.updateActiveItem(t)),
                this._directDescendantItems.changes.subscribe((t) => {
                  const i = this._keyManager;
                  if (
                    "enter" === this._panelAnimationState &&
                    i.activeItem?._hasFocus()
                  ) {
                    const r = t.toArray(),
                      s = Math.max(
                        0,
                        Math.min(r.length - 1, i.activeItemIndex || 0)
                      );
                    r[s] && !r[s].disabled
                      ? i.setActiveItem(s)
                      : i.setNextItemActive();
                  }
                });
            }
            ngOnDestroy() {
              this._keyManager?.destroy(),
                this._directDescendantItems.destroy(),
                this.closed.complete(),
                this._firstItemFocusSubscription?.unsubscribe();
            }
            _hovered() {
              return this._directDescendantItems.changes.pipe(
                tc(this._directDescendantItems),
                Sr((i) => Tu(...i.map((r) => r._hovered)))
              );
            }
            addItem(t) {}
            removeItem(t) {}
            _handleKeydown(t) {
              const i = t.keyCode,
                r = this._keyManager;
              switch (i) {
                case 27:
                  aF(t) || (t.preventDefault(), this.closed.emit("keydown"));
                  break;
                case 37:
                  this.parentMenu &&
                    "ltr" === this.direction &&
                    this.closed.emit("keydown");
                  break;
                case 39:
                  this.parentMenu &&
                    "rtl" === this.direction &&
                    this.closed.emit("keydown");
                  break;
                default:
                  return (
                    (38 === i || 40 === i) && r.setFocusOrigin("keyboard"),
                    void r.onKeydown(t)
                  );
              }
              t.stopPropagation();
            }
            focusFirstItem(t = "program") {
              this._firstItemFocusSubscription?.unsubscribe(),
                (this._firstItemFocusSubscription = this._ngZone.onStable
                  .pipe(er(1))
                  .subscribe(() => {
                    let i = null;
                    if (
                      (this._directDescendantItems.length &&
                        (i = this._directDescendantItems.first
                          ._getHostElement()
                          .closest('[role="menu"]')),
                      !i || !i.contains(document.activeElement))
                    ) {
                      const r = this._keyManager;
                      r.setFocusOrigin(t).setFirstItemActive(),
                        !r.activeItem && i && i.focus();
                    }
                  }));
            }
            resetActiveItem() {
              this._keyManager.setActiveItem(-1);
            }
            setElevation(t) {
              const i = Math.min(this._baseElevation + t, 24),
                r = `${this._elevationPrefix}${i}`,
                s = Object.keys(this._classList).find((o) =>
                  o.startsWith(this._elevationPrefix)
                );
              (!s || s === this._previousElevation) &&
                (this._previousElevation &&
                  (this._classList[this._previousElevation] = !1),
                (this._classList[r] = !0),
                (this._previousElevation = r));
            }
            setPositionClasses(t = this.xPosition, i = this.yPosition) {
              const r = this._classList;
              (r["mat-menu-before"] = "before" === t),
                (r["mat-menu-after"] = "after" === t),
                (r["mat-menu-above"] = "above" === i),
                (r["mat-menu-below"] = "below" === i),
                this._changeDetectorRef?.markForCheck();
            }
            _startAnimation() {
              this._panelAnimationState = "enter";
            }
            _resetAnimation() {
              this._panelAnimationState = "void";
            }
            _onAnimationDone(t) {
              this._animationDone.next(t), (this._isAnimating = !1);
            }
            _onAnimationStart(t) {
              (this._isAnimating = !0),
                "enter" === t.toState &&
                  0 === this._keyManager.activeItemIndex &&
                  (t.element.scrollTop = 0);
            }
            _updateDirectDescendants() {
              this._allItems.changes.pipe(tc(this._allItems)).subscribe((t) => {
                this._directDescendantItems.reset(
                  t.filter((i) => i._parentMenu === this)
                ),
                  this._directDescendantItems.notifyOnChanges();
              });
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(G(rn), G(wt), G(QF), G(Ui));
            }),
            (n.ɵdir = He({
              type: n,
              contentQueries: function (t, i, r) {
                if (
                  (1 & t && (pd(r, ite, 5), pd(r, xu, 5), pd(r, xu, 4)), 2 & t)
                ) {
                  let s;
                  Ei((s = Ci())) && (i.lazyContent = s.first),
                    Ei((s = Ci())) && (i._allItems = s),
                    Ei((s = Ci())) && (i.items = s);
                }
              },
              viewQuery: function (t, i) {
                if ((1 & t && jr(ys, 5), 2 & t)) {
                  let r;
                  Ei((r = Ci())) && (i.templateRef = r.first);
                }
              },
              inputs: {
                backdropClass: "backdropClass",
                ariaLabel: ["aria-label", "ariaLabel"],
                ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
                ariaDescribedby: ["aria-describedby", "ariaDescribedby"],
                xPosition: "xPosition",
                yPosition: "yPosition",
                overlapTrigger: "overlapTrigger",
                hasBackdrop: "hasBackdrop",
                panelClass: ["class", "panelClass"],
                classList: "classList",
              },
              outputs: { closed: "closed", close: "close" },
            })),
            n
          );
        })(),
        Vw = (() => {
          class n extends zh {
            constructor(t, i, r, s) {
              super(t, i, r, s),
                (this._elevationPrefix = "mat-elevation-z"),
                (this._baseElevation = 8);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(G(rn), G(wt), G(QF), G(Ui));
            }),
            (n.ɵcmp = Xi({
              type: n,
              selectors: [["mat-menu"]],
              hostVars: 3,
              hostBindings: function (t, i) {
                2 & t &&
                  ii("aria-label", null)("aria-labelledby", null)(
                    "aria-describedby",
                    null
                  );
              },
              exportAs: ["matMenu"],
              features: [qt([{ provide: Uw, useExisting: n }]), St],
              ngContentSelectors: tte,
              decls: 1,
              vars: 0,
              consts: [
                [
                  "tabindex",
                  "-1",
                  "role",
                  "menu",
                  1,
                  "mat-mdc-menu-panel",
                  "mdc-menu-surface",
                  "mdc-menu-surface--open",
                  "mat-mdc-elevation-specific",
                  3,
                  "id",
                  "ngClass",
                  "keydown",
                  "click",
                ],
                [1, "mat-mdc-menu-content", "mdc-list"],
              ],
              template: function (t, i) {
                1 & t && (rd(), jt(0, ete, 3, 6, "ng-template"));
              },
              dependencies: [Jl],
              styles: [
                '.mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:var(--mdc-menu-max-height, calc(100vh - 32px));margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;z-index:8;border-radius:var(--mdc-shape-medium, 4px);transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;list-style-type:none}.mat-mdc-menu-content:focus{outline:none}.mat-mdc-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-mdc-menu-panel{outline:solid 1px}.mat-mdc-menu-panel.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;position:relative}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px}.mat-mdc-menu-item:focus{outline:none}[dir=rtl] .mat-mdc-menu-item,.mat-mdc-menu-item[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-menu-item::-moz-focus-inner{border:0}.mat-mdc-menu-item.mdc-list-item{align-items:center}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item .mat-icon{margin-right:16px}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:16px}.mat-mdc-menu-item .mdc-list-item__primary-text{white-space:normal}.mat-mdc-menu-item.mat-mdc-menu-item-submenu-trigger{padding-right:32px}[dir=rtl] .mat-mdc-menu-item.mat-mdc-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}.cdk-high-contrast-active .mat-mdc-menu-item{margin-top:1px}.mat-mdc-menu-submenu-icon{position:absolute;top:50%;right:16px;transform:translateY(-50%);width:5px;height:10px;fill:currentColor}[dir=rtl] .mat-mdc-menu-submenu-icon{right:auto;left:16px;transform:translateY(-50%) scaleX(-1)}.cdk-high-contrast-active .mat-mdc-menu-submenu-icon{fill:CanvasText}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}',
              ],
              encapsulation: 2,
              data: { animation: [Hg.transformMenu, Hg.fadeInItems] },
              changeDetection: 0,
            })),
            n
          );
        })();
      const JF = new ye("mat-menu-scroll-strategy"),
        ate = {
          provide: JF,
          deps: [zg],
          useFactory: function ote(n) {
            return () => n.scrollStrategies.reposition();
          },
        },
        e2 = Dh({ passive: !0 });
      let lte = (() => {
          class n {
            get _deprecatedMatMenuTriggerFor() {
              return this.menu;
            }
            set _deprecatedMatMenuTriggerFor(t) {
              this.menu = t;
            }
            get menu() {
              return this._menu;
            }
            set menu(t) {
              t !== this._menu &&
                ((this._menu = t),
                this._menuCloseSubscription.unsubscribe(),
                t &&
                  (this._menuCloseSubscription = t.close.subscribe((i) => {
                    this._destroyMenu(i),
                      ("click" === i || "tab" === i) &&
                        this._parentMaterialMenu &&
                        this._parentMaterialMenu.closed.emit(i);
                  })),
                this._menuItemInstance?._setTriggersSubmenu(
                  this.triggersSubmenu()
                ));
            }
            constructor(t, i, r, s, o, a, l, c, u) {
              (this._overlay = t),
                (this._element = i),
                (this._viewContainerRef = r),
                (this._menuItemInstance = a),
                (this._dir = l),
                (this._focusMonitor = c),
                (this._ngZone = u),
                (this._overlayRef = null),
                (this._menuOpen = !1),
                (this._closingActionsSubscription = Sn.EMPTY),
                (this._hoverSubscription = Sn.EMPTY),
                (this._menuCloseSubscription = Sn.EMPTY),
                (this._changeDetectorRef = ft(Ui)),
                (this._handleTouchStart = (d) => {
                  Tw(d) || (this._openedBy = "touch");
                }),
                (this._openedBy = void 0),
                (this.restoreFocus = !0),
                (this.menuOpened = new Ut()),
                (this.onMenuOpen = this.menuOpened),
                (this.menuClosed = new Ut()),
                (this.onMenuClose = this.menuClosed),
                (this._scrollStrategy = s),
                (this._parentMaterialMenu = o instanceof zh ? o : void 0),
                i.nativeElement.addEventListener(
                  "touchstart",
                  this._handleTouchStart,
                  e2
                );
            }
            ngAfterContentInit() {
              this._handleHover();
            }
            ngOnDestroy() {
              this._overlayRef &&
                (this._overlayRef.dispose(), (this._overlayRef = null)),
                this._element.nativeElement.removeEventListener(
                  "touchstart",
                  this._handleTouchStart,
                  e2
                ),
                this._menuCloseSubscription.unsubscribe(),
                this._closingActionsSubscription.unsubscribe(),
                this._hoverSubscription.unsubscribe();
            }
            get menuOpen() {
              return this._menuOpen;
            }
            get dir() {
              return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr";
            }
            triggersSubmenu() {
              return !!(
                this._menuItemInstance &&
                this._parentMaterialMenu &&
                this.menu
              );
            }
            toggleMenu() {
              return this._menuOpen ? this.closeMenu() : this.openMenu();
            }
            openMenu() {
              const t = this.menu;
              if (this._menuOpen || !t) return;
              const i = this._createOverlay(t),
                r = i.getConfig(),
                s = r.positionStrategy;
              this._setPosition(t, s),
                (r.hasBackdrop =
                  null == t.hasBackdrop
                    ? !this.triggersSubmenu()
                    : t.hasBackdrop),
                i.attach(this._getPortal(t)),
                t.lazyContent && t.lazyContent.attach(this.menuData),
                (this._closingActionsSubscription =
                  this._menuClosingActions().subscribe(() => this.closeMenu())),
                this._initMenu(t),
                t instanceof zh &&
                  (t._startAnimation(),
                  t._directDescendantItems.changes
                    .pipe(Jo(t.close))
                    .subscribe(() => {
                      s.withLockedPosition(!1).reapplyLastPosition(),
                        s.withLockedPosition(!0);
                    }));
            }
            closeMenu() {
              this.menu?.close.emit();
            }
            focus(t, i) {
              this._focusMonitor && t
                ? this._focusMonitor.focusVia(this._element, t, i)
                : this._element.nativeElement.focus(i);
            }
            updatePosition() {
              this._overlayRef?.updatePosition();
            }
            _destroyMenu(t) {
              if (!this._overlayRef || !this.menuOpen) return;
              const i = this.menu;
              this._closingActionsSubscription.unsubscribe(),
                this._overlayRef.detach(),
                this.restoreFocus &&
                  ("keydown" === t ||
                    !this._openedBy ||
                    !this.triggersSubmenu()) &&
                  this.focus(this._openedBy),
                (this._openedBy = void 0),
                i instanceof zh
                  ? (i._resetAnimation(),
                    i.lazyContent
                      ? i._animationDone
                          .pipe(
                            _i((r) => "void" === r.toState),
                            er(1),
                            Jo(i.lazyContent._attached)
                          )
                          .subscribe({
                            next: () => i.lazyContent.detach(),
                            complete: () => this._setIsMenuOpen(!1),
                          })
                      : this._setIsMenuOpen(!1))
                  : (this._setIsMenuOpen(!1), i?.lazyContent?.detach());
            }
            _initMenu(t) {
              (t.parentMenu = this.triggersSubmenu()
                ? this._parentMaterialMenu
                : void 0),
                (t.direction = this.dir),
                this._setMenuElevation(t),
                t.focusFirstItem(this._openedBy || "program"),
                this._setIsMenuOpen(!0);
            }
            _setMenuElevation(t) {
              if (t.setElevation) {
                let i = 0,
                  r = t.parentMenu;
                for (; r; ) i++, (r = r.parentMenu);
                t.setElevation(i);
              }
            }
            _setIsMenuOpen(t) {
              t !== this._menuOpen &&
                ((this._menuOpen = t),
                this._menuOpen
                  ? this.menuOpened.emit()
                  : this.menuClosed.emit(),
                this.triggersSubmenu() &&
                  this._menuItemInstance._setHighlighted(t),
                this._changeDetectorRef.markForCheck());
            }
            _createOverlay(t) {
              if (!this._overlayRef) {
                const i = this._getOverlayConfig(t);
                this._subscribeToPositions(t, i.positionStrategy),
                  (this._overlayRef = this._overlay.create(i)),
                  this._overlayRef.keydownEvents().subscribe();
              }
              return this._overlayRef;
            }
            _getOverlayConfig(t) {
              return new jF({
                positionStrategy: this._overlay
                  .position()
                  .flexibleConnectedTo(this._element)
                  .withLockedPosition()
                  .withGrowAfterOpen()
                  .withTransformOriginOn(
                    ".mat-menu-panel, .mat-mdc-menu-panel"
                  ),
                backdropClass:
                  t.backdropClass || "cdk-overlay-transparent-backdrop",
                panelClass: t.overlayPanelClass,
                scrollStrategy: this._scrollStrategy(),
                direction: this._dir,
              });
            }
            _subscribeToPositions(t, i) {
              t.setPositionClasses &&
                i.positionChanges.subscribe((r) => {
                  const s =
                      "start" === r.connectionPair.overlayX
                        ? "after"
                        : "before",
                    o = "top" === r.connectionPair.overlayY ? "below" : "above";
                  this._ngZone
                    ? this._ngZone.run(() => t.setPositionClasses(s, o))
                    : t.setPositionClasses(s, o);
                });
            }
            _setPosition(t, i) {
              let [r, s] =
                  "before" === t.xPosition
                    ? ["end", "start"]
                    : ["start", "end"],
                [o, a] =
                  "above" === t.yPosition
                    ? ["bottom", "top"]
                    : ["top", "bottom"],
                [l, c] = [o, a],
                [u, d] = [r, s],
                h = 0;
              if (this.triggersSubmenu()) {
                if (
                  ((d = r = "before" === t.xPosition ? "start" : "end"),
                  (s = u = "end" === r ? "start" : "end"),
                  this._parentMaterialMenu)
                ) {
                  if (null == this._parentInnerPadding) {
                    const f = this._parentMaterialMenu.items.first;
                    this._parentInnerPadding = f
                      ? f._getHostElement().offsetTop
                      : 0;
                  }
                  h =
                    "bottom" === o
                      ? this._parentInnerPadding
                      : -this._parentInnerPadding;
                }
              } else
                t.overlapTrigger ||
                  ((l = "top" === o ? "bottom" : "top"),
                  (c = "top" === a ? "bottom" : "top"));
              i.withPositions([
                {
                  originX: r,
                  originY: l,
                  overlayX: u,
                  overlayY: o,
                  offsetY: h,
                },
                {
                  originX: s,
                  originY: l,
                  overlayX: d,
                  overlayY: o,
                  offsetY: h,
                },
                {
                  originX: r,
                  originY: c,
                  overlayX: u,
                  overlayY: a,
                  offsetY: -h,
                },
                {
                  originX: s,
                  originY: c,
                  overlayX: d,
                  overlayY: a,
                  offsetY: -h,
                },
              ]);
            }
            _menuClosingActions() {
              const t = this._overlayRef.backdropClick(),
                i = this._overlayRef.detachments();
              return Tu(
                t,
                this._parentMaterialMenu
                  ? this._parentMaterialMenu.closed
                  : Ge(),
                this._parentMaterialMenu
                  ? this._parentMaterialMenu._hovered().pipe(
                      _i((o) => o !== this._menuItemInstance),
                      _i(() => this._menuOpen)
                    )
                  : Ge(),
                i
              );
            }
            _handleMousedown(t) {
              Cw(t) ||
                ((this._openedBy = 0 === t.button ? "mouse" : void 0),
                this.triggersSubmenu() && t.preventDefault());
            }
            _handleKeydown(t) {
              const i = t.keyCode;
              (13 === i || 32 === i) && (this._openedBy = "keyboard"),
                this.triggersSubmenu() &&
                  ((39 === i && "ltr" === this.dir) ||
                    (37 === i && "rtl" === this.dir)) &&
                  ((this._openedBy = "keyboard"), this.openMenu());
            }
            _handleClick(t) {
              this.triggersSubmenu()
                ? (t.stopPropagation(), this.openMenu())
                : this.toggleMenu();
            }
            _handleHover() {
              !this.triggersSubmenu() ||
                !this._parentMaterialMenu ||
                (this._hoverSubscription = this._parentMaterialMenu
                  ._hovered()
                  .pipe(
                    _i((t) => t === this._menuItemInstance && !t.disabled),
                    wF(0, Rw)
                  )
                  .subscribe(() => {
                    (this._openedBy = "mouse"),
                      this.menu instanceof zh && this.menu._isAnimating
                        ? this.menu._animationDone
                            .pipe(
                              er(1),
                              wF(0, Rw),
                              Jo(this._parentMaterialMenu._hovered())
                            )
                            .subscribe(() => this.openMenu())
                        : this.openMenu();
                  }));
            }
            _getPortal(t) {
              return (
                (!this._portal || this._portal.templateRef !== t.templateRef) &&
                  (this._portal = new OF(
                    t.templateRef,
                    this._viewContainerRef
                  )),
                this._portal
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                G(zg),
                G(rn),
                G(br),
                G(JF),
                G(Uw, 8),
                G(xu, 10),
                G(Ph, 8),
                G(Aw),
                G(wt)
              );
            }),
            (n.ɵdir = He({
              type: n,
              hostVars: 3,
              hostBindings: function (t, i) {
                1 & t &&
                  Le("click", function (s) {
                    return i._handleClick(s);
                  })("mousedown", function (s) {
                    return i._handleMousedown(s);
                  })("keydown", function (s) {
                    return i._handleKeydown(s);
                  }),
                  2 & t &&
                    ii("aria-haspopup", i.menu ? "menu" : null)(
                      "aria-expanded",
                      i.menuOpen
                    )("aria-controls", i.menuOpen ? i.menu.panelId : null);
              },
              inputs: {
                _deprecatedMatMenuTriggerFor: [
                  "mat-menu-trigger-for",
                  "_deprecatedMatMenuTriggerFor",
                ],
                menu: ["matMenuTriggerFor", "menu"],
                menuData: ["matMenuTriggerData", "menuData"],
                restoreFocus: ["matMenuTriggerRestoreFocus", "restoreFocus"],
              },
              outputs: {
                menuOpened: "menuOpened",
                onMenuOpen: "onMenuOpen",
                menuClosed: "menuClosed",
                onMenuClose: "onMenuClose",
              },
            })),
            n
          );
        })(),
        zw = (() => {
          class n extends lte {}
          return (
            (n.ɵfac = (function () {
              let e;
              return function (i) {
                return (e || (e = Vn(n)))(i || n);
              };
            })()),
            (n.ɵdir = He({
              type: n,
              selectors: [
                ["", "mat-menu-trigger-for", ""],
                ["", "matMenuTriggerFor", ""],
              ],
              hostAttrs: [1, "mat-mdc-menu-trigger"],
              exportAs: ["matMenuTrigger"],
              features: [St],
            })),
            n
          );
        })(),
        t2 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({
              providers: [ate],
              imports: [Dp, Pw, Ds, Zee, Vh, Ds],
            })),
            n
          );
        })();
      const os = new ye("NgValueAccessor"),
        hne = ["switch"],
        fne = ["*"],
        pne = new ye("mat-slide-toggle-default-options", {
          providedIn: "root",
          factory: () => ({ disableToggleValue: !1 }),
        }),
        mne = { provide: os, useExisting: Xt(() => oN), multi: !0 };
      class sN {
        constructor(e, t) {
          (this.source = e), (this.checked = t);
        }
      }
      let gne = 0;
      const _ne = tee(
        eee(
          CF(
            EF(
              class {
                constructor(n) {
                  this._elementRef = n;
                }
              }
            )
          )
        )
      );
      let vne = (() => {
          class n extends _ne {
            get required() {
              return this._required;
            }
            set required(t) {
              this._required = $a(t);
            }
            get checked() {
              return this._checked;
            }
            set checked(t) {
              (this._checked = $a(t)), this._changeDetectorRef.markForCheck();
            }
            get inputId() {
              return `${this.id || this._uniqueId}-input`;
            }
            constructor(t, i, r, s, o, a, l) {
              super(t),
                (this._focusMonitor = i),
                (this._changeDetectorRef = r),
                (this.defaults = o),
                (this._onChange = (c) => {}),
                (this._onTouched = () => {}),
                (this._required = !1),
                (this._checked = !1),
                (this.name = null),
                (this.labelPosition = "after"),
                (this.ariaLabel = null),
                (this.ariaLabelledby = null),
                (this.change = new Ut()),
                (this.toggleChange = new Ut()),
                (this.tabIndex = parseInt(s) || 0),
                (this.color = this.defaultColor = o.color || "accent"),
                (this._noopAnimations = "NoopAnimations" === a),
                (this.id = this._uniqueId = `${l}${++gne}`);
            }
            ngAfterContentInit() {
              this._focusMonitor
                .monitor(this._elementRef, !0)
                .subscribe((t) => {
                  "keyboard" === t || "program" === t
                    ? ((this._focused = !0),
                      this._changeDetectorRef.markForCheck())
                    : t ||
                      Promise.resolve().then(() => {
                        (this._focused = !1),
                          this._onTouched(),
                          this._changeDetectorRef.markForCheck();
                      });
                });
            }
            ngOnDestroy() {
              this._focusMonitor.stopMonitoring(this._elementRef);
            }
            writeValue(t) {
              this.checked = !!t;
            }
            registerOnChange(t) {
              this._onChange = t;
            }
            registerOnTouched(t) {
              this._onTouched = t;
            }
            setDisabledState(t) {
              (this.disabled = t), this._changeDetectorRef.markForCheck();
            }
            toggle() {
              (this.checked = !this.checked), this._onChange(this.checked);
            }
            _emitChangeEvent() {
              this._onChange(this.checked),
                this.change.emit(this._createChangeEvent(this.checked));
            }
          }
          return (
            (n.ɵfac = function (t) {
              qv();
            }),
            (n.ɵdir = He({
              type: n,
              inputs: {
                name: "name",
                id: "id",
                labelPosition: "labelPosition",
                ariaLabel: ["aria-label", "ariaLabel"],
                ariaLabelledby: ["aria-labelledby", "ariaLabelledby"],
                ariaDescribedby: ["aria-describedby", "ariaDescribedby"],
                required: "required",
                checked: "checked",
              },
              outputs: { change: "change", toggleChange: "toggleChange" },
              features: [St],
            })),
            n
          );
        })(),
        oN = (() => {
          class n extends vne {
            get buttonId() {
              return `${this.id || this._uniqueId}-button`;
            }
            constructor(t, i, r, s, o, a) {
              super(t, i, r, s, o, a, "mat-mdc-slide-toggle-"),
                (this._labelId = this._uniqueId + "-label");
            }
            _handleClick() {
              this.toggleChange.emit(),
                this.defaults.disableToggleValue ||
                  ((this.checked = !this.checked),
                  this._onChange(this.checked),
                  this.change.emit(new sN(this, this.checked)));
            }
            focus() {
              this._switchElement.nativeElement.focus();
            }
            _createChangeEvent(t) {
              return new sN(this, t);
            }
            _getAriaLabelledBy() {
              return this.ariaLabelledby
                ? this.ariaLabelledby
                : this.ariaLabel
                ? null
                : this._labelId;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                G(rn),
                G(Aw),
                G(Ui),
                (function Uu(n) {
                  return (function QB(n, e) {
                    if ("class" === e) return n.classes;
                    if ("style" === e) return n.styles;
                    const t = n.attrs;
                    if (t) {
                      const i = t.length;
                      let r = 0;
                      for (; r < i; ) {
                        const s = t[r];
                        if (ZS(s)) break;
                        if (0 === s) r += 2;
                        else if ("number" == typeof s)
                          for (r++; r < i && "string" == typeof t[r]; ) r++;
                        else {
                          if (s === e) return t[r + 1];
                          r += 2;
                        }
                      }
                    }
                    return null;
                  })(ni(), n);
                })("tabindex"),
                G(pne),
                G(_d, 8)
              );
            }),
            (n.ɵcmp = Xi({
              type: n,
              selectors: [["mat-slide-toggle"]],
              viewQuery: function (t, i) {
                if ((1 & t && jr(hne, 5), 2 & t)) {
                  let r;
                  Ei((r = Ci())) && (i._switchElement = r.first);
                }
              },
              hostAttrs: [1, "mat-mdc-slide-toggle"],
              hostVars: 11,
              hostBindings: function (t, i) {
                2 & t &&
                  (gy("id", i.id),
                  ii("tabindex", null)("aria-label", null)("name", null)(
                    "aria-labelledby",
                    null
                  ),
                  gs("mat-mdc-slide-toggle-focused", i._focused)(
                    "mat-mdc-slide-toggle-checked",
                    i.checked
                  )("_mat-animation-noopable", i._noopAnimations));
              },
              inputs: {
                disabled: "disabled",
                disableRipple: "disableRipple",
                color: "color",
                tabIndex: "tabIndex",
              },
              exportAs: ["matSlideToggle"],
              features: [qt([mne]), St],
              ngContentSelectors: fne,
              decls: 17,
              vars: 24,
              consts: [
                [1, "mdc-form-field"],
                [
                  "role",
                  "switch",
                  "type",
                  "button",
                  1,
                  "mdc-switch",
                  3,
                  "tabIndex",
                  "disabled",
                  "click",
                ],
                ["switch", ""],
                [1, "mdc-switch__track"],
                [1, "mdc-switch__handle-track"],
                [1, "mdc-switch__handle"],
                [1, "mdc-switch__shadow"],
                [1, "mdc-elevation-overlay"],
                [1, "mdc-switch__ripple"],
                [
                  "mat-ripple",
                  "",
                  1,
                  "mat-mdc-slide-toggle-ripple",
                  "mat-mdc-focus-indicator",
                  3,
                  "matRippleTrigger",
                  "matRippleDisabled",
                  "matRippleCentered",
                ],
                [1, "mdc-switch__icons"],
                [
                  "viewBox",
                  "0 0 24 24",
                  1,
                  "mdc-switch__icon",
                  "mdc-switch__icon--on",
                ],
                [
                  "d",
                  "M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z",
                ],
                [
                  "viewBox",
                  "0 0 24 24",
                  1,
                  "mdc-switch__icon",
                  "mdc-switch__icon--off",
                ],
                ["d", "M20 13H4v-2h16v2z"],
                [3, "for", "click"],
              ],
              template: function (t, i) {
                if (
                  (1 & t &&
                    (rd(),
                    Se(0, "div", 0)(1, "button", 1, 2),
                    Le("click", function () {
                      return i._handleClick();
                    }),
                    Gt(3, "div", 3),
                    Se(4, "div", 4)(5, "div", 5)(6, "div", 6),
                    Gt(7, "div", 7),
                    Re(),
                    Se(8, "div", 8),
                    Gt(9, "div", 9),
                    Re(),
                    Se(10, "div", 10),
                    K_(),
                    Se(11, "svg", 11),
                    Gt(12, "path", 12),
                    Re(),
                    Se(13, "svg", 13),
                    Gt(14, "path", 14),
                    Re()()()()(),
                    (function qS() {
                      !(function HB() {
                        rt.lFrame.currentNamespace = null;
                      })();
                    })(),
                    Se(15, "label", 15),
                    Le("click", function (s) {
                      return s.stopPropagation();
                    }),
                    Gl(16),
                    Re()()),
                  2 & t)
                ) {
                  const r = yr(2);
                  gs("mdc-form-field--align-end", "before" == i.labelPosition),
                    je(1),
                    gs("mdc-switch--selected", i.checked)(
                      "mdc-switch--unselected",
                      !i.checked
                    )("mdc-switch--checked", i.checked)(
                      "mdc-switch--disabled",
                      i.disabled
                    ),
                    Xe("tabIndex", i.tabIndex)("disabled", i.disabled),
                    ii("id", i.buttonId)("name", i.name)(
                      "aria-label",
                      i.ariaLabel
                    )("aria-labelledby", i._getAriaLabelledBy())(
                      "aria-describedby",
                      i.ariaDescribedby
                    )("aria-required", i.required || null)(
                      "aria-checked",
                      i.checked
                    ),
                    je(8),
                    Xe("matRippleTrigger", r)(
                      "matRippleDisabled",
                      i.disableRipple || i.disabled
                    )("matRippleCentered", !0),
                    je(6),
                    Xe("for", i.buttonId),
                    ii("id", i._labelId);
                }
              },
              dependencies: [PF],
              styles: [
                '.mdc-form-field{display:inline-flex;align-items:center;vertical-align:middle}.mdc-form-field[hidden]{display:none}.mdc-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{margin-left:auto;margin-right:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{padding-left:0;padding-right:4px}.mdc-form-field--nowrap>label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{padding-left:4px;padding-right:0}.mdc-form-field--space-between{justify-content:space-between}.mdc-form-field--space-between>label{margin:0}[dir=rtl] .mdc-form-field--space-between>label,.mdc-form-field--space-between>label[dir=rtl]{margin:0}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--mdc-elevation-overlay-color, #fff)}.mdc-switch{align-items:center;background:none;border:none;cursor:pointer;display:inline-flex;flex-shrink:0;margin:0;outline:none;overflow:visible;padding:0;position:relative}.mdc-switch[hidden]{display:none}.mdc-switch:disabled{cursor:default;pointer-events:none}.mdc-switch__track{overflow:hidden;position:relative;width:100%}.mdc-switch__track::before,.mdc-switch__track::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;position:absolute;width:100%}@media screen and (forced-colors: active){.mdc-switch__track::before,.mdc-switch__track::after{border-color:currentColor}}.mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0)}.mdc-switch__track::after{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(-100%)}[dir=rtl] .mdc-switch__track::after,.mdc-switch__track[dir=rtl]::after{transform:translateX(100%)}.mdc-switch--selected .mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__track::before,.mdc-switch--selected .mdc-switch__track[dir=rtl]::before{transform:translateX(-100%)}.mdc-switch--selected .mdc-switch__track::after{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0)}.mdc-switch__handle-track{height:100%;pointer-events:none;position:absolute;top:0;transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);left:0;right:auto;transform:translateX(0)}[dir=rtl] .mdc-switch__handle-track,.mdc-switch__handle-track[dir=rtl]{left:auto;right:0}.mdc-switch--selected .mdc-switch__handle-track{transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__handle-track,.mdc-switch--selected .mdc-switch__handle-track[dir=rtl]{transform:translateX(-100%)}.mdc-switch__handle{display:flex;pointer-events:auto;position:absolute;top:50%;transform:translateY(-50%);left:0;right:auto}[dir=rtl] .mdc-switch__handle,.mdc-switch__handle[dir=rtl]{left:auto;right:0}.mdc-switch__handle::before,.mdc-switch__handle::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";width:100%;height:100%;left:0;position:absolute;top:0;transition:background-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1),border-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);z-index:-1}@media screen and (forced-colors: active){.mdc-switch__handle::before,.mdc-switch__handle::after{border-color:currentColor}}.mdc-switch__shadow{border-radius:inherit;bottom:0;left:0;position:absolute;right:0;top:0}.mdc-elevation-overlay{bottom:0;left:0;right:0;top:0}.mdc-switch__ripple{left:50%;position:absolute;top:50%;transform:translate(-50%, -50%);z-index:-1}.mdc-switch:disabled .mdc-switch__ripple{display:none}.mdc-switch__icons{height:100%;position:relative;width:100%;z-index:1}.mdc-switch__icon{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0;opacity:0;transition:opacity 30ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-switch--selected .mdc-switch__icon--on,.mdc-switch--unselected .mdc-switch__icon--off{opacity:1;transition:opacity 45ms 30ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle{display:inline-block;-webkit-tap-highlight-color:rgba(0,0,0,0);outline:0}.mat-mdc-slide-toggle .mdc-switch{width:var(--mdc-switch-track-width, 36px)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-selected-handle-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-hover-handle-color, #310077)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-focus-handle-color, #310077)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-selected-pressed-handle-color, #310077)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-selected-handle-color, #424242)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-unselected-handle-color, #616161)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-hover-handle-color, #212121)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-focus-handle-color, #212121)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-unselected-pressed-handle-color, #212121)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-unselected-handle-color, #424242)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle::before{background:var(--mdc-switch-handle-surface-color, var(--mdc-theme-surface, #fff))}.mat-mdc-slide-toggle .mdc-switch:enabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-handle-elevation, 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-disabled-handle-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__focus-ring-wrapper,.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle{height:var(--mdc-switch-handle-height, 20px)}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__handle::after{opacity:var(--mdc-switch-disabled-handle-opacity, 0.38)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle{border-radius:var(--mdc-switch-handle-shape, 10px)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle{width:var(--mdc-switch-handle-width, 20px)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__handle-track{width:calc(100% - var(--mdc-switch-handle-width, 20px))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled .mdc-switch__icon{fill:var(--mdc-switch-selected-icon-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-selected-icon-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled .mdc-switch__icon{fill:var(--mdc-switch-unselected-icon-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-unselected-icon-color, var(--mdc-theme-on-primary, #fff))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:disabled .mdc-switch__icons{opacity:var(--mdc-switch-disabled-selected-icon-opacity, 0.38)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:disabled .mdc-switch__icons{opacity:var(--mdc-switch-disabled-unselected-icon-opacity, 0.38)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected .mdc-switch__icon{width:var(--mdc-switch-selected-icon-size, 18px);height:var(--mdc-switch-selected-icon-size, 18px)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected .mdc-switch__icon{width:var(--mdc-switch-unselected-icon-size, 18px);height:var(--mdc-switch-unselected-icon-size, 18px)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-hover-state-layer-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-focus-state-layer-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active .mdc-switch__ripple::after{background-color:var(--mdc-switch-selected-pressed-state-layer-color, var(--mdc-theme-primary, #6200ee))}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-hover-state-layer-color, #424242)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-focus-state-layer-color, #424242)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active .mdc-switch__ripple::after{background-color:var(--mdc-switch-unselected-pressed-state-layer-color, #424242)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus):hover .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:hover:not(:focus).mdc-ripple-surface--hover .mdc-switch__ripple::before{opacity:var(--mdc-switch-selected-hover-state-layer-opacity, 0.04)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus.mdc-ripple-upgraded--background-focused .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:focus:not(.mdc-ripple-upgraded):focus .mdc-switch__ripple::before{transition-duration:75ms;opacity:var(--mdc-switch-selected-focus-state-layer-opacity, 0.12)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active:not(.mdc-ripple-upgraded) .mdc-switch__ripple::after{transition:opacity 150ms linear}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active:not(.mdc-ripple-upgraded):active .mdc-switch__ripple::after{transition-duration:75ms;opacity:var(--mdc-switch-selected-pressed-state-layer-opacity, 0.1)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--selected:enabled:active.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-switch-selected-pressed-state-layer-opacity, 0.1)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus):hover .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:hover:not(:focus).mdc-ripple-surface--hover .mdc-switch__ripple::before{opacity:var(--mdc-switch-unselected-hover-state-layer-opacity, 0.04)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus.mdc-ripple-upgraded--background-focused .mdc-switch__ripple::before,.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:focus:not(.mdc-ripple-upgraded):focus .mdc-switch__ripple::before{transition-duration:75ms;opacity:var(--mdc-switch-unselected-focus-state-layer-opacity, 0.12)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active:not(.mdc-ripple-upgraded) .mdc-switch__ripple::after{transition:opacity 150ms linear}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active:not(.mdc-ripple-upgraded):active .mdc-switch__ripple::after{transition-duration:75ms;opacity:var(--mdc-switch-unselected-pressed-state-layer-opacity, 0.1)}.mat-mdc-slide-toggle .mdc-switch.mdc-switch--unselected:enabled:active.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-switch-unselected-pressed-state-layer-opacity, 0.1)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__ripple{height:var(--mdc-switch-state-layer-size, 48px);width:var(--mdc-switch-state-layer-size, 48px)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__track{height:var(--mdc-switch-track-height, 14px)}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__track{opacity:var(--mdc-switch-disabled-track-opacity, 0.12)}.mat-mdc-slide-toggle .mdc-switch:enabled .mdc-switch__track::after{background:var(--mdc-switch-selected-track-color, #d7bbff)}.mat-mdc-slide-toggle .mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-hover-track-color, #d7bbff)}.mat-mdc-slide-toggle .mdc-switch:enabled:focus:not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-focus-track-color, #d7bbff)}.mat-mdc-slide-toggle .mdc-switch:enabled:active .mdc-switch__track::after{background:var(--mdc-switch-selected-pressed-track-color, #d7bbff)}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__track::after{background:var(--mdc-switch-disabled-selected-track-color, #424242)}.mat-mdc-slide-toggle .mdc-switch:enabled .mdc-switch__track::before{background:var(--mdc-switch-unselected-track-color, #e0e0e0)}.mat-mdc-slide-toggle .mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-hover-track-color, #e0e0e0)}.mat-mdc-slide-toggle .mdc-switch:enabled:focus:not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-focus-track-color, #e0e0e0)}.mat-mdc-slide-toggle .mdc-switch:enabled:active .mdc-switch__track::before{background:var(--mdc-switch-unselected-pressed-track-color, #e0e0e0)}.mat-mdc-slide-toggle .mdc-switch:disabled .mdc-switch__track::before{background:var(--mdc-switch-disabled-unselected-track-color, #424242)}.mat-mdc-slide-toggle .mdc-switch .mdc-switch__track{border-radius:var(--mdc-switch-track-shape, 7px)}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple,.mat-mdc-slide-toggle .mdc-switch__ripple::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple:not(:empty),.mat-mdc-slide-toggle .mdc-switch__ripple::after:not(:empty){transform:translateZ(0)}.mat-mdc-slide-toggle .mdc-switch__ripple::after{content:"";opacity:0}.mat-mdc-slide-toggle .mdc-switch:hover .mdc-switch__ripple::after{opacity:.04;transition:opacity 75ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mdc-switch .mdc-switch__ripple::after{opacity:.12}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mat-mdc-focus-indicator::before{content:""}.mat-mdc-slide-toggle .mat-ripple-element{opacity:.12}.mat-mdc-slide-toggle .mat-mdc-focus-indicator::before{border-radius:50%}.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle-track,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-elevation-overlay,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__icon,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::after,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::after{transition:none}',
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        aN = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({})),
            n
          );
        })(),
        lN = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ imports: [aN, Ds, Pw, Dp, aN, Ds] })),
            n
          );
        })(),
        xne = (() => {
          class n {
            constructor(t) {
              this.sanitizer = t;
            }
            transform(t, ...i) {
              const r = this.format(t);
              return this.sanitizer.bypassSecurityTrustHtml(r);
            }
            format(t) {
              const i = t.split("\n");
              let r = "";
              for (let s of i)
                (s = s.trim()),
                  /^(#+)\s(.+)$/g.test(s)
                    ? (r += s.replace(/^(#+)\s(.+)$/g, (a, l, c) => {
                        const u = l.length;
                        return `<h${u}>${c}</h${u}>`;
                      }))
                    : /^(-+)\s(.+)$/g.test(s)
                    ? (r += s.replace(
                        /^(-+)\s(.+)$/g,
                        (a, l, c) =>
                          `<li style="padding-left: ${
                            20 * l.length
                          }px">${c}</li>`
                      ))
                    : (r += this.escapeHtml(s) + "<br>");
              return r;
            }
            escapeHtml(t) {
              return t
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(G(V1, 16));
            }),
            (n.ɵpipe = bi({ name: "format", type: n, pure: !0 })),
            n
          );
        })();
      const wne = ["editIpt"];
      function Mne(n, e) {
        if ((1 & n && (Se(0, "div", 9), ri(1), Re()), 2 & n)) {
          const t = me(2).$implicit;
          Hr("background-color:" + me().typeColor[t.type]), je(1), vs(t.type);
        }
      }
      function Sne(n, e) {
        1 & n &&
          (Gt(0, "div", 10),
          (function GA(n, e) {
            const t = Rt();
            let i;
            const r = n + nn;
            t.firstCreatePass
              ? ((i = (function H4(n, e) {
                  if (e)
                    for (let t = e.length - 1; t >= 0; t--) {
                      const i = e[t];
                      if (n === i.name) return i;
                    }
                })(e, t.pipeRegistry)),
                (t.data[r] = i),
                i.onDestroy &&
                  (t.destroyHooks ?? (t.destroyHooks = [])).push(
                    r,
                    i.onDestroy
                  ))
              : (i = t.data[r]);
            const s = i.factory || (i.factory = la(i.type)),
              o = pr(G);
            try {
              const a = Cf(!1),
                l = s();
              return (
                Cf(a),
                (function Rz(n, e, t, i) {
                  t >= n.data.length &&
                    ((n.data[t] = null), (n.blueprint[t] = null)),
                    (e[t] = i);
                })(t, se(), r, l),
                l
              );
            } finally {
              pr(o);
            }
          })(1, "format")),
          2 & n && Xe("innerHTML", WA(1, 1, me(2).$implicit.content), rC);
      }
      function Ene(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "textarea", 11, 12),
            Le("keydown.enter", function (r) {
              return at(t), lt(me(3).enterKeyToEdit(r));
            })("blur", function (r) {
              return at(t), lt(me(3).editIptBlur(r));
            })("input", function () {
              return at(t), lt(me(3).getTextareaHeight());
            }),
            Re();
        }
        if (2 & n) {
          const t = me(2).$implicit;
          tp("height", me().textareaHeight, "px"),
            Xe(
              "placeholder",
              "\u65b0\u589e" === t.tid
                ? "\u6dfb\u52a0\u4e00\u4e2a\u65b0\u4efb\u52a1(Tab)"
                : "\u8bf7\u8f93\u5165\u4efb\u52a1\u5185\u5bb9"
            )("value", t.content);
        }
      }
      const Cne = function (n, e) {
          return ["item", n, e];
        },
        Tne = function (n) {
          return [n];
        };
      function Ane(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 3),
            Le("dblclick", function () {
              at(t);
              const r = me().$implicit;
              return lt(me().toggleEdit(r));
            })("contextmenu", function (r) {
              at(t);
              const s = me().$implicit;
              return lt(me().showContentMenu(r, s));
            })("dragstart", function (r) {
              at(t);
              const s = me().$implicit;
              return lt(me().onDragStart(r, s));
            }),
            Se(1, "div", 4)(2, "mat-slide-toggle", 5),
            Le("change", function (r) {
              at(t);
              const s = me().$implicit,
                o = me();
              return lt(o.toggleChange(r, o.id, s.tid));
            })("dblclick", function (r) {
              return r.stopPropagation();
            }),
            Re(),
            jt(3, Mne, 2, 3, "div", 6),
            Re(),
            jt(4, Sne, 2, 3, "div", 7),
            jt(5, Ene, 2, 4, "ng-template", null, 8, Eo),
            Re();
        }
        if (2 & n) {
          const t = yr(6),
            i = me().$implicit,
            r = me();
          Xe(
            "ngClass",
            Cy(
              6,
              Cne,
              i.tid === r.selected ? "selected" : "",
              i.done ? "done" : ""
            )
          ),
            je(1),
            Xe("ngClass", dd(9, Tne, r.isPinned ? "pinnedStatus" : "")),
            je(1),
            Xe("checked", i.done),
            je(1),
            Xe("ngIf", i.type),
            je(1),
            Xe("ngIf", !i.isEdit)("ngIfElse", t);
        }
      }
      function Dne(n, e) {
        if ((1 & n && (Vr(0), jt(1, Ane, 7, 11, "div", 2), zr()), 2 & n)) {
          const t = e.$implicit,
            i = me();
          je(1),
            Xe(
              "ngIf",
              !t.isDelete && ("all" === i.filterType || t.type === i.filterType)
            );
        }
      }
      let dM = (() => {
        class n {
          constructor(t, i) {
            (this.todoService = t),
              (this.cdr = i),
              (this.selected = ""),
              (this.editId = ""),
              (this.content = ""),
              (this.textareaHeight = 25),
              (this.todos = []),
              (this.id = ""),
              (this.filterType = ""),
              (this.isPinned = !1),
              (this.deleteTodo = new Ut());
          }
          ngOnInit() {
            this.todoService.toggleGroup.subscribe(
              ({ id: t, tid: i, val: r }) => {
                this.toExitEdit(event, t, i, r);
              }
            );
          }
          get typeColor() {
            return {
              紧急: "#FF0000",
              无头绪: "#000080",
              待沟通: "#FFA500",
              需讨论: "#800080",
              待验证: "#009696",
              待自测: "#7eb17e",
              需求变更: "#acac00",
              已解决: "#008500",
              已关闭: "#808080",
              已拒绝: "#8B0000",
            };
          }
          getTextareaHeight() {
            if (!this.editInput) return;
            const t = this.editInput.nativeElement;
            (this.textareaHeight = 1),
              requestAnimationFrame(
                () => (this.textareaHeight = Math.max(t.scrollHeight, 30))
              );
          }
          toggleChange(t, i, r) {
            this.todoService.toggleDone(i, r, t.checked),
              t.checked && window.api.toggleAnimation("attack"),
              this.todoService.saveList();
          }
          toggleEdit(t) {
            var i = this;
            return ai(function* () {
              t.done ||
                (i.checkedNewAdd(),
                i.editId &&
                  i.editId !== t.tid &&
                  i.editInput &&
                  i.content !== i.editInput.nativeElement.value &&
                  0 ===
                    (yield window.api.openTip(
                      "info",
                      "\u4fdd\u5b58",
                      "\u662f\u5426\u4fdd\u5b58\u5f53\u524d\u7f16\u8f91\u9879",
                      "\u76ee\u524d\u5df2\u5b58\u5728\u4e00\u4e2a\u7f16\u8f91\u9879\uff0c\u9700\u8981\u5148\u4fdd\u5b58\u4fee\u6539\u6216\u653e\u5f03\u4fee\u6539\u624d\u80fd\u7ee7\u7eed\u7f16\u8f91\u5176\u4ed6todo",
                      ["\u4fdd\u5b58\u4fee\u6539", "\u653e\u5f03\u4fee\u6539"]
                    )).response &&
                  (i.todoService.toEdit(
                    i.id,
                    i.editId,
                    i.editInput.nativeElement.value
                  ),
                  i.todoService.saveList()),
                (i.editId = t.tid),
                (i.content = t.content),
                i.todoService.toggleEdit(i.id, t.tid),
                requestAnimationFrame(() => {
                  i.getTextareaHeight(), i.editInput.nativeElement.focus();
                }));
            })();
          }
          enterKeyToEdit(t) {
            t.stopPropagation(),
              this.checkedNewAdd(this.id),
              this.editId &&
                this.editInput &&
                this.editInput.nativeElement.value.length > 0 &&
                (this.todoService.toEdit(
                  this.id,
                  this.editId,
                  this.editInput.nativeElement.value
                ),
                this.todoService.saveList(),
                (this.editId = ""),
                (this.content = ""));
          }
          toExitEdit(t, i, r, s) {
            var o = this;
            return ai(function* () {
              t && t.stopPropagation();
              const a = s || o.editInput?.nativeElement.value,
                l = i || o.id,
                c = r || o.editId;
              o.checkedNewAdd(l),
                c &&
                  ("\u65b0\u589e" !== c &&
                    o.content !== a &&
                    !t &&
                    0 ===
                      (yield window.api.openTip(
                        "info",
                        "\u4fdd\u5b58",
                        "\u662f\u5426\u4fdd\u5b58\u5f53\u524d\u7f16\u8f91\u9879",
                        "\u76ee\u524d\u5df2\u5b58\u5728\u4e00\u4e2a\u7f16\u8f91\u9879\uff0c\u9700\u8981\u5148\u4fdd\u5b58\u4fee\u6539\u6216\u653e\u5f03\u4fee\u6539\u624d\u80fd\u7ee7\u7eed\u7f16\u8f91\u5176\u4ed6todo",
                        ["\u4fdd\u5b58\u4fee\u6539", "\u653e\u5f03\u4fee\u6539"]
                      )).response &&
                    o.todoService.toEdit(l, c, a),
                  o.todoService.toggleEdit(l, c, !1),
                  o.todoService.saveList(),
                  (o.editId = ""),
                  (o.content = ""),
                  o.cdr.detectChanges());
            })();
          }
          showContentMenu(t, i) {
            var r = this;
            window.api.showTodoMenu(
              { x: t.clientX + 20, y: t.clientY + 10 },
              (function () {
                var o = ai(function* (a) {
                  "edit" === a
                    ? (yield r.toggleEdit(i), r.cdr.detectChanges())
                    : "delete" === a
                    ? (r.deleteTodo.emit({ id: r.id, tid: i.tid }),
                      r.todoService.saveList(),
                      window.api.toggleAnimation("down"))
                    : (r.todoService.toggleType(r.id, i.tid, a),
                      r.cdr.detectChanges());
                });
                return function (a) {
                  return o.apply(this, arguments);
                };
              })()
            );
          }
          checkedNewAdd(t) {
            let i = !1,
              r = t || this.id,
              s = this.todoService.todoList.find((o) => o.id === r);
            if (s && -1 != s.list.findIndex((a) => "\u65b0\u589e" === a.tid)) {
              i = !0;
              let a = this.todoService.todoList.find((l) => l.id === r);
              a &&
                ((a.list = a.list.filter((l) => "\u65b0\u589e" != l.tid)),
                this.editInput.nativeElement.value.length > 0 &&
                  (this.todoService.addTodo(
                    r,
                    this.editInput.nativeElement.value
                  ),
                  this.todoService.saveList()));
            }
            i && (this.editId = "");
          }
          onDragStart(t, i) {
            "\u65b0\u589e" !== i.tid &&
              t.dataTransfer?.setData(
                "todoDetail",
                JSON.stringify({ todo: i, id: this.id })
              );
          }
          editIptBlur(t) {
            t.stopPropagation(), this.toExitEdit();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(gu), G(Ui));
          }),
          (n.ɵcmp = Xi({
            type: n,
            selectors: [["app-contenter-list"]],
            viewQuery: function (t, i) {
              if ((1 & t && jr(wne, 5), 2 & t)) {
                let r;
                Ei((r = Ci())) && (i.editInput = r.first);
              }
            },
            hostBindings: function (t, i) {
              1 & t &&
                Le(
                  "keydown.enter",
                  function (s) {
                    return i.enterKeyToEdit(s);
                  },
                  0,
                  Qu
                )(
                  "keydown.esc",
                  function (s) {
                    return i.toExitEdit(s);
                  },
                  !1,
                  Qu
                );
            },
            inputs: {
              todos: "todos",
              id: "id",
              filterType: "filterType",
              isPinned: "isPinned",
            },
            outputs: { deleteTodo: "deleteTodo" },
            decls: 2,
            vars: 1,
            consts: [
              [1, "contenter-list"],
              [4, "ngFor", "ngForOf"],
              [
                "draggable",
                "true",
                3,
                "ngClass",
                "dblclick",
                "contextmenu",
                "dragstart",
                4,
                "ngIf",
              ],
              [
                "draggable",
                "true",
                3,
                "ngClass",
                "dblclick",
                "contextmenu",
                "dragstart",
              ],
              [1, "status", 3, "ngClass"],
              [3, "checked", "change", "dblclick"],
              ["class", "types", 3, "style", 4, "ngIf"],
              ["class", "content", 3, "innerHTML", 4, "ngIf", "ngIfElse"],
              ["tempEdit", ""],
              [1, "types"],
              [1, "content", 3, "innerHTML"],
              [
                "type",
                "text",
                "autofocus",
                "",
                3,
                "placeholder",
                "value",
                "keydown.enter",
                "blur",
                "input",
              ],
              ["editIpt", ""],
            ],
            template: function (t, i) {
              1 & t &&
                (Se(0, "div", 0), jt(1, Dne, 2, 1, "ng-container", 1), Re()),
                2 & t && (je(1), Xe("ngForOf", i.todos));
            },
            dependencies: [Jl, xd, ec, oN, xne],
            styles: [
              ".contenter-list[_ngcontent-%COMP%]{flex:1;max-height:100%;overflow-y:scroll;padding-right:5px;box-sizing:border-box}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]{box-sizing:border-box;background-color:#fff;min-height:5rem;padding:8px 1rem;margin-bottom:1rem;border-radius:.6rem;display:flex;align-items:center;-webkit-user-select:none;user-select:none;overflow:hidden}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .status[_ngcontent-%COMP%]{display:flex}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .pinnedStatus[_ngcontent-%COMP%]{flex-direction:column}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .pinnedStatus[_ngcontent-%COMP%]   .types[_ngcontent-%COMP%]{margin-top:15px}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .types[_ngcontent-%COMP%]{font-size:12px;color:#edf7fc;padding:2px 5px;border-radius:8px}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{box-sizing:border-box;flex:1;margin-left:10px;word-wrap:break-word;overflow:hidden;white-space:pre-wrap}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   textarea[_ngcontent-%COMP%]{width:100%;height:2.8rem;line-height:1.2rem;font-size:1rem;padding:3px 0 3px 10px;border-radius:8px;resize:none}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;height:2.8rem;padding-left:10px;border-radius:8px}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#edf7fc}.contenter-list[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:hover   .content[_ngcontent-%COMP%]{color:#01aaec}.contenter-list[_ngcontent-%COMP%]   .selected[_ngcontent-%COMP%]{border:1px solid #3532f3}.contenter-list[_ngcontent-%COMP%]   .done[_ngcontent-%COMP%]{background-color:#ccc}.contenter-list[_ngcontent-%COMP%]   .done[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{color:#868686;text-decoration:line-through}",
            ],
          })),
          n
        );
      })();
      const Ine = ["addIpt"],
        Rne = ["editIpt"],
        Pne = ["contenterList"];
      function One(n, e) {
        if (1 & n) {
          const t = qn();
          Vr(0),
            Se(1, "div", 31),
            Le("dblclick", function () {
              at(t);
              const r = me(3).$implicit;
              return lt(me().toogleEditGroup(r.id));
            })("contextmenu", function (r) {
              at(t);
              const s = me(3).$implicit;
              return lt(me().showGroupMenu(r, s.id));
            }),
            ri(2),
            Re(),
            zr();
        }
        if (2 & n) {
          const t = me(3).$implicit;
          je(1), Xe("title", t.title), je(1), ip(" ", t.title, " ");
        }
      }
      function Lne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 32)(1, "input", 33, 34),
            Le("blur", function (r) {
              return at(t), lt(me(4).editGroupBlur(r));
            })("keydown.enter", function (r) {
              return at(t), lt(me(4).onEnterPressed(r));
            }),
            Re()();
        }
        if (2 & n) {
          const t = me(3).$implicit;
          je(1), Xe("value", t.title);
        }
      }
      const Fne = function (n) {
        return ["operate-item", n];
      };
      function Nne(n, e) {
        if (1 & n) {
          const t = qn();
          Vr(0),
            Se(1, "div", 17),
            jt(2, One, 3, 2, "ng-container", 15),
            jt(3, Lne, 3, 1, "ng-template", null, 18, Eo),
            Se(5, "div", 19)(6, "div", 20),
            ri(7),
            Re(),
            Se(8, "div", 21),
            Le("menuOpened", function () {
              at(t);
              const r = me(2).$implicit;
              return lt(me().menuOpened(r.id));
            }),
            Gt(9, "i", 22),
            Re(),
            Se(10, "div", 23),
            Le("click", function () {
              at(t);
              const r = me(2).$implicit;
              return lt(me().toggleStick(r.id));
            }),
            Gt(11, "i", 24),
            Re(),
            Se(12, "div", 25),
            Le("click", function () {
              at(t);
              const r = me(2).$implicit;
              return lt(me().toSort(r.id));
            }),
            Gt(13, "i", 26),
            Re(),
            Se(14, "div", 27),
            Le("click", function (r) {
              at(t);
              const s = me(2).$implicit;
              return lt(me().addTodo(r, s.id));
            }),
            Gt(15, "i", 5),
            Re()()(),
            Se(16, "div", 28),
            Le("drop", function (r) {
              at(t);
              const s = me(2).$implicit;
              return lt(me().onDrop(r, s.id));
            })("dragover", function (r) {
              return at(t), lt(me(3).onDragOver(r));
            }),
            Se(17, "app-contenter-list", 29, 30),
            Le("deleteTodo", function (r) {
              return at(t), lt(me(3).deleteTodo(r));
            }),
            Re()(),
            zr();
        }
        if (2 & n) {
          const t = yr(4),
            i = me(2).$implicit,
            r = me(),
            s = yr(11);
          je(2),
            Xe("ngIf", i.id != r.editId)("ngIfElse", t),
            je(5),
            my(
              " ",
              r.groupTotalCount(i.id)[1],
              " / ",
              r.groupTotalCount(i.id)[0],
              " "
            ),
            je(1),
            Xe("matMenuTriggerFor", s),
            je(2),
            Xe("ngClass", dd(9, Fne, r.isAlwaysOnTop ? "activedColor" : "")),
            je(7),
            Xe("todos", i.list)("id", i.id)(
              "filterType",
              i.filterType || "all"
            );
        }
      }
      function kne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 17)(1, "div", 32)(2, "input", 35, 36),
            Le("blur", function (r) {
              return at(t), lt(me(3).addGroupBlur(r));
            })("keydown.enter", function (r) {
              return at(t), lt(me(3).addGroupBlur(r));
            }),
            Re()()();
        }
      }
      function Bne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 14),
            Le("click", function (r) {
              at(t);
              const s = me().$implicit;
              return lt(me().activeGroup(r, s.id));
            }),
            jt(1, Nne, 19, 11, "ng-container", 15),
            jt(2, kne, 4, 0, "ng-template", null, 16, Eo),
            Re();
        }
        if (2 & n) {
          const t = yr(3),
            i = me().$implicit;
          je(1), Xe("ngIf", i.title)("ngIfElse", t);
        }
      }
      function Une(n, e) {
        if ((1 & n && (Vr(0), jt(1, Bne, 4, 2, "div", 13), zr()), 2 & n)) {
          const t = e.$implicit;
          je(1), Xe("ngIf", !t.isDelete);
        }
      }
      function Vne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "button", 11),
            Le("click", function () {
              const s = at(t).$implicit;
              return lt(me().toggleFilter(s));
            }),
            ri(1),
            Re();
        }
        if (2 & n) {
          const t = e.$implicit;
          Xe("disabled", me().filterType === t), je(1), vs(t);
        }
      }
      let zne = (() => {
        class n {
          constructor(t, i) {
            (this.todoService = t),
              (this.cdr = i),
              (this.selectedId = ""),
              (this.isAlwaysOnTop = !1),
              (this.activeGId = ""),
              (this.editId = ""),
              (this.filterType = "all"),
              (this.typeList = []),
              (this.filterGroupId = ""),
              (this.togglePanel = new Ut()),
              (this.todoList = t.todoList),
              (this.activeGId = this.todoList[0].id);
          }
          groupTotalCount(t) {
            let i = this.todoList.find((o) => o.id === t),
              r = i?.list.reduce(
                (o, a) => (a.done && !a.isDelete ? (o += 1) : o),
                0
              );
            return [i?.list.filter((o) => !o.isDelete).length, r];
          }
          toggleStick(t) {
            var i = this;
            return ai(function* () {
              (i.todoService.pinnedId = t),
                (i.isAlwaysOnTop = yield window.api?.toggleStick()),
                localStorage.setItem("pinnedId", t),
                window.api.togglePinned();
            })();
          }
          activeGroup(t, i) {
            t.stopPropagation(), (this.activeGId = i);
          }
          addTodo(t, i) {
            var r = this;
            return ai(function* () {
              t.stopPropagation();
              const s = i || r.activeGId,
                o = r.contenterLists.find((a) => a.id == s);
              o &&
                (yield o.toExitEdit(),
                r.todoService.addNullTodo(s),
                (o.editId = "\u65b0\u589e"),
                r.cdr.detectChanges(),
                requestAnimationFrame(() =>
                  o.editInput?.nativeElement.focus()
                ));
            })();
          }
          deleteTodo(t) {
            this.todoService.toDeleteTodo(t.id, t.tid),
              this.todoService.saveList(),
              this.cdr.detectChanges();
          }
          onDragOver(t) {
            t.preventDefault();
          }
          onDrop(t, i) {
            const r = t.dataTransfer?.getData("todoDetail");
            if (r) {
              const { todo: s, id: o } = JSON.parse(r);
              o !== i &&
                (this.todoService.toDeleteTodo(o, s.tid),
                s.type
                  ? this.todoService.addTodo(i, s.content, s.done, s.id, s.type)
                  : this.todoService.addTodo(i, s.content, s.done, s.id),
                this.todoService.saveList());
            }
          }
          addGroup() {
            this.todoService.addNullGroup(),
              requestAnimationFrame(() => this.addIpt.nativeElement.focus());
          }
          addGroupBlur(t) {
            const i = t.target.value.trim();
            this.todoService.deleteGroup("newGroupId"),
              i.length > 0 &&
                (this.todoService.addGroup(i), this.todoService.saveList());
          }
          toogleEditGroup(t) {
            (this.editId = t),
              requestAnimationFrame(() => this.editIpt.nativeElement.focus());
          }
          editGroupBlur(t) {
            var i = this;
            return ai(function* () {
              let r = t.target.value.trim(),
                s = i.todoList.find((o) => o.id === i.editId)?.title;
              r.length > 0 && s !== r
                ? i.blurTip(r)
                : ((i.editId = ""), i.cdr.detectChanges());
            })();
          }
          blurTip(t) {
            var i = this;
            return ai(function* () {
              const r = i.editId;
              (i.editId = ""),
                0 ===
                  (yield window.api.openTip(
                    "question",
                    "tips:",
                    "\u662f\u5426\u4fee\u6539\u7ec4\u540d",
                    "\u5f53\u524d\u7f16\u8f91\u7684\u7ec4\u540d\u53d1\u751f\u53d8\u5316,\u662f\u5426\u4fdd\u5b58\u4fee\u6539"
                  )).response &&
                  (i.todoService.editGroup(r, t),
                  i.todoService.saveList(),
                  i.cdr.detectChanges());
            })();
          }
          onEnterPressed(t) {
            const i = t;
            i.stopPropagation();
            let r = i.target.value.trim();
            if (r.length > 0) {
              let s = this.todoList.find((o) => o.id === this.editId)?.title;
              "Escape" === i.key && r !== s
                ? this.blurTip(r)
                : (this.todoService.editGroup(this.editId, r),
                  this.todoService.saveList(),
                  (this.editId = ""));
            }
          }
          showGroupMenu(t, i) {
            var r = this;
            window.api.showGroupMenu(
              { x: t.clientX + 20, y: t.clientY + 10 },
              (function () {
                var o = ai(function* (a) {
                  "edit" === a
                    ? (r.toogleEditGroup(i), r.cdr.detectChanges())
                    : "delete" === a &&
                      0 ===
                        (yield window.api.openTip(
                          "warning",
                          "\u5220\u9664",
                          "\u662f\u5426\u8981\u5220\u9664\u8be5\u5206\u7ec4",
                          "\u6ce8\u610f:\u5220\u9664\u5206\u7ec4\u540e,\u7ec4\u5185\u7684\u6240\u6709todo\u4e5f\u5c06\u4f1a\u5220\u9664"
                        )).response &&
                      (r.todoService.deleteGroup(i),
                      r.todoService.saveList(),
                      r.cdr.detectChanges());
                });
                return function (a) {
                  return o.apply(this, arguments);
                };
              })()
            );
          }
          toSort(t) {
            this.todoService.toSort(t);
          }
          menuOpened(t) {
            const i = this.todoList.find((s) => s.id === t);
            i && (this.filterType = i.filterType || "all");
            let r = [];
            i?.list.forEach((s) => {
              s.type && r.push(s.type);
            }),
              (this.filterGroupId = t),
              (this.typeList = [...new Set(r)]);
          }
          toggleFilter(t) {
            const i = this.todoList.find((r) => r.id === this.filterGroupId);
            i && (i.filterType = t);
          }
          openPetWin() {
            window.api.openPetWin();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(gu), G(Ui));
          }),
          (n.ɵcmp = Xi({
            type: n,
            selectors: [["app-panel-list"]],
            viewQuery: function (t, i) {
              if ((1 & t && (jr(Ine, 5), jr(Rne, 5), jr(Pne, 5)), 2 & t)) {
                let r;
                Ei((r = Ci())) && (i.addIpt = r.first),
                  Ei((r = Ci())) && (i.editIpt = r.first),
                  Ei((r = Ci())) && (i.contenterLists = r);
              }
            },
            hostBindings: function (t, i) {
              1 & t &&
                Le(
                  "keydown.tab",
                  function (s) {
                    return i.addTodo(s);
                  },
                  0,
                  Qu
                );
            },
            outputs: { togglePanel: "togglePanel" },
            decls: 15,
            vars: 3,
            consts: [
              [1, "panelBox"],
              [1, "panelContenter", 3, "click"],
              [4, "ngFor", "ngForOf"],
              [1, "setting"],
              ["title", "\u6dfb\u52a0\u5206\u7ec4", 1, "item", 3, "click"],
              [1, "iconfont", "icon-add"],
              [
                "title",
                "\u5207\u6362\u4e3a\u5217\u8868",
                1,
                "item",
                3,
                "click",
              ],
              [1, "iconfont", "icon-liebiao"],
              ["title", "\u5ba0\u7269\u6a21\u5f0f", 1, "item", 3, "click"],
              [1, "iconfont", "icon-chongwutubiao18"],
              ["filterMenu", "matMenu"],
              ["mat-menu-item", "", 3, "disabled", "click"],
              [
                "mat-menu-item",
                "",
                3,
                "disabled",
                "click",
                4,
                "ngFor",
                "ngForOf",
              ],
              ["class", "panel", 3, "click", 4, "ngIf"],
              [1, "panel", 3, "click"],
              [4, "ngIf", "ngIfElse"],
              ["nullTemplate", ""],
              [1, "header"],
              ["elseTemplate", ""],
              [1, "operate"],
              [1, "total"],
              [
                "title",
                "\u6492\u9009",
                1,
                "item",
                3,
                "matMenuTriggerFor",
                "menuOpened",
              ],
              [1, "iconfont", "icon-a-hierarchicallist"],
              ["title", "\u9489\u4f4f", 3, "ngClass", "click"],
              [1, "iconfont", "icon-ding"],
              [
                "title",
                "\u6392\u5e8f\uff08\u5e8f\u53f7\u4f18\u5148\uff0c\u5e8f\u53f7\u5b9a\u4e49\u5982\uff1a#123\u7a7a\u683c \u5185\u5bb9\uff09",
                1,
                "operate-item",
                3,
                "click",
              ],
              [1, "iconfont", "icon-shengxu"],
              ["title", "\u65b0\u589e", 1, "operate-item", 3, "click"],
              [1, "contentList", 3, "drop", "dragover"],
              [3, "todos", "id", "filterType", "deleteTodo"],
              ["contenterList", ""],
              [1, "title", 3, "title", "dblclick", "contextmenu"],
              [1, "title"],
              [
                "type",
                "text",
                "placeholder",
                "\u8bf7\u8f93\u5165\u7ec4\u540d",
                3,
                "value",
                "blur",
                "keydown.enter",
              ],
              ["editIpt", ""],
              [
                "type",
                "text",
                "placeholder",
                "\u8bf7\u8f93\u5165\u7ec4\u540d",
                3,
                "blur",
                "keydown.enter",
              ],
              ["addIpt", ""],
            ],
            template: function (t, i) {
              1 & t &&
                (Se(0, "div", 0)(1, "div", 1),
                Le("click", function () {
                  return (i.activeGId = "");
                }),
                jt(2, Une, 2, 1, "ng-container", 2),
                Re(),
                Se(3, "div", 3)(4, "div", 4),
                Le("click", function () {
                  return i.addGroup();
                }),
                Gt(5, "i", 5),
                Re(),
                Se(6, "div", 6),
                Le("click", function () {
                  return i.togglePanel.emit();
                }),
                Gt(7, "i", 7),
                Re(),
                Se(8, "div", 8),
                Le("click", function () {
                  return i.openPetWin();
                }),
                Gt(9, "i", 9),
                Re()(),
                Se(10, "mat-menu", null, 10)(12, "button", 11),
                Le("click", function () {
                  return i.toggleFilter("all");
                }),
                ri(13, "\u5168\u90e8"),
                Re(),
                jt(14, Vne, 2, 2, "button", 12),
                Re()()),
                2 & t &&
                  (je(2),
                  Xe("ngForOf", i.todoList),
                  je(10),
                  Xe("disabled", "all" === i.filterType),
                  je(2),
                  Xe("ngForOf", i.typeList));
            },
            dependencies: [Jl, xd, ec, Vw, xu, zw, dM],
            styles: [
              ".panelBox[_ngcontent-%COMP%]{height:98vh;overflow:hidden;padding-top:20px;box-sizing:border-box}@media screen and (max-width: 600px){.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]{height:98vh;overflow-y:scroll}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]{margin:auto auto 15px}.panelBox[_ngcontent-%COMP%]   .setting[_ngcontent-%COMP%]{right:0}}@media screen and (min-width: 600px){.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]{display:flex;height:100%;overflow-x:scroll;overflow-y:hidden}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]{min-width:25rem;height:100%;margin:0 10px 20px;overflow:hidden;box-sizing:border-box}.panelBox[_ngcontent-%COMP%]   .setting[_ngcontent-%COMP%]{right:20px}}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]{width:25rem;height:100vh;box-sizing:border-box;padding:20px 10px;background-color:#f3f4f6;display:flex;flex-direction:column}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;height:40px;margin-bottom:15px}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{width:100%;line-height:40px;font-size:20px;font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{box-sizing:border-box;width:100%;height:35px;border-radius:8px;padding-left:12px}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]{display:flex;height:35px}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]   .total[_ngcontent-%COMP%]{line-height:35px;width:55px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-left:5px;margin-right:-10px}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]   .operate-item[_ngcontent-%COMP%]{width:45px;height:35px;line-height:35px;text-align:center;margin-left:8px}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]   .operate-item[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{font-weight:700;font-size:1.2rem}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]   .operate-item[_ngcontent-%COMP%]:hover{color:#f1b04d;cursor:pointer}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .contentList[_ngcontent-%COMP%]{flex:1;overflow:hidden;padding:20px 0}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]{box-sizing:border-box;background-color:#fff;min-height:3rem;line-height:3rem;padding:0 1rem;margin-bottom:1rem;border-radius:.6rem}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{margin-left:10px;padding:1rem 0}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:hover{cursor:pointer}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .selected[_ngcontent-%COMP%]{border:1px solid #3532f3}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .done[_ngcontent-%COMP%]{background-color:#ccc}.panelBox[_ngcontent-%COMP%]   .panelContenter[_ngcontent-%COMP%]   .panel[_ngcontent-%COMP%]   .done[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{color:#868686;text-decoration:line-through}.panelBox[_ngcontent-%COMP%]   .activedColor[_ngcontent-%COMP%]{color:#4dd0f1}.panelBox[_ngcontent-%COMP%]   .setting[_ngcontent-%COMP%]{position:absolute;bottom:50px;width:50px;text-align:center}.panelBox[_ngcontent-%COMP%]   .setting[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]{width:45px;height:45px;line-height:45px;margin-top:15px;background-color:#ddd;border-radius:50%}.panelBox[_ngcontent-%COMP%]   .setting[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .iconfont[_ngcontent-%COMP%]{font-size:22px}.panelBox[_ngcontent-%COMP%]   .setting[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:hover{color:#f1b04d;cursor:pointer;background-color:#e9e6e6}",
            ],
          })),
          n
        );
      })();
      const Hne = ["contenterList"],
        Gne = ["addIpt"],
        Wne = ["editIpt"];
      function jne(n, e) {
        if (
          (1 & n &&
            (Se(0, "div", 7),
            Gt(1, "i", 31),
            Se(2, "div", 32),
            ri(3),
            Re(),
            Se(4, "span", 33),
            ri(5),
            Re()()),
          2 & n)
        ) {
          const t = me(3).$implicit,
            i = me();
          je(2),
            Xe("id", t.id)("title", t.title),
            je(1),
            vs(t.title),
            je(2),
            vs(i.getLength(t.list));
        }
      }
      function Xne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 34)(1, "input", 35, 36),
            Le("blur", function (r) {
              return at(t), lt(me(4).groupEditBlur(r));
            })("keydown.enter", function (r) {
              return at(t), lt(me(4).onEnterPressed(r));
            })("keydown.escape", function (r) {
              return at(t), lt(me(4).onEnterPressed(r));
            }),
            Re()();
        }
        if (2 & n) {
          const t = me(3).$implicit;
          je(1), Xe("value", t.title);
        }
      }
      const qne = function (n, e) {
        return [n, e];
      };
      function Yne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 28),
            Le("click", function () {
              at(t);
              const r = me(2).$implicit;
              return lt(me().toggleGroup(r.id));
            })("drop", function (r) {
              at(t);
              const s = me(2).$implicit;
              return lt(me().onDrop(r, s.id));
            })("dragover", function (r) {
              return at(t), lt(me(3).onDragOver(r));
            })("dblclick", function () {
              at(t);
              const r = me(2).$implicit;
              return lt(me().toogleEditGroup(r.id));
            })("contextmenu", function (r) {
              at(t);
              const s = me(2).$implicit;
              return lt(me().showGroupMenu(r, s.id));
            }),
            jt(1, jne, 6, 4, "div", 29),
            jt(2, Xne, 3, 1, "ng-template", null, 30, Eo),
            Re();
        }
        if (2 & n) {
          const t = yr(3),
            i = me(2).$implicit,
            r = me();
          Xe(
            "ngClass",
            Cy(
              3,
              qne,
              r.activeItem === i.id ? "active" : "",
              r.dragActiveId === i.id ? "dragActive" : ""
            )
          ),
            je(1),
            Xe("ngIf", i.id !== r.editId)("ngIfElse", t);
        }
      }
      function Zne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 37)(1, "input", 38, 39),
            Le("blur", function (r) {
              return at(t), lt(me(3).groupBlur(r));
            })("keydown.enter", function (r) {
              return at(t), lt(me(3).onEnterPressed(r));
            })("keydown.escape", function (r) {
              return at(t), lt(me(3).onEnterPressed(r));
            }),
            Re()();
        }
      }
      function Kne(n, e) {
        if (
          (1 & n &&
            (Vr(0),
            jt(1, Yne, 4, 6, "div", 26),
            jt(2, Zne, 3, 0, "ng-template", null, 27, Eo),
            zr()),
          2 & n)
        ) {
          const t = yr(3),
            i = me().$implicit;
          je(1), Xe("ngIf", "newGroupId" !== i.id)("ngIfElse", t);
        }
      }
      function $ne(n, e) {
        if (
          (1 & n && (Vr(0), jt(1, Kne, 4, 2, "ng-container", 25), zr()), 2 & n)
        ) {
          const t = e.$implicit;
          je(1), Xe("ngIf", !t.isDelete);
        }
      }
      function Qne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "div", 40)(1, "app-contenter-list", 41, 42),
            Le("deleteTodo", function (r) {
              return at(t), lt(me().deleteTodo(r));
            }),
            Re()();
        }
        if (2 & n) {
          const t = me();
          je(1),
            Xe("todos", t.todos)("id", t.activeItem)(
              "filterType",
              t.todoList[t.index].filterType || "all"
            );
        }
      }
      function Jne(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "button", 23),
            Le("click", function () {
              const s = at(t).$implicit;
              return lt(me().toggleFilter(s));
            }),
            ri(1),
            Re();
        }
        if (2 & n) {
          const t = e.$implicit;
          Xe("disabled", me().filterType === t), je(1), vs(t);
        }
      }
      let eie = (() => {
        class n {
          get title() {
            return this.todoList.find((t) => t.id === this.activeItem)?.title;
          }
          constructor(t, i) {
            (this.todoService = t),
              (this.cdr = i),
              (this.isAlwaysOnTop = !1),
              (this.activeItem = ""),
              (this.dragActiveId = ""),
              (this.editId = ""),
              (this.todoList = []),
              (this.filterType = "all"),
              (this.typeList = []),
              (this.togglePanel = new Ut()),
              (this.todoList = t.todoList);
          }
          ngOnInit() {
            this.todoList &&
              this.todoList[0] &&
              (this.activeItem = this.todoList[0].id);
          }
          get index() {
            return this.todoList.findIndex((i) => i.id === this.activeItem);
          }
          get todos() {
            return (
              this.todoList.filter((t) => t.id === this.activeItem)[0]?.list ||
              []
            );
          }
          getLength(t) {
            return t.filter((i) => !i.isDelete).length;
          }
          getTitle() {
            const t = this.editId || this.activeItem;
            return this.todoList.find((i) => i.id === t)?.title;
          }
          toggleGroup(t) {
            if (this.activeItem != t) {
              let { editId: i, editInput: r } = this.contenterList;
              i &&
                r &&
                this.todoService.toggleGroup.next({
                  id: this.activeItem,
                  tid: i,
                  val: r.nativeElement.value,
                });
            }
            this.activeItem = t;
          }
          toggleStick() {
            var t = this;
            return ai(function* () {
              (t.todoService.pinnedId = t.activeItem),
                (t.isAlwaysOnTop = yield window.api?.toggleStick()),
                localStorage.setItem("pinnedId", t.activeItem),
                window.api.togglePinned();
            })();
          }
          addTodo() {
            var t = this;
            return ai(function* () {
              t.contenterList && (yield t.contenterList.toExitEdit()),
                t.todoService.addNullTodo(t.activeItem),
                t.contenterList && (t.contenterList.editId = "\u65b0\u589e"),
                t.cdr.detectChanges(),
                requestAnimationFrame(
                  () =>
                    t.contenterList.editInput &&
                    t.contenterList.editInput.nativeElement.focus()
                );
            })();
          }
          deleteTodo(t) {
            this.todoService.toDeleteTodo(t.id, t.tid),
              this.todoService.saveList(),
              this.cdr.detectChanges();
          }
          onDragOver(t) {
            t.preventDefault(), (this.dragActiveId = t.target.id);
          }
          onDrop(t, i) {
            this.dragActiveId = "";
            const r = t.dataTransfer?.getData("todoDetail");
            if (r) {
              const { todo: s, id: o } = JSON.parse(r);
              o !== i &&
                (this.todoService.toDeleteTodo(o, s.tid),
                this.todoService.addTodo(i, s.content, s.done, s.id),
                this.todoService.saveList());
            }
          }
          addGroup() {
            this.editId ||
              (this.todoService.addNullGroup(),
              (this.editId = "newGroupId"),
              requestAnimationFrame(() => this.addIpt.nativeElement.focus()));
          }
          groupBlur(t, i = !1) {
            this.todoService.deleteGroup("newGroupId");
            let r = t.target.value.trim();
            !i &&
              r.length > 0 &&
              (this.todoService.addGroup(r),
              this.todoService.saveList(),
              1 === this.todoList.length &&
                (this.activeItem = this.todoList[0].id)),
              this.cdr.detectChanges(),
              (this.editId = "");
          }
          toogleEditGroup(t) {
            (this.editId = t),
              requestAnimationFrame(() => this.editIpt.nativeElement.focus());
          }
          groupEditBlur(t) {
            var i = this;
            return ai(function* () {
              let r = t.target.value.trim();
              r.length > 0 && i.getTitle() !== r
                ? i.blurTip(r)
                : ((i.editId = ""), i.cdr.detectChanges());
            })();
          }
          onEnterPressed(t) {
            const i = t;
            if ((i.stopPropagation(), "newGroupId" === this.editId))
              return void this.groupBlur(i, "Escape" === i.key);
            let r = i.target.value.trim();
            r.length > 0 &&
              ("Escape" === i.key &&
              "newGroupId" !== this.editId &&
              r !== this.getTitle()
                ? this.blurTip(r)
                : (this.todoService.editGroup(this.editId, r),
                  this.todoService.saveList(),
                  (this.editId = "")));
          }
          blurTip(t) {
            var i = this;
            return ai(function* () {
              const r = i.editId;
              (i.editId = ""),
                0 ===
                  (yield window.api.openTip(
                    "question",
                    "tips:",
                    "\u662f\u5426\u4fee\u6539\u7ec4\u540d",
                    "\u5f53\u524d\u7f16\u8f91\u7684\u7ec4\u540d\u53d1\u751f\u53d8\u5316,\u662f\u5426\u4fdd\u5b58\u4fee\u6539"
                  )).response &&
                  (i.todoService.editGroup(r, t),
                  i.todoService.saveList(),
                  i.cdr.detectChanges());
            })();
          }
          showGroupMenu(t, i) {
            var r = this;
            window.api.showGroupMenu(
              { x: t.clientX + 20, y: t.clientY + 10 },
              (function () {
                var o = ai(function* (a) {
                  "edit" === a
                    ? (r.toogleEditGroup(i), r.cdr.detectChanges())
                    : "delete" === a &&
                      0 ===
                        (yield window.api.openTip(
                          "warning",
                          "\u5220\u9664",
                          "\u662f\u5426\u8981\u5220\u9664\u8be5\u5206\u7ec4",
                          "\u6ce8\u610f:\u5220\u9664\u5206\u7ec4\u540e,\u7ec4\u5185\u7684\u6240\u6709todo\u4e5f\u5c06\u4f1a\u5220\u9664"
                        )).response &&
                      (r.todoService.deleteGroup(i),
                      r.todoService.saveList(),
                      (r.activeItem = r.todoService.todoList[0]?.id || ""),
                      r.cdr.detectChanges());
                });
                return function (a) {
                  return o.apply(this, arguments);
                };
              })()
            );
          }
          toSort() {
            this.todoService.toSort(this.activeItem);
          }
          menuOpened() {
            const t = this.todoList.find((r) => r.id === this.activeItem);
            t && (this.filterType = t.filterType || "all");
            let i = [];
            t?.list.forEach((r) => {
              r.type && i.push(r.type);
            }),
              (this.typeList = [...new Set(i)]);
          }
          toggleFilter(t) {
            const i = this.todoList.find((r) => r.id === this.activeItem);
            i && (i.filterType = t);
          }
          openPetWin() {
            window.api.openPetWin();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(gu), G(Ui));
          }),
          (n.ɵcmp = Xi({
            type: n,
            selectors: [["app-list"]],
            viewQuery: function (t, i) {
              if ((1 & t && (jr(Hne, 5), jr(Gne, 5), jr(Wne, 5)), 2 & t)) {
                let r;
                Ei((r = Ci())) && (i.contenterList = r.first),
                  Ei((r = Ci())) && (i.addIpt = r.first),
                  Ei((r = Ci())) && (i.editIpt = r.first);
              }
            },
            hostBindings: function (t, i) {
              1 & t &&
                Le(
                  "keydown.tab",
                  function (s) {
                    return i.addTodo(s);
                  },
                  0,
                  Qu
                );
            },
            outputs: { togglePanel: "togglePanel" },
            decls: 36,
            vars: 6,
            consts: [
              [1, "list"],
              [1, "left"],
              [1, "todolist"],
              [4, "ngFor", "ngForOf"],
              [1, "operator"],
              [1, "item", 3, "click"],
              [1, "iconfont", "icon-add"],
              [1, "content"],
              [1, "iconfont", "icon-yuanshujumianban"],
              [1, "iconfont", "icon-chongwutubiao18"],
              [1, "right"],
              [1, "header"],
              [1, "title"],
              [1, "operate"],
              [
                "title",
                "\u6492\u9009",
                1,
                "item",
                3,
                "matMenuTriggerFor",
                "menuOpened",
              ],
              [1, "iconfont", "icon-a-hierarchicallist"],
              ["title", "\u7f6e\u9876", 1, "item", 3, "click"],
              [1, "iconfont", "icon-ding"],
              [
                "title",
                "\u6392\u5e8f\uff08\u5e8f\u53f7\u4f18\u5148\uff0c\u5e8f\u53f7\u5b9a\u4e49\u5982\uff1a#123\u7a7a\u683c \u5185\u5bb9\uff09",
                1,
                "item",
                3,
                "click",
              ],
              [1, "iconfont", "icon-shengxu"],
              ["title", "\u65b0\u589e", 1, "item", 3, "click"],
              ["class", "contentList", 4, "ngIf"],
              ["filterMenu", "matMenu"],
              ["mat-menu-item", "", 3, "disabled", "click"],
              [
                "mat-menu-item",
                "",
                3,
                "disabled",
                "click",
                4,
                "ngFor",
                "ngForOf",
              ],
              [4, "ngIf"],
              [
                "class",
                "item",
                3,
                "ngClass",
                "click",
                "drop",
                "dragover",
                "dblclick",
                "contextmenu",
                4,
                "ngIf",
                "ngIfElse",
              ],
              ["newGroupTemp", ""],
              [
                1,
                "item",
                3,
                "ngClass",
                "click",
                "drop",
                "dragover",
                "dblclick",
                "contextmenu",
              ],
              ["class", "content", 4, "ngIf", "ngIfElse"],
              ["editGroupTemp", ""],
              [1, "iconfont", "icon-show-list"],
              [1, "center", 3, "id", "title"],
              [1, "number"],
              [1, "editGroup"],
              [
                "type",
                "text",
                "placeholder",
                "\u8bf7\u8f93\u5165\u7ec4\u540d",
                3,
                "value",
                "blur",
                "keydown.enter",
                "keydown.escape",
              ],
              ["editIpt", ""],
              [1, "newGroup", "item", "edit"],
              [
                "type",
                "text",
                "placeholder",
                "\u8bf7\u8f93\u5165\u7ec4\u540d",
                3,
                "blur",
                "keydown.enter",
                "keydown.escape",
              ],
              ["addIpt", ""],
              [1, "contentList"],
              [3, "todos", "id", "filterType", "deleteTodo"],
              ["contenterList", ""],
            ],
            template: function (t, i) {
              if (
                (1 & t &&
                  (Se(0, "div", 0)(1, "div", 1)(2, "div", 2),
                  jt(3, $ne, 2, 1, "ng-container", 3),
                  Re(),
                  Se(4, "div", 4)(5, "div", 5),
                  Le("click", function () {
                    return i.addGroup();
                  }),
                  Gt(6, "i", 6),
                  Se(7, "div", 7),
                  ri(8, "\u6dfb\u52a0\u5206\u7ec4"),
                  Re()(),
                  Se(9, "div", 5),
                  Le("click", function () {
                    return i.togglePanel.emit();
                  }),
                  Gt(10, "i", 8),
                  Se(11, "div", 7),
                  ri(12, "\u9762\u677f\u6a21\u5f0f"),
                  Re()(),
                  Se(13, "div", 5),
                  Le("click", function () {
                    return i.openPetWin();
                  }),
                  Gt(14, "i", 9),
                  Se(15, "div", 7),
                  ri(16, "\u5ba0\u7269\u6a21\u5f0f"),
                  Re()()()(),
                  Se(17, "div", 10)(18, "div", 11)(19, "div", 12),
                  ri(20),
                  Re(),
                  Se(21, "div", 13)(22, "div", 14),
                  Le("menuOpened", function () {
                    return i.menuOpened();
                  }),
                  Gt(23, "i", 15),
                  Re(),
                  Se(24, "div", 16),
                  Le("click", function () {
                    return i.toggleStick();
                  }),
                  Gt(25, "i", 17),
                  Re(),
                  Se(26, "div", 18),
                  Le("click", function () {
                    return i.toSort();
                  }),
                  Gt(27, "i", 19),
                  Re(),
                  Se(28, "div", 20),
                  Le("click", function () {
                    return i.addTodo();
                  }),
                  Gt(29, "i", 6),
                  Re()()(),
                  jt(30, Qne, 3, 3, "div", 21),
                  Se(31, "mat-menu", null, 22)(33, "button", 23),
                  Le("click", function () {
                    return i.toggleFilter("all");
                  }),
                  ri(34, "\u5168\u90e8"),
                  Re(),
                  jt(35, Jne, 2, 2, "button", 24),
                  Re()()()),
                2 & t)
              ) {
                const r = yr(32);
                je(3),
                  Xe("ngForOf", i.todoList),
                  je(17),
                  vs(i.title),
                  je(2),
                  Xe("matMenuTriggerFor", r),
                  je(8),
                  Xe("ngIf", i.todos.length > 0),
                  je(3),
                  Xe("disabled", "all" === i.filterType),
                  je(2),
                  Xe("ngForOf", i.typeList);
              }
            },
            dependencies: [Jl, xd, ec, Vw, xu, zw, dM],
            styles: [
              ".list[_ngcontent-%COMP%]{width:100vw;box-sizing:border-box;padding:10px;background-color:#fff;display:flex}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]{box-sizing:border-box;display:flex;flex-direction:column;align-items:center;justify-content:space-between;width:21vw;height:100vh;padding-top:20px;background-color:#f3f4f6;border-radius:8px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]{width:20vw}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]{padding:5px 10px;font-size:1rem;margin-bottom:10px;box-sizing:border-box}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;height:50px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .center[_ngcontent-%COMP%]{flex:1;margin-left:10px;padding-right:18px;height:50px;line-height:50px;box-sizing:border-box;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#e8eaf0}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .editGroup[_ngcontent-%COMP%]{height:50px;line-height:50px;box-sizing:border-box}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .editGroup[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;height:90%;line-height:1;font-size:16px;padding-left:10px;box-sizing:border-box}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .newGroup[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;height:50px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .edit[_ngcontent-%COMP%]{border:2px solid #4dd0f1;border-radius:8px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .edit[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;height:100%;line-height:1;font-size:16px;padding-left:10px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .dragActive[_ngcontent-%COMP%]{border:3px dashed #4dd0f1}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .todolist[_ngcontent-%COMP%]   .active[_ngcontent-%COMP%]{background-color:#b9c5e0;border-radius:8px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .operator[_ngcontent-%COMP%]{box-sizing:border-box;border-top:1px solid #ccc;width:100%;padding:20px 10px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .operator[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]{display:flex;align-items:center;height:40px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .operator[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{margin-left:10px}.list[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .operator[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#e9e7e7;color:#706262}.list[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]{box-sizing:border-box;margin-left:10px;padding:15px 10px;flex:1;height:100vh;background-color:#f3f4f6;border-radius:10px;overflow:hidden;display:flex;flex-direction:column}.list[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;height:35px;margin-bottom:10px}.list[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{font-weight:600;font-size:1.3rem}.list[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]{display:flex;height:35px}.list[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]{width:45px;height:35px;line-height:35px;text-align:center;margin-left:8px}.list[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{font-weight:700;font-size:1.2rem}.list[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .operate[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:hover{color:#f1b04d;cursor:pointer}.list[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .contentList[_ngcontent-%COMP%]{flex:1;overflow:hidden}.list[_ngcontent-%COMP%]   .activedColor[_ngcontent-%COMP%]{color:#4dd0f1}",
            ],
          })),
          n
        );
      })();
      function tie(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "button", 12),
            Le("click", function () {
              const s = at(t).$implicit;
              return lt(me().toggleFilter(s));
            }),
            ri(1),
            Re();
        }
        if (2 & n) {
          const t = e.$implicit;
          Xe("disabled", me().filterType === t), je(1), vs(t);
        }
      }
      const nie = function (n) {
          return ["iconfont icon-Previous", n];
        },
        iie = function (n) {
          return ["iconfont icon-Next", n];
        };
      let rie = (() => {
        class n {
          constructor(t, i) {
            (this.cdr = t),
              (this.todoService = i),
              (this.todoList = []),
              (this.activeIndex = 0),
              (this.filterType = "all"),
              (this.typeList = []),
              (this.todoList = i.todoList);
            const r = localStorage.getItem("pinnedId") || "";
            let s = this.todoList.findIndex((o) => o.id === r);
            -1 != s && (this.activeIndex = s);
          }
          ngOnInit() {}
          closePinned() {
            localStorage.removeItem("pinnedId"), window.api.closePinned();
          }
          getTitle() {
            return this.todoService.getTitle(
              this.todoList[this.activeIndex].id
            );
          }
          toggleTodos(t = !1) {
            this.activeIndex = t
              ? this.activeIndex >= this.todoList.length - 1
                ? this.todoList.length - 1
                : this.activeIndex + 1
              : this.activeIndex <= 0
              ? 0
              : this.activeIndex - 1;
          }
          deleteTodo(t) {
            this.todoService.toDeleteTodo(t.id, t.tid),
              this.todoService.saveList(),
              this.cdr.detectChanges();
          }
          toSort() {
            this.todoService.toSort(this.todoList[this.activeIndex].id);
          }
          menuOpened() {
            const t = this.todoList.find(
              (r) => r.id === this.todoList[this.activeIndex].id
            );
            t && (this.filterType = t.filterType || "all");
            let i = [];
            t?.list.forEach((r) => {
              r.type && i.push(r.type);
            }),
              (this.typeList = [...new Set(i)]);
          }
          toggleFilter(t) {
            const i = this.todoList.find(
              (r) => r.id === this.todoList[this.activeIndex].id
            );
            i && (i.filterType = t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(Ui), G(gu));
          }),
          (n.ɵcmp = Xi({
            type: n,
            selectors: [["app-pinned"]],
            decls: 18,
            vars: 14,
            consts: [
              [1, "pinned"],
              [1, "title"],
              [1, "left"],
              [3, "ngClass", "click"],
              ["title", "\u6807\u9898\u53ef\u62d6\u52a8", 1, "center"],
              [1, "right"],
              [
                "title",
                "\u7b5b\u9009",
                1,
                "iconfont",
                "icon-a-hierarchicallist",
                3,
                "matMenuTriggerFor",
                "menuOpened",
              ],
              [1, "iconfont", "icon-shengxu", 3, "click"],
              [1, "iconfont", "icon-close", 3, "click"],
              [1, "content"],
              [3, "id", "todos", "filterType", "isPinned", "deleteTodo"],
              ["filterMenu", "matMenu"],
              ["mat-menu-item", "", 3, "disabled", "click"],
              [
                "mat-menu-item",
                "",
                3,
                "disabled",
                "click",
                4,
                "ngFor",
                "ngForOf",
              ],
            ],
            template: function (t, i) {
              if (
                (1 & t &&
                  (Se(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "span", 3),
                  Le("click", function () {
                    return i.toggleTodos();
                  }),
                  Re(),
                  Se(4, "span", 3),
                  Le("click", function () {
                    return i.toggleTodos(!0);
                  }),
                  Re()(),
                  Se(5, "div", 4),
                  ri(6),
                  Re(),
                  Se(7, "div", 5)(8, "span", 6),
                  Le("menuOpened", function () {
                    return i.menuOpened();
                  }),
                  Re(),
                  Se(9, "span", 7),
                  Le("click", function () {
                    return i.toSort();
                  }),
                  Re(),
                  Se(10, "span", 8),
                  Le("click", function () {
                    return i.closePinned();
                  }),
                  Re()()(),
                  Se(11, "div", 9)(12, "app-contenter-list", 10),
                  Le("deleteTodo", function (s) {
                    return i.deleteTodo(s);
                  }),
                  Re()(),
                  Se(13, "mat-menu", null, 11)(15, "button", 12),
                  Le("click", function () {
                    return i.toggleFilter("all");
                  }),
                  ri(16, "\u5168\u90e8"),
                  Re(),
                  jt(17, tie, 2, 2, "button", 13),
                  Re()()),
                2 & t)
              ) {
                const r = yr(14);
                je(3),
                  Xe(
                    "ngClass",
                    dd(10, nie, 0 === i.activeIndex ? "disabled" : "")
                  ),
                  je(1),
                  Xe(
                    "ngClass",
                    dd(
                      12,
                      iie,
                      i.activeIndex === i.todoList.length - 1 ? "disabled" : ""
                    )
                  ),
                  je(2),
                  vs(i.getTitle()),
                  je(2),
                  Xe("matMenuTriggerFor", r),
                  je(4),
                  Xe("id", i.todoList[i.activeIndex].id)(
                    "todos",
                    i.todoList[i.activeIndex].list
                  )(
                    "filterType",
                    i.todoList[i.activeIndex].filterType || "all"
                  )("isPinned", !0),
                  je(3),
                  Xe("disabled", "all" === i.filterType),
                  je(2),
                  Xe("ngForOf", i.typeList);
              }
            },
            dependencies: [Jl, xd, Vw, xu, zw, dM],
            styles: [
              ".pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{text-align:center;font-size:16px;line-height:25px;border-bottom:1px dashed #ccc;display:flex;justify-content:space-between;align-items:center;padding:2px 15px}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .iconfont[_ngcontent-%COMP%]{font-size:20px;cursor:pointer}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .iconfont[_ngcontent-%COMP%]:hover{color:#ff9100}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]{width:50px}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .center[_ngcontent-%COMP%]{flex:1;-webkit-app-region:drag}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]{width:65px}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .iconfont[_ngcontent-%COMP%]{font-size:18px;margin-right:10px}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .iconfont[_ngcontent-%COMP%]:hover{color:red}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .icon-shengxu[_ngcontent-%COMP%]:hover{color:#ff9100}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .disabled[_ngcontent-%COMP%], .pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .disabled[_ngcontent-%COMP%]{cursor:default;color:#ccc}.pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   .disabled[_ngcontent-%COMP%]:hover, .pinned[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   .disabled[_ngcontent-%COMP%]:hover{color:#ccc}.pinned[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{box-sizing:border-box;width:100%;height:100vh;overflow-y:scroll;padding-bottom:20px}",
            ],
          })),
          n
        );
      })();
      function sie(n, e) {
        if (1 & n) {
          const t = qn();
          Vr(0),
            Se(1, "app-list", 5),
            Le("togglePanel", function () {
              return at(t), lt(me(3).togglePanel());
            }),
            Re(),
            zr();
        }
      }
      function oie(n, e) {
        if (
          (1 & n && (Vr(0), jt(1, sie, 2, 0, "ng-container", 2), zr()), 2 & n)
        ) {
          me();
          const t = yr(3),
            i = me();
          je(1), Xe("ngIf", !i.isPanel)("ngIfElse", t);
        }
      }
      function aie(n, e) {
        if (1 & n) {
          const t = qn();
          Se(0, "app-panel-list", 5),
            Le("togglePanel", function () {
              return at(t), lt(me(2).togglePanel());
            }),
            Re();
        }
      }
      function lie(n, e) {
        1 & n && Gt(0, "app-pinned");
      }
      function cie(n, e) {
        if (
          (1 & n &&
            (Se(0, "div", 1),
            jt(1, oie, 2, 2, "ng-container", 2),
            jt(2, aie, 1, 0, "ng-template", null, 3, Eo),
            jt(4, lie, 1, 0, "ng-template", null, 4, Eo),
            Re()),
          2 & n)
        ) {
          const t = yr(5),
            i = me();
          je(1), Xe("ngIf", !i.pinnedId)("ngIfElse", t);
        }
      }
      let cN = (() => {
        class n {
          get pinnedId() {
            return (
              this.todoService.pinnedId || localStorage.getItem("pinnedId")
            );
          }
          constructor(t) {
            (this.todoService = t),
              (this.isInit = !1),
              (this.title = "todo"),
              (this.isAlwaysOnTop = !1),
              (this.isPanel = !1),
              (this.todoList = []),
              t.isInitSubject.subscribe((i) => {
                this.isInit = i;
              });
          }
          ngOnInit() {
            var t = this;
            return ai(function* () {
              let i = yield t.todoService.getList();
              t.todoList = i;
            })();
          }
          togglePanel() {
            this.isPanel = !this.isPanel;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(G(gu));
          }),
          (n.ɵcmp = Xi({
            type: n,
            selectors: [["app-home"]],
            decls: 1,
            vars: 1,
            consts: [
              ["class", "contenter", 4, "ngIf"],
              [1, "contenter"],
              [4, "ngIf", "ngIfElse"],
              ["panelTemplate", ""],
              ["pinnedTemplate", ""],
              [3, "togglePanel"],
            ],
            template: function (t, i) {
              1 & t && jt(0, cie, 6, 2, "div", 0),
                2 & t && Xe("ngIf", i.isInit);
            },
            dependencies: [ec, zne, eie, rie],
            styles: [
              ".contenter[_ngcontent-%COMP%]{width:100vw;height:100vh;box-sizing:border-box;background-color:#fff;overflow:hidden}",
            ],
          })),
          n
        );
      })();
      const uie = [
        { path: "", component: cN },
        { path: "pet", component: YQ },
        { path: "*", component: cN },
      ];
      let die = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ imports: [eR.forRoot(uie, { useHash: !0 }), eR] })),
            n
          );
        })(),
        hie = (() => {
          class n {
            constructor() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Xi({
              type: n,
              selectors: [["app-root"]],
              decls: 1,
              vars: 0,
              template: function (t, i) {
                1 & t && Gt(0, "router-outlet");
              },
              dependencies: [j0],
            })),
            n
          );
        })();
      function uN(n) {
        return new J(3e3, !1);
      }
      function qie() {
        return typeof window < "u" && typeof window.document < "u";
      }
      function hM() {
        return (
          typeof process < "u" &&
          "[object process]" === {}.toString.call(process)
        );
      }
      function ia(n) {
        switch (n.length) {
          case 0:
            return new Bh();
          case 1:
            return n[0];
          default:
            return new kF(n);
        }
      }
      function dN(n, e, t, i, r = new Map(), s = new Map()) {
        const o = [],
          a = [];
        let l = -1,
          c = null;
        if (
          (i.forEach((u) => {
            const d = u.get("offset"),
              h = d == l,
              f = (h && c) || new Map();
            u.forEach((p, _) => {
              let m = _,
                g = p;
              if ("offset" !== _)
                switch (((m = e.normalizePropertyName(m, o)), g)) {
                  case Fw:
                    g = r.get(_);
                    break;
                  case go:
                    g = s.get(_);
                    break;
                  default:
                    g = e.normalizeStyleValue(_, m, g, o);
                }
              f.set(m, g);
            }),
              h || a.push(f),
              (c = f),
              (l = d);
          }),
          o.length)
        )
          throw (function Fie(n) {
            return new J(3502, !1);
          })();
        return a;
      }
      function fM(n, e, t, i) {
        switch (e) {
          case "start":
            n.onStart(() => i(t && pM(t, "start", n)));
            break;
          case "done":
            n.onDone(() => i(t && pM(t, "done", n)));
            break;
          case "destroy":
            n.onDestroy(() => i(t && pM(t, "destroy", n)));
        }
      }
      function pM(n, e, t) {
        const s = mM(
            n.element,
            n.triggerName,
            n.fromState,
            n.toState,
            e || n.phaseName,
            t.totalTime ?? n.totalTime,
            !!t.disabled
          ),
          o = n._data;
        return null != o && (s._data = o), s;
      }
      function mM(n, e, t, i, r = "", s = 0, o) {
        return {
          element: n,
          triggerName: e,
          fromState: t,
          toState: i,
          phaseName: r,
          totalTime: s,
          disabled: !!o,
        };
      }
      function ur(n, e, t) {
        let i = n.get(e);
        return i || n.set(e, (i = t)), i;
      }
      function hN(n) {
        const e = n.indexOf(":");
        return [n.substring(1, e), n.slice(e + 1)];
      }
      let gM = (n, e) => !1,
        fN = (n, e, t) => [],
        pN = null;
      function _M(n) {
        const e = n.parentNode || n.host;
        return e === pN ? null : e;
      }
      (hM() || typeof Element < "u") &&
        (qie()
          ? ((pN = (() => document.documentElement)()),
            (gM = (n, e) => {
              for (; e; ) {
                if (e === n) return !0;
                e = _M(e);
              }
              return !1;
            }))
          : (gM = (n, e) => n.contains(e)),
        (fN = (n, e, t) => {
          if (t) return Array.from(n.querySelectorAll(e));
          const i = n.querySelector(e);
          return i ? [i] : [];
        }));
      let tl = null,
        mN = !1;
      const gN = gM,
        _N = fN;
      let vN = (() => {
          class n {
            validateStyleProperty(t) {
              return (function Zie(n) {
                tl ||
                  ((tl =
                    (function Kie() {
                      return typeof document < "u" ? document.body : null;
                    })() || {}),
                  (mN = !!tl.style && "WebkitAppearance" in tl.style));
                let e = !0;
                return (
                  tl.style &&
                    !(function Yie(n) {
                      return "ebkit" == n.substring(1, 6);
                    })(n) &&
                    ((e = n in tl.style),
                    !e &&
                      mN &&
                      (e =
                        "Webkit" + n.charAt(0).toUpperCase() + n.slice(1) in
                        tl.style)),
                  e
                );
              })(t);
            }
            matchesElement(t, i) {
              return !1;
            }
            containsElement(t, i) {
              return gN(t, i);
            }
            getParentElement(t) {
              return _M(t);
            }
            query(t, i, r) {
              return _N(t, i, r);
            }
            computeStyle(t, i, r) {
              return r || "";
            }
            animate(t, i, r, s, o, a = [], l) {
              return new Bh(r, s);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        vM = (() => {
          class n {}
          return (n.NOOP = new vN()), n;
        })();
      const $ie = 1e3,
        yM = "ng-enter",
        Qg = "ng-leave",
        Jg = "ng-trigger",
        e_ = ".ng-trigger",
        bN = "ng-animating",
        bM = ".ng-animating";
      function vo(n) {
        if ("number" == typeof n) return n;
        const e = n.match(/^(-?[\.\d]+)(m?s)/);
        return !e || e.length < 2 ? 0 : xM(parseFloat(e[1]), e[2]);
      }
      function xM(n, e) {
        return "s" === e ? n * $ie : n;
      }
      function t_(n, e, t) {
        return n.hasOwnProperty("duration")
          ? n
          : (function Jie(n, e, t) {
              let r,
                s = 0,
                o = "";
              if ("string" == typeof n) {
                const a = n.match(
                  /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i
                );
                if (null === a)
                  return e.push(uN()), { duration: 0, delay: 0, easing: "" };
                r = xM(parseFloat(a[1]), a[2]);
                const l = a[3];
                null != l && (s = xM(parseFloat(l), a[4]));
                const c = a[5];
                c && (o = c);
              } else r = n;
              if (!t) {
                let a = !1,
                  l = e.length;
                r < 0 &&
                  (e.push(
                    (function fie() {
                      return new J(3100, !1);
                    })()
                  ),
                  (a = !0)),
                  s < 0 &&
                    (e.push(
                      (function pie() {
                        return new J(3101, !1);
                      })()
                    ),
                    (a = !0)),
                  a && e.splice(l, 0, uN());
              }
              return { duration: r, delay: s, easing: o };
            })(n, e, t);
      }
      function qh(n, e = {}) {
        return (
          Object.keys(n).forEach((t) => {
            e[t] = n[t];
          }),
          e
        );
      }
      function xN(n) {
        const e = new Map();
        return (
          Object.keys(n).forEach((t) => {
            e.set(t, n[t]);
          }),
          e
        );
      }
      function ra(n, e = new Map(), t) {
        if (t) for (let [i, r] of t) e.set(i, r);
        for (let [i, r] of n) e.set(i, r);
        return e;
      }
      function MN(n, e, t) {
        return t ? e + ":" + t + ";" : "";
      }
      function SN(n) {
        let e = "";
        for (let t = 0; t < n.style.length; t++) {
          const i = n.style.item(t);
          e += MN(0, i, n.style.getPropertyValue(i));
        }
        for (const t in n.style)
          n.style.hasOwnProperty(t) &&
            !t.startsWith("_") &&
            (e += MN(0, ire(t), n.style[t]));
        n.setAttribute("style", e);
      }
      function Is(n, e, t) {
        n.style &&
          (e.forEach((i, r) => {
            const s = MM(r);
            t && !t.has(r) && t.set(r, n.style[s]), (n.style[s] = i);
          }),
          hM() && SN(n));
      }
      function nl(n, e) {
        n.style &&
          (e.forEach((t, i) => {
            const r = MM(i);
            n.style[r] = "";
          }),
          hM() && SN(n));
      }
      function Yh(n) {
        return Array.isArray(n) ? (1 == n.length ? n[0] : FF(n)) : n;
      }
      const wM = new RegExp("{{\\s*(.+?)\\s*}}", "g");
      function EN(n) {
        let e = [];
        if ("string" == typeof n) {
          let t;
          for (; (t = wM.exec(n)); ) e.push(t[1]);
          wM.lastIndex = 0;
        }
        return e;
      }
      function Zh(n, e, t) {
        const i = n.toString(),
          r = i.replace(wM, (s, o) => {
            let a = e[o];
            return (
              null == a &&
                (t.push(
                  (function gie(n) {
                    return new J(3003, !1);
                  })()
                ),
                (a = "")),
              a.toString()
            );
          });
        return r == i ? n : r;
      }
      function n_(n) {
        const e = [];
        let t = n.next();
        for (; !t.done; ) e.push(t.value), (t = n.next());
        return e;
      }
      const nre = /-+([a-z0-9])/g;
      function MM(n) {
        return n.replace(nre, (...e) => e[1].toUpperCase());
      }
      function ire(n) {
        return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }
      function dr(n, e, t) {
        switch (e.type) {
          case 7:
            return n.visitTrigger(e, t);
          case 0:
            return n.visitState(e, t);
          case 1:
            return n.visitTransition(e, t);
          case 2:
            return n.visitSequence(e, t);
          case 3:
            return n.visitGroup(e, t);
          case 4:
            return n.visitAnimate(e, t);
          case 5:
            return n.visitKeyframes(e, t);
          case 6:
            return n.visitStyle(e, t);
          case 8:
            return n.visitReference(e, t);
          case 9:
            return n.visitAnimateChild(e, t);
          case 10:
            return n.visitAnimateRef(e, t);
          case 11:
            return n.visitQuery(e, t);
          case 12:
            return n.visitStagger(e, t);
          default:
            throw (function _ie(n) {
              return new J(3004, !1);
            })();
        }
      }
      function CN(n, e) {
        return window.getComputedStyle(n)[e];
      }
      const s_ = "*";
      function cre(n, e) {
        const t = [];
        return (
          "string" == typeof n
            ? n.split(/\s*,\s*/).forEach((i) =>
                (function ure(n, e, t) {
                  if (":" == n[0]) {
                    const l = (function dre(n, e) {
                      switch (n) {
                        case ":enter":
                          return "void => *";
                        case ":leave":
                          return "* => void";
                        case ":increment":
                          return (t, i) => parseFloat(i) > parseFloat(t);
                        case ":decrement":
                          return (t, i) => parseFloat(i) < parseFloat(t);
                        default:
                          return (
                            e.push(
                              (function Rie(n) {
                                return new J(3016, !1);
                              })()
                            ),
                            "* => *"
                          );
                      }
                    })(n, t);
                    if ("function" == typeof l) return void e.push(l);
                    n = l;
                  }
                  const i = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                  if (null == i || i.length < 4)
                    return (
                      t.push(
                        (function Iie(n) {
                          return new J(3015, !1);
                        })()
                      ),
                      e
                    );
                  const r = i[1],
                    s = i[2],
                    o = i[3];
                  e.push(TN(r, o));
                  "<" == s[0] && !(r == s_ && o == s_) && e.push(TN(o, r));
                })(i, t, e)
              )
            : t.push(n),
          t
        );
      }
      const o_ = new Set(["true", "1"]),
        a_ = new Set(["false", "0"]);
      function TN(n, e) {
        const t = o_.has(n) || a_.has(n),
          i = o_.has(e) || a_.has(e);
        return (r, s) => {
          let o = n == s_ || n == r,
            a = e == s_ || e == s;
          return (
            !o && t && "boolean" == typeof r && (o = r ? o_.has(n) : a_.has(n)),
            !a && i && "boolean" == typeof s && (a = s ? o_.has(e) : a_.has(e)),
            o && a
          );
        };
      }
      const hre = new RegExp("s*:selfs*,?", "g");
      function SM(n, e, t, i) {
        return new fre(n).build(e, t, i);
      }
      class fre {
        constructor(e) {
          this._driver = e;
        }
        build(e, t, i) {
          const r = new gre(t);
          return this._resetContextStyleTimingState(r), dr(this, Yh(e), r);
        }
        _resetContextStyleTimingState(e) {
          (e.currentQuerySelector = ""),
            (e.collectedStyles = new Map()),
            e.collectedStyles.set("", new Map()),
            (e.currentTime = 0);
        }
        visitTrigger(e, t) {
          let i = (t.queryCount = 0),
            r = (t.depCount = 0);
          const s = [],
            o = [];
          return (
            "@" == e.name.charAt(0) &&
              t.errors.push(
                (function yie() {
                  return new J(3006, !1);
                })()
              ),
            e.definitions.forEach((a) => {
              if ((this._resetContextStyleTimingState(t), 0 == a.type)) {
                const l = a,
                  c = l.name;
                c
                  .toString()
                  .split(/\s*,\s*/)
                  .forEach((u) => {
                    (l.name = u), s.push(this.visitState(l, t));
                  }),
                  (l.name = c);
              } else if (1 == a.type) {
                const l = this.visitTransition(a, t);
                (i += l.queryCount), (r += l.depCount), o.push(l);
              } else
                t.errors.push(
                  (function bie() {
                    return new J(3007, !1);
                  })()
                );
            }),
            {
              type: 7,
              name: e.name,
              states: s,
              transitions: o,
              queryCount: i,
              depCount: r,
              options: null,
            }
          );
        }
        visitState(e, t) {
          const i = this.visitStyle(e.styles, t),
            r = (e.options && e.options.params) || null;
          if (i.containsDynamicStyles) {
            const s = new Set(),
              o = r || {};
            i.styles.forEach((a) => {
              a instanceof Map &&
                a.forEach((l) => {
                  EN(l).forEach((c) => {
                    o.hasOwnProperty(c) || s.add(c);
                  });
                });
            }),
              s.size &&
                (n_(s.values()),
                t.errors.push(
                  (function xie(n, e) {
                    return new J(3008, !1);
                  })()
                ));
          }
          return {
            type: 0,
            name: e.name,
            style: i,
            options: r ? { params: r } : null,
          };
        }
        visitTransition(e, t) {
          (t.queryCount = 0), (t.depCount = 0);
          const i = dr(this, Yh(e.animation), t);
          return {
            type: 1,
            matchers: cre(e.expr, t.errors),
            animation: i,
            queryCount: t.queryCount,
            depCount: t.depCount,
            options: il(e.options),
          };
        }
        visitSequence(e, t) {
          return {
            type: 2,
            steps: e.steps.map((i) => dr(this, i, t)),
            options: il(e.options),
          };
        }
        visitGroup(e, t) {
          const i = t.currentTime;
          let r = 0;
          const s = e.steps.map((o) => {
            t.currentTime = i;
            const a = dr(this, o, t);
            return (r = Math.max(r, t.currentTime)), a;
          });
          return (
            (t.currentTime = r), { type: 3, steps: s, options: il(e.options) }
          );
        }
        visitAnimate(e, t) {
          const i = (function vre(n, e) {
            if (n.hasOwnProperty("duration")) return n;
            if ("number" == typeof n) return EM(t_(n, e).duration, 0, "");
            const t = n;
            if (
              t
                .split(/\s+/)
                .some((s) => "{" == s.charAt(0) && "{" == s.charAt(1))
            ) {
              const s = EM(0, 0, "");
              return (s.dynamic = !0), (s.strValue = t), s;
            }
            const r = t_(t, e);
            return EM(r.duration, r.delay, r.easing);
          })(e.timings, t.errors);
          t.currentAnimateTimings = i;
          let r,
            s = e.styles ? e.styles : _o({});
          if (5 == s.type) r = this.visitKeyframes(s, t);
          else {
            let o = e.styles,
              a = !1;
            if (!o) {
              a = !0;
              const c = {};
              i.easing && (c.easing = i.easing), (o = _o(c));
            }
            t.currentTime += i.duration + i.delay;
            const l = this.visitStyle(o, t);
            (l.isEmptyStep = a), (r = l);
          }
          return (
            (t.currentAnimateTimings = null),
            { type: 4, timings: i, style: r, options: null }
          );
        }
        visitStyle(e, t) {
          const i = this._makeStyleAst(e, t);
          return this._validateStyleAst(i, t), i;
        }
        _makeStyleAst(e, t) {
          const i = [],
            r = Array.isArray(e.styles) ? e.styles : [e.styles];
          for (let a of r)
            "string" == typeof a
              ? a === go
                ? i.push(a)
                : t.errors.push(new J(3002, !1))
              : i.push(xN(a));
          let s = !1,
            o = null;
          return (
            i.forEach((a) => {
              if (
                a instanceof Map &&
                (a.has("easing") && ((o = a.get("easing")), a.delete("easing")),
                !s)
              )
                for (let l of a.values())
                  if (l.toString().indexOf("{{") >= 0) {
                    s = !0;
                    break;
                  }
            }),
            {
              type: 6,
              styles: i,
              easing: o,
              offset: e.offset,
              containsDynamicStyles: s,
              options: null,
            }
          );
        }
        _validateStyleAst(e, t) {
          const i = t.currentAnimateTimings;
          let r = t.currentTime,
            s = t.currentTime;
          i && s > 0 && (s -= i.duration + i.delay),
            e.styles.forEach((o) => {
              "string" != typeof o &&
                o.forEach((a, l) => {
                  const c = t.collectedStyles.get(t.currentQuerySelector),
                    u = c.get(l);
                  let d = !0;
                  u &&
                    (s != r &&
                      s >= u.startTime &&
                      r <= u.endTime &&
                      (t.errors.push(
                        (function Mie(n, e, t, i, r) {
                          return new J(3010, !1);
                        })()
                      ),
                      (d = !1)),
                    (s = u.startTime)),
                    d && c.set(l, { startTime: s, endTime: r }),
                    t.options &&
                      (function tre(n, e, t) {
                        const i = e.params || {},
                          r = EN(n);
                        r.length &&
                          r.forEach((s) => {
                            i.hasOwnProperty(s) ||
                              t.push(
                                (function mie(n) {
                                  return new J(3001, !1);
                                })()
                              );
                          });
                      })(a, t.options, t.errors);
                });
            });
        }
        visitKeyframes(e, t) {
          const i = { type: 5, styles: [], options: null };
          if (!t.currentAnimateTimings)
            return (
              t.errors.push(
                (function Sie() {
                  return new J(3011, !1);
                })()
              ),
              i
            );
          let s = 0;
          const o = [];
          let a = !1,
            l = !1,
            c = 0;
          const u = e.steps.map((g) => {
            const y = this._makeStyleAst(g, t);
            let v =
                null != y.offset
                  ? y.offset
                  : (function _re(n) {
                      if ("string" == typeof n) return null;
                      let e = null;
                      if (Array.isArray(n))
                        n.forEach((t) => {
                          if (t instanceof Map && t.has("offset")) {
                            const i = t;
                            (e = parseFloat(i.get("offset"))),
                              i.delete("offset");
                          }
                        });
                      else if (n instanceof Map && n.has("offset")) {
                        const t = n;
                        (e = parseFloat(t.get("offset"))), t.delete("offset");
                      }
                      return e;
                    })(y.styles),
              b = 0;
            return (
              null != v && (s++, (b = y.offset = v)),
              (l = l || b < 0 || b > 1),
              (a = a || b < c),
              (c = b),
              o.push(b),
              y
            );
          });
          l &&
            t.errors.push(
              (function Eie() {
                return new J(3012, !1);
              })()
            ),
            a &&
              t.errors.push(
                (function Cie() {
                  return new J(3200, !1);
                })()
              );
          const d = e.steps.length;
          let h = 0;
          s > 0 && s < d
            ? t.errors.push(
                (function Tie() {
                  return new J(3202, !1);
                })()
              )
            : 0 == s && (h = 1 / (d - 1));
          const f = d - 1,
            p = t.currentTime,
            _ = t.currentAnimateTimings,
            m = _.duration;
          return (
            u.forEach((g, y) => {
              const v = h > 0 ? (y == f ? 1 : h * y) : o[y],
                b = v * m;
              (t.currentTime = p + _.delay + b),
                (_.duration = b),
                this._validateStyleAst(g, t),
                (g.offset = v),
                i.styles.push(g);
            }),
            i
          );
        }
        visitReference(e, t) {
          return {
            type: 8,
            animation: dr(this, Yh(e.animation), t),
            options: il(e.options),
          };
        }
        visitAnimateChild(e, t) {
          return t.depCount++, { type: 9, options: il(e.options) };
        }
        visitAnimateRef(e, t) {
          return {
            type: 10,
            animation: this.visitReference(e.animation, t),
            options: il(e.options),
          };
        }
        visitQuery(e, t) {
          const i = t.currentQuerySelector,
            r = e.options || {};
          t.queryCount++, (t.currentQuery = e);
          const [s, o] = (function pre(n) {
            const e = !!n.split(/\s*,\s*/).find((t) => ":self" == t);
            return (
              e && (n = n.replace(hre, "")),
              (n = n
                .replace(/@\*/g, e_)
                .replace(/@\w+/g, (t) => e_ + "-" + t.slice(1))
                .replace(/:animating/g, bM)),
              [n, e]
            );
          })(e.selector);
          (t.currentQuerySelector = i.length ? i + " " + s : s),
            ur(t.collectedStyles, t.currentQuerySelector, new Map());
          const a = dr(this, Yh(e.animation), t);
          return (
            (t.currentQuery = null),
            (t.currentQuerySelector = i),
            {
              type: 11,
              selector: s,
              limit: r.limit || 0,
              optional: !!r.optional,
              includeSelf: o,
              animation: a,
              originalSelector: e.selector,
              options: il(e.options),
            }
          );
        }
        visitStagger(e, t) {
          t.currentQuery ||
            t.errors.push(
              (function Aie() {
                return new J(3013, !1);
              })()
            );
          const i =
            "full" === e.timings
              ? { duration: 0, delay: 0, easing: "full" }
              : t_(e.timings, t.errors, !0);
          return {
            type: 12,
            animation: dr(this, Yh(e.animation), t),
            timings: i,
            options: null,
          };
        }
      }
      class gre {
        constructor(e) {
          (this.errors = e),
            (this.queryCount = 0),
            (this.depCount = 0),
            (this.currentTransition = null),
            (this.currentQuery = null),
            (this.currentQuerySelector = null),
            (this.currentAnimateTimings = null),
            (this.currentTime = 0),
            (this.collectedStyles = new Map()),
            (this.options = null),
            (this.unsupportedCSSPropertiesFound = new Set());
        }
      }
      function il(n) {
        return (
          n
            ? (n = qh(n)).params &&
              (n.params = (function mre(n) {
                return n ? qh(n) : null;
              })(n.params))
            : (n = {}),
          n
        );
      }
      function EM(n, e, t) {
        return { duration: n, delay: e, easing: t };
      }
      function CM(n, e, t, i, r, s, o = null, a = !1) {
        return {
          type: 1,
          element: n,
          keyframes: e,
          preStyleProps: t,
          postStyleProps: i,
          duration: r,
          delay: s,
          totalTime: r + s,
          easing: o,
          subTimeline: a,
        };
      }
      class l_ {
        constructor() {
          this._map = new Map();
        }
        get(e) {
          return this._map.get(e) || [];
        }
        append(e, t) {
          let i = this._map.get(e);
          i || this._map.set(e, (i = [])), i.push(...t);
        }
        has(e) {
          return this._map.has(e);
        }
        clear() {
          this._map.clear();
        }
      }
      const xre = new RegExp(":enter", "g"),
        Mre = new RegExp(":leave", "g");
      function TM(n, e, t, i, r, s = new Map(), o = new Map(), a, l, c = []) {
        return new Sre().buildKeyframes(n, e, t, i, r, s, o, a, l, c);
      }
      class Sre {
        buildKeyframes(e, t, i, r, s, o, a, l, c, u = []) {
          c = c || new l_();
          const d = new AM(e, t, c, r, s, u, []);
          d.options = l;
          const h = l.delay ? vo(l.delay) : 0;
          d.currentTimeline.delayNextStep(h),
            d.currentTimeline.setStyles([o], null, d.errors, l),
            dr(this, i, d);
          const f = d.timelines.filter((p) => p.containsAnimation());
          if (f.length && a.size) {
            let p;
            for (let _ = f.length - 1; _ >= 0; _--) {
              const m = f[_];
              if (m.element === t) {
                p = m;
                break;
              }
            }
            p &&
              !p.allowOnlyTimelineStyles() &&
              p.setStyles([a], null, d.errors, l);
          }
          return f.length
            ? f.map((p) => p.buildKeyframes())
            : [CM(t, [], [], [], 0, h, "", !1)];
        }
        visitTrigger(e, t) {}
        visitState(e, t) {}
        visitTransition(e, t) {}
        visitAnimateChild(e, t) {
          const i = t.subInstructions.get(t.element);
          if (i) {
            const r = t.createSubContext(e.options),
              s = t.currentTimeline.currentTime,
              o = this._visitSubInstructions(i, r, r.options);
            s != o && t.transformIntoNewTimeline(o);
          }
          t.previousNode = e;
        }
        visitAnimateRef(e, t) {
          const i = t.createSubContext(e.options);
          i.transformIntoNewTimeline(),
            this._applyAnimationRefDelays(
              [e.options, e.animation.options],
              t,
              i
            ),
            this.visitReference(e.animation, i),
            t.transformIntoNewTimeline(i.currentTimeline.currentTime),
            (t.previousNode = e);
        }
        _applyAnimationRefDelays(e, t, i) {
          for (const r of e) {
            const s = r?.delay;
            if (s) {
              const o =
                "number" == typeof s ? s : vo(Zh(s, r?.params ?? {}, t.errors));
              i.delayNextStep(o);
            }
          }
        }
        _visitSubInstructions(e, t, i) {
          let s = t.currentTimeline.currentTime;
          const o = null != i.duration ? vo(i.duration) : null,
            a = null != i.delay ? vo(i.delay) : null;
          return (
            0 !== o &&
              e.forEach((l) => {
                const c = t.appendInstructionToTimeline(l, o, a);
                s = Math.max(s, c.duration + c.delay);
              }),
            s
          );
        }
        visitReference(e, t) {
          t.updateOptions(e.options, !0),
            dr(this, e.animation, t),
            (t.previousNode = e);
        }
        visitSequence(e, t) {
          const i = t.subContextCount;
          let r = t;
          const s = e.options;
          if (
            s &&
            (s.params || s.delay) &&
            ((r = t.createSubContext(s)),
            r.transformIntoNewTimeline(),
            null != s.delay)
          ) {
            6 == r.previousNode.type &&
              (r.currentTimeline.snapshotCurrentStyles(),
              (r.previousNode = c_));
            const o = vo(s.delay);
            r.delayNextStep(o);
          }
          e.steps.length &&
            (e.steps.forEach((o) => dr(this, o, r)),
            r.currentTimeline.applyStylesToKeyframe(),
            r.subContextCount > i && r.transformIntoNewTimeline()),
            (t.previousNode = e);
        }
        visitGroup(e, t) {
          const i = [];
          let r = t.currentTimeline.currentTime;
          const s = e.options && e.options.delay ? vo(e.options.delay) : 0;
          e.steps.forEach((o) => {
            const a = t.createSubContext(e.options);
            s && a.delayNextStep(s),
              dr(this, o, a),
              (r = Math.max(r, a.currentTimeline.currentTime)),
              i.push(a.currentTimeline);
          }),
            i.forEach((o) => t.currentTimeline.mergeTimelineCollectedStyles(o)),
            t.transformIntoNewTimeline(r),
            (t.previousNode = e);
        }
        _visitTiming(e, t) {
          if (e.dynamic) {
            const i = e.strValue;
            return t_(t.params ? Zh(i, t.params, t.errors) : i, t.errors);
          }
          return { duration: e.duration, delay: e.delay, easing: e.easing };
        }
        visitAnimate(e, t) {
          const i = (t.currentAnimateTimings = this._visitTiming(e.timings, t)),
            r = t.currentTimeline;
          i.delay && (t.incrementTime(i.delay), r.snapshotCurrentStyles());
          const s = e.style;
          5 == s.type
            ? this.visitKeyframes(s, t)
            : (t.incrementTime(i.duration),
              this.visitStyle(s, t),
              r.applyStylesToKeyframe()),
            (t.currentAnimateTimings = null),
            (t.previousNode = e);
        }
        visitStyle(e, t) {
          const i = t.currentTimeline,
            r = t.currentAnimateTimings;
          !r && i.hasCurrentStyleProperties() && i.forwardFrame();
          const s = (r && r.easing) || e.easing;
          e.isEmptyStep
            ? i.applyEmptyStep(s)
            : i.setStyles(e.styles, s, t.errors, t.options),
            (t.previousNode = e);
        }
        visitKeyframes(e, t) {
          const i = t.currentAnimateTimings,
            r = t.currentTimeline.duration,
            s = i.duration,
            a = t.createSubContext().currentTimeline;
          (a.easing = i.easing),
            e.styles.forEach((l) => {
              a.forwardTime((l.offset || 0) * s),
                a.setStyles(l.styles, l.easing, t.errors, t.options),
                a.applyStylesToKeyframe();
            }),
            t.currentTimeline.mergeTimelineCollectedStyles(a),
            t.transformIntoNewTimeline(r + s),
            (t.previousNode = e);
        }
        visitQuery(e, t) {
          const i = t.currentTimeline.currentTime,
            r = e.options || {},
            s = r.delay ? vo(r.delay) : 0;
          s &&
            (6 === t.previousNode.type ||
              (0 == i && t.currentTimeline.hasCurrentStyleProperties())) &&
            (t.currentTimeline.snapshotCurrentStyles(), (t.previousNode = c_));
          let o = i;
          const a = t.invokeQuery(
            e.selector,
            e.originalSelector,
            e.limit,
            e.includeSelf,
            !!r.optional,
            t.errors
          );
          t.currentQueryTotal = a.length;
          let l = null;
          a.forEach((c, u) => {
            t.currentQueryIndex = u;
            const d = t.createSubContext(e.options, c);
            s && d.delayNextStep(s),
              c === t.element && (l = d.currentTimeline),
              dr(this, e.animation, d),
              d.currentTimeline.applyStylesToKeyframe(),
              (o = Math.max(o, d.currentTimeline.currentTime));
          }),
            (t.currentQueryIndex = 0),
            (t.currentQueryTotal = 0),
            t.transformIntoNewTimeline(o),
            l &&
              (t.currentTimeline.mergeTimelineCollectedStyles(l),
              t.currentTimeline.snapshotCurrentStyles()),
            (t.previousNode = e);
        }
        visitStagger(e, t) {
          const i = t.parentContext,
            r = t.currentTimeline,
            s = e.timings,
            o = Math.abs(s.duration),
            a = o * (t.currentQueryTotal - 1);
          let l = o * t.currentQueryIndex;
          switch (s.duration < 0 ? "reverse" : s.easing) {
            case "reverse":
              l = a - l;
              break;
            case "full":
              l = i.currentStaggerTime;
          }
          const u = t.currentTimeline;
          l && u.delayNextStep(l);
          const d = u.currentTime;
          dr(this, e.animation, t),
            (t.previousNode = e),
            (i.currentStaggerTime =
              r.currentTime - d + (r.startTime - i.currentTimeline.startTime));
        }
      }
      const c_ = {};
      class AM {
        constructor(e, t, i, r, s, o, a, l) {
          (this._driver = e),
            (this.element = t),
            (this.subInstructions = i),
            (this._enterClassName = r),
            (this._leaveClassName = s),
            (this.errors = o),
            (this.timelines = a),
            (this.parentContext = null),
            (this.currentAnimateTimings = null),
            (this.previousNode = c_),
            (this.subContextCount = 0),
            (this.options = {}),
            (this.currentQueryIndex = 0),
            (this.currentQueryTotal = 0),
            (this.currentStaggerTime = 0),
            (this.currentTimeline = l || new u_(this._driver, t, 0)),
            a.push(this.currentTimeline);
        }
        get params() {
          return this.options.params;
        }
        updateOptions(e, t) {
          if (!e) return;
          const i = e;
          let r = this.options;
          null != i.duration && (r.duration = vo(i.duration)),
            null != i.delay && (r.delay = vo(i.delay));
          const s = i.params;
          if (s) {
            let o = r.params;
            o || (o = this.options.params = {}),
              Object.keys(s).forEach((a) => {
                (!t || !o.hasOwnProperty(a)) &&
                  (o[a] = Zh(s[a], o, this.errors));
              });
          }
        }
        _copyOptions() {
          const e = {};
          if (this.options) {
            const t = this.options.params;
            if (t) {
              const i = (e.params = {});
              Object.keys(t).forEach((r) => {
                i[r] = t[r];
              });
            }
          }
          return e;
        }
        createSubContext(e = null, t, i) {
          const r = t || this.element,
            s = new AM(
              this._driver,
              r,
              this.subInstructions,
              this._enterClassName,
              this._leaveClassName,
              this.errors,
              this.timelines,
              this.currentTimeline.fork(r, i || 0)
            );
          return (
            (s.previousNode = this.previousNode),
            (s.currentAnimateTimings = this.currentAnimateTimings),
            (s.options = this._copyOptions()),
            s.updateOptions(e),
            (s.currentQueryIndex = this.currentQueryIndex),
            (s.currentQueryTotal = this.currentQueryTotal),
            (s.parentContext = this),
            this.subContextCount++,
            s
          );
        }
        transformIntoNewTimeline(e) {
          return (
            (this.previousNode = c_),
            (this.currentTimeline = this.currentTimeline.fork(this.element, e)),
            this.timelines.push(this.currentTimeline),
            this.currentTimeline
          );
        }
        appendInstructionToTimeline(e, t, i) {
          const r = {
              duration: t ?? e.duration,
              delay: this.currentTimeline.currentTime + (i ?? 0) + e.delay,
              easing: "",
            },
            s = new Ere(
              this._driver,
              e.element,
              e.keyframes,
              e.preStyleProps,
              e.postStyleProps,
              r,
              e.stretchStartingKeyframe
            );
          return this.timelines.push(s), r;
        }
        incrementTime(e) {
          this.currentTimeline.forwardTime(this.currentTimeline.duration + e);
        }
        delayNextStep(e) {
          e > 0 && this.currentTimeline.delayNextStep(e);
        }
        invokeQuery(e, t, i, r, s, o) {
          let a = [];
          if ((r && a.push(this.element), e.length > 0)) {
            e = (e = e.replace(xre, "." + this._enterClassName)).replace(
              Mre,
              "." + this._leaveClassName
            );
            let c = this._driver.query(this.element, e, 1 != i);
            0 !== i &&
              (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)),
              a.push(...c);
          }
          return (
            !s &&
              0 == a.length &&
              o.push(
                (function Die(n) {
                  return new J(3014, !1);
                })()
              ),
            a
          );
        }
      }
      class u_ {
        constructor(e, t, i, r) {
          (this._driver = e),
            (this.element = t),
            (this.startTime = i),
            (this._elementTimelineStylesLookup = r),
            (this.duration = 0),
            (this.easing = null),
            (this._previousKeyframe = new Map()),
            (this._currentKeyframe = new Map()),
            (this._keyframes = new Map()),
            (this._styleSummary = new Map()),
            (this._localTimelineStyles = new Map()),
            (this._pendingStyles = new Map()),
            (this._backFill = new Map()),
            (this._currentEmptyStepKeyframe = null),
            this._elementTimelineStylesLookup ||
              (this._elementTimelineStylesLookup = new Map()),
            (this._globalTimelineStyles =
              this._elementTimelineStylesLookup.get(t)),
            this._globalTimelineStyles ||
              ((this._globalTimelineStyles = this._localTimelineStyles),
              this._elementTimelineStylesLookup.set(
                t,
                this._localTimelineStyles
              )),
            this._loadKeyframe();
        }
        containsAnimation() {
          switch (this._keyframes.size) {
            case 0:
              return !1;
            case 1:
              return this.hasCurrentStyleProperties();
            default:
              return !0;
          }
        }
        hasCurrentStyleProperties() {
          return this._currentKeyframe.size > 0;
        }
        get currentTime() {
          return this.startTime + this.duration;
        }
        delayNextStep(e) {
          const t = 1 === this._keyframes.size && this._pendingStyles.size;
          this.duration || t
            ? (this.forwardTime(this.currentTime + e),
              t && this.snapshotCurrentStyles())
            : (this.startTime += e);
        }
        fork(e, t) {
          return (
            this.applyStylesToKeyframe(),
            new u_(
              this._driver,
              e,
              t || this.currentTime,
              this._elementTimelineStylesLookup
            )
          );
        }
        _loadKeyframe() {
          this._currentKeyframe &&
            (this._previousKeyframe = this._currentKeyframe),
            (this._currentKeyframe = this._keyframes.get(this.duration)),
            this._currentKeyframe ||
              ((this._currentKeyframe = new Map()),
              this._keyframes.set(this.duration, this._currentKeyframe));
        }
        forwardFrame() {
          (this.duration += 1), this._loadKeyframe();
        }
        forwardTime(e) {
          this.applyStylesToKeyframe(),
            (this.duration = e),
            this._loadKeyframe();
        }
        _updateStyle(e, t) {
          this._localTimelineStyles.set(e, t),
            this._globalTimelineStyles.set(e, t),
            this._styleSummary.set(e, { time: this.currentTime, value: t });
        }
        allowOnlyTimelineStyles() {
          return this._currentEmptyStepKeyframe !== this._currentKeyframe;
        }
        applyEmptyStep(e) {
          e && this._previousKeyframe.set("easing", e);
          for (let [t, i] of this._globalTimelineStyles)
            this._backFill.set(t, i || go), this._currentKeyframe.set(t, go);
          this._currentEmptyStepKeyframe = this._currentKeyframe;
        }
        setStyles(e, t, i, r) {
          t && this._previousKeyframe.set("easing", t);
          const s = (r && r.params) || {},
            o = (function Cre(n, e) {
              const t = new Map();
              let i;
              return (
                n.forEach((r) => {
                  if ("*" === r) {
                    i = i || e.keys();
                    for (let s of i) t.set(s, go);
                  } else ra(r, t);
                }),
                t
              );
            })(e, this._globalTimelineStyles);
          for (let [a, l] of o) {
            const c = Zh(l, s, i);
            this._pendingStyles.set(a, c),
              this._localTimelineStyles.has(a) ||
                this._backFill.set(a, this._globalTimelineStyles.get(a) ?? go),
              this._updateStyle(a, c);
          }
        }
        applyStylesToKeyframe() {
          0 != this._pendingStyles.size &&
            (this._pendingStyles.forEach((e, t) => {
              this._currentKeyframe.set(t, e);
            }),
            this._pendingStyles.clear(),
            this._localTimelineStyles.forEach((e, t) => {
              this._currentKeyframe.has(t) || this._currentKeyframe.set(t, e);
            }));
        }
        snapshotCurrentStyles() {
          for (let [e, t] of this._localTimelineStyles)
            this._pendingStyles.set(e, t), this._updateStyle(e, t);
        }
        getFinalKeyframe() {
          return this._keyframes.get(this.duration);
        }
        get properties() {
          const e = [];
          for (let t in this._currentKeyframe) e.push(t);
          return e;
        }
        mergeTimelineCollectedStyles(e) {
          e._styleSummary.forEach((t, i) => {
            const r = this._styleSummary.get(i);
            (!r || t.time > r.time) && this._updateStyle(i, t.value);
          });
        }
        buildKeyframes() {
          this.applyStylesToKeyframe();
          const e = new Set(),
            t = new Set(),
            i = 1 === this._keyframes.size && 0 === this.duration;
          let r = [];
          this._keyframes.forEach((a, l) => {
            const c = ra(a, new Map(), this._backFill);
            c.forEach((u, d) => {
              u === Fw ? e.add(d) : u === go && t.add(d);
            }),
              i || c.set("offset", l / this.duration),
              r.push(c);
          });
          const s = e.size ? n_(e.values()) : [],
            o = t.size ? n_(t.values()) : [];
          if (i) {
            const a = r[0],
              l = new Map(a);
            a.set("offset", 0), l.set("offset", 1), (r = [a, l]);
          }
          return CM(
            this.element,
            r,
            s,
            o,
            this.duration,
            this.startTime,
            this.easing,
            !1
          );
        }
      }
      class Ere extends u_ {
        constructor(e, t, i, r, s, o, a = !1) {
          super(e, t, o.delay),
            (this.keyframes = i),
            (this.preStyleProps = r),
            (this.postStyleProps = s),
            (this._stretchStartingKeyframe = a),
            (this.timings = {
              duration: o.duration,
              delay: o.delay,
              easing: o.easing,
            });
        }
        containsAnimation() {
          return this.keyframes.length > 1;
        }
        buildKeyframes() {
          let e = this.keyframes,
            { delay: t, duration: i, easing: r } = this.timings;
          if (this._stretchStartingKeyframe && t) {
            const s = [],
              o = i + t,
              a = t / o,
              l = ra(e[0]);
            l.set("offset", 0), s.push(l);
            const c = ra(e[0]);
            c.set("offset", IN(a)), s.push(c);
            const u = e.length - 1;
            for (let d = 1; d <= u; d++) {
              let h = ra(e[d]);
              const f = h.get("offset");
              h.set("offset", IN((t + f * i) / o)), s.push(h);
            }
            (i = o), (t = 0), (r = ""), (e = s);
          }
          return CM(
            this.element,
            e,
            this.preStyleProps,
            this.postStyleProps,
            i,
            t,
            r,
            !0
          );
        }
      }
      function IN(n, e = 3) {
        const t = Math.pow(10, e - 1);
        return Math.round(n * t) / t;
      }
      class DM {}
      const Tre = new Set([
        "width",
        "height",
        "minWidth",
        "minHeight",
        "maxWidth",
        "maxHeight",
        "left",
        "top",
        "bottom",
        "right",
        "fontSize",
        "outlineWidth",
        "outlineOffset",
        "paddingTop",
        "paddingLeft",
        "paddingBottom",
        "paddingRight",
        "marginTop",
        "marginLeft",
        "marginBottom",
        "marginRight",
        "borderRadius",
        "borderWidth",
        "borderTopWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderBottomWidth",
        "textIndent",
        "perspective",
      ]);
      class Are extends DM {
        normalizePropertyName(e, t) {
          return MM(e);
        }
        normalizeStyleValue(e, t, i, r) {
          let s = "";
          const o = i.toString().trim();
          if (Tre.has(t) && 0 !== i && "0" !== i)
            if ("number" == typeof i) s = "px";
            else {
              const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
              a &&
                0 == a[1].length &&
                r.push(
                  (function vie(n, e) {
                    return new J(3005, !1);
                  })()
                );
            }
          return o + s;
        }
      }
      function RN(n, e, t, i, r, s, o, a, l, c, u, d, h) {
        return {
          type: 0,
          element: n,
          triggerName: e,
          isRemovalTransition: r,
          fromState: t,
          fromStyles: s,
          toState: i,
          toStyles: o,
          timelines: a,
          queriedElements: l,
          preStyleProps: c,
          postStyleProps: u,
          totalTime: d,
          errors: h,
        };
      }
      const IM = {};
      class PN {
        constructor(e, t, i) {
          (this._triggerName = e), (this.ast = t), (this._stateStyles = i);
        }
        match(e, t, i, r) {
          return (function Dre(n, e, t, i, r) {
            return n.some((s) => s(e, t, i, r));
          })(this.ast.matchers, e, t, i, r);
        }
        buildStyles(e, t, i) {
          let r = this._stateStyles.get("*");
          return (
            void 0 !== e && (r = this._stateStyles.get(e?.toString()) || r),
            r ? r.buildStyles(t, i) : new Map()
          );
        }
        build(e, t, i, r, s, o, a, l, c, u) {
          const d = [],
            h = (this.ast.options && this.ast.options.params) || IM,
            p = this.buildStyles(i, (a && a.params) || IM, d),
            _ = (l && l.params) || IM,
            m = this.buildStyles(r, _, d),
            g = new Set(),
            y = new Map(),
            v = new Map(),
            b = "void" === r,
            x = { params: Ire(_, h), delay: this.ast.options?.delay },
            M = u ? [] : TM(e, t, this.ast.animation, s, o, p, m, x, c, d);
          let S = 0;
          if (
            (M.forEach((w) => {
              S = Math.max(w.duration + w.delay, S);
            }),
            d.length)
          )
            return RN(t, this._triggerName, i, r, b, p, m, [], [], y, v, S, d);
          M.forEach((w) => {
            const E = w.element,
              V = ur(y, E, new Set());
            w.preStyleProps.forEach((F) => V.add(F));
            const j = ur(v, E, new Set());
            w.postStyleProps.forEach((F) => j.add(F)), E !== t && g.add(E);
          });
          const C = n_(g.values());
          return RN(t, this._triggerName, i, r, b, p, m, M, C, y, v, S);
        }
      }
      function Ire(n, e) {
        const t = qh(e);
        for (const i in n) n.hasOwnProperty(i) && null != n[i] && (t[i] = n[i]);
        return t;
      }
      class Rre {
        constructor(e, t, i) {
          (this.styles = e), (this.defaultParams = t), (this.normalizer = i);
        }
        buildStyles(e, t) {
          const i = new Map(),
            r = qh(this.defaultParams);
          return (
            Object.keys(e).forEach((s) => {
              const o = e[s];
              null !== o && (r[s] = o);
            }),
            this.styles.styles.forEach((s) => {
              "string" != typeof s &&
                s.forEach((o, a) => {
                  o && (o = Zh(o, r, t));
                  const l = this.normalizer.normalizePropertyName(a, t);
                  (o = this.normalizer.normalizeStyleValue(a, l, o, t)),
                    i.set(a, o);
                });
            }),
            i
          );
        }
      }
      class Ore {
        constructor(e, t, i) {
          (this.name = e),
            (this.ast = t),
            (this._normalizer = i),
            (this.transitionFactories = []),
            (this.states = new Map()),
            t.states.forEach((r) => {
              this.states.set(
                r.name,
                new Rre(r.style, (r.options && r.options.params) || {}, i)
              );
            }),
            ON(this.states, "true", "1"),
            ON(this.states, "false", "0"),
            t.transitions.forEach((r) => {
              this.transitionFactories.push(new PN(e, r, this.states));
            }),
            (this.fallbackTransition = (function Lre(n, e, t) {
              return new PN(
                n,
                {
                  type: 1,
                  animation: { type: 2, steps: [], options: null },
                  matchers: [(o, a) => !0],
                  options: null,
                  queryCount: 0,
                  depCount: 0,
                },
                e
              );
            })(e, this.states));
        }
        get containsQueries() {
          return this.ast.queryCount > 0;
        }
        matchTransition(e, t, i, r) {
          return (
            this.transitionFactories.find((o) => o.match(e, t, i, r)) || null
          );
        }
        matchStyles(e, t, i) {
          return this.fallbackTransition.buildStyles(e, t, i);
        }
      }
      function ON(n, e, t) {
        n.has(e)
          ? n.has(t) || n.set(t, n.get(e))
          : n.has(t) && n.set(e, n.get(t));
      }
      const Fre = new l_();
      class Nre {
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = i),
            (this._animations = new Map()),
            (this._playersById = new Map()),
            (this.players = []);
        }
        register(e, t) {
          const i = [],
            r = [],
            s = SM(this._driver, t, i, r);
          if (i.length)
            throw (function Nie(n) {
              return new J(3503, !1);
            })();
          this._animations.set(e, s);
        }
        _buildPlayer(e, t, i) {
          const r = e.element,
            s = dN(0, this._normalizer, 0, e.keyframes, t, i);
          return this._driver.animate(
            r,
            s,
            e.duration,
            e.delay,
            e.easing,
            [],
            !0
          );
        }
        create(e, t, i = {}) {
          const r = [],
            s = this._animations.get(e);
          let o;
          const a = new Map();
          if (
            (s
              ? ((o = TM(
                  this._driver,
                  t,
                  s,
                  yM,
                  Qg,
                  new Map(),
                  new Map(),
                  i,
                  Fre,
                  r
                )),
                o.forEach((u) => {
                  const d = ur(a, u.element, new Map());
                  u.postStyleProps.forEach((h) => d.set(h, null));
                }))
              : (r.push(
                  (function kie() {
                    return new J(3300, !1);
                  })()
                ),
                (o = [])),
            r.length)
          )
            throw (function Bie(n) {
              return new J(3504, !1);
            })();
          a.forEach((u, d) => {
            u.forEach((h, f) => {
              u.set(f, this._driver.computeStyle(d, f, go));
            });
          });
          const c = ia(
            o.map((u) => {
              const d = a.get(u.element);
              return this._buildPlayer(u, new Map(), d);
            })
          );
          return (
            this._playersById.set(e, c),
            c.onDestroy(() => this.destroy(e)),
            this.players.push(c),
            c
          );
        }
        destroy(e) {
          const t = this._getPlayer(e);
          t.destroy(), this._playersById.delete(e);
          const i = this.players.indexOf(t);
          i >= 0 && this.players.splice(i, 1);
        }
        _getPlayer(e) {
          const t = this._playersById.get(e);
          if (!t)
            throw (function Uie(n) {
              return new J(3301, !1);
            })();
          return t;
        }
        listen(e, t, i, r) {
          const s = mM(t, "", "", "");
          return fM(this._getPlayer(e), i, s, r), () => {};
        }
        command(e, t, i, r) {
          if ("register" == i) return void this.register(e, r[0]);
          if ("create" == i) return void this.create(e, t, r[0] || {});
          const s = this._getPlayer(e);
          switch (i) {
            case "play":
              s.play();
              break;
            case "pause":
              s.pause();
              break;
            case "reset":
              s.reset();
              break;
            case "restart":
              s.restart();
              break;
            case "finish":
              s.finish();
              break;
            case "init":
              s.init();
              break;
            case "setPosition":
              s.setPosition(parseFloat(r[0]));
              break;
            case "destroy":
              this.destroy(e);
          }
        }
      }
      const LN = "ng-animate-queued",
        RM = "ng-animate-disabled",
        zre = [],
        FN = {
          namespaceId: "",
          setForRemoval: !1,
          setForMove: !1,
          hasAnimation: !1,
          removedBeforeQueried: !1,
        },
        Hre = {
          namespaceId: "",
          setForMove: !1,
          setForRemoval: !1,
          hasAnimation: !1,
          removedBeforeQueried: !0,
        },
        Or = "__ng_removed";
      class PM {
        get params() {
          return this.options.params;
        }
        constructor(e, t = "") {
          this.namespaceId = t;
          const i = e && e.hasOwnProperty("value");
          if (
            ((this.value = (function Xre(n) {
              return n ?? null;
            })(i ? e.value : e)),
            i)
          ) {
            const s = qh(e);
            delete s.value, (this.options = s);
          } else this.options = {};
          this.options.params || (this.options.params = {});
        }
        absorbOptions(e) {
          const t = e.params;
          if (t) {
            const i = this.options.params;
            Object.keys(t).forEach((r) => {
              null == i[r] && (i[r] = t[r]);
            });
          }
        }
      }
      const Kh = "void",
        OM = new PM(Kh);
      class Gre {
        constructor(e, t, i) {
          (this.id = e),
            (this.hostElement = t),
            (this._engine = i),
            (this.players = []),
            (this._triggers = new Map()),
            (this._queue = []),
            (this._elementListeners = new Map()),
            (this._hostClassName = "ng-tns-" + e),
            Lr(t, this._hostClassName);
        }
        listen(e, t, i, r) {
          if (!this._triggers.has(t))
            throw (function Vie(n, e) {
              return new J(3302, !1);
            })();
          if (null == i || 0 == i.length)
            throw (function zie(n) {
              return new J(3303, !1);
            })();
          if (
            !(function qre(n) {
              return "start" == n || "done" == n;
            })(i)
          )
            throw (function Hie(n, e) {
              return new J(3400, !1);
            })();
          const s = ur(this._elementListeners, e, []),
            o = { name: t, phase: i, callback: r };
          s.push(o);
          const a = ur(this._engine.statesByElement, e, new Map());
          return (
            a.has(t) || (Lr(e, Jg), Lr(e, Jg + "-" + t), a.set(t, OM)),
            () => {
              this._engine.afterFlush(() => {
                const l = s.indexOf(o);
                l >= 0 && s.splice(l, 1), this._triggers.has(t) || a.delete(t);
              });
            }
          );
        }
        register(e, t) {
          return !this._triggers.has(e) && (this._triggers.set(e, t), !0);
        }
        _getTrigger(e) {
          const t = this._triggers.get(e);
          if (!t)
            throw (function Gie(n) {
              return new J(3401, !1);
            })();
          return t;
        }
        trigger(e, t, i, r = !0) {
          const s = this._getTrigger(t),
            o = new LM(this.id, t, e);
          let a = this._engine.statesByElement.get(e);
          a ||
            (Lr(e, Jg),
            Lr(e, Jg + "-" + t),
            this._engine.statesByElement.set(e, (a = new Map())));
          let l = a.get(t);
          const c = new PM(i, this.id);
          if (
            (!(i && i.hasOwnProperty("value")) &&
              l &&
              c.absorbOptions(l.options),
            a.set(t, c),
            l || (l = OM),
            c.value !== Kh && l.value === c.value)
          ) {
            if (
              !(function Kre(n, e) {
                const t = Object.keys(n),
                  i = Object.keys(e);
                if (t.length != i.length) return !1;
                for (let r = 0; r < t.length; r++) {
                  const s = t[r];
                  if (!e.hasOwnProperty(s) || n[s] !== e[s]) return !1;
                }
                return !0;
              })(l.params, c.params)
            ) {
              const _ = [],
                m = s.matchStyles(l.value, l.params, _),
                g = s.matchStyles(c.value, c.params, _);
              _.length
                ? this._engine.reportError(_)
                : this._engine.afterFlush(() => {
                    nl(e, m), Is(e, g);
                  });
            }
            return;
          }
          const h = ur(this._engine.playersByElement, e, []);
          h.forEach((_) => {
            _.namespaceId == this.id &&
              _.triggerName == t &&
              _.queued &&
              _.destroy();
          });
          let f = s.matchTransition(l.value, c.value, e, c.params),
            p = !1;
          if (!f) {
            if (!r) return;
            (f = s.fallbackTransition), (p = !0);
          }
          return (
            this._engine.totalQueuedPlayers++,
            this._queue.push({
              element: e,
              triggerName: t,
              transition: f,
              fromState: l,
              toState: c,
              player: o,
              isFallbackTransition: p,
            }),
            p ||
              (Lr(e, LN),
              o.onStart(() => {
                Mu(e, LN);
              })),
            o.onDone(() => {
              let _ = this.players.indexOf(o);
              _ >= 0 && this.players.splice(_, 1);
              const m = this._engine.playersByElement.get(e);
              if (m) {
                let g = m.indexOf(o);
                g >= 0 && m.splice(g, 1);
              }
            }),
            this.players.push(o),
            h.push(o),
            o
          );
        }
        deregister(e) {
          this._triggers.delete(e),
            this._engine.statesByElement.forEach((t) => t.delete(e)),
            this._elementListeners.forEach((t, i) => {
              this._elementListeners.set(
                i,
                t.filter((r) => r.name != e)
              );
            });
        }
        clearElementCache(e) {
          this._engine.statesByElement.delete(e),
            this._elementListeners.delete(e);
          const t = this._engine.playersByElement.get(e);
          t &&
            (t.forEach((i) => i.destroy()),
            this._engine.playersByElement.delete(e));
        }
        _signalRemovalForInnerTriggers(e, t) {
          const i = this._engine.driver.query(e, e_, !0);
          i.forEach((r) => {
            if (r[Or]) return;
            const s = this._engine.fetchNamespacesByElement(r);
            s.size
              ? s.forEach((o) => o.triggerLeaveAnimation(r, t, !1, !0))
              : this.clearElementCache(r);
          }),
            this._engine.afterFlushAnimationsDone(() =>
              i.forEach((r) => this.clearElementCache(r))
            );
        }
        triggerLeaveAnimation(e, t, i, r) {
          const s = this._engine.statesByElement.get(e),
            o = new Map();
          if (s) {
            const a = [];
            if (
              (s.forEach((l, c) => {
                if ((o.set(c, l.value), this._triggers.has(c))) {
                  const u = this.trigger(e, c, Kh, r);
                  u && a.push(u);
                }
              }),
              a.length)
            )
              return (
                this._engine.markElementAsRemoved(this.id, e, !0, t, o),
                i && ia(a).onDone(() => this._engine.processLeaveNode(e)),
                !0
              );
          }
          return !1;
        }
        prepareLeaveAnimationListeners(e) {
          const t = this._elementListeners.get(e),
            i = this._engine.statesByElement.get(e);
          if (t && i) {
            const r = new Set();
            t.forEach((s) => {
              const o = s.name;
              if (r.has(o)) return;
              r.add(o);
              const l = this._triggers.get(o).fallbackTransition,
                c = i.get(o) || OM,
                u = new PM(Kh),
                d = new LM(this.id, o, e);
              this._engine.totalQueuedPlayers++,
                this._queue.push({
                  element: e,
                  triggerName: o,
                  transition: l,
                  fromState: c,
                  toState: u,
                  player: d,
                  isFallbackTransition: !0,
                });
            });
          }
        }
        removeNode(e, t) {
          const i = this._engine;
          if (
            (e.childElementCount && this._signalRemovalForInnerTriggers(e, t),
            this.triggerLeaveAnimation(e, t, !0))
          )
            return;
          let r = !1;
          if (i.totalAnimations) {
            const s = i.players.length ? i.playersByQueriedElement.get(e) : [];
            if (s && s.length) r = !0;
            else {
              let o = e;
              for (; (o = o.parentNode); )
                if (i.statesByElement.get(o)) {
                  r = !0;
                  break;
                }
            }
          }
          if ((this.prepareLeaveAnimationListeners(e), r))
            i.markElementAsRemoved(this.id, e, !1, t);
          else {
            const s = e[Or];
            (!s || s === FN) &&
              (i.afterFlush(() => this.clearElementCache(e)),
              i.destroyInnerAnimations(e),
              i._onRemovalComplete(e, t));
          }
        }
        insertNode(e, t) {
          Lr(e, this._hostClassName);
        }
        drainQueuedTransitions(e) {
          const t = [];
          return (
            this._queue.forEach((i) => {
              const r = i.player;
              if (r.destroyed) return;
              const s = i.element,
                o = this._elementListeners.get(s);
              o &&
                o.forEach((a) => {
                  if (a.name == i.triggerName) {
                    const l = mM(
                      s,
                      i.triggerName,
                      i.fromState.value,
                      i.toState.value
                    );
                    (l._data = e), fM(i.player, a.phase, l, a.callback);
                  }
                }),
                r.markedForDestroy
                  ? this._engine.afterFlush(() => {
                      r.destroy();
                    })
                  : t.push(i);
            }),
            (this._queue = []),
            t.sort((i, r) => {
              const s = i.transition.ast.depCount,
                o = r.transition.ast.depCount;
              return 0 == s || 0 == o
                ? s - o
                : this._engine.driver.containsElement(i.element, r.element)
                ? 1
                : -1;
            })
          );
        }
        destroy(e) {
          this.players.forEach((t) => t.destroy()),
            this._signalRemovalForInnerTriggers(this.hostElement, e);
        }
        elementContainsData(e) {
          let t = !1;
          return (
            this._elementListeners.has(e) && (t = !0),
            (t = !!this._queue.find((i) => i.element === e) || t),
            t
          );
        }
      }
      class Wre {
        _onRemovalComplete(e, t) {
          this.onRemovalComplete(e, t);
        }
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this.driver = t),
            (this._normalizer = i),
            (this.players = []),
            (this.newHostElements = new Map()),
            (this.playersByElement = new Map()),
            (this.playersByQueriedElement = new Map()),
            (this.statesByElement = new Map()),
            (this.disabledNodes = new Set()),
            (this.totalAnimations = 0),
            (this.totalQueuedPlayers = 0),
            (this._namespaceLookup = {}),
            (this._namespaceList = []),
            (this._flushFns = []),
            (this._whenQuietFns = []),
            (this.namespacesByHostElement = new Map()),
            (this.collectedEnterElements = []),
            (this.collectedLeaveElements = []),
            (this.onRemovalComplete = (r, s) => {});
        }
        get queuedPlayers() {
          const e = [];
          return (
            this._namespaceList.forEach((t) => {
              t.players.forEach((i) => {
                i.queued && e.push(i);
              });
            }),
            e
          );
        }
        createNamespace(e, t) {
          const i = new Gre(e, t, this);
          return (
            this.bodyNode && this.driver.containsElement(this.bodyNode, t)
              ? this._balanceNamespaceList(i, t)
              : (this.newHostElements.set(t, i), this.collectEnterElement(t)),
            (this._namespaceLookup[e] = i)
          );
        }
        _balanceNamespaceList(e, t) {
          const i = this._namespaceList,
            r = this.namespacesByHostElement;
          if (i.length - 1 >= 0) {
            let o = !1,
              a = this.driver.getParentElement(t);
            for (; a; ) {
              const l = r.get(a);
              if (l) {
                const c = i.indexOf(l);
                i.splice(c + 1, 0, e), (o = !0);
                break;
              }
              a = this.driver.getParentElement(a);
            }
            o || i.unshift(e);
          } else i.push(e);
          return r.set(t, e), e;
        }
        register(e, t) {
          let i = this._namespaceLookup[e];
          return i || (i = this.createNamespace(e, t)), i;
        }
        registerTrigger(e, t, i) {
          let r = this._namespaceLookup[e];
          r && r.register(t, i) && this.totalAnimations++;
        }
        destroy(e, t) {
          if (!e) return;
          const i = this._fetchNamespace(e);
          this.afterFlush(() => {
            this.namespacesByHostElement.delete(i.hostElement),
              delete this._namespaceLookup[e];
            const r = this._namespaceList.indexOf(i);
            r >= 0 && this._namespaceList.splice(r, 1);
          }),
            this.afterFlushAnimationsDone(() => i.destroy(t));
        }
        _fetchNamespace(e) {
          return this._namespaceLookup[e];
        }
        fetchNamespacesByElement(e) {
          const t = new Set(),
            i = this.statesByElement.get(e);
          if (i)
            for (let r of i.values())
              if (r.namespaceId) {
                const s = this._fetchNamespace(r.namespaceId);
                s && t.add(s);
              }
          return t;
        }
        trigger(e, t, i, r) {
          if (d_(t)) {
            const s = this._fetchNamespace(e);
            if (s) return s.trigger(t, i, r), !0;
          }
          return !1;
        }
        insertNode(e, t, i, r) {
          if (!d_(t)) return;
          const s = t[Or];
          if (s && s.setForRemoval) {
            (s.setForRemoval = !1), (s.setForMove = !0);
            const o = this.collectedLeaveElements.indexOf(t);
            o >= 0 && this.collectedLeaveElements.splice(o, 1);
          }
          if (e) {
            const o = this._fetchNamespace(e);
            o && o.insertNode(t, i);
          }
          r && this.collectEnterElement(t);
        }
        collectEnterElement(e) {
          this.collectedEnterElements.push(e);
        }
        markElementAsDisabled(e, t) {
          t
            ? this.disabledNodes.has(e) ||
              (this.disabledNodes.add(e), Lr(e, RM))
            : this.disabledNodes.has(e) &&
              (this.disabledNodes.delete(e), Mu(e, RM));
        }
        removeNode(e, t, i, r) {
          if (d_(t)) {
            const s = e ? this._fetchNamespace(e) : null;
            if (
              (s ? s.removeNode(t, r) : this.markElementAsRemoved(e, t, !1, r),
              i)
            ) {
              const o = this.namespacesByHostElement.get(t);
              o && o.id !== e && o.removeNode(t, r);
            }
          } else this._onRemovalComplete(t, r);
        }
        markElementAsRemoved(e, t, i, r, s) {
          this.collectedLeaveElements.push(t),
            (t[Or] = {
              namespaceId: e,
              setForRemoval: r,
              hasAnimation: i,
              removedBeforeQueried: !1,
              previousTriggersValues: s,
            });
        }
        listen(e, t, i, r, s) {
          return d_(t) ? this._fetchNamespace(e).listen(t, i, r, s) : () => {};
        }
        _buildInstruction(e, t, i, r, s) {
          return e.transition.build(
            this.driver,
            e.element,
            e.fromState.value,
            e.toState.value,
            i,
            r,
            e.fromState.options,
            e.toState.options,
            t,
            s
          );
        }
        destroyInnerAnimations(e) {
          let t = this.driver.query(e, e_, !0);
          t.forEach((i) => this.destroyActiveAnimationsForElement(i)),
            0 != this.playersByQueriedElement.size &&
              ((t = this.driver.query(e, bM, !0)),
              t.forEach((i) => this.finishActiveQueriedAnimationOnElement(i)));
        }
        destroyActiveAnimationsForElement(e) {
          const t = this.playersByElement.get(e);
          t &&
            t.forEach((i) => {
              i.queued ? (i.markedForDestroy = !0) : i.destroy();
            });
        }
        finishActiveQueriedAnimationOnElement(e) {
          const t = this.playersByQueriedElement.get(e);
          t && t.forEach((i) => i.finish());
        }
        whenRenderingDone() {
          return new Promise((e) => {
            if (this.players.length) return ia(this.players).onDone(() => e());
            e();
          });
        }
        processLeaveNode(e) {
          const t = e[Or];
          if (t && t.setForRemoval) {
            if (((e[Or] = FN), t.namespaceId)) {
              this.destroyInnerAnimations(e);
              const i = this._fetchNamespace(t.namespaceId);
              i && i.clearElementCache(e);
            }
            this._onRemovalComplete(e, t.setForRemoval);
          }
          e.classList?.contains(RM) && this.markElementAsDisabled(e, !1),
            this.driver.query(e, ".ng-animate-disabled", !0).forEach((i) => {
              this.markElementAsDisabled(i, !1);
            });
        }
        flush(e = -1) {
          let t = [];
          if (
            (this.newHostElements.size &&
              (this.newHostElements.forEach((i, r) =>
                this._balanceNamespaceList(i, r)
              ),
              this.newHostElements.clear()),
            this.totalAnimations && this.collectedEnterElements.length)
          )
            for (let i = 0; i < this.collectedEnterElements.length; i++)
              Lr(this.collectedEnterElements[i], "ng-star-inserted");
          if (
            this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)
          ) {
            const i = [];
            try {
              t = this._flushAnimations(i, e);
            } finally {
              for (let r = 0; r < i.length; r++) i[r]();
            }
          } else
            for (let i = 0; i < this.collectedLeaveElements.length; i++)
              this.processLeaveNode(this.collectedLeaveElements[i]);
          if (
            ((this.totalQueuedPlayers = 0),
            (this.collectedEnterElements.length = 0),
            (this.collectedLeaveElements.length = 0),
            this._flushFns.forEach((i) => i()),
            (this._flushFns = []),
            this._whenQuietFns.length)
          ) {
            const i = this._whenQuietFns;
            (this._whenQuietFns = []),
              t.length
                ? ia(t).onDone(() => {
                    i.forEach((r) => r());
                  })
                : i.forEach((r) => r());
          }
        }
        reportError(e) {
          throw (function Wie(n) {
            return new J(3402, !1);
          })();
        }
        _flushAnimations(e, t) {
          const i = new l_(),
            r = [],
            s = new Map(),
            o = [],
            a = new Map(),
            l = new Map(),
            c = new Map(),
            u = new Set();
          this.disabledNodes.forEach((O) => {
            u.add(O);
            const L = this.driver.query(O, ".ng-animate-queued", !0);
            for (let U = 0; U < L.length; U++) u.add(L[U]);
          });
          const d = this.bodyNode,
            h = Array.from(this.statesByElement.keys()),
            f = BN(h, this.collectedEnterElements),
            p = new Map();
          let _ = 0;
          f.forEach((O, L) => {
            const U = yM + _++;
            p.set(L, U), O.forEach((W) => Lr(W, U));
          });
          const m = [],
            g = new Set(),
            y = new Set();
          for (let O = 0; O < this.collectedLeaveElements.length; O++) {
            const L = this.collectedLeaveElements[O],
              U = L[Or];
            U &&
              U.setForRemoval &&
              (m.push(L),
              g.add(L),
              U.hasAnimation
                ? this.driver
                    .query(L, ".ng-star-inserted", !0)
                    .forEach((W) => g.add(W))
                : y.add(L));
          }
          const v = new Map(),
            b = BN(h, Array.from(g));
          b.forEach((O, L) => {
            const U = Qg + _++;
            v.set(L, U), O.forEach((W) => Lr(W, U));
          }),
            e.push(() => {
              f.forEach((O, L) => {
                const U = p.get(L);
                O.forEach((W) => Mu(W, U));
              }),
                b.forEach((O, L) => {
                  const U = v.get(L);
                  O.forEach((W) => Mu(W, U));
                }),
                m.forEach((O) => {
                  this.processLeaveNode(O);
                });
            });
          const x = [],
            M = [];
          for (let O = this._namespaceList.length - 1; O >= 0; O--)
            this._namespaceList[O].drainQueuedTransitions(t).forEach((U) => {
              const W = U.player,
                Z = U.element;
              if ((x.push(W), this.collectedEnterElements.length)) {
                const ve = Z[Or];
                if (ve && ve.setForMove) {
                  if (
                    ve.previousTriggersValues &&
                    ve.previousTriggersValues.has(U.triggerName)
                  ) {
                    const xe = ve.previousTriggersValues.get(U.triggerName),
                      Ze = this.statesByElement.get(U.element);
                    if (Ze && Ze.has(U.triggerName)) {
                      const dt = Ze.get(U.triggerName);
                      (dt.value = xe), Ze.set(U.triggerName, dt);
                    }
                  }
                  return void W.destroy();
                }
              }
              const B = !d || !this.driver.containsElement(d, Z),
                q = v.get(Z),
                le = p.get(Z),
                te = this._buildInstruction(U, i, le, q, B);
              if (te.errors && te.errors.length) return void M.push(te);
              if (B)
                return (
                  W.onStart(() => nl(Z, te.fromStyles)),
                  W.onDestroy(() => Is(Z, te.toStyles)),
                  void r.push(W)
                );
              if (U.isFallbackTransition)
                return (
                  W.onStart(() => nl(Z, te.fromStyles)),
                  W.onDestroy(() => Is(Z, te.toStyles)),
                  void r.push(W)
                );
              const ce = [];
              te.timelines.forEach((ve) => {
                (ve.stretchStartingKeyframe = !0),
                  this.disabledNodes.has(ve.element) || ce.push(ve);
              }),
                (te.timelines = ce),
                i.append(Z, te.timelines),
                o.push({ instruction: te, player: W, element: Z }),
                te.queriedElements.forEach((ve) => ur(a, ve, []).push(W)),
                te.preStyleProps.forEach((ve, xe) => {
                  if (ve.size) {
                    let Ze = l.get(xe);
                    Ze || l.set(xe, (Ze = new Set())),
                      ve.forEach((dt, Ue) => Ze.add(Ue));
                  }
                }),
                te.postStyleProps.forEach((ve, xe) => {
                  let Ze = c.get(xe);
                  Ze || c.set(xe, (Ze = new Set())),
                    ve.forEach((dt, Ue) => Ze.add(Ue));
                });
            });
          if (M.length) {
            const O = [];
            M.forEach((L) => {
              O.push(
                (function jie(n, e) {
                  return new J(3505, !1);
                })()
              );
            }),
              x.forEach((L) => L.destroy()),
              this.reportError(O);
          }
          const S = new Map(),
            C = new Map();
          o.forEach((O) => {
            const L = O.element;
            i.has(L) &&
              (C.set(L, L),
              this._beforeAnimationBuild(
                O.player.namespaceId,
                O.instruction,
                S
              ));
          }),
            r.forEach((O) => {
              const L = O.element;
              this._getPreviousPlayers(
                L,
                !1,
                O.namespaceId,
                O.triggerName,
                null
              ).forEach((W) => {
                ur(S, L, []).push(W), W.destroy();
              });
            });
          const w = m.filter((O) => VN(O, l, c)),
            E = new Map();
          kN(E, this.driver, y, c, go).forEach((O) => {
            VN(O, l, c) && w.push(O);
          });
          const j = new Map();
          f.forEach((O, L) => {
            kN(j, this.driver, new Set(O), l, Fw);
          }),
            w.forEach((O) => {
              const L = E.get(O),
                U = j.get(O);
              E.set(
                O,
                new Map([
                  ...Array.from(L?.entries() ?? []),
                  ...Array.from(U?.entries() ?? []),
                ])
              );
            });
          const F = [],
            k = [],
            z = {};
          o.forEach((O) => {
            const { element: L, player: U, instruction: W } = O;
            if (i.has(L)) {
              if (u.has(L))
                return (
                  U.onDestroy(() => Is(L, W.toStyles)),
                  (U.disabled = !0),
                  U.overrideTotalTime(W.totalTime),
                  void r.push(U)
                );
              let Z = z;
              if (C.size > 1) {
                let q = L;
                const le = [];
                for (; (q = q.parentNode); ) {
                  const te = C.get(q);
                  if (te) {
                    Z = te;
                    break;
                  }
                  le.push(q);
                }
                le.forEach((te) => C.set(te, Z));
              }
              const B = this._buildAnimation(U.namespaceId, W, S, s, j, E);
              if ((U.setRealPlayer(B), Z === z)) F.push(U);
              else {
                const q = this.playersByElement.get(Z);
                q && q.length && (U.parentPlayer = ia(q)), r.push(U);
              }
            } else
              nl(L, W.fromStyles),
                U.onDestroy(() => Is(L, W.toStyles)),
                k.push(U),
                u.has(L) && r.push(U);
          }),
            k.forEach((O) => {
              const L = s.get(O.element);
              if (L && L.length) {
                const U = ia(L);
                O.setRealPlayer(U);
              }
            }),
            r.forEach((O) => {
              O.parentPlayer ? O.syncPlayerEvents(O.parentPlayer) : O.destroy();
            });
          for (let O = 0; O < m.length; O++) {
            const L = m[O],
              U = L[Or];
            if ((Mu(L, Qg), U && U.hasAnimation)) continue;
            let W = [];
            if (a.size) {
              let B = a.get(L);
              B && B.length && W.push(...B);
              let q = this.driver.query(L, bM, !0);
              for (let le = 0; le < q.length; le++) {
                let te = a.get(q[le]);
                te && te.length && W.push(...te);
              }
            }
            const Z = W.filter((B) => !B.destroyed);
            Z.length ? Yre(this, L, Z) : this.processLeaveNode(L);
          }
          return (
            (m.length = 0),
            F.forEach((O) => {
              this.players.push(O),
                O.onDone(() => {
                  O.destroy();
                  const L = this.players.indexOf(O);
                  this.players.splice(L, 1);
                }),
                O.play();
            }),
            F
          );
        }
        elementContainsData(e, t) {
          let i = !1;
          const r = t[Or];
          return (
            r && r.setForRemoval && (i = !0),
            this.playersByElement.has(t) && (i = !0),
            this.playersByQueriedElement.has(t) && (i = !0),
            this.statesByElement.has(t) && (i = !0),
            this._fetchNamespace(e).elementContainsData(t) || i
          );
        }
        afterFlush(e) {
          this._flushFns.push(e);
        }
        afterFlushAnimationsDone(e) {
          this._whenQuietFns.push(e);
        }
        _getPreviousPlayers(e, t, i, r, s) {
          let o = [];
          if (t) {
            const a = this.playersByQueriedElement.get(e);
            a && (o = a);
          } else {
            const a = this.playersByElement.get(e);
            if (a) {
              const l = !s || s == Kh;
              a.forEach((c) => {
                c.queued || (!l && c.triggerName != r) || o.push(c);
              });
            }
          }
          return (
            (i || r) &&
              (o = o.filter(
                (a) => !((i && i != a.namespaceId) || (r && r != a.triggerName))
              )),
            o
          );
        }
        _beforeAnimationBuild(e, t, i) {
          const s = t.element,
            o = t.isRemovalTransition ? void 0 : e,
            a = t.isRemovalTransition ? void 0 : t.triggerName;
          for (const l of t.timelines) {
            const c = l.element,
              u = c !== s,
              d = ur(i, c, []);
            this._getPreviousPlayers(c, u, o, a, t.toState).forEach((f) => {
              const p = f.getRealPlayer();
              p.beforeDestroy && p.beforeDestroy(), f.destroy(), d.push(f);
            });
          }
          nl(s, t.fromStyles);
        }
        _buildAnimation(e, t, i, r, s, o) {
          const a = t.triggerName,
            l = t.element,
            c = [],
            u = new Set(),
            d = new Set(),
            h = t.timelines.map((p) => {
              const _ = p.element;
              u.add(_);
              const m = _[Or];
              if (m && m.removedBeforeQueried)
                return new Bh(p.duration, p.delay);
              const g = _ !== l,
                y = (function Zre(n) {
                  const e = [];
                  return UN(n, e), e;
                })((i.get(_) || zre).map((S) => S.getRealPlayer())).filter(
                  (S) => !!S.element && S.element === _
                ),
                v = s.get(_),
                b = o.get(_),
                x = dN(0, this._normalizer, 0, p.keyframes, v, b),
                M = this._buildPlayer(p, x, y);
              if ((p.subTimeline && r && d.add(_), g)) {
                const S = new LM(e, a, _);
                S.setRealPlayer(M), c.push(S);
              }
              return M;
            });
          c.forEach((p) => {
            ur(this.playersByQueriedElement, p.element, []).push(p),
              p.onDone(() =>
                (function jre(n, e, t) {
                  let i = n.get(e);
                  if (i) {
                    if (i.length) {
                      const r = i.indexOf(t);
                      i.splice(r, 1);
                    }
                    0 == i.length && n.delete(e);
                  }
                  return i;
                })(this.playersByQueriedElement, p.element, p)
              );
          }),
            u.forEach((p) => Lr(p, bN));
          const f = ia(h);
          return (
            f.onDestroy(() => {
              u.forEach((p) => Mu(p, bN)), Is(l, t.toStyles);
            }),
            d.forEach((p) => {
              ur(r, p, []).push(f);
            }),
            f
          );
        }
        _buildPlayer(e, t, i) {
          return t.length > 0
            ? this.driver.animate(
                e.element,
                t,
                e.duration,
                e.delay,
                e.easing,
                i
              )
            : new Bh(e.duration, e.delay);
        }
      }
      class LM {
        constructor(e, t, i) {
          (this.namespaceId = e),
            (this.triggerName = t),
            (this.element = i),
            (this._player = new Bh()),
            (this._containsRealPlayer = !1),
            (this._queuedCallbacks = new Map()),
            (this.destroyed = !1),
            (this.parentPlayer = null),
            (this.markedForDestroy = !1),
            (this.disabled = !1),
            (this.queued = !0),
            (this.totalTime = 0);
        }
        setRealPlayer(e) {
          this._containsRealPlayer ||
            ((this._player = e),
            this._queuedCallbacks.forEach((t, i) => {
              t.forEach((r) => fM(e, i, void 0, r));
            }),
            this._queuedCallbacks.clear(),
            (this._containsRealPlayer = !0),
            this.overrideTotalTime(e.totalTime),
            (this.queued = !1));
        }
        getRealPlayer() {
          return this._player;
        }
        overrideTotalTime(e) {
          this.totalTime = e;
        }
        syncPlayerEvents(e) {
          const t = this._player;
          t.triggerCallback && e.onStart(() => t.triggerCallback("start")),
            e.onDone(() => this.finish()),
            e.onDestroy(() => this.destroy());
        }
        _queueEvent(e, t) {
          ur(this._queuedCallbacks, e, []).push(t);
        }
        onDone(e) {
          this.queued && this._queueEvent("done", e), this._player.onDone(e);
        }
        onStart(e) {
          this.queued && this._queueEvent("start", e), this._player.onStart(e);
        }
        onDestroy(e) {
          this.queued && this._queueEvent("destroy", e),
            this._player.onDestroy(e);
        }
        init() {
          this._player.init();
        }
        hasStarted() {
          return !this.queued && this._player.hasStarted();
        }
        play() {
          !this.queued && this._player.play();
        }
        pause() {
          !this.queued && this._player.pause();
        }
        restart() {
          !this.queued && this._player.restart();
        }
        finish() {
          this._player.finish();
        }
        destroy() {
          (this.destroyed = !0), this._player.destroy();
        }
        reset() {
          !this.queued && this._player.reset();
        }
        setPosition(e) {
          this.queued || this._player.setPosition(e);
        }
        getPosition() {
          return this.queued ? 0 : this._player.getPosition();
        }
        triggerCallback(e) {
          const t = this._player;
          t.triggerCallback && t.triggerCallback(e);
        }
      }
      function d_(n) {
        return n && 1 === n.nodeType;
      }
      function NN(n, e) {
        const t = n.style.display;
        return (n.style.display = e ?? "none"), t;
      }
      function kN(n, e, t, i, r) {
        const s = [];
        t.forEach((l) => s.push(NN(l)));
        const o = [];
        i.forEach((l, c) => {
          const u = new Map();
          l.forEach((d) => {
            const h = e.computeStyle(c, d, r);
            u.set(d, h), (!h || 0 == h.length) && ((c[Or] = Hre), o.push(c));
          }),
            n.set(c, u);
        });
        let a = 0;
        return t.forEach((l) => NN(l, s[a++])), o;
      }
      function BN(n, e) {
        const t = new Map();
        if ((n.forEach((a) => t.set(a, [])), 0 == e.length)) return t;
        const i = 1,
          r = new Set(e),
          s = new Map();
        function o(a) {
          if (!a) return i;
          let l = s.get(a);
          if (l) return l;
          const c = a.parentNode;
          return (l = t.has(c) ? c : r.has(c) ? i : o(c)), s.set(a, l), l;
        }
        return (
          e.forEach((a) => {
            const l = o(a);
            l !== i && t.get(l).push(a);
          }),
          t
        );
      }
      function Lr(n, e) {
        n.classList?.add(e);
      }
      function Mu(n, e) {
        n.classList?.remove(e);
      }
      function Yre(n, e, t) {
        ia(t).onDone(() => n.processLeaveNode(e));
      }
      function UN(n, e) {
        for (let t = 0; t < n.length; t++) {
          const i = n[t];
          i instanceof kF ? UN(i.players, e) : e.push(i);
        }
      }
      function VN(n, e, t) {
        const i = t.get(n);
        if (!i) return !1;
        let r = e.get(n);
        return r ? i.forEach((s) => r.add(s)) : e.set(n, i), t.delete(n), !0;
      }
      class h_ {
        constructor(e, t, i) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = i),
            (this._triggerCache = {}),
            (this.onRemovalComplete = (r, s) => {}),
            (this._transitionEngine = new Wre(e, t, i)),
            (this._timelineEngine = new Nre(e, t, i)),
            (this._transitionEngine.onRemovalComplete = (r, s) =>
              this.onRemovalComplete(r, s));
        }
        registerTrigger(e, t, i, r, s) {
          const o = e + "-" + r;
          let a = this._triggerCache[o];
          if (!a) {
            const l = [],
              c = [],
              u = SM(this._driver, s, l, c);
            if (l.length)
              throw (function Lie(n, e) {
                return new J(3404, !1);
              })();
            (a = (function Pre(n, e, t) {
              return new Ore(n, e, t);
            })(r, u, this._normalizer)),
              (this._triggerCache[o] = a);
          }
          this._transitionEngine.registerTrigger(t, r, a);
        }
        register(e, t) {
          this._transitionEngine.register(e, t);
        }
        destroy(e, t) {
          this._transitionEngine.destroy(e, t);
        }
        onInsert(e, t, i, r) {
          this._transitionEngine.insertNode(e, t, i, r);
        }
        onRemove(e, t, i, r) {
          this._transitionEngine.removeNode(e, t, r || !1, i);
        }
        disableAnimations(e, t) {
          this._transitionEngine.markElementAsDisabled(e, t);
        }
        process(e, t, i, r) {
          if ("@" == i.charAt(0)) {
            const [s, o] = hN(i);
            this._timelineEngine.command(s, t, o, r);
          } else this._transitionEngine.trigger(e, t, i, r);
        }
        listen(e, t, i, r, s) {
          if ("@" == i.charAt(0)) {
            const [o, a] = hN(i);
            return this._timelineEngine.listen(o, t, a, s);
          }
          return this._transitionEngine.listen(e, t, i, r, s);
        }
        flush(e = -1) {
          this._transitionEngine.flush(e);
        }
        get players() {
          return this._transitionEngine.players.concat(
            this._timelineEngine.players
          );
        }
        whenRenderingDone() {
          return this._transitionEngine.whenRenderingDone();
        }
      }
      let Qre = (() => {
        class n {
          constructor(t, i, r) {
            (this._element = t),
              (this._startStyles = i),
              (this._endStyles = r),
              (this._state = 0);
            let s = n.initialStylesByElement.get(t);
            s || n.initialStylesByElement.set(t, (s = new Map())),
              (this._initialStyles = s);
          }
          start() {
            this._state < 1 &&
              (this._startStyles &&
                Is(this._element, this._startStyles, this._initialStyles),
              (this._state = 1));
          }
          finish() {
            this.start(),
              this._state < 2 &&
                (Is(this._element, this._initialStyles),
                this._endStyles &&
                  (Is(this._element, this._endStyles),
                  (this._endStyles = null)),
                (this._state = 1));
          }
          destroy() {
            this.finish(),
              this._state < 3 &&
                (n.initialStylesByElement.delete(this._element),
                this._startStyles &&
                  (nl(this._element, this._startStyles),
                  (this._endStyles = null)),
                this._endStyles &&
                  (nl(this._element, this._endStyles),
                  (this._endStyles = null)),
                Is(this._element, this._initialStyles),
                (this._state = 3));
          }
        }
        return (n.initialStylesByElement = new WeakMap()), n;
      })();
      function FM(n) {
        let e = null;
        return (
          n.forEach((t, i) => {
            (function Jre(n) {
              return "display" === n || "position" === n;
            })(i) && ((e = e || new Map()), e.set(i, t));
          }),
          e
        );
      }
      class zN {
        constructor(e, t, i, r) {
          (this.element = e),
            (this.keyframes = t),
            (this.options = i),
            (this._specialStyles = r),
            (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._initialized = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this.time = 0),
            (this.parentPlayer = null),
            (this.currentSnapshot = new Map()),
            (this._duration = i.duration),
            (this._delay = i.delay || 0),
            (this.time = this._duration + this._delay);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this._buildPlayer(), this._preparePlayerBeforeStart();
        }
        _buildPlayer() {
          if (this._initialized) return;
          this._initialized = !0;
          const e = this.keyframes;
          (this.domPlayer = this._triggerWebAnimation(
            this.element,
            e,
            this.options
          )),
            (this._finalKeyframe = e.length ? e[e.length - 1] : new Map()),
            this.domPlayer.addEventListener("finish", () => this._onFinish());
        }
        _preparePlayerBeforeStart() {
          this._delay ? this._resetDomPlayerState() : this.domPlayer.pause();
        }
        _convertKeyframesToObject(e) {
          const t = [];
          return (
            e.forEach((i) => {
              t.push(Object.fromEntries(i));
            }),
            t
          );
        }
        _triggerWebAnimation(e, t, i) {
          return e.animate(this._convertKeyframesToObject(t), i);
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        play() {
          this._buildPlayer(),
            this.hasStarted() ||
              (this._onStartFns.forEach((e) => e()),
              (this._onStartFns = []),
              (this._started = !0),
              this._specialStyles && this._specialStyles.start()),
            this.domPlayer.play();
        }
        pause() {
          this.init(), this.domPlayer.pause();
        }
        finish() {
          this.init(),
            this._specialStyles && this._specialStyles.finish(),
            this._onFinish(),
            this.domPlayer.finish();
        }
        reset() {
          this._resetDomPlayerState(),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        _resetDomPlayerState() {
          this.domPlayer && this.domPlayer.cancel();
        }
        restart() {
          this.reset(), this.play();
        }
        hasStarted() {
          return this._started;
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._resetDomPlayerState(),
            this._onFinish(),
            this._specialStyles && this._specialStyles.destroy(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        setPosition(e) {
          void 0 === this.domPlayer && this.init(),
            (this.domPlayer.currentTime = e * this.time);
        }
        getPosition() {
          return this.domPlayer.currentTime / this.time;
        }
        get totalTime() {
          return this._delay + this._duration;
        }
        beforeDestroy() {
          const e = new Map();
          this.hasStarted() &&
            this._finalKeyframe.forEach((i, r) => {
              "offset" !== r &&
                e.set(r, this._finished ? i : CN(this.element, r));
            }),
            (this.currentSnapshot = e);
        }
        triggerCallback(e) {
          const t = "start" === e ? this._onStartFns : this._onDoneFns;
          t.forEach((i) => i()), (t.length = 0);
        }
      }
      class ese {
        validateStyleProperty(e) {
          return !0;
        }
        validateAnimatableStyleProperty(e) {
          return !0;
        }
        matchesElement(e, t) {
          return !1;
        }
        containsElement(e, t) {
          return gN(e, t);
        }
        getParentElement(e) {
          return _M(e);
        }
        query(e, t, i) {
          return _N(e, t, i);
        }
        computeStyle(e, t, i) {
          return window.getComputedStyle(e)[t];
        }
        animate(e, t, i, r, s, o = []) {
          const l = {
            duration: i,
            delay: r,
            fill: 0 == r ? "both" : "forwards",
          };
          s && (l.easing = s);
          const c = new Map(),
            u = o.filter((f) => f instanceof zN);
          (function rre(n, e) {
            return 0 === n || 0 === e;
          })(i, r) &&
            u.forEach((f) => {
              f.currentSnapshot.forEach((p, _) => c.set(_, p));
            });
          let d = (function ere(n) {
            return n.length
              ? n[0] instanceof Map
                ? n
                : n.map((e) => xN(e))
              : [];
          })(t).map((f) => ra(f));
          d = (function sre(n, e, t) {
            if (t.size && e.length) {
              let i = e[0],
                r = [];
              if (
                (t.forEach((s, o) => {
                  i.has(o) || r.push(o), i.set(o, s);
                }),
                r.length)
              )
                for (let s = 1; s < e.length; s++) {
                  let o = e[s];
                  r.forEach((a) => o.set(a, CN(n, a)));
                }
            }
            return e;
          })(e, d, c);
          const h = (function $re(n, e) {
            let t = null,
              i = null;
            return (
              Array.isArray(e) && e.length
                ? ((t = FM(e[0])), e.length > 1 && (i = FM(e[e.length - 1])))
                : e instanceof Map && (t = FM(e)),
              t || i ? new Qre(n, t, i) : null
            );
          })(e, d);
          return new zN(e, d, l, h);
        }
      }
      let tse = (() => {
        class n extends LF {
          constructor(t, i) {
            super(),
              (this._nextAnimationId = 0),
              (this._renderer = t.createRenderer(i.body, {
                id: "0",
                encapsulation: Fr.None,
                styles: [],
                data: { animation: [] },
              }));
          }
          build(t) {
            const i = this._nextAnimationId.toString();
            this._nextAnimationId++;
            const r = Array.isArray(t) ? FF(t) : t;
            return (
              HN(this._renderer, null, i, "register", [r]),
              new nse(i, this._renderer)
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re($u), re(Lt));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class nse extends fee {
        constructor(e, t) {
          super(), (this._id = e), (this._renderer = t);
        }
        create(e, t) {
          return new ise(this._id, e, t || {}, this._renderer);
        }
      }
      class ise {
        constructor(e, t, i, r) {
          (this.id = e),
            (this.element = t),
            (this._renderer = r),
            (this.parentPlayer = null),
            (this._started = !1),
            (this.totalTime = 0),
            this._command("create", i);
        }
        _listen(e, t) {
          return this._renderer.listen(this.element, `@@${this.id}:${e}`, t);
        }
        _command(e, ...t) {
          return HN(this._renderer, this.element, this.id, e, t);
        }
        onDone(e) {
          this._listen("done", e);
        }
        onStart(e) {
          this._listen("start", e);
        }
        onDestroy(e) {
          this._listen("destroy", e);
        }
        init() {
          this._command("init");
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this._command("play"), (this._started = !0);
        }
        pause() {
          this._command("pause");
        }
        restart() {
          this._command("restart");
        }
        finish() {
          this._command("finish");
        }
        destroy() {
          this._command("destroy");
        }
        reset() {
          this._command("reset"), (this._started = !1);
        }
        setPosition(e) {
          this._command("setPosition", e);
        }
        getPosition() {
          return this._renderer.engine.players[+this.id]?.getPosition() ?? 0;
        }
      }
      function HN(n, e, t, i, r) {
        return n.setProperty(e, `@@${t}:${i}`, r);
      }
      const GN = "@.disabled";
      let rse = (() => {
        class n {
          constructor(t, i, r) {
            (this.delegate = t),
              (this.engine = i),
              (this._zone = r),
              (this._currentId = 0),
              (this._microtaskId = 1),
              (this._animationCallbacksBuffer = []),
              (this._rendererCache = new Map()),
              (this._cdRecurDepth = 0),
              (this.promise = Promise.resolve(0)),
              (i.onRemovalComplete = (s, o) => {
                const a = o?.parentNode(s);
                a && o.removeChild(a, s);
              });
          }
          createRenderer(t, i) {
            const s = this.delegate.createRenderer(t, i);
            if (!(t && i && i.data && i.data.animation)) {
              let u = this._rendererCache.get(s);
              return (
                u ||
                  ((u = new WN("", s, this.engine, () =>
                    this._rendererCache.delete(s)
                  )),
                  this._rendererCache.set(s, u)),
                u
              );
            }
            const o = i.id,
              a = i.id + "-" + this._currentId;
            this._currentId++, this.engine.register(a, t);
            const l = (u) => {
              Array.isArray(u)
                ? u.forEach(l)
                : this.engine.registerTrigger(o, a, t, u.name, u);
            };
            return (
              i.data.animation.forEach(l), new sse(this, a, s, this.engine)
            );
          }
          begin() {
            this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
          }
          _scheduleCountTask() {
            this.promise.then(() => {
              this._microtaskId++;
            });
          }
          scheduleListenerCallback(t, i, r) {
            t >= 0 && t < this._microtaskId
              ? this._zone.run(() => i(r))
              : (0 == this._animationCallbacksBuffer.length &&
                  Promise.resolve(null).then(() => {
                    this._zone.run(() => {
                      this._animationCallbacksBuffer.forEach((s) => {
                        const [o, a] = s;
                        o(a);
                      }),
                        (this._animationCallbacksBuffer = []);
                    });
                  }),
                this._animationCallbacksBuffer.push([i, r]));
          }
          end() {
            this._cdRecurDepth--,
              0 == this._cdRecurDepth &&
                this._zone.runOutsideAngular(() => {
                  this._scheduleCountTask(),
                    this.engine.flush(this._microtaskId);
                }),
              this.delegate.end && this.delegate.end();
          }
          whenRenderingDone() {
            return this.engine.whenRenderingDone();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(re($u), re(h_), re(wt));
          }),
          (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class WN {
        constructor(e, t, i, r) {
          (this.namespaceId = e),
            (this.delegate = t),
            (this.engine = i),
            (this._onDestroy = r),
            (this.destroyNode = this.delegate.destroyNode
              ? (s) => t.destroyNode(s)
              : null);
        }
        get data() {
          return this.delegate.data;
        }
        destroy() {
          this.engine.destroy(this.namespaceId, this.delegate),
            this.delegate.destroy(),
            this._onDestroy?.();
        }
        createElement(e, t) {
          return this.delegate.createElement(e, t);
        }
        createComment(e) {
          return this.delegate.createComment(e);
        }
        createText(e) {
          return this.delegate.createText(e);
        }
        appendChild(e, t) {
          this.delegate.appendChild(e, t),
            this.engine.onInsert(this.namespaceId, t, e, !1);
        }
        insertBefore(e, t, i, r = !0) {
          this.delegate.insertBefore(e, t, i),
            this.engine.onInsert(this.namespaceId, t, e, r);
        }
        removeChild(e, t, i) {
          this.engine.onRemove(this.namespaceId, t, this.delegate, i);
        }
        selectRootElement(e, t) {
          return this.delegate.selectRootElement(e, t);
        }
        parentNode(e) {
          return this.delegate.parentNode(e);
        }
        nextSibling(e) {
          return this.delegate.nextSibling(e);
        }
        setAttribute(e, t, i, r) {
          this.delegate.setAttribute(e, t, i, r);
        }
        removeAttribute(e, t, i) {
          this.delegate.removeAttribute(e, t, i);
        }
        addClass(e, t) {
          this.delegate.addClass(e, t);
        }
        removeClass(e, t) {
          this.delegate.removeClass(e, t);
        }
        setStyle(e, t, i, r) {
          this.delegate.setStyle(e, t, i, r);
        }
        removeStyle(e, t, i) {
          this.delegate.removeStyle(e, t, i);
        }
        setProperty(e, t, i) {
          "@" == t.charAt(0) && t == GN
            ? this.disableAnimations(e, !!i)
            : this.delegate.setProperty(e, t, i);
        }
        setValue(e, t) {
          this.delegate.setValue(e, t);
        }
        listen(e, t, i) {
          return this.delegate.listen(e, t, i);
        }
        disableAnimations(e, t) {
          this.engine.disableAnimations(e, t);
        }
      }
      class sse extends WN {
        constructor(e, t, i, r, s) {
          super(t, i, r, s), (this.factory = e), (this.namespaceId = t);
        }
        setProperty(e, t, i) {
          "@" == t.charAt(0)
            ? "." == t.charAt(1) && t == GN
              ? this.disableAnimations(e, (i = void 0 === i || !!i))
              : this.engine.process(this.namespaceId, e, t.slice(1), i)
            : this.delegate.setProperty(e, t, i);
        }
        listen(e, t, i) {
          if ("@" == t.charAt(0)) {
            const r = (function ose(n) {
              switch (n) {
                case "body":
                  return document.body;
                case "document":
                  return document;
                case "window":
                  return window;
                default:
                  return n;
              }
            })(e);
            let s = t.slice(1),
              o = "";
            return (
              "@" != s.charAt(0) &&
                ([s, o] = (function ase(n) {
                  const e = n.indexOf(".");
                  return [n.substring(0, e), n.slice(e + 1)];
                })(s)),
              this.engine.listen(this.namespaceId, r, s, o, (a) => {
                this.factory.scheduleListenerCallback(a._data || -1, i, a);
              })
            );
          }
          return this.delegate.listen(e, t, i);
        }
      }
      const jN = [
          { provide: LF, useClass: tse },
          {
            provide: DM,
            useFactory: function cse() {
              return new Are();
            },
          },
          {
            provide: h_,
            useClass: (() => {
              class n extends h_ {
                constructor(t, i, r, s) {
                  super(t.body, i, r);
                }
                ngOnDestroy() {
                  this.flush();
                }
              }
              return (
                (n.ɵfac = function (t) {
                  return new (t || n)(re(Lt), re(vM), re(DM), re($l));
                }),
                (n.ɵprov = Me({ token: n, factory: n.ɵfac })),
                n
              );
            })(),
          },
          {
            provide: $u,
            useFactory: function use(n, e, t) {
              return new rse(n, e, t);
            },
            deps: [Fp, h_, wt],
          },
        ],
        NM = [
          { provide: vM, useFactory: () => new ese() },
          { provide: _d, useValue: "BrowserAnimations" },
          ...jN,
        ],
        XN = [
          { provide: vM, useClass: vN },
          { provide: _d, useValue: "NoopAnimations" },
          ...jN,
        ];
      let dse = (() => {
          class n {
            static withConfig(t) {
              return { ngModule: n, providers: t.disableAnimations ? XN : NM };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ providers: NM, imports: [N1] })),
            n
          );
        })(),
        qN = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ imports: [Ds, Pw, Ds] })),
            n
          );
        })(),
        YN = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ imports: [Dp, Ds, Vh, Vh, Ds] })),
            n
          );
        })();
      const mse = [qN, lN, YN, t2];
      let gse = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n })),
            (n.ɵinj = cn({ imports: [mse, qN, lN, YN, t2] })),
            n
          );
        })(),
        _se = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = _n({ type: n, bootstrap: [hie] })),
            (n.ɵinj = cn({ imports: [N1, die, dse, gse] })),
            n
          );
        })();
      DW()
        .bootstrapModule(_se)
        .catch((n) => console.error(n));
    },
  },
  (Ot) => {
    Ot((Ot.s = 972));
  },
]);
